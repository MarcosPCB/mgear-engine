; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	C:\Users\Marcos\Desktop\prj\mGear-1\mGear-1\input.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_InputInit
PUBLIC	_InputProcess
PUBLIC	_InputClose
PUBLIC	_StartText
PUBLIC	_StopText
PUBLIC	_SetMousePos
PUBLIC	??_C@_0DA@PMCGCBBG@Game?5Controller?5?$CFd?5could?5not?5be?5@ ; `string'
PUBLIC	??_C@_0BM@LJNKGHEH@Found?5?$CFd?5controller?5devices?$AA@ ; `string'
PUBLIC	??_C@_0DC@MGGNMPIL@Controller?5?$CFd?5does?5not?5support?5f@ ; `string'
PUBLIC	??_C@_0CA@HBDNELMP@Could?5not?5initialize?5rumble?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BL@HONEDAOF@Text?5Input?5already?5started?$AA@ ; `string'
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	_SDL_GetError:PROC
EXTRN	_SDL_StartTextInput:PROC
EXTRN	_SDL_StopTextInput:PROC
EXTRN	_SDL_WarpMouseInWindow:PROC
EXTRN	_SDL_NumJoysticks:PROC
EXTRN	_SDL_JoystickOpen:PROC
EXTRN	_SDL_JoystickClose:PROC
EXTRN	_SDL_IsGameController:PROC
EXTRN	_SDL_GameControllerOpen:PROC
EXTRN	_SDL_GameControllerUpdate:PROC
EXTRN	_SDL_GameControllerGetAxis:PROC
EXTRN	_SDL_GameControllerGetButton:PROC
EXTRN	_SDL_GameControllerClose:PROC
EXTRN	_SDL_HapticOpenFromJoystick:PROC
EXTRN	_SDL_HapticClose:PROC
EXTRN	_SDL_HapticRumbleInit:PROC
EXTRN	_SDL_Log:PROC
EXTRN	@WTS@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_st:BYTE
EXTRN	_events:BYTE
EXTRN	_wn:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BL@HONEDAOF@Text?5Input?5already?5started?$AA@
CONST	SEGMENT
??_C@_0BL@HONEDAOF@Text?5Input?5already?5started?$AA@ DB 'Text Input alre'
	DB	'ady started', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HBDNELMP@Could?5not?5initialize?5rumble?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0CA@HBDNELMP@Could?5not?5initialize?5rumble?3?5?$CFs?$AA@ DB 'Could'
	DB	' not initialize rumble: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MGGNMPIL@Controller?5?$CFd?5does?5not?5support?5f@
CONST	SEGMENT
??_C@_0DC@MGGNMPIL@Controller?5?$CFd?5does?5not?5support?5f@ DB 'Controll'
	DB	'er %d does not support force feedback: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LJNKGHEH@Found?5?$CFd?5controller?5devices?$AA@
CONST	SEGMENT
??_C@_0BM@LJNKGHEH@Found?5?$CFd?5controller?5devices?$AA@ DB 'Found %d co'
	DB	'ntroller devices', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PMCGCBBG@Game?5Controller?5?$CFd?5could?5not?5be?5@
CONST	SEGMENT
??_C@_0DA@PMCGCBBG@Game?5Controller?5?$CFd?5could?5not?5be?5@ DB 'Game Co'
	DB	'ntroller %d could not be initialized: %s', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\input.c
;	COMDAT _SetMousePos
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_SetMousePos PROC					; COMDAT

; 292  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 293  : 	WTS(&x,&y);

	lea	edx, DWORD PTR _y$[ebp]
	lea	ecx, DWORD PTR _x$[ebp]
	call	@WTS@8

; 294  : 
; 295  : 	SDL_WarpMouseInWindow(wn,x,y);

	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wn
	push	edx
	call	_SDL_WarpMouseInWindow
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_SetMousePos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\input.c
;	COMDAT _StopText
_TEXT	SEGMENT
_StopText PROC						; COMDAT

; 286  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 287  : 	st.Text_Input=0;

	mov	BYTE PTR _st+66798, 0

; 288  : 	SDL_StopTextInput();

	call	_SDL_StopTextInput

; 289  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_StopText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\input.c
;	COMDAT _StartText
_TEXT	SEGMENT
_StartText PROC						; COMDAT

; 271  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 272  : 	if(st.Text_Input)

	movzx	eax, BYTE PTR _st+66798
	test	eax, eax
	je	SHORT $LN2@StartText

; 273  : 	{
; 274  : 		LogApp("Text Input already started");

	push	OFFSET ??_C@_0BL@HONEDAOF@Text?5Input?5already?5started?$AA@
	call	_SDL_Log
	add	esp, 4

; 275  : 		return 0;

	xor	al, al
	jmp	SHORT $LN3@StartText

; 276  : 	}
; 277  : 	else

	jmp	SHORT $LN3@StartText
$LN2@StartText:

; 278  : 	{
; 279  : 		SDL_StartTextInput();

	call	_SDL_StartTextInput

; 280  : 		st.Text_Input=1;

	mov	BYTE PTR _st+66798, 1

; 281  : 		return 1;

	mov	al, 1
$LN3@StartText:

; 282  : 	}
; 283  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_StartText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\input.c
;	COMDAT _InputClose
_TEXT	SEGMENT
_i$ = -8						; size = 2
_InputClose PROC					; COMDAT

; 256  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 257  : 	uint16 i;
; 258  : 
; 259  : 	if(st.control_num>0)

	movzx	eax, BYTE PTR _st+2335447
	test	eax, eax
	jle	SHORT $LN5@InputClose

; 260  : 	{
; 261  : 		for(i=0;i<st.control_num;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN3@InputClose
$LN2@InputClose:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN3@InputClose:
	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _st+2335447
	cmp	eax, ecx
	jge	SHORT $LN5@InputClose

; 262  : 		{
; 263  : 			SDL_HapticClose(st.controller[i].force);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 248
	mov	edx, DWORD PTR _st[ecx+2335620]
	push	edx
	call	_SDL_HapticClose
	add	esp, 4

; 264  : 			SDL_JoystickClose(st.controller[i].joystick);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 248
	mov	edx, DWORD PTR _st[ecx+2335692]
	push	edx
	call	_SDL_JoystickClose
	add	esp, 4

; 265  : 			SDL_GameControllerClose(st.controller[i].device);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 248
	mov	edx, DWORD PTR _st[ecx+2335448]
	push	edx
	call	_SDL_GameControllerClose
	add	esp, 4

; 266  : 		}

	jmp	SHORT $LN2@InputClose
$LN5@InputClose:

; 267  : 	}
; 268  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_InputClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\input.c
;	COMDAT _InputProcess
_TEXT	SEGMENT
_j$ = -32						; size = 2
_i$ = -20						; size = 2
_len$ = -8						; size = 4
_InputProcess PROC					; COMDAT

; 152  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 153  : 	size_t len;
; 154  : 	uint16 i, j;
; 155  : 		//while(SDL_PollEvent(&events))
; 156  : 
; 157  : 				for(i=0;i<MAX_KEYS;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN32@InputProce
$LN31@InputProce:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN32@InputProce:
	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, 128				; 00000080H
	jge	SHORT $LN30@InputProce

; 158  : 				{
; 159  : 				
; 160  : 					if(events.type==SDL_KEYUP)

	cmp	DWORD PTR _events, 769			; 00000301H
	jne	SHORT $LN29@InputProce

; 161  : 					{
; 162  : 						if(st.keys[i].key==events.key.keysym.scancode)

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _st[eax*8+65644]
	cmp	ecx, DWORD PTR _events+16
	jne	SHORT $LN28@InputProce

; 163  : 							st.keys[i].state=0;

	movzx	eax, WORD PTR _i$[ebp]
	mov	BYTE PTR _st[eax*8+65648], 0
$LN28@InputProce:

; 164  : 					}
; 165  : 					else

	jmp	SHORT $LN27@InputProce
$LN29@InputProce:

; 166  : 					if(events.type==SDL_KEYDOWN)

	cmp	DWORD PTR _events, 768			; 00000300H
	jne	SHORT $LN27@InputProce

; 167  : 					{
; 168  : 						if(st.keys[i].key==events.key.keysym.scancode)

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _st[eax*8+65644]
	cmp	ecx, DWORD PTR _events+16
	jne	SHORT $LN27@InputProce

; 169  : 							st.keys[i].state=1;

	movzx	eax, WORD PTR _i$[ebp]
	mov	BYTE PTR _st[eax*8+65648], 1
$LN27@InputProce:

; 170  : 					}
; 171  : 				
; 172  : 				}

	jmp	SHORT $LN31@InputProce
$LN30@InputProce:

; 173  : 
; 174  : 				if(st.control_num>0)

	movzx	eax, BYTE PTR _st+2335447
	test	eax, eax
	jle	$LN24@InputProce

; 175  : 				{
; 176  : 					SDL_GameControllerUpdate();

	call	_SDL_GameControllerUpdate

; 177  : 
; 178  : 					for(j=0;j<st.control_num;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN23@InputProce
$LN22@InputProce:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN23@InputProce:
	movzx	eax, WORD PTR _j$[ebp]
	movzx	ecx, BYTE PTR _st+2335447
	cmp	eax, ecx
	jge	$LN24@InputProce

; 179  : 					{		
; 180  : 						for(i=0;i<15;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN20@InputProce
$LN19@InputProce:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN20@InputProce:
	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, 15					; 0000000fH
	jge	$LN18@InputProce

; 181  : 						{
; 182  : 							st.controller[j].button[i].state=SDL_GameControllerGetButton(st.controller[j].device,st.controller[j].button[i].name);

	movzx	eax, WORD PTR _j$[ebp]
	imul	ecx, eax, 248
	movzx	edx, WORD PTR _i$[ebp]
	mov	eax, DWORD PTR _st[ecx+edx*8+2335452]
	push	eax
	movzx	ecx, WORD PTR _j$[ebp]
	imul	edx, ecx, 248
	mov	eax, DWORD PTR _st[edx+2335448]
	push	eax
	call	_SDL_GameControllerGetButton
	add	esp, 8
	movzx	ecx, WORD PTR _j$[ebp]
	imul	edx, ecx, 248
	movzx	ecx, WORD PTR _i$[ebp]
	mov	BYTE PTR _st[edx+ecx*8+2335456], al

; 183  : 
; 184  : 							if(i<6)

	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, 6
	jge	SHORT $LN17@InputProce

; 185  : 								st.controller[j].axis[i].state=SDL_GameControllerGetAxis(st.controller[j].device,st.controller[j].axis[i].name);

	movzx	eax, WORD PTR _j$[ebp]
	imul	ecx, eax, 248
	movzx	edx, WORD PTR _i$[ebp]
	mov	eax, DWORD PTR _st[ecx+edx*8+2335572]
	push	eax
	movzx	ecx, WORD PTR _j$[ebp]
	imul	edx, ecx, 248
	mov	eax, DWORD PTR _st[edx+2335448]
	push	eax
	call	_SDL_GameControllerGetAxis
	add	esp, 8
	movzx	ecx, WORD PTR _j$[ebp]
	imul	edx, ecx, 248
	movzx	ecx, WORD PTR _i$[ebp]
	mov	WORD PTR _st[edx+ecx*8+2335576], ax
$LN17@InputProce:

; 186  : 						}

	jmp	$LN19@InputProce
$LN18@InputProce:

; 187  : 					}

	jmp	$LN22@InputProce
$LN24@InputProce:

; 188  : 				}
; 189  : 				
; 190  : 				if(st.keys[BACKSPACE_KEY].state && st.Text_Input)

	mov	eax, 8
	imul	ecx, eax, 26
	movzx	edx, BYTE PTR _st[ecx+65648]
	test	edx, edx
	je	SHORT $LN16@InputProce
	movzx	eax, BYTE PTR _st+66798
	test	eax, eax
	je	SHORT $LN16@InputProce

; 191  : 				{
; 192  : 					len=strlen(st.TextInput);

	push	OFFSET _st+66670
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 193  : 
; 194  : 					if(len>1)

	cmp	DWORD PTR _len$[ebp], 1
	jbe	SHORT $LN15@InputProce

; 195  : 					{
; 196  : 						st.TextInput[len]='\b';

	mov	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR _st[eax+66670], 8

; 197  : 						st.TextInput[len-1]='\0';

	mov	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR _st[eax+66669], 0

; 198  : 					}
; 199  : 					else

	jmp	SHORT $LN14@InputProce
$LN15@InputProce:

; 200  : 					if(len==1)

	cmp	DWORD PTR _len$[ebp], 1
	jne	SHORT $LN14@InputProce

; 201  : 					{
; 202  : 						st.TextInput[0]='\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _st[ecx+66670], 0
$LN14@InputProce:

; 203  : 					}
; 204  : 
; 205  : 					st.keys[BACKSPACE_KEY].state=0;

	mov	eax, 8
	imul	ecx, eax, 26
	mov	BYTE PTR _st[ecx+65648], 0
$LN16@InputProce:

; 206  : 				}
; 207  : 				
; 208  : 				if(events.type==SDL_TEXTINPUT && st.Text_Input)

	cmp	DWORD PTR _events, 771			; 00000303H
	jne	SHORT $LN12@InputProce
	movzx	eax, BYTE PTR _st+66798
	test	eax, eax
	je	SHORT $LN12@InputProce

; 209  : 					strcat(st.TextInput,events.text.text);

	push	OFFSET _events+12
	push	OFFSET _st+66670
	call	_strcat
	add	esp, 8
$LN12@InputProce:

; 210  : 				
; 211  : 				if(events.type==SDL_MOUSEMOTION)

	cmp	DWORD PTR _events, 1024			; 00000400H
	jne	SHORT $LN11@InputProce

; 212  : 				{
; 213  : 					st.mouse.x=events.motion.x;

	mov	eax, DWORD PTR _events+20
	mov	DWORD PTR _st+65624, eax

; 214  : 					st.mouse.y=events.motion.y;

	mov	eax, DWORD PTR _events+24
	mov	DWORD PTR _st+65628, eax
$LN11@InputProce:

; 215  : 				}
; 216  : 
; 217  : 				if(events.type==SDL_MOUSEBUTTONDOWN)

	cmp	DWORD PTR _events, 1025			; 00000401H
	jne	SHORT $LN10@InputProce

; 218  : 				{
; 219  : 					st.mouse.x=events.motion.x;

	mov	eax, DWORD PTR _events+20
	mov	DWORD PTR _st+65624, eax

; 220  : 					st.mouse.y=events.motion.y;

	mov	eax, DWORD PTR _events+24
	mov	DWORD PTR _st+65628, eax

; 221  : 
; 222  : 					if(events.button.button==SDL_BUTTON_LEFT)

	movzx	eax, BYTE PTR _events+16
	cmp	eax, 1
	jne	SHORT $LN9@InputProce

; 223  : 						st.mouse1=1;

	mov	BYTE PTR _st+65636, 1
$LN9@InputProce:

; 224  : 
; 225  : 					if(events.button.button==SDL_BUTTON_RIGHT)

	movzx	eax, BYTE PTR _events+16
	cmp	eax, 3
	jne	SHORT $LN8@InputProce

; 226  : 						st.mouse2=1;

	mov	BYTE PTR _st+65637, 1
$LN8@InputProce:

; 227  : 
; 228  : 				}
; 229  : 				else

	jmp	SHORT $LN7@InputProce
$LN10@InputProce:

; 230  : 				if(events.type==SDL_MOUSEBUTTONUP)

	cmp	DWORD PTR _events, 1026			; 00000402H
	jne	SHORT $LN6@InputProce

; 231  : 				{
; 232  : 					st.mouse.x=events.motion.x;

	mov	eax, DWORD PTR _events+20
	mov	DWORD PTR _st+65624, eax

; 233  : 					st.mouse.y=events.motion.y;

	mov	eax, DWORD PTR _events+24
	mov	DWORD PTR _st+65628, eax

; 234  : 
; 235  : 					if(events.button.button==SDL_BUTTON_LEFT)

	movzx	eax, BYTE PTR _events+16
	cmp	eax, 1
	jne	SHORT $LN5@InputProce

; 236  : 						st.mouse1=0;

	mov	BYTE PTR _st+65636, 0
$LN5@InputProce:

; 237  : 
; 238  : 					if(events.button.button==SDL_BUTTON_RIGHT)

	movzx	eax, BYTE PTR _events+16
	cmp	eax, 3
	jne	SHORT $LN4@InputProce

; 239  : 						st.mouse2=0;

	mov	BYTE PTR _st+65637, 0
$LN4@InputProce:

; 240  : 
; 241  : 				}
; 242  : 				else

	jmp	SHORT $LN7@InputProce
$LN6@InputProce:

; 243  : 				if(events.type==SDL_MOUSEWHEEL)

	cmp	DWORD PTR _events, 1027			; 00000403H
	jne	SHORT $LN7@InputProce

; 244  : 					st.mouse_wheel=events.wheel.y;

	mov	eax, DWORD PTR _events+20
	mov	DWORD PTR _st+65640, eax
$LN7@InputProce:

; 245  : 
; 246  : 		
; 247  : 
; 248  : 		if(st.keys[RETURN_KEY].state && st.PlayingVideo)

	mov	eax, 8
	shl	eax, 0
	movzx	ecx, BYTE PTR _st[eax+65648]
	test	ecx, ecx
	je	SHORT $LN33@InputProce
	movzx	eax, BYTE PTR _st+66669
	test	eax, eax
	je	SHORT $LN33@InputProce

; 249  : 		{
; 250  : 			st.PlayingVideo=0;

	mov	BYTE PTR _st+66669, 0

; 251  : 			st.keys[RETURN_KEY].state=0;

	mov	eax, 8
	shl	eax, 0
	mov	BYTE PTR _st[eax+65648], 0
$LN33@InputProce:

; 252  : 		}
; 253  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_InputProcess ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\input.c
;	COMDAT _InputInit
_TEXT	SEGMENT
tv360 = -232						; size = 4
tv344 = -232						; size = 4
tv334 = -232						; size = 4
_i$ = -32						; size = 4
_j$ = -20						; size = 4
_num$ = -8						; size = 4
_InputInit PROC						; COMDAT

; 4    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5    : 	uint32 num, j, i;
; 6    : 
; 7    : 	st.keys[ESC_KEY].key=SDL_SCANCODE_ESCAPE;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	DWORD PTR _st[ecx+65644], 41		; 00000029H

; 8    : 	st.keys[RETURN_KEY].key=SDL_SCANCODE_RETURN;

	mov	eax, 8
	shl	eax, 0
	mov	DWORD PTR _st[eax+65644], 40		; 00000028H

; 9    : 	st.keys[2].key=SDL_SCANCODE_RIGHT;

	mov	eax, 8
	shl	eax, 1
	mov	DWORD PTR _st[eax+65644], 79		; 0000004fH

; 10   : 	st.keys[3].key=SDL_SCANCODE_LEFT;

	mov	eax, 8
	imul	ecx, eax, 3
	mov	DWORD PTR _st[ecx+65644], 80		; 00000050H

; 11   : 	st.keys[4].key=SDL_SCANCODE_UP;

	mov	eax, 8
	shl	eax, 2
	mov	DWORD PTR _st[eax+65644], 82		; 00000052H

; 12   : 	st.keys[5].key=SDL_SCANCODE_DOWN;

	mov	eax, 8
	imul	ecx, eax, 5
	mov	DWORD PTR _st[ecx+65644], 81		; 00000051H

; 13   : 	st.keys[6].key=SDL_SCANCODE_SPACE;

	mov	eax, 8
	imul	ecx, eax, 6
	mov	DWORD PTR _st[ecx+65644], 44		; 0000002cH

; 14   : 	st.keys[7].key=SDL_SCANCODE_LCTRL;

	mov	eax, 8
	imul	ecx, eax, 7
	mov	DWORD PTR _st[ecx+65644], 224		; 000000e0H

; 15   : 	st.keys[8].key=SDL_SCANCODE_RCTRL;

	mov	eax, 8
	shl	eax, 3
	mov	DWORD PTR _st[eax+65644], 228		; 000000e4H

; 16   : 	st.keys[9].key=SDL_SCANCODE_LSHIFT;

	mov	eax, 8
	imul	ecx, eax, 9
	mov	DWORD PTR _st[ecx+65644], 225		; 000000e1H

; 17   : 	st.keys[10].key=SDL_SCANCODE_RSHIFT;

	mov	eax, 8
	imul	ecx, eax, 10
	mov	DWORD PTR _st[ecx+65644], 229		; 000000e5H

; 18   : 	st.keys[11].key=SDL_SCANCODE_TAB;

	mov	eax, 8
	imul	ecx, eax, 11
	mov	DWORD PTR _st[ecx+65644], 43		; 0000002bH

; 19   : 	st.keys[12].key=SDL_SCANCODE_LALT;

	mov	eax, 8
	imul	ecx, eax, 12
	mov	DWORD PTR _st[ecx+65644], 226		; 000000e2H

; 20   : 	st.keys[13].key=SDL_SCANCODE_RALT;

	mov	eax, 8
	imul	ecx, eax, 13
	mov	DWORD PTR _st[ecx+65644], 230		; 000000e6H

; 21   : 	st.keys[14].key=SDL_SCANCODE_F1;

	mov	eax, 8
	imul	ecx, eax, 14
	mov	DWORD PTR _st[ecx+65644], 58		; 0000003aH

; 22   : 	st.keys[15].key=SDL_SCANCODE_F2;

	mov	eax, 8
	imul	ecx, eax, 15
	mov	DWORD PTR _st[ecx+65644], 59		; 0000003bH

; 23   : 	st.keys[16].key=SDL_SCANCODE_F3;

	mov	eax, 8
	shl	eax, 4
	mov	DWORD PTR _st[eax+65644], 60		; 0000003cH

; 24   : 	st.keys[17].key=SDL_SCANCODE_F4;

	mov	eax, 8
	imul	ecx, eax, 17
	mov	DWORD PTR _st[ecx+65644], 61		; 0000003dH

; 25   : 	st.keys[18].key=SDL_SCANCODE_F5;

	mov	eax, 8
	imul	ecx, eax, 18
	mov	DWORD PTR _st[ecx+65644], 62		; 0000003eH

; 26   : 	st.keys[19].key=SDL_SCANCODE_F6;

	mov	eax, 8
	imul	ecx, eax, 19
	mov	DWORD PTR _st[ecx+65644], 63		; 0000003fH

; 27   : 	st.keys[20].key=SDL_SCANCODE_F7;

	mov	eax, 8
	imul	ecx, eax, 20
	mov	DWORD PTR _st[ecx+65644], 64		; 00000040H

; 28   : 	st.keys[21].key=SDL_SCANCODE_F8;

	mov	eax, 8
	imul	ecx, eax, 21
	mov	DWORD PTR _st[ecx+65644], 65		; 00000041H

; 29   : 	st.keys[22].key=SDL_SCANCODE_F9;

	mov	eax, 8
	imul	ecx, eax, 22
	mov	DWORD PTR _st[ecx+65644], 66		; 00000042H

; 30   : 	st.keys[23].key=SDL_SCANCODE_F10;

	mov	eax, 8
	imul	ecx, eax, 23
	mov	DWORD PTR _st[ecx+65644], 67		; 00000043H

; 31   : 	st.keys[24].key=SDL_SCANCODE_F11;

	mov	eax, 8
	imul	ecx, eax, 24
	mov	DWORD PTR _st[ecx+65644], 68		; 00000044H

; 32   : 	st.keys[25].key=SDL_SCANCODE_F12;

	mov	eax, 8
	imul	ecx, eax, 25
	mov	DWORD PTR _st[ecx+65644], 69		; 00000045H

; 33   : 	st.keys[26].key=SDL_SCANCODE_BACKSPACE;

	mov	eax, 8
	imul	ecx, eax, 26
	mov	DWORD PTR _st[ecx+65644], 42		; 0000002aH

; 34   : 	st.keys[27].key=SDL_SCANCODE_0;

	mov	eax, 8
	imul	ecx, eax, 27
	mov	DWORD PTR _st[ecx+65644], 39		; 00000027H

; 35   : 	st.keys[28].key=SDL_SCANCODE_1;

	mov	eax, 8
	imul	ecx, eax, 28
	mov	DWORD PTR _st[ecx+65644], 30		; 0000001eH

; 36   : 	st.keys[29].key=SDL_SCANCODE_2;

	mov	eax, 8
	imul	ecx, eax, 29
	mov	DWORD PTR _st[ecx+65644], 31		; 0000001fH

; 37   : 	st.keys[30].key=SDL_SCANCODE_3;

	mov	eax, 8
	imul	ecx, eax, 30
	mov	DWORD PTR _st[ecx+65644], 32		; 00000020H

; 38   : 	st.keys[31].key=SDL_SCANCODE_4;

	mov	eax, 8
	imul	ecx, eax, 31
	mov	DWORD PTR _st[ecx+65644], 33		; 00000021H

; 39   : 	st.keys[32].key=SDL_SCANCODE_5;

	mov	eax, 8
	shl	eax, 5
	mov	DWORD PTR _st[eax+65644], 34		; 00000022H

; 40   : 	st.keys[33].key=SDL_SCANCODE_6;

	mov	eax, 8
	imul	ecx, eax, 33
	mov	DWORD PTR _st[ecx+65644], 35		; 00000023H

; 41   : 	st.keys[34].key=SDL_SCANCODE_7;

	mov	eax, 8
	imul	ecx, eax, 34
	mov	DWORD PTR _st[ecx+65644], 36		; 00000024H

; 42   : 	st.keys[35].key=SDL_SCANCODE_8;

	mov	eax, 8
	imul	ecx, eax, 35
	mov	DWORD PTR _st[ecx+65644], 37		; 00000025H

; 43   : 	st.keys[36].key=SDL_SCANCODE_9;

	mov	eax, 8
	imul	ecx, eax, 36
	mov	DWORD PTR _st[ecx+65644], 38		; 00000026H

; 44   : 	st.keys[37].key=SDL_SCANCODE_A;

	mov	eax, 8
	imul	ecx, eax, 37
	mov	DWORD PTR _st[ecx+65644], 4

; 45   : 	st.keys[38].key=SDL_SCANCODE_B;

	mov	eax, 8
	imul	ecx, eax, 38
	mov	DWORD PTR _st[ecx+65644], 5

; 46   : 	st.keys[39].key=SDL_SCANCODE_C;

	mov	eax, 8
	imul	ecx, eax, 39
	mov	DWORD PTR _st[ecx+65644], 6

; 47   : 	st.keys[40].key=SDL_SCANCODE_D;

	mov	eax, 8
	imul	ecx, eax, 40
	mov	DWORD PTR _st[ecx+65644], 7

; 48   : 	st.keys[41].key=SDL_SCANCODE_E;

	mov	eax, 8
	imul	ecx, eax, 41
	mov	DWORD PTR _st[ecx+65644], 8

; 49   : 	st.keys[42].key=SDL_SCANCODE_F;

	mov	eax, 8
	imul	ecx, eax, 42
	mov	DWORD PTR _st[ecx+65644], 9

; 50   : 	st.keys[43].key=SDL_SCANCODE_G;

	mov	eax, 8
	imul	ecx, eax, 43
	mov	DWORD PTR _st[ecx+65644], 10		; 0000000aH

; 51   : 	st.keys[44].key=SDL_SCANCODE_H;

	mov	eax, 8
	imul	ecx, eax, 44
	mov	DWORD PTR _st[ecx+65644], 11		; 0000000bH

; 52   : 	st.keys[45].key=SDL_SCANCODE_I;

	mov	eax, 8
	imul	ecx, eax, 45
	mov	DWORD PTR _st[ecx+65644], 12		; 0000000cH

; 53   : 	st.keys[46].key=SDL_SCANCODE_J;

	mov	eax, 8
	imul	ecx, eax, 46
	mov	DWORD PTR _st[ecx+65644], 13		; 0000000dH

; 54   : 	st.keys[47].key=SDL_SCANCODE_K;

	mov	eax, 8
	imul	ecx, eax, 47
	mov	DWORD PTR _st[ecx+65644], 14		; 0000000eH

; 55   : 	st.keys[48].key=SDL_SCANCODE_L;

	mov	eax, 8
	imul	ecx, eax, 48
	mov	DWORD PTR _st[ecx+65644], 15		; 0000000fH

; 56   : 	st.keys[49].key=SDL_SCANCODE_M;

	mov	eax, 8
	imul	ecx, eax, 49
	mov	DWORD PTR _st[ecx+65644], 16		; 00000010H

; 57   : 	st.keys[50].key=SDL_SCANCODE_N;

	mov	eax, 8
	imul	ecx, eax, 50
	mov	DWORD PTR _st[ecx+65644], 17		; 00000011H

; 58   : 	st.keys[51].key=SDL_SCANCODE_O;

	mov	eax, 8
	imul	ecx, eax, 51
	mov	DWORD PTR _st[ecx+65644], 18		; 00000012H

; 59   : 	st.keys[52].key=SDL_SCANCODE_P;

	mov	eax, 8
	imul	ecx, eax, 52
	mov	DWORD PTR _st[ecx+65644], 19		; 00000013H

; 60   : 	st.keys[53].key=SDL_SCANCODE_Q;

	mov	eax, 8
	imul	ecx, eax, 53
	mov	DWORD PTR _st[ecx+65644], 20		; 00000014H

; 61   : 	st.keys[54].key=SDL_SCANCODE_R;

	mov	eax, 8
	imul	ecx, eax, 54
	mov	DWORD PTR _st[ecx+65644], 21		; 00000015H

; 62   : 	st.keys[55].key=SDL_SCANCODE_S;

	mov	eax, 8
	imul	ecx, eax, 55
	mov	DWORD PTR _st[ecx+65644], 22		; 00000016H

; 63   : 	st.keys[56].key=SDL_SCANCODE_T;

	mov	eax, 8
	imul	ecx, eax, 56
	mov	DWORD PTR _st[ecx+65644], 23		; 00000017H

; 64   : 	st.keys[57].key=SDL_SCANCODE_U;

	mov	eax, 8
	imul	ecx, eax, 57
	mov	DWORD PTR _st[ecx+65644], 24		; 00000018H

; 65   : 	st.keys[58].key=SDL_SCANCODE_V;

	mov	eax, 8
	imul	ecx, eax, 58
	mov	DWORD PTR _st[ecx+65644], 25		; 00000019H

; 66   : 	st.keys[59].key=SDL_SCANCODE_W;

	mov	eax, 8
	imul	ecx, eax, 59
	mov	DWORD PTR _st[ecx+65644], 26		; 0000001aH

; 67   : 	st.keys[60].key=SDL_SCANCODE_X;

	mov	eax, 8
	imul	ecx, eax, 60
	mov	DWORD PTR _st[ecx+65644], 27		; 0000001bH

; 68   : 	st.keys[61].key=SDL_SCANCODE_Y;

	mov	eax, 8
	imul	ecx, eax, 61
	mov	DWORD PTR _st[ecx+65644], 28		; 0000001cH

; 69   : 	st.keys[62].key=SDL_SCANCODE_Z;

	mov	eax, 8
	imul	ecx, eax, 62
	mov	DWORD PTR _st[ecx+65644], 29		; 0000001dH

; 70   : 	st.keys[63].key=SDL_SCANCODE_COMMA;

	mov	eax, 8
	imul	ecx, eax, 63
	mov	DWORD PTR _st[ecx+65644], 54		; 00000036H

; 71   : 	st.keys[64].key=SDL_SCANCODE_BACKSLASH;

	mov	eax, 8
	shl	eax, 6
	mov	DWORD PTR _st[eax+65644], 49		; 00000031H

; 72   : 	st.keys[65].key=SDL_SCANCODE_GRAVE;

	mov	eax, 8
	imul	ecx, eax, 65
	mov	DWORD PTR _st[ecx+65644], 53		; 00000035H

; 73   : 	st.keys[66].key=SDL_SCANCODE_SLASH;

	mov	eax, 8
	imul	ecx, eax, 66
	mov	DWORD PTR _st[ecx+65644], 56		; 00000038H

; 74   : 	st.keys[67].key=SDL_SCANCODE_APOSTROPHE;

	mov	eax, 8
	imul	ecx, eax, 67
	mov	DWORD PTR _st[ecx+65644], 52		; 00000034H

; 75   : 	st.keys[68].key=SDL_SCANCODE_EQUALS;

	mov	eax, 8
	imul	ecx, eax, 68
	mov	DWORD PTR _st[ecx+65644], 46		; 0000002eH

; 76   : 	st.keys[69].key=SDL_SCANCODE_MINUS;

	mov	eax, 8
	imul	ecx, eax, 69
	mov	DWORD PTR _st[ecx+65644], 45		; 0000002dH

; 77   : 	st.keys[70].key=SDL_SCANCODE_LEFTBRACKET;

	mov	eax, 8
	imul	ecx, eax, 70
	mov	DWORD PTR _st[ecx+65644], 47		; 0000002fH

; 78   : 	st.keys[71].key=SDL_SCANCODE_RIGHTBRACKET;

	mov	eax, 8
	imul	ecx, eax, 71
	mov	DWORD PTR _st[ecx+65644], 48		; 00000030H

; 79   : 	st.keys[72].key=SDL_SCANCODE_PERIOD;

	mov	eax, 8
	imul	ecx, eax, 72
	mov	DWORD PTR _st[ecx+65644], 55		; 00000037H

; 80   : 	st.keys[73].key=SDL_SCANCODE_SEMICOLON;

	mov	eax, 8
	imul	ecx, eax, 73
	mov	DWORD PTR _st[ecx+65644], 51		; 00000033H

; 81   : 	st.keys[74].key=SDL_SCANCODE_CAPSLOCK;

	mov	eax, 8
	imul	ecx, eax, 74
	mov	DWORD PTR _st[ecx+65644], 57		; 00000039H

; 82   : 	st.keys[75].key=SDL_SCANCODE_DELETE;

	mov	eax, 8
	imul	ecx, eax, 75
	mov	DWORD PTR _st[ecx+65644], 76		; 0000004cH

; 83   : 
; 84   : 	num=SDL_NumJoysticks();

	call	_SDL_NumJoysticks
	mov	DWORD PTR _num$[ebp], eax

; 85   : 
; 86   : 	//Check if it's a game controller
; 87   : 
; 88   : 	if(num>4) num=4; //Max number of joysticks is 4

	cmp	DWORD PTR _num$[ebp], 4
	jbe	SHORT $LN16@InputInit
	mov	DWORD PTR _num$[ebp], 4
$LN16@InputInit:

; 89   : 	j=0;

	mov	DWORD PTR _j$[ebp], 0

; 90   : 
; 91   : 	for(i=0;i<num;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@InputInit
$LN14@InputInit:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN15@InputInit:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _num$[ebp]
	jae	$LN13@InputInit

; 92   : 	{
; 93   : 		if(SDL_IsGameController(i))

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SDL_IsGameController
	add	esp, 4
	test	eax, eax
	je	$LN12@InputInit

; 94   : 		{
; 95   : 			if((st.controller[j].device=SDL_GameControllerOpen(i))==NULL)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SDL_GameControllerOpen
	add	esp, 4
	mov	DWORD PTR tv334[ebp], eax
	imul	ecx, DWORD PTR _j$[ebp], 248
	mov	edx, DWORD PTR tv334[ebp]
	mov	DWORD PTR _st[ecx+2335448], edx
	cmp	DWORD PTR tv334[ebp], 0
	jne	SHORT $LN11@InputInit

; 96   : 				LogApp("Game Controller %d could not be initialized: %s",i,SDL_GetError());

	call	_SDL_GetError
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0DA@PMCGCBBG@Game?5Controller?5?$CFd?5could?5not?5be?5@
	call	_SDL_Log
	add	esp, 12					; 0000000cH

; 97   : 			else

	jmp	SHORT $LN12@InputInit
$LN11@InputInit:

; 98   : 			if((st.controller[j].joystick=SDL_JoystickOpen(i))==NULL)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SDL_JoystickOpen
	add	esp, 4
	mov	DWORD PTR tv344[ebp], eax
	imul	ecx, DWORD PTR _j$[ebp], 248
	mov	edx, DWORD PTR tv344[ebp]
	mov	DWORD PTR _st[ecx+2335692], edx
	cmp	DWORD PTR tv344[ebp], 0
	jne	SHORT $LN9@InputInit

; 99   : 				LogApp("Game Controller %d could not be initialized: %s",i,SDL_GetError());

	call	_SDL_GetError
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0DA@PMCGCBBG@Game?5Controller?5?$CFd?5could?5not?5be?5@
	call	_SDL_Log
	add	esp, 12					; 0000000cH

; 100  : 			else

	jmp	SHORT $LN12@InputInit
$LN9@InputInit:

; 101  : 				j++;

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN12@InputInit:

; 102  : 		}
; 103  : 		/*
; 104  : 		else
; 105  : 		if((st.Joy[i]=SDL_JoystickOpen(i))==NULL)
; 106  : 			LogApp("Joystick %d could not be initialized: %s",i,SDL_GetError());
; 107  : 			*/
; 108  : 	}

	jmp	$LN14@InputInit
$LN13@InputInit:

; 109  : 
; 110  : 	LogApp("Found %d controller devices",j);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@LJNKGHEH@Found?5?$CFd?5controller?5devices?$AA@
	call	_SDL_Log
	add	esp, 8

; 111  : 
; 112  : 	if(j>0)

	cmp	DWORD PTR _j$[ebp], 0
	jbe	$LN17@InputInit

; 113  : 	{
; 114  : 
; 115  : 		st.control_num=j;

	mov	al, BYTE PTR _j$[ebp]
	mov	BYTE PTR _st+2335447, al

; 116  : 
; 117  : 		for(i=0;i<j;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@InputInit
$LN5@InputInit:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@InputInit:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _j$[ebp]
	jae	$LN17@InputInit

; 118  : 		{
; 119  : 			if((st.controller[i].force=SDL_HapticOpenFromJoystick(st.controller[i].joystick))==NULL)

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, DWORD PTR _st[eax+2335692]
	push	ecx
	call	_SDL_HapticOpenFromJoystick
	add	esp, 4
	mov	DWORD PTR tv360[ebp], eax
	imul	edx, DWORD PTR _i$[ebp], 248
	mov	eax, DWORD PTR tv360[ebp]
	mov	DWORD PTR _st[edx+2335620], eax
	cmp	DWORD PTR tv360[ebp], 0
	jne	SHORT $LN3@InputInit

; 120  : 				LogApp("Controller %d does not support force feedback: %s",j,SDL_GetError());

	call	_SDL_GetError
	push	eax
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	push	OFFSET ??_C@_0DC@MGGNMPIL@Controller?5?$CFd?5does?5not?5support?5f@
	call	_SDL_Log
	add	esp, 12					; 0000000cH

; 121  : 			else

	jmp	SHORT $LN2@InputInit
$LN3@InputInit:

; 122  : 				if(SDL_HapticRumbleInit(st.controller[i].force)!=0)

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, DWORD PTR _st[eax+2335620]
	push	ecx
	call	_SDL_HapticRumbleInit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@InputInit

; 123  : 					LogApp("Could not initialize rumble: %s",SDL_GetError());

	call	_SDL_GetError
	push	eax
	push	OFFSET ??_C@_0CA@HBDNELMP@Could?5not?5initialize?5rumble?3?5?$CFs?$AA@
	call	_SDL_Log
	add	esp, 8
$LN2@InputInit:

; 124  : 
; 125  : 			st.controller[i].axis[0].name=SDL_CONTROLLER_AXIS_LEFTX;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	imul	edx, ecx, 0
	mov	DWORD PTR _st[eax+edx+2335572], 0

; 126  : 			st.controller[i].axis[1].name=SDL_CONTROLLER_AXIS_LEFTY;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	shl	ecx, 0
	mov	DWORD PTR _st[eax+ecx+2335572], 1

; 127  : 			st.controller[i].axis[2].name=SDL_CONTROLLER_AXIS_RIGHTX;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	shl	ecx, 1
	mov	DWORD PTR _st[eax+ecx+2335572], 2

; 128  : 			st.controller[i].axis[3].name=SDL_CONTROLLER_AXIS_RIGHTY;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	imul	edx, ecx, 3
	mov	DWORD PTR _st[eax+edx+2335572], 3

; 129  : 			st.controller[i].axis[4].name=SDL_CONTROLLER_AXIS_TRIGGERLEFT;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	shl	ecx, 2
	mov	DWORD PTR _st[eax+ecx+2335572], 4

; 130  : 			st.controller[i].axis[5].name=SDL_CONTROLLER_AXIS_TRIGGERRIGHT;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	imul	edx, ecx, 5
	mov	DWORD PTR _st[eax+edx+2335572], 5

; 131  : 
; 132  : 			st.controller[i].button[0].name=SDL_CONTROLLER_BUTTON_A;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	imul	edx, ecx, 0
	mov	DWORD PTR _st[eax+edx+2335452], 0

; 133  : 			st.controller[i].button[1].name=SDL_CONTROLLER_BUTTON_B;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	shl	ecx, 0
	mov	DWORD PTR _st[eax+ecx+2335452], 1

; 134  : 			st.controller[i].button[2].name=SDL_CONTROLLER_BUTTON_X;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	shl	ecx, 1
	mov	DWORD PTR _st[eax+ecx+2335452], 2

; 135  : 			st.controller[i].button[3].name=SDL_CONTROLLER_BUTTON_Y;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	imul	edx, ecx, 3
	mov	DWORD PTR _st[eax+edx+2335452], 3

; 136  : 			st.controller[i].button[4].name=SDL_CONTROLLER_BUTTON_BACK;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	shl	ecx, 2
	mov	DWORD PTR _st[eax+ecx+2335452], 4

; 137  : 			st.controller[i].button[5].name=SDL_CONTROLLER_BUTTON_GUIDE;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	imul	edx, ecx, 5
	mov	DWORD PTR _st[eax+edx+2335452], 5

; 138  : 			st.controller[i].button[6].name=SDL_CONTROLLER_BUTTON_START;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	imul	edx, ecx, 6
	mov	DWORD PTR _st[eax+edx+2335452], 6

; 139  : 			st.controller[i].button[7].name=SDL_CONTROLLER_BUTTON_LEFTSTICK;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	imul	edx, ecx, 7
	mov	DWORD PTR _st[eax+edx+2335452], 7

; 140  : 			st.controller[i].button[8].name=SDL_CONTROLLER_BUTTON_RIGHTSTICK;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	shl	ecx, 3
	mov	DWORD PTR _st[eax+ecx+2335452], 8

; 141  : 			st.controller[i].button[9].name=SDL_CONTROLLER_BUTTON_LEFTSHOULDER;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	imul	edx, ecx, 9
	mov	DWORD PTR _st[eax+edx+2335452], 9

; 142  : 			st.controller[i].button[10].name=SDL_CONTROLLER_BUTTON_RIGHTSHOULDER;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	imul	edx, ecx, 10
	mov	DWORD PTR _st[eax+edx+2335452], 10	; 0000000aH

; 143  : 			st.controller[i].button[11].name=SDL_CONTROLLER_BUTTON_DPAD_UP;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	imul	edx, ecx, 11
	mov	DWORD PTR _st[eax+edx+2335452], 11	; 0000000bH

; 144  : 			st.controller[i].button[12].name=SDL_CONTROLLER_BUTTON_DPAD_DOWN;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	imul	edx, ecx, 12
	mov	DWORD PTR _st[eax+edx+2335452], 12	; 0000000cH

; 145  : 			st.controller[i].button[13].name=SDL_CONTROLLER_BUTTON_DPAD_LEFT;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	imul	edx, ecx, 13
	mov	DWORD PTR _st[eax+edx+2335452], 13	; 0000000dH

; 146  : 			st.controller[i].button[14].name=SDL_CONTROLLER_BUTTON_DPAD_RIGHT;

	imul	eax, DWORD PTR _i$[ebp], 248
	mov	ecx, 8
	imul	edx, ecx, 14
	mov	DWORD PTR _st[eax+edx+2335452], 14	; 0000000eH

; 147  : 		}

	jmp	$LN5@InputInit
$LN17@InputInit:

; 148  : 	}
; 149  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_InputInit ENDP
_TEXT	ENDS
END
