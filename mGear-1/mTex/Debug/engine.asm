; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	C:\Users\Marcos\Desktop\prj\mGear-1\mGear-1\engine.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0OI@GJFBFCOP@?$CDversion?5110?6varying?5in?5vec3?5Pos@ ; `string'
PUBLIC	??_C@_0MG@BKMGOPGG@?$CDversion?5110?6uniform?5sampler2D?5t@ ; `string'
PUBLIC	??_C@_0NN@FCAKKMCK@?$CDversion?5110?6uniform?5sampler2D?5t@ ; `string'
PUBLIC	??_C@_0BIF@GBAEIKJH@?$CDversion?5110?6uniform?5sampler2D?5t@ ; `string'
PUBLIC	??_C@_0BBN@JJOIBKFE@?$CDversion?5110?6uniform?5sampler2D?5t@ ; `string'
PUBLIC	??_C@_0CMD@FLBEOBHH@?$CDversion?5110?6varying?5in?5vec2?5Tex@ ; `string'
PUBLIC	??_C@_0PM@NPFOCGLD@?$CDversion?5130?6in?5vec3?5Position?$DL?6i@ ; `string'
PUBLIC	??_C@_0BDP@HLHOENOH@?$CDversion?5130?6uniform?5sampler2D?5t@ ; `string'
PUBLIC	??_C@_0NB@HNGLJMAI@?$CDversion?5130?6uniform?5sampler2D?5t@ ; `string'
PUBLIC	??_C@_0BFE@LHCNEGLH@?$CDversion?5130?6uniform?5sampler2D?5t@ ; `string'
PUBLIC	??_C@_0BAB@HLALIPKD@?$CDversion?5130?6uniform?5sampler2D?5t@ ; `string'
PUBLIC	??_C@_0CMF@PHINLJLD@?$CDversion?5130?6in?5vec2?5TexCoord2?$DL?6@ ; `string'
PUBLIC	_vbdt_num
PUBLIC	_texone_num
_DATA	SEGMENT
COMM	_st:BYTE:0328140H
COMM	_ent:BYTE:084020H
COMM	_events:BYTE:038H
COMM	_game_lights:BYTE:0280H
COMM	_mgg_sys:BYTE:0b4H
COMM	_mgg_map:BYTE:0f00H
COMM	_mgg_game:BYTE:01e00H
COMM	_wn:DWORD
COMM	_lmp:BYTE:08400H
COMM	_DataN:DWORD
COMM	_DataNT:DWORD
COMM	_DATA_TEST:DWORD
COMM	_z_buffer:WORD:01c800H
COMM	_z_slot:WORD:039H
COMM	_z_used:BYTE
COMM	_lm:DWORD
COMM	_vbd:BYTE:040H
COMM	_vbdt:DWORD
_DATA	ENDS
_BSS	SEGMENT
_vbdt_num DW	01H DUP (?)
	ALIGN	4

_texone_num DW	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_texone_ids:WORD:0800H
COMM	_movie:BYTE:03cH
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

_stbi__vertically_flip_on_load DD 01H DUP (?)
_stbi__unpremultiply_on_load DD 01H DUP (?)
_stbi__de_iphone_flag DD 01H DUP (?)
?tesg@?1??Renderer@@9@9 DD 01H DUP (?)			; `Renderer'::`2'::tesg
_BSS	ENDS
CONST	SEGMENT
_stbi__zdefault_length DB 08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
_stbi__zdefault_distance DB 05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
?tag@?O@??stbi__process_marker@@9@9 DB 04aH		; `stbi__process_marker'::`14'::tag
	DB	046H
	DB	049H
	DB	046H
	DB	00H
	ORG $+3
?tag@?BA@??stbi__process_marker@@9@9 DB 041H		; `stbi__process_marker'::`16'::tag
	DB	064H
	DB	06fH
	DB	062H
	DB	065H
	DB	00H
	ORG $+2
_stbi__jbias DD	00H
	DD	0ffffffffH
	DD	0fffffffdH
	DD	0fffffff9H
	DD	0fffffff1H
	DD	0ffffffe1H
	DD	0ffffffc1H
	DD	0ffffff81H
	DD	0ffffff01H
	DD	0fffffe01H
	DD	0fffffc01H
	DD	0fffff801H
	DD	0fffff001H
	DD	0ffffe001H
	DD	0ffffc001H
	DD	0ffff8001H
CONST	ENDS
;	COMDAT ??_C@_0CMF@PHINLJLD@?$CDversion?5130?6in?5vec2?5TexCoord2?$DL?6@
CONST	SEGMENT
??_C@_0CMF@PHINLJLD@?$CDversion?5130?6in?5vec2?5TexCoord2?$DL?6@ DB '#ver'
	DB	'sion 130', 0aH, 'in vec2 TexCoord2;', 0aH, 'in vec4 colore;', 0aH
	DB	'in vec2 TexLight2;', 0aH, 'out vec4 FColor;', 0aH, 'uniform s'
	DB	'ampler2D texu;', 0aH, 'uniform sampler2D texu2;', 0aH, 'unifo'
	DB	'rm sampler2D texu3;', 0aH, 'uniform float normal;', 0aH, 'voi'
	DB	'd main()', 0aH, '{', 0aH, 'if(normal == 0.0)', 0aH, 'FColor ='
	DB	' texture(texu, TexCoord2) * colore;', 0aH, 'else', 0aH, 'if(n'
	DB	'ormal == 1.0)', 0aH, '{', 0aH, 'vec4 Lightmap = texture(texu2'
	DB	', TexLight2) * 4.0;', 0aH, 'vec3 L = normalize(Lightmap.rgb);'
	DB	0aH, 'vec3 N = normalize(texture(texu3, TexCoord2).rgb * 2.0 -'
	DB	' 1.0);', 0aH, 'FColor = texture(texu, TexCoord2) * colore * ('
	DB	'Lightmap * max(dot(N, L), 0.0));', 0aH, '}', 0aH, 'else', 0aH
	DB	'if(normal == 2.0)', 0aH, '{', 0aH, 'vec4 Lightmap = texture(t'
	DB	'exu2, TexLight2) * 4.0;', 0aH, 'FColor = texture(texu, TexCoo'
	DB	'rd2) * colore * Lightmap;', 0aH, '}', 0aH, 'else', 0aH, 'if(n'
	DB	'ormal == 3.0)', 0aH, 'FColor = texture(texu, TexCoord2) * col'
	DB	'ore;', 0aH, '}', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAB@HLALIPKD@?$CDversion?5130?6uniform?5sampler2D?5t@
CONST	SEGMENT
??_C@_0BAB@HLALIPKD@?$CDversion?5130?6uniform?5sampler2D?5t@ DB '#version'
	DB	' 130', 0aH, 'uniform sampler2D texu;', 0aH, 'uniform sampler2'
	DB	'D texu2;', 0aH, 'in vec2 TexCoord2;', 0aH, 'in vec4 colore;', 0aH
	DB	'out vec4 FColor;', 0aH, 'void main()', 0aH, '{', 0aH, 'vec4 D'
	DB	'iffuse = texture(texu, TexCoord2);', 0aH, 'vec4 Alpha = textu'
	DB	're(texu2, TexCoord2);', 0aH, 'FColor = vec4(Alpha.rgb * Diffu'
	DB	'se.rgb,1.0);', 0aH, '};', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BFE@LHCNEGLH@?$CDversion?5130?6uniform?5sampler2D?5t@
CONST	SEGMENT
??_C@_0BFE@LHCNEGLH@?$CDversion?5130?6uniform?5sampler2D?5t@ DB '#version'
	DB	' 130', 0aH, 'uniform sampler2D texu;', 0aH, 'uniform sampler2'
	DB	'D texu2;', 0aH, 'in vec2 TexCoord2;', 0aH, 'in vec4 colore;', 0aH
	DB	'out vec4 FColor;', 0aH, 'void main()', 0aH, '{', 0aH, 'vec4 D'
	DB	'iffuse = texture(texu, TexCoord2) * colore;', 0aH, 'vec4 Bckg'
	DB	' = texture(texu2, TexCoord2);', 0aH, 'if(Diffuse.a == 1.0)', 0aH
	DB	'discard;', 0aH, 'else', 0aH, '{', 0aH, 'FColor = vec4((Diffus'
	DB	'e.a * Diffuse.rgb) + ((1.0 - Diffuse.a) * Bckg.rgb), 1.0);', 0aH
	DB	'}', 0aH, '};', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0NB@HNGLJMAI@?$CDversion?5130?6uniform?5sampler2D?5t@
CONST	SEGMENT
??_C@_0NB@HNGLJMAI@?$CDversion?5130?6uniform?5sampler2D?5t@ DB '#version '
	DB	'130', 0aH, 'uniform sampler2D texu;', 0aH, 'in vec2 TexCoord2'
	DB	';', 0aH, 'in vec4 colore;', 0aH, 'out vec4 FColor;', 0aH, 'vo'
	DB	'id main()', 0aH, '{', 0aH, 'vec4 Diffuse = texture(texu, TexC'
	DB	'oord2) * colore;', 0aH, 'if(Diffuse.a < 1.0)', 0aH, 'discard;'
	DB	0aH, 'else', 0aH, 'FColor = Diffuse;', 0aH, '};', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BDP@HLHOENOH@?$CDversion?5130?6uniform?5sampler2D?5t@
CONST	SEGMENT
??_C@_0BDP@HLHOENOH@?$CDversion?5130?6uniform?5sampler2D?5t@ DB '#version'
	DB	' 130', 0aH, 'uniform sampler2D texu;', 0aH, 'uniform int ligh'
	DB	't_type;in vec2 TexCoord2;', 0aH, 'in vec4 colore;', 0aH, 'out'
	DB	' vec4 FColor;', 0aH, 'void main()', 0aH, '{', 0aH, 'if( light'
	DB	'_type == 0)', 0aH, 'FColor = texture(texu, TexCoord2);', 0aH, 'e'
	DB	'lse', 0aH, 'if( light_type == 1)', 0aH, 'FColor = texture(tex'
	DB	'u, TexCoord2) * 2.0;', 0aH, 'else', 0aH, 'if( light_type == 2'
	DB	')', 0aH, 'FColor = texture(texu, TexCoord2) * 4.0;', 0aH, '};'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0PM@NPFOCGLD@?$CDversion?5130?6in?5vec3?5Position?$DL?6i@
CONST	SEGMENT
??_C@_0PM@NPFOCGLD@?$CDversion?5130?6in?5vec3?5Position?$DL?6i@ DB '#vers'
	DB	'ion 130', 0aH, 'in vec3 Position;', 0aH, 'in vec2 TexCoord;', 0aH
	DB	'in vec4 Color;', 0aH, 'in vec2 TexLight;', 0aH, 'out vec2 Tex'
	DB	'Coord2;', 0aH, 'out vec4 colore;', 0aH, 'out vec2 TexLight2;', 0aH
	DB	'void main()', 0aH, '{', 0aH, 'gl_Position = vec4(Position, 1.'
	DB	'0);', 0aH, 'TexCoord2 = TexCoord;', 0aH, 'colore = Color;', 0aH
	DB	'TexLight2 = TexLight;', 0aH, '};', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CMD@FLBEOBHH@?$CDversion?5110?6varying?5in?5vec2?5Tex@
CONST	SEGMENT
??_C@_0CMD@FLBEOBHH@?$CDversion?5110?6varying?5in?5vec2?5Tex@ DB '#versio'
	DB	'n 110', 0aH, 'varying in vec2 TexCoord2;', 0aH, 'varying in v'
	DB	'ec4 colore;', 0aH, 'varying out vec4 FColor;', 0aH, 'uniform '
	DB	'sampler2D texu;', 0aH, 'uniform sampler2D texu2;', 0aH, 'unif'
	DB	'orm sampler2D texu3;', 0aH, 'uniform float normal;', 0aH, 'vo'
	DB	'id main()', 0aH, '{', 0aH, 'vec4 Lightmap = texture2D(texu2, '
	DB	'TexCoord2);', 0aH, 'vec3 L = normalize(Lightmap.rgb);', 0aH, 'i'
	DB	'f(normal == 1.0)', 0aH, '{', 0aH, 'vec3 N = normalize((textur'
	DB	'e2D(texu3, TexCoord2).rgb) * 2.0 - 1.0);', 0aH, 'FColor = (te'
	DB	'xture2D(texu, TexCoord2) * colore) * ((Lightmap) * max(dot(N,'
	DB	' L), 0.0));', 0aH, '}', 0aH, 'else', 0aH, 'if(normal == 0.0 |'
	DB	'| normal == 2.0)', 0aH, '{', 0aH, 'vec3 NormalColor = vec3(0.'
	DB	'501, 0.501, 1.0);', 0aH, 'FColor = (texture2D(texu, TexCoord2'
	DB	') * colore) * ((Lightmap) * max(dot(NormalColor, L), 0.0));', 0aH
	DB	'}', 0aH, 'else', 0aH, 'if(normal == 3.0)', 0aH, 'FColor = tex'
	DB	'ture2D(texu, TexCoord2) * colore;', 0aH, '}', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBN@JJOIBKFE@?$CDversion?5110?6uniform?5sampler2D?5t@
CONST	SEGMENT
??_C@_0BBN@JJOIBKFE@?$CDversion?5110?6uniform?5sampler2D?5t@ DB '#version'
	DB	' 110', 0aH, 'uniform sampler2D texu;', 0aH, 'uniform sampler2'
	DB	'D texu2;', 0aH, 'varying in vec2 TexCoord2;', 0aH, 'varying i'
	DB	'n vec4 colore;', 0aH, 'varying out vec4 FColor;', 0aH, 'void '
	DB	'main()', 0aH, '{', 0aH, 'vec4 Diffuse = texture2D(texu, TexCo'
	DB	'ord2);', 0aH, 'vec4 Alpha = texture2D(texu2, TexCoord2);', 0aH
	DB	'FColor = vec4(Alpha.rgb * Diffuse.rgb,1.0);', 0aH, '};', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BIF@GBAEIKJH@?$CDversion?5110?6uniform?5sampler2D?5t@
CONST	SEGMENT
??_C@_0BIF@GBAEIKJH@?$CDversion?5110?6uniform?5sampler2D?5t@ DB '#version'
	DB	' 110', 0aH, 'uniform sampler2D texu;', 0aH, 'uniform sampler2'
	DB	'D texu2;', 0aH, 'varying in vec2 TexCoord2;', 0aH, 'varying i'
	DB	'n vec4 colore;', 0aH, 'varying out vec4 FColor;', 0aH, 'void '
	DB	'main()', 0aH, '{', 0aH, 'vec4 Diffuse = texture2D(texu, TexCo'
	DB	'ord2) * colore;', 0aH, 'vec4 Bckg = texture2D(texu2, TexCoord'
	DB	'2) * colore;', 0aH, 'if(Diffuse.a == 1.0)', 0aH, 'discard;', 0aH
	DB	'if(Diffuse.a < 1.0 && Diffuse.a > 0.5)', 0aH, '{', 0aH, 'FCol'
	DB	'or = vec4((Diffuse.a * Diffuse.rgb) * Bckg.rgb, 1.0);', 0aH, '}'
	DB	0aH, '};', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0NN@FCAKKMCK@?$CDversion?5110?6uniform?5sampler2D?5t@
CONST	SEGMENT
??_C@_0NN@FCAKKMCK@?$CDversion?5110?6uniform?5sampler2D?5t@ DB '#version '
	DB	'110', 0aH, 'uniform sampler2D texu;', 0aH, 'varying in vec2 T'
	DB	'exCoord2;', 0aH, 'varying in vec4 colore;', 0aH, 'varying out'
	DB	' vec4 FColor;', 0aH, 'void main()', 0aH, '{', 0aH, 'vec4 Diff'
	DB	'use = texture2D(texu, TexCoord2);', 0aH, 'if(Diffuse.a < 1.0)'
	DB	0aH, 'discard;', 0aH, 'FColor = Diffuse;', 0aH, '};', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0MG@BKMGOPGG@?$CDversion?5110?6uniform?5sampler2D?5t@
CONST	SEGMENT
??_C@_0MG@BKMGOPGG@?$CDversion?5110?6uniform?5sampler2D?5t@ DB '#version '
	DB	'110', 0aH, 'uniform sampler2D texu;', 0aH, 'uniform float nor'
	DB	'mal;', 0aH, 'varying in vec2 TexCoord2;', 0aH, 'varying in ve'
	DB	'c4 colore;', 0aH, 'varying out vec4 FColor;', 0aH, 'void main'
	DB	'()', 0aH, '{', 0aH, 'FColor = texture2D(texu,TexCoord2) * col'
	DB	'ore;', 0aH, '};', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0OI@GJFBFCOP@?$CDversion?5110?6varying?5in?5vec3?5Pos@
CONST	SEGMENT
??_C@_0OI@GJFBFCOP@?$CDversion?5110?6varying?5in?5vec3?5Pos@ DB '#version'
	DB	' 110', 0aH, 'varying in vec3 Position;', 0aH, 'varying in vec'
	DB	'2 TexCoord;', 0aH, 'varying in vec4 Color;', 0aH, 'varying ou'
	DB	't vec2 TexCoord2;', 0aH, 'varying out vec4 colore;', 0aH, 'vo'
	DB	'id main()', 0aH, '{', 0aH, 'gl_Position = vec4(Position, 1.0)'
	DB	';', 0aH, 'TexCoord2 = TexCoord;', 0aH, 'colore = Color;', 0aH
	DB	'};', 0aH, 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
?invalid_chunk@?BO@??stbi__parse_png_file@@9@9 DB 'XXXX PNG chunk not kno'
	DB	'wn', 00H					; `stbi__parse_png_file'::`30'::invalid_chunk
	ORG $+3
_stbi__l2h_gamma DD 0400ccccdr			; 2.2
_stbi__l2h_scale DD 03f800000r			; 1
_stbi__h2l_gamma_i DD 03ee8ba2er		; 0.454545
_stbi__h2l_scale_i DD 03f800000r		; 1
?length_dezigzag@?1??stbi__compute_huffman_codes@@9@9 DB 010H ; `stbi__compute_huffman_codes'::`2'::length_dezigzag
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
	ORG $+1
_stbi__zlength_base DD 03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0dH
	DD	0fH
	DD	011H
	DD	013H
	DD	017H
	DD	01bH
	DD	01fH
	DD	023H
	DD	02bH
	DD	033H
	DD	03bH
	DD	043H
	DD	053H
	DD	063H
	DD	073H
	DD	083H
	DD	0a3H
	DD	0c3H
	DD	0e3H
	DD	0102H
	DD	00H
	DD	00H
?rgb@?5??stbi__process_frame_header@@9@9 DB 052H	; `stbi__process_frame_header'::`6'::rgb
	DB	047H
	DB	042H
	ORG $+1
_stbi__zlength_extra DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	DD	00H
	DD	00H
_stbi__depth_scale_table DB 00H
	DB	0ffH
	DB	055H
	DB	00H
	DB	011H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	ORG $+3
_stbi__zdist_base DD 01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	07H
	DD	09H
	DD	0dH
	DD	011H
	DD	019H
	DD	021H
	DD	031H
	DD	041H
	DD	061H
	DD	081H
	DD	0c1H
	DD	0101H
	DD	0181H
	DD	0201H
	DD	0301H
	DD	0401H
	DD	0601H
	DD	0801H
	DD	0c01H
	DD	01001H
	DD	01801H
	DD	02001H
	DD	03001H
	DD	04001H
	DD	06001H
	DD	00H
	DD	00H
_stbi__zdist_extra DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
	ORG $+8
_Texture_VShader110 DD FLAT:??_C@_0OI@GJFBFCOP@?$CDversion?5110?6varying?5in?5vec3?5Pos@
	ORG $+252
_Texture_FShader110 DD FLAT:??_C@_0MG@BKMGOPGG@?$CDversion?5110?6uniform?5sampler2D?5t@
	ORG $+252
_TextureNoT_FShader110 DD FLAT:??_C@_0NN@FCAKKMCK@?$CDversion?5110?6uniform?5sampler2D?5t@
	ORG $+252
_TextureT_FShader110 DD FLAT:??_C@_0BIF@GBAEIKJH@?$CDversion?5110?6uniform?5sampler2D?5t@
	ORG $+252
_Blend_FShader110 DD FLAT:??_C@_0BBN@JJOIBKFE@?$CDversion?5110?6uniform?5sampler2D?5t@
	ORG $+252
_Lightmap_FShader110 DD FLAT:??_C@_0CMD@FLBEOBHH@?$CDversion?5110?6varying?5in?5vec2?5Tex@
	ORG $+508
_Texture_VShader DD FLAT:??_C@_0PM@NPFOCGLD@?$CDversion?5130?6in?5vec3?5Position?$DL?6i@
	ORG $+252
_Texture_FShader DD FLAT:??_C@_0BDP@HLHOENOH@?$CDversion?5130?6uniform?5sampler2D?5t@
	ORG $+252
_TextureNoT_FShader DD FLAT:??_C@_0NB@HNGLJMAI@?$CDversion?5130?6uniform?5sampler2D?5t@
	ORG $+252
_TextureT_FShader DD FLAT:??_C@_0BFE@LHCNEGLH@?$CDversion?5130?6uniform?5sampler2D?5t@
	ORG $+252
_Blend_FShader DD FLAT:??_C@_0BAB@HLALIPKD@?$CDversion?5130?6uniform?5sampler2D?5t@
	ORG $+252
_Lightmap_FShader DD FLAT:??_C@_0CMF@PHINLJLD@?$CDversion?5130?6in?5vec2?5TexCoord2?$DL?6@
	ORG $+508
?png_sig@?1??stbi__check_png_header@@9@9 DB 089H	; `stbi__check_png_header'::`2'::png_sig
	DB	050H
	DB	04eH
	DB	047H
	DB	0dH
	DB	0aH
	DB	01aH
	DB	0aH
_first_row_filter DB 00H
	DB	01H
	DB	00H
	DB	05H
	DB	06H
	ORG $+3
_stbi__stdio_callbacks DD FLAT:_stbi__stdio_read
	DD	FLAT:_stbi__stdio_skip
	DD	FLAT:_stbi__stdio_eof
	ORG $+4
_stbi__bmask DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
	DD	0ffffH
	ORG $+4
_stbi__jpeg_dezigzag DB 00H
	DB	01H
	DB	08H
	DB	010H
	DB	09H
	DB	02H
	DB	03H
	DB	0aH
	DB	011H
	DB	018H
	DB	020H
	DB	019H
	DB	012H
	DB	0bH
	DB	04H
	DB	05H
	DB	0cH
	DB	013H
	DB	01aH
	DB	021H
	DB	028H
	DB	030H
	DB	029H
	DB	022H
	DB	01bH
	DB	014H
	DB	0dH
	DB	06H
	DB	07H
	DB	0eH
	DB	015H
	DB	01cH
	DB	023H
	DB	02aH
	DB	031H
	DB	038H
	DB	039H
	DB	032H
	DB	02bH
	DB	024H
	DB	01dH
	DB	016H
	DB	0fH
	DB	017H
	DB	01eH
	DB	025H
	DB	02cH
	DB	033H
	DB	03aH
	DB	03bH
	DB	034H
	DB	02dH
	DB	026H
	DB	01fH
	DB	027H
	DB	02eH
	DB	035H
	DB	03cH
	DB	03dH
	DB	036H
	DB	02fH
	DB	037H
	DB	03eH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
_DATA	ENDS
PUBLIC	_Init
PUBLIC	_OpenFont
PUBLIC	_Quit
PUBLIC	_CheckMGGInSystem
PUBLIC	_CheckMGGFile
PUBLIC	_LoadMGG
PUBLIC	_FreeMGG
PUBLIC	_InitMGG
PUBLIC	@SetTimerM@8
PUBLIC	@GetTimerM@0
PUBLIC	_FPSCounter
PUBLIC	_CreateLog
PUBLIC	_LogIn
PUBLIC	_RestartVideo
PUBLIC	_STWci
PUBLIC	_POT
PUBLIC	@WTS@8
PUBLIC	_WTSf
PUBLIC	_ResetVB
PUBLIC	_mCos
PUBLIC	_mSin
PUBLIC	_mTan
PUBLIC	_CalCos16s
PUBLIC	_CalSin16s
PUBLIC	_CalTan16s
PUBLIC	_CalCos32s
PUBLIC	_CalSin32s
PUBLIC	_CalTan32s
PUBLIC	_CalCos16u
PUBLIC	_CalSin16u
PUBLIC	_CalTan16u
PUBLIC	_CalCos32u
PUBLIC	_CalSin32u
PUBLIC	_CalTan32u
PUBLIC	_BASICBKD
PUBLIC	_DrawObj
PUBLIC	_DrawLine
PUBLIC	_DrawString2
PUBLIC	_DrawString2UI
PUBLIC	_DrawStringUI
PUBLIC	_DrawUI
PUBLIC	_DrawPolygon
PUBLIC	_DrawUI2
PUBLIC	_DrawStringUIv
PUBLIC	_Renderer
PUBLIC	_CheckCollisionMouse
PUBLIC	_CheckCollisionMouseWorld
PUBLIC	_UIData
PUBLIC	_StringUI2Data
PUBLIC	_StringUIData
PUBLIC	_StringUIvData
PUBLIC	_String2Data
PUBLIC	_StringData
PUBLIC	_Finish
PUBLIC	_DrawSys
PUBLIC	_stbi_load_from_memory
PUBLIC	_stbi_load_from_callbacks
PUBLIC	_stbi_load
PUBLIC	_stbi_load_from_file
PUBLIC	_stbi_load_16_from_memory
PUBLIC	_stbi_load_16_from_callbacks
PUBLIC	_stbi_load_16
PUBLIC	_stbi_load_from_file_16
PUBLIC	_stbi_loadf_from_memory
PUBLIC	_stbi_loadf_from_callbacks
PUBLIC	_stbi_loadf
PUBLIC	_stbi_loadf_from_file
PUBLIC	_stbi_ldr_to_hdr_gamma
PUBLIC	_stbi_ldr_to_hdr_scale
PUBLIC	_stbi_is_hdr_from_callbacks
PUBLIC	_stbi_is_hdr_from_memory
PUBLIC	_stbi_is_hdr
PUBLIC	_stbi_is_hdr_from_file
PUBLIC	_stbi_failure_reason
PUBLIC	_stbi_image_free
PUBLIC	_stbi_info_from_memory
PUBLIC	_stbi_info_from_callbacks
PUBLIC	_stbi_info
PUBLIC	_stbi_info_from_file
PUBLIC	_stbi_set_unpremultiply_on_load
PUBLIC	_stbi_convert_iphone_png_to_rgb
PUBLIC	_stbi_set_flip_vertically_on_load
PUBLIC	_stbi_zlib_decode_malloc_guesssize
PUBLIC	_stbi_zlib_decode_malloc_guesssize_headerflag
PUBLIC	_stbi_zlib_decode_malloc
PUBLIC	_stbi_zlib_decode_buffer
PUBLIC	_stbi_zlib_decode_noheader_malloc
PUBLIC	_stbi_zlib_decode_noheader_buffer
PUBLIC	_stbi_hdr_to_ldr_gamma
PUBLIC	_stbi_hdr_to_ldr_scale
PUBLIC	_WindowEvents
PUBLIC	_LineData
PUBLIC	??_C@_0BD@CBEDEJPH@unknown?5image?5type?$AA@	; `string'
PUBLIC	??_C@_08NOGIMCHF@outofmem?$AA@			; `string'
PUBLIC	?__LINE__Var@?1??stbi__load_and_postprocess_8bit@@9@9@e7b221e1 ; `stbi__load_and_postprocess_8bit'::`2'::__LINE__Var
PUBLIC	??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@ ; `string'
PUBLIC	??_C@_1DE@BAGIOALB@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA6?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??stbi__load_and_postprocess_16bit@@9@9@e7b221e1 ; `stbi__load_and_postprocess_16bit'::`2'::__LINE__Var
PUBLIC	??_C@_1DC@NDPEGMEG@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA8?$AA?$AA@ ; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0M@JPDHFAGK@can?8t?5fopen?$AA@		; `string'
PUBLIC	?__LINE__Var@?1??stbi__convert_format@@9@9@e7b221e1 ; `stbi__convert_format'::`2'::__LINE__Var
PUBLIC	??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA4?$AA?$AA@ ; `string'
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	?__LINE__Var@?1??stbi__convert_format16@@9@9@e7b221e1 ; `stbi__convert_format16'::`2'::__LINE__Var
PUBLIC	??_C@_0BB@FOKGPEKG@bad?5code?5lengths?$AA@	; `string'
PUBLIC	?__LINE__Var@?1??stbi__jpeg_huff_decode@@9@9@e7b221e1 ; `stbi__jpeg_huff_decode'::`2'::__LINE__Var
PUBLIC	??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AA?$CI?$AA3?$AA2?$AA?5?$AA?9?$AA?5?$AAh?$AA?9?$AA?$DO?$AAs@ ; `string'
PUBLIC	?__LINE__Var@?1??stbi__extend_receive@@9@9@e7b221e1 ; `stbi__extend_receive'::`2'::__LINE__Var
PUBLIC	??_C@_1HO@LDGMAAKB@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs?$AAt?$AAb?$AAi@ ; `string'
PUBLIC	??_C@_0BB@IIMLINA@bad?5huffman?5code?$AA@	; `string'
PUBLIC	??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac?$AA@ ; `string'
PUBLIC	??_C@_0BA@KLNDOKJD@expected?5marker?$AA@	; `string'
PUBLIC	??_C@_0M@LPHNODCG@bad?5DRI?5len?$AA@		; `string'
PUBLIC	??_C@_0N@BOFJCHAP@bad?5DQT?5type?$AA@		; `string'
PUBLIC	??_C@_0O@CNHKKDIM@bad?5DQT?5table?$AA@		; `string'
PUBLIC	??_C@_0P@JLGKOCGN@bad?5DHT?5header?$AA@		; `string'
PUBLIC	??_C@_0M@CICAFFCH@bad?5COM?5len?$AA@		; `string'
PUBLIC	??_C@_0M@EENLKPDI@bad?5APP?5len?$AA@		; `string'
PUBLIC	??_C@_0P@NNGPHMMK@unknown?5marker?$AA@		; `string'
PUBLIC	??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count?$AA@ ; `string'
PUBLIC	??_C@_0M@GNEHAHOH@bad?5SOS?5len?$AA@		; `string'
PUBLIC	??_C@_0M@NOCCBFAC@bad?5DC?5huff?$AA@		; `string'
PUBLIC	??_C@_0M@JGMCBLGG@bad?5AC?5huff?$AA@		; `string'
PUBLIC	??_C@_07EEJOMGGP@bad?5SOS?$AA@			; `string'
PUBLIC	??_C@_0M@DOFMJEMP@bad?5SOF?5len?$AA@		; `string'
PUBLIC	??_C@_0L@BCINMEBJ@only?58?9bit?$AA@		; `string'
PUBLIC	??_C@_0BB@LNEGOMA@no?5header?5height?$AA@	; `string'
PUBLIC	??_C@_07BIDACDEF@0?5width?$AA@			; `string'
PUBLIC	??_C@_0BE@DAPHADHL@bad?5component?5count?$AA@	; `string'
PUBLIC	??_C@_05BLPKENEJ@bad?5H?$AA@			; `string'
PUBLIC	??_C@_05MPLLHCJG@bad?5V?$AA@			; `string'
PUBLIC	??_C@_06LJIHDFHI@bad?5TQ?$AA@			; `string'
PUBLIC	??_C@_09OJDLMMBJ@too?5large?$AA@		; `string'
PUBLIC	??_C@_06CLMBLEP@no?5SOI?$AA@			; `string'
PUBLIC	??_C@_06IFCEAHIA@no?5SOF?$AA@			; `string'
PUBLIC	??_C@_0M@EPMOIECP@bad?5DNL?5len?$AA@		; `string'
PUBLIC	??_C@_0P@PNCLKCLJ@bad?5DNL?5height?$AA@		; `string'
PUBLIC	??_C@_0N@KBPNPPBJ@bad?5req_comp?$AA@		; `string'
PUBLIC	?__LINE__Var@?1??stbi__bit_reverse@@9@9@e7b221e1 ; `stbi__bit_reverse'::`2'::__LINE__Var
PUBLIC	??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6?$AA?$AA@ ; `string'
PUBLIC	??_C@_09EOHLEIKL@bad?5sizes?$AA@		; `string'
PUBLIC	??_C@_0BA@MDNKOBMC@bad?5codelengths?$AA@	; `string'
PUBLIC	?__LINE__Var@?1??stbi__fill_bits@@9@9@e7b221e1	; `stbi__fill_bits'::`2'::__LINE__Var
PUBLIC	??_C@_1EK@GAHNONBJ@?$AAz?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AA1?$AAU?$AA?5?$AA?$DM?$AA?$DM?$AA?5?$AAz?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AA_?$AAb@ ; `string'
PUBLIC	?__LINE__Var@?1??stbi__zhuffman_decode_slowpath@@9@9@e7b221e1 ; `stbi__zhuffman_decode_slowpath'::`2'::__LINE__Var
PUBLIC	??_C@_1CA@BMLMNMFI@?$AAz?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$FL?$AAb?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BE@IBFIPFO@output?5buffer?5limit?$AA@	; `string'
PUBLIC	??_C@_08DIAPIMGJ@bad?5dist?$AA@			; `string'
PUBLIC	?__LINE__Var@?1??stbi__compute_huffman_codes@@9@9@e7b221e1 ; `stbi__compute_huffman_codes'::`2'::__LINE__Var
PUBLIC	??_C@_1BA@NKONKNHF@?$AAc?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA8?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??stbi__parse_uncompressed_block@@9@9@e7b221e1 ; `stbi__parse_uncompressed_block'::`2'::__LINE__Var
PUBLIC	??_C@_1CC@BHGGCLFF@?$AAa?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0N@IECDHMDI@zlib?5corrupt?$AA@		; `string'
PUBLIC	??_C@_0BB@PIPBCKIA@read?5past?5buffer?$AA@	; `string'
PUBLIC	??_C@_0BA@OBKOPAFL@bad?5zlib?5header?$AA@	; `string'
PUBLIC	??_C@_0P@DOGMHEBI@no?5preset?5dict?$AA@		; `string'
PUBLIC	??_C@_0BA@MCNBDLPD@bad?5compression?$AA@	; `string'
PUBLIC	??_C@_0M@DMDNBACF@bad?5png?5sig?$AA@		; `string'
PUBLIC	?__LINE__Var@?1??stbi__create_png_image_raw@@9@9@e7b221e1 ; `stbi__create_png_image_raw'::`2'::__LINE__Var
PUBLIC	??_C@_1FC@ICDHLHK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9@ ; `string'
PUBLIC	??_C@_0BC@BHMPBBMG@not?5enough?5pixels?$AA@	; `string'
PUBLIC	??_C@_0P@FBBCPGMN@invalid?5filter?$AA@		; `string'
PUBLIC	??_C@_1CK@EJKIMPDL@?$AAi?$AAm?$AAg?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA_?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@CPJBBDGC@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?$CL?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??stbi__compute_transparency@@9@9@e7b221e1 ; `stbi__compute_transparency'::`2'::__LINE__Var
PUBLIC	??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??stbi__compute_transparency16@@9@9@e7b221e1 ; `stbi__compute_transparency16'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1??stbi__de_iphone@@9@9@e7b221e1	; `stbi__de_iphone'::`2'::__LINE__Var
PUBLIC	??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@ ; `string'
PUBLIC	??_C@_0O@KBHBNJOK@multiple?5IHDR?$AA@		; `string'
PUBLIC	??_C@_0N@POJLKMKK@bad?5IHDR?5len?$AA@		; `string'
PUBLIC	??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only?$AA@ ; `string'
PUBLIC	??_C@_09MBBNGCKB@bad?5ctype?$AA@		; `string'
PUBLIC	??_C@_0BA@MDMBDDFG@bad?5comp?5method?$AA@	; `string'
PUBLIC	??_C@_0BC@GHLIKKMD@bad?5filter?5method?$AA@	; `string'
PUBLIC	??_C@_0BF@JCGDPBAA@bad?5interlace?5method?$AA@	; `string'
PUBLIC	??_C@_0O@FNFBHCOO@0?9pixel?5image?$AA@		; `string'
PUBLIC	??_C@_0P@JEAFOMAF@first?5not?5IHDR?$AA@		; `string'
PUBLIC	??_C@_0N@JCPAJAKB@invalid?5PLTE?$AA@		; `string'
PUBLIC	??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT?$AA@	; `string'
PUBLIC	??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE?$AA@	; `string'
PUBLIC	??_C@_0N@KDLCCKCH@bad?5tRNS?5len?$AA@		; `string'
PUBLIC	??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha?$AA@	; `string'
PUBLIC	??_C@_07CKIELOEH@no?5PLTE?$AA@			; `string'
PUBLIC	??_C@_09MNNCNKEO@outofdata?$AA@			; `string'
PUBLIC	??_C@_07MLPECBNA@no?5IDAT?$AA@			; `string'
PUBLIC	??_C@_07IANEBNLB@not?5BMP?$AA@			; `string'
PUBLIC	??_C@_0M@KHBIBJBG@unknown?5BMP?$AA@		; `string'
PUBLIC	??_C@_07IEJCHBDI@bad?5BMP?$AA@			; `string'
PUBLIC	??_C@_0L@FEJFGKNE@monochrome?$AA@		; `string'
PUBLIC	??_C@_07IMHMNOIB@BMP?5RLE?$AA@			; `string'
PUBLIC	??_C@_07MALOAKCI@invalid?$AA@			; `string'
PUBLIC	??_C@_07JNJHIMGH@bad?5bpp?$AA@			; `string'
PUBLIC	??_C@_09DAEBACAB@bad?5masks?$AA@		; `string'
PUBLIC	??_C@_0L@DMAPJJO@bad?5format?$AA@		; `string'
PUBLIC	?__LINE__Var@?1??stbi__tga_load@@9@9@e7b221e1	; `stbi__tga_load'::`2'::__LINE__Var
PUBLIC	??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB?$AAI?$AA_?$AAr?$AAg?$AAb?$AA?$AA@ ; `string'
PUBLIC	??_C@_0M@ILLOCNCO@bad?5palette?$AA@		; `string'
PUBLIC	??_C@_02DPNLHKJD@a?$CL?$AA@			; `string'
PUBLIC	??_C@_09JFHIBJMD@mgear?4log?$AA@		; `string'
PUBLIC	??_C@_1DA@PFAEBODD@?$AAO?$AAp?$AAe?$AAn?$AAi?$AAn?$AAg?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_1CE@CDPPCMAP@?$AAC?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_08PJPFOJIA@?$CFs?5?$CF?42f?6?$AA@		; `string'
PUBLIC	??_C@_0BA@BIGBPAJK@Engine?5started?6?$AA@	; `string'
PUBLIC	??_C@_0N@JPOOLMEG@Log?5created?6?$AA@		; `string'
PUBLIC	??_C@_0N@NDCMMGFF@?$CFs?5fps?3?5?$CF?42f?$AA@	; `string'
PUBLIC	??_C@_05PDOBBJNA@Color?$AA@			; `string'
PUBLIC	??_C@_08GCJNLIKG@Position?$AA@			; `string'
PUBLIC	??_C@_08NGMLKGCO@TexCoord?$AA@			; `string'
PUBLIC	??_C@_08DGBKPNED@TexLight?$AA@			; `string'
PUBLIC	??_C@_0BM@HCNBMJIE@SDL?5Initilization?5failed?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BD@DNBPCBJE@SDL?52?40?5initialzed?$AA@	; `string'
PUBLIC	??_C@_0CG@LLIBEPGC@Error?5while?5initializing?5SDL?5TTF@ ; `string'
PUBLIC	??_C@_0BE@MBBIJNFJ@SDL?5TTF?5initialized?$AA@	; `string'
PUBLIC	??_C@_0DJ@GHPNMNEC@Error?5setting?5fullscreen?5video?5m@ ; `string'
PUBLIC	??_C@_0DG@HINKMIAE@Error?5setting?5widowed?5video?5mode@ ; `string'
PUBLIC	??_C@_0CB@CJINDJOG@Window?5created?0?5?$CFd?5x?5?$CFd?0?5?$CFd?5bits@ ; `string'
PUBLIC	??_C@_0BL@JKBAOCCM@Error?5setting?5renderer?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BH@PJDJGOFF@Opengl?5context?5created?$AA@ ; `string'
PUBLIC	??_C@_0BL@PNJKGHIL@GL_ARB_vertex_array_object?$AA@ ; `string'
PUBLIC	??_C@_0FD@HGLPPOCA@VAO?5not?5supported?0?5check?5your?5vi@ ; `string'
PUBLIC	??_C@_0BM@OOMEFFAE@GL_ARB_vertex_buffer_object?$AA@ ; `string'
PUBLIC	??_C@_0FF@HDHKLDIO@VBOs?5not?5supported?0?5check?5your?5v@ ; `string'
PUBLIC	??_C@_0BE@PFGKPDCP@GL_EXT_vertex_array?$AA@	; `string'
PUBLIC	??_C@_0DP@GKIFJBKD@Your?5video?5card?5is?5not?5adequate?5@ ; `string'
PUBLIC	??_C@_0BD@HLIFEONF@GL_EXT_framebuffer?$AA@	; `string'
PUBLIC	??_C@_0GA@BFFFOFBB@Framebuffer?5object?5not?5support?0?5@ ; `string'
PUBLIC	??_C@_0O@BNBOBIPB@Shader?5?$CFd?3?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0BK@JJHKDBGE@Counld?5not?5compile?5shader?$AA@ ; `string'
PUBLIC	??_C@_0BD@CHEFDAHK@Changing?5to?5VBO?4?4?4?$AA@	; `string'
PUBLIC	??_C@_0BC@FPJNDHAI@Changing?5to?5VA?4?4?4?$AA@	; `string'
PUBLIC	??_C@_04DBNNPNIH@texu?$AA@			; `string'
PUBLIC	??_C@_05JOJNJPAP@texu2?$AA@			; `string'
PUBLIC	??_C@_05IHIGKOEO@texu3?$AA@			; `string'
PUBLIC	??_C@_06IKLLLDHL@normal?$AA@			; `string'
PUBLIC	??_C@_0L@GLKJCCIE@light_type?$AA@		; `string'
PUBLIC	??_C@_0BD@MFHDJABA@Opengl?5initialized?$AA@	; `string'
PUBLIC	??_C@_0CA@IICOLDCN@GL_ARB_texture_non_power_of_two?$AA@ ; `string'
PUBLIC	??_C@_0GF@JPJDLJAN@Non?5power?5of?5two?5textures?5not?5su@ ; `string'
PUBLIC	??_C@_0BJ@NKHMPMDJ@GL_ARB_texture_rectangle?$AA@ ; `string'
PUBLIC	??_C@_0BI@KIAKBMLM@GL_NV_texture_rectangle?$AA@	; `string'
PUBLIC	??_C@_0FP@HOKOFLMI@Rectangle?5textures?5not?5supported@ ; `string'
PUBLIC	??_C@_0BC@DHDBMALK@Input?5initialized?$AA@	; `string'
PUBLIC	??_C@_0CC@HAGAANID@Error?5while?5opening?5TTF?5font?5?3?5?$CF@ ; `string'
PUBLIC	??_C@_0BA@NDONFOIB@Video?5restarted?$AA@	; `string'
PUBLIC	??_C@_0DH@KKJPEJIP@Error?5setting?5windowed?5video?5mod@ ; `string'
PUBLIC	??_C@_0BK@MKEONLB@Window?5resized?5to?5?$CFd?5x?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BK@JNFOJKPO@Error?5reading?5MGG?5file?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BD@IGEJGLBO@MGG?5File?5Version?51?$AA@	; `string'
PUBLIC	??_C@_0BL@HGJNDNHB@Invalid?5MGG?5file?5header?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BE@GOCIOEKA@Invalid?5MGG?5file?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BJ@MDEIDPPP@Invalid?5MGG?5file?5info?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0DJ@PPPGBEPE@Error?5allocating?5memory?5for?5text@ ; `string'
PUBLIC	??_C@_0CC@PLAHMHNO@Error?5loading?5texture?5from?5memor@ ; `string'
PUBLIC	??_C@_0EI@OCDBEPGI@Error?5allocating?5memory?5for?5norm@ ; `string'
PUBLIC	??_C@_0DB@EBPLCLOB@Error?5loading?5normal?5mapping?5tex@ ; `string'
PUBLIC	??_C@_0DG@BNCAOHGG@Error?5could?5not?5allocate?5memory?5@ ; `string'
PUBLIC	??_C@_0CH@GLOGGAHF@Warning?3?5max?5number?5os?5strings?5r@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@39000000
PUBLIC	__real@39638e39
PUBLIC	__real@3a000000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@400921fb53c8d4f1
PUBLIC	__real@40400000
PUBLIC	__real@404ca5dc1af05a77
PUBLIC	__real@4066800000000000
PUBLIC	__real@41200000
PUBLIC	__real@42c80000
PUBLIC	__real@437f0000
PUBLIC	__real@43b40ccd
PUBLIC	__real@447a0000
PUBLIC	__real@44800000
PUBLIC	__real@45000000
PUBLIC	__real@46100000
PUBLIC	__real@46180000
PUBLIC	__real@46800000
PUBLIC	__real@47000000
PUBLIC	__real@bf800000
PUBLIC	__xmm@00000200000002000000020000000200
PUBLIC	__xmm@00080008000800080008000800080008
PUBLIC	__xmm@00ff00ff00ff00ff00ff00ff00ff00ff
PUBLIC	__xmm@01010000010100000101000001010000
PUBLIC	__xmm@08a914e808a914e808a914e808a914e8
PUBLIC	__xmm@11c8e09e11c8e09e11c8e09e11c8e09e
PUBLIC	__xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
PUBLIC	__xmm@12d0046b12d0046b12d0046b12d0046b
PUBLIC	__xmm@166f166f166f166f166f166f166f166f
PUBLIC	__xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80808080808080808080808080808080
PUBLIC	__xmm@e09ee565e09ee565e09ee565e09ee565
PUBLIC	__xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
PUBLIC	__xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
PUBLIC	__xmm@f493f493f493f493f493f493f493f493
PUBLIC	__xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
PUBLIC	__xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_strstr:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__glBindTexture@8:PROC
EXTRN	__imp__glBlendFunc@8:PROC
EXTRN	__imp__glClear@4:PROC
EXTRN	__imp__glClearColor@16:PROC
EXTRN	__imp__glClearDepth@8:PROC
EXTRN	__imp__glColorPointer@16:PROC
EXTRN	__imp__glDeleteTextures@8:PROC
EXTRN	__imp__glDepthFunc@4:PROC
EXTRN	__imp__glDisable@4:PROC
EXTRN	__imp__glDisableClientState@4:PROC
EXTRN	__imp__glEnable@4:PROC
EXTRN	__imp__glEnableClientState@4:PROC
EXTRN	__imp__glGenTextures@8:PROC
EXTRN	__imp__glGetString@4:PROC
EXTRN	__imp__glGetTexImage@20:PROC
EXTRN	__imp__glLoadIdentity@0:PROC
EXTRN	__imp__glMatrixMode@4:PROC
EXTRN	__imp__glOrtho@48:PROC
EXTRN	__imp__glPixelStorei@8:PROC
EXTRN	__imp__glTexCoordPointer@16:PROC
EXTRN	__imp__glTexImage2D@36:PROC
EXTRN	__imp__glTexParameterf@12:PROC
EXTRN	__imp__glTexParameteri@12:PROC
EXTRN	__imp__glTexSubImage2D@36:PROC
EXTRN	__imp__glVertexPointer@16:PROC
EXTRN	__imp__glViewport@16:PROC
EXTRN	_GLeeEnabled:PROC
EXTRN	_SDL_GetError:PROC
EXTRN	_exit:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_realloc:PROC
EXTRN	__lrotl:PROC
EXTRN	_SDL_FreeSurface:PROC
EXTRN	_SDL_CreateWindow:PROC
EXTRN	_SDL_SetWindowTitle:PROC
EXTRN	_SDL_DestroyWindow:PROC
EXTRN	_SDL_GL_SetAttribute:PROC
EXTRN	_SDL_GL_CreateContext:PROC
EXTRN	_SDL_GL_SetSwapInterval:PROC
EXTRN	_SDL_SetRelativeMouseMode:PROC
EXTRN	_SDL_GetRelativeMouseMode:PROC
EXTRN	_SDL_Log:PROC
EXTRN	_SDL_LogSetOutputFunction:PROC
EXTRN	_SDL_GetTicks:PROC
EXTRN	_SDL_Init:PROC
EXTRN	_SDL_Quit:PROC
EXTRN	_TTF_Init:PROC
EXTRN	_TTF_OpenFont:PROC
EXTRN	_TTF_RenderUTF8_Blended:PROC
EXTRN	_TTF_Quit:PROC
EXTRN	_fclose:PROC
EXTRN	_feof:PROC
EXTRN	_fopen:PROC
EXTRN	_fopen_s:PROC
EXTRN	_fprintf:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_ftell:PROC
EXTRN	_rewind:PROC
EXTRN	_sprintf:PROC
EXTRN	_abs:PROC
EXTRN	_InputInit:PROC
EXTRN	_InputProcess:PROC
EXTRN	_InputClose:PROC
EXTRN	_atan2:PROC
EXTRN	_cos:PROC
EXTRN	_pow:PROC
EXTRN	_sin:PROC
EXTRN	_tan:PROC
EXTRN	__wassert:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftoui3:PROC
EXTRN	__GLEE_VERSION_3_0:BYTE
EXTRN	_GLeeFuncPtr_glDrawRangeElements:DWORD
EXTRN	_GLeeFuncPtr_glActiveTexture:DWORD
EXTRN	_GLeeFuncPtr_glBindBuffer:DWORD
EXTRN	_GLeeFuncPtr_glGenBuffers:DWORD
EXTRN	_GLeeFuncPtr_glBufferData:DWORD
EXTRN	_GLeeFuncPtr_glBufferSubData:DWORD
EXTRN	_GLeeFuncPtr_glDrawBuffers:DWORD
EXTRN	_GLeeFuncPtr_glAttachShader:DWORD
EXTRN	_GLeeFuncPtr_glCompileShader:DWORD
EXTRN	_GLeeFuncPtr_glCreateProgram:DWORD
EXTRN	_GLeeFuncPtr_glCreateShader:DWORD
EXTRN	_GLeeFuncPtr_glDeleteProgram:DWORD
EXTRN	_GLeeFuncPtr_glDeleteShader:DWORD
EXTRN	_GLeeFuncPtr_glDetachShader:DWORD
EXTRN	_GLeeFuncPtr_glDisableVertexAttribArray:DWORD
EXTRN	_GLeeFuncPtr_glEnableVertexAttribArray:DWORD
EXTRN	_GLeeFuncPtr_glGetAttribLocation:DWORD
EXTRN	_GLeeFuncPtr_glGetProgramiv:DWORD
EXTRN	_GLeeFuncPtr_glGetProgramInfoLog:DWORD
EXTRN	_GLeeFuncPtr_glGetShaderiv:DWORD
EXTRN	_GLeeFuncPtr_glGetShaderInfoLog:DWORD
EXTRN	_GLeeFuncPtr_glGetUniformLocation:DWORD
EXTRN	_GLeeFuncPtr_glLinkProgram:DWORD
EXTRN	_GLeeFuncPtr_glShaderSource:DWORD
EXTRN	_GLeeFuncPtr_glUseProgram:DWORD
EXTRN	_GLeeFuncPtr_glUniform1f:DWORD
EXTRN	_GLeeFuncPtr_glUniform1i:DWORD
EXTRN	_GLeeFuncPtr_glVertexAttribPointer:DWORD
EXTRN	_GLeeFuncPtr_glBindRenderbuffer:DWORD
EXTRN	_GLeeFuncPtr_glGenRenderbuffers:DWORD
EXTRN	_GLeeFuncPtr_glRenderbufferStorage:DWORD
EXTRN	_GLeeFuncPtr_glBindFramebuffer:DWORD
EXTRN	_GLeeFuncPtr_glGenFramebuffers:DWORD
EXTRN	_GLeeFuncPtr_glFramebufferTexture2D:DWORD
EXTRN	_GLeeFuncPtr_glFramebufferRenderbuffer:DWORD
EXTRN	_GLeeFuncPtr_glGenerateMipmap:DWORD
EXTRN	_GLeeFuncPtr_glBindVertexArray:DWORD
EXTRN	_GLeeFuncPtr_glGenVertexArrays:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_stbi__g_failure_reason DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
CONST	SEGMENT
__xmm@fa7efa7efa7efa7efa7efa7efa7efa7e DB '~', 0faH, '~', 0faH, '~', 0faH
	DB	'~', 0faH, '~', 0faH, '~', 0faH, '~', 0faH, '~', 0faH
CONST	ENDS
;	COMDAT __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
CONST	SEGMENT
__xmm@f9c31a9df9c31a9df9c31a9df9c31a9d DB 09dH, 01aH, 0c3H, 0f9H, 09dH, 01aH
	DB	0c3H, 0f9H, 09dH, 01aH, 0c3H, 0f9H, 09dH, 01aH, 0c3H, 0f9H
CONST	ENDS
;	COMDAT __xmm@f493f493f493f493f493f493f493f493
CONST	SEGMENT
__xmm@f493f493f493f493f493f493f493f493 DB 093H, 0f4H, 093H, 0f4H, 093H, 0f4H
	DB	093H, 0f4H, 093H, 0f4H, 093H, 0f4H, 093H, 0f4H, 093H, 0f4H
CONST	ENDS
;	COMDAT __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
CONST	SEGMENT
__xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9 DB 0a9H, 08H, 01aH, 0ebH, 0a9H, 08H
	DB	01aH, 0ebH, 0a9H, 08H, 01aH, 0ebH, 0a9H, 08H, 01aH, 0ebH
CONST	ENDS
;	COMDAT __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
CONST	SEGMENT
__xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0 DB 0d0H, 012H, 0cfH, 0e9H, 0d0H, 012H
	DB	0cfH, 0e9H, 0d0H, 012H, 0cfH, 0e9H, 0d0H, 012H, 0cfH, 0e9H
CONST	ENDS
;	COMDAT __xmm@e09ee565e09ee565e09ee565e09ee565
CONST	SEGMENT
__xmm@e09ee565e09ee565e09ee565e09ee565 DB 'e', 0e5H, 09eH, 0e0H, 'e', 0e5H
	DB	09eH, 0e0H, 'e', 0e5H, 09eH, 0e0H, 'e', 0e5H, 09eH, 0e0H
CONST	ENDS
;	COMDAT __xmm@80808080808080808080808080808080
CONST	SEGMENT
__xmm@80808080808080808080808080808080 DB 080H, 080H, 080H, 080H, 080H, 080H
	DB	080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
CONST	SEGMENT
__xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a DB 'Z', 01cH, 'Z', 01cH, 'Z', 01cH
	DB	'Z', 01cH, 'Z', 01cH, 'Z', 01cH, 'Z', 01cH, 'Z', 01cH
CONST	ENDS
;	COMDAT __xmm@166f166f166f166f166f166f166f166f
CONST	SEGMENT
__xmm@166f166f166f166f166f166f166f166f DB 'o', 016H, 'o', 016H, 'o', 016H
	DB	'o', 016H, 'o', 016H, 'o', 016H, 'o', 016H, 'o', 016H
CONST	ENDS
;	COMDAT __xmm@12d0046b12d0046b12d0046b12d0046b
CONST	SEGMENT
__xmm@12d0046b12d0046b12d0046b12d0046b DB 'k', 04H, 0d0H, 012H, 'k', 04H, 0d0H
	DB	012H, 'k', 04H, 0d0H, 012H, 'k', 04H, 0d0H, 012H
CONST	ENDS
;	COMDAT __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
CONST	SEGMENT
__xmm@11c8f9c311c8f9c311c8f9c311c8f9c3 DB 0c3H, 0f9H, 0c8H, 011H, 0c3H, 0f9H
	DB	0c8H, 011H, 0c3H, 0f9H, 0c8H, 011H, 0c3H, 0f9H, 0c8H, 011H
CONST	ENDS
;	COMDAT __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
CONST	SEGMENT
__xmm@11c8e09e11c8e09e11c8e09e11c8e09e DB 09eH, 0e0H, 0c8H, 011H, 09eH, 0e0H
	DB	0c8H, 011H, 09eH, 0e0H, 0c8H, 011H, 09eH, 0e0H, 0c8H, 011H
CONST	ENDS
;	COMDAT __xmm@08a914e808a914e808a914e808a914e8
CONST	SEGMENT
__xmm@08a914e808a914e808a914e808a914e8 DB 0e8H, 014H, 0a9H, 08H, 0e8H, 014H
	DB	0a9H, 08H, 0e8H, 014H, 0a9H, 08H, 0e8H, 014H, 0a9H, 08H
CONST	ENDS
;	COMDAT __xmm@01010000010100000101000001010000
CONST	SEGMENT
__xmm@01010000010100000101000001010000 DB 00H, 00H, 01H, 01H, 00H, 00H, 01H
	DB	01H, 00H, 00H, 01H, 01H, 00H, 00H, 01H, 01H
CONST	ENDS
;	COMDAT __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
CONST	SEGMENT
__xmm@00ff00ff00ff00ff00ff00ff00ff00ff DB 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
	DB	0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
CONST	ENDS
;	COMDAT __xmm@00080008000800080008000800080008
CONST	SEGMENT
__xmm@00080008000800080008000800080008 DB 08H, 00H, 08H, 00H, 08H, 00H, 08H
	DB	00H, 08H, 00H, 08H, 00H, 08H, 00H, 08H, 00H
CONST	ENDS
;	COMDAT __xmm@00000200000002000000020000000200
CONST	SEGMENT
__xmm@00000200000002000000020000000200 DB 00H, 02H, 00H, 00H, 00H, 02H, 00H
	DB	00H, 00H, 02H, 00H, 00H, 00H, 02H, 00H, 00H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@47000000
CONST	SEGMENT
__real@47000000 DD 047000000r			; 32768
CONST	ENDS
;	COMDAT __real@46800000
CONST	SEGMENT
__real@46800000 DD 046800000r			; 16384
CONST	ENDS
;	COMDAT __real@46180000
CONST	SEGMENT
__real@46180000 DD 046180000r			; 9728
CONST	ENDS
;	COMDAT __real@46100000
CONST	SEGMENT
__real@46100000 DD 046100000r			; 9216
CONST	ENDS
;	COMDAT __real@45000000
CONST	SEGMENT
__real@45000000 DD 045000000r			; 2048
CONST	ENDS
;	COMDAT __real@44800000
CONST	SEGMENT
__real@44800000 DD 044800000r			; 1024
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43b40ccd
CONST	SEGMENT
__real@43b40ccd DD 043b40ccdr			; 360.1
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
CONST	ENDS
;	COMDAT __real@404ca5dc1af05a77
CONST	SEGMENT
__real@404ca5dc1af05a77 DQ 0404ca5dc1af05a77r	; 57.2958
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@400921fb53c8d4f1
CONST	SEGMENT
__real@400921fb53c8d4f1 DQ 0400921fb53c8d4f1r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3a000000
CONST	SEGMENT
__real@3a000000 DD 03a000000r			; 0.000488281
CONST	ENDS
;	COMDAT __real@39638e39
CONST	SEGMENT
__real@39638e39 DD 039638e39r			; 0.000217014
CONST	ENDS
;	COMDAT __real@39000000
CONST	SEGMENT
__real@39000000 DD 039000000r			; 0.00012207
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GLOGGAHF@Warning?3?5max?5number?5os?5strings?5r@
CONST	SEGMENT
??_C@_0CH@GLOGGAHF@Warning?3?5max?5number?5os?5strings?5r@ DB 'Warning: m'
	DB	'ax number os strings reached', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@BNCAOHGG@Error?5could?5not?5allocate?5memory?5@
CONST	SEGMENT
??_C@_0DG@BNCAOHGG@Error?5could?5not?5allocate?5memory?5@ DB 'Error could'
	DB	' not allocate memory for the Vertex Buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@EBPLCLOB@Error?5loading?5normal?5mapping?5tex@
CONST	SEGMENT
??_C@_0DB@EBPLCLOB@Error?5loading?5normal?5mapping?5tex@ DB 'Error loadin'
	DB	'g normal mapping texture from memory', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@OCDBEPGI@Error?5allocating?5memory?5for?5norm@
CONST	SEGMENT
??_C@_0EI@OCDBEPGI@Error?5allocating?5memory?5for?5norm@ DB 'Error alloca'
	DB	'ting memory for normal mapping texture %d, size %d, file %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PLAHMHNO@Error?5loading?5texture?5from?5memor@
CONST	SEGMENT
??_C@_0CC@PLAHMHNO@Error?5loading?5texture?5from?5memor@ DB 'Error loadin'
	DB	'g texture from memory', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@PPPGBEPE@Error?5allocating?5memory?5for?5text@
CONST	SEGMENT
??_C@_0DJ@PPPGBEPE@Error?5allocating?5memory?5for?5text@ DB 'Error alloca'
	DB	'ting memory for texture %d, size %d, file %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MDEIDPPP@Invalid?5MGG?5file?5info?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BJ@MDEIDPPP@Invalid?5MGG?5file?5info?5?$CFs?$AA@ DB 'Invalid MGG f'
	DB	'ile info %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GOCIOEKA@Invalid?5MGG?5file?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BE@GOCIOEKA@Invalid?5MGG?5file?5?$CFs?$AA@ DB 'Invalid MGG file %s'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HGJNDNHB@Invalid?5MGG?5file?5header?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BL@HGJNDNHB@Invalid?5MGG?5file?5header?5?$CFs?$AA@ DB 'Invalid MGG'
	DB	' file header %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IGEJGLBO@MGG?5File?5Version?51?$AA@
CONST	SEGMENT
??_C@_0BD@IGEJGLBO@MGG?5File?5Version?51?$AA@ DB 'MGG File Version 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JNFOJKPO@Error?5reading?5MGG?5file?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BK@JNFOJKPO@Error?5reading?5MGG?5file?5?$CFs?$AA@ DB 'Error readin'
	DB	'g MGG file %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MKEONLB@Window?5resized?5to?5?$CFd?5x?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BK@MKEONLB@Window?5resized?5to?5?$CFd?5x?5?$CFd?$AA@ DB 'Window re'
	DB	'sized to %d x %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@KKJPEJIP@Error?5setting?5windowed?5video?5mod@
CONST	SEGMENT
??_C@_0DH@KKJPEJIP@Error?5setting?5windowed?5video?5mod@ DB 'Error settin'
	DB	'g windowed video mode %d x %d %d bits - %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NDONFOIB@Video?5restarted?$AA@
CONST	SEGMENT
??_C@_0BA@NDONFOIB@Video?5restarted?$AA@ DB 'Video restarted', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HAGAANID@Error?5while?5opening?5TTF?5font?5?3?5?$CF@
CONST	SEGMENT
??_C@_0CC@HAGAANID@Error?5while?5opening?5TTF?5font?5?3?5?$CF@ DB 'Error '
	DB	'while opening TTF font : %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DHDBMALK@Input?5initialized?$AA@
CONST	SEGMENT
??_C@_0BC@DHDBMALK@Input?5initialized?$AA@ DB 'Input initialized', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@HOKOFLMI@Rectangle?5textures?5not?5supported@
CONST	SEGMENT
??_C@_0FP@HOKOFLMI@Rectangle?5textures?5not?5supported@ DB 'Rectangle tex'
	DB	'tures not supported, your video card is not supported or try '
	DB	'updating your driver', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KIAKBMLM@GL_NV_texture_rectangle?$AA@
CONST	SEGMENT
??_C@_0BI@KIAKBMLM@GL_NV_texture_rectangle?$AA@ DB 'GL_NV_texture_rectang'
	DB	'le', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NKHMPMDJ@GL_ARB_texture_rectangle?$AA@
CONST	SEGMENT
??_C@_0BJ@NKHMPMDJ@GL_ARB_texture_rectangle?$AA@ DB 'GL_ARB_texture_recta'
	DB	'ngle', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@JPJDLJAN@Non?5power?5of?5two?5textures?5not?5su@
CONST	SEGMENT
??_C@_0GF@JPJDLJAN@Non?5power?5of?5two?5textures?5not?5su@ DB 'Non power '
	DB	'of two textures not supported, loading times might increase a'
	DB	'nd video''s fps might decrease', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IICOLDCN@GL_ARB_texture_non_power_of_two?$AA@
CONST	SEGMENT
??_C@_0CA@IICOLDCN@GL_ARB_texture_non_power_of_two?$AA@ DB 'GL_ARB_textur'
	DB	'e_non_power_of_two', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MFHDJABA@Opengl?5initialized?$AA@
CONST	SEGMENT
??_C@_0BD@MFHDJABA@Opengl?5initialized?$AA@ DB 'Opengl initialized', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GLKJCCIE@light_type?$AA@
CONST	SEGMENT
??_C@_0L@GLKJCCIE@light_type?$AA@ DB 'light_type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKLLLDHL@normal?$AA@
CONST	SEGMENT
??_C@_06IKLLLDHL@normal?$AA@ DB 'normal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IHIGKOEO@texu3?$AA@
CONST	SEGMENT
??_C@_05IHIGKOEO@texu3?$AA@ DB 'texu3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JOJNJPAP@texu2?$AA@
CONST	SEGMENT
??_C@_05JOJNJPAP@texu2?$AA@ DB 'texu2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DBNNPNIH@texu?$AA@
CONST	SEGMENT
??_C@_04DBNNPNIH@texu?$AA@ DB 'texu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FPJNDHAI@Changing?5to?5VA?4?4?4?$AA@
CONST	SEGMENT
??_C@_0BC@FPJNDHAI@Changing?5to?5VA?4?4?4?$AA@ DB 'Changing to VA...', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CHEFDAHK@Changing?5to?5VBO?4?4?4?$AA@
CONST	SEGMENT
??_C@_0BD@CHEFDAHK@Changing?5to?5VBO?4?4?4?$AA@ DB 'Changing to VBO...', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JJHKDBGE@Counld?5not?5compile?5shader?$AA@
CONST	SEGMENT
??_C@_0BK@JJHKDBGE@Counld?5not?5compile?5shader?$AA@ DB 'Counld not compi'
	DB	'le shader', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNBOBIPB@Shader?5?$CFd?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0O@BNBOBIPB@Shader?5?$CFd?3?5?$CFs?$AA@ DB 'Shader %d: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@BFFFOFBB@Framebuffer?5object?5not?5support?0?5@
CONST	SEGMENT
??_C@_0GA@BFFFOFBB@Framebuffer?5object?5not?5support?0?5@ DB 'Framebuffer'
	DB	' object not support, check your video''s card driver for upda'
	DB	'tes... Usign VA instead!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HLIFEONF@GL_EXT_framebuffer?$AA@
CONST	SEGMENT
??_C@_0BD@HLIFEONF@GL_EXT_framebuffer?$AA@ DB 'GL_EXT_framebuffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@GKIFJBKD@Your?5video?5card?5is?5not?5adequate?5@
CONST	SEGMENT
??_C@_0DP@GKIFJBKD@Your?5video?5card?5is?5not?5adequate?5@ DB 'Your video'
	DB	' card is not adequate to play this game... Goodbye!!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PFGKPDCP@GL_EXT_vertex_array?$AA@
CONST	SEGMENT
??_C@_0BE@PFGKPDCP@GL_EXT_vertex_array?$AA@ DB 'GL_EXT_vertex_array', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@HDHKLDIO@VBOs?5not?5supported?0?5check?5your?5v@
CONST	SEGMENT
??_C@_0FF@HDHKLDIO@VBOs?5not?5supported?0?5check?5your?5v@ DB 'VBOs not s'
	DB	'upported, check your video''s card driver for updates... Usin'
	DB	'g VA instead!!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OOMEFFAE@GL_ARB_vertex_buffer_object?$AA@
CONST	SEGMENT
??_C@_0BM@OOMEFFAE@GL_ARB_vertex_buffer_object?$AA@ DB 'GL_ARB_vertex_buf'
	DB	'fer_object', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@HGLPPOCA@VAO?5not?5supported?0?5check?5your?5vi@
CONST	SEGMENT
??_C@_0FD@HGLPPOCA@VAO?5not?5supported?0?5check?5your?5vi@ DB 'VAO not su'
	DB	'pported, check your video''s card driver for updates... Using'
	DB	' VBO instead', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PNJKGHIL@GL_ARB_vertex_array_object?$AA@
CONST	SEGMENT
??_C@_0BL@PNJKGHIL@GL_ARB_vertex_array_object?$AA@ DB 'GL_ARB_vertex_arra'
	DB	'y_object', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PJDJGOFF@Opengl?5context?5created?$AA@
CONST	SEGMENT
??_C@_0BH@PJDJGOFF@Opengl?5context?5created?$AA@ DB 'Opengl context creat'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JKBAOCCM@Error?5setting?5renderer?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BL@JKBAOCCM@Error?5setting?5renderer?3?5?$CFs?$AA@ DB 'Error setti'
	DB	'ng renderer: %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CJINDJOG@Window?5created?0?5?$CFd?5x?5?$CFd?0?5?$CFd?5bits@
CONST	SEGMENT
??_C@_0CB@CJINDJOG@Window?5created?0?5?$CFd?5x?5?$CFd?0?5?$CFd?5bits@ DB 'W'
	DB	'indow created, %d x %d, %d bits', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HINKMIAE@Error?5setting?5widowed?5video?5mode@
CONST	SEGMENT
??_C@_0DG@HINKMIAE@Error?5setting?5widowed?5video?5mode@ DB 'Error settin'
	DB	'g widowed video mode %d x %d %d bits - %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@GHPNMNEC@Error?5setting?5fullscreen?5video?5m@
CONST	SEGMENT
??_C@_0DJ@GHPNMNEC@Error?5setting?5fullscreen?5video?5m@ DB 'Error settin'
	DB	'g fullscreen video mode %d x %d %d bits - %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MBBIJNFJ@SDL?5TTF?5initialized?$AA@
CONST	SEGMENT
??_C@_0BE@MBBIJNFJ@SDL?5TTF?5initialized?$AA@ DB 'SDL TTF initialized', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LLIBEPGC@Error?5while?5initializing?5SDL?5TTF@
CONST	SEGMENT
??_C@_0CG@LLIBEPGC@Error?5while?5initializing?5SDL?5TTF@ DB 'Error while '
	DB	'initializing SDL TTF : %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DNBPCBJE@SDL?52?40?5initialzed?$AA@
CONST	SEGMENT
??_C@_0BD@DNBPCBJE@SDL?52?40?5initialzed?$AA@ DB 'SDL 2.0 initialzed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HCNBMJIE@SDL?5Initilization?5failed?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BM@HCNBMJIE@SDL?5Initilization?5failed?5?$CFs?$AA@ DB 'SDL Initili'
	DB	'zation failed %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DGBKPNED@TexLight?$AA@
CONST	SEGMENT
??_C@_08DGBKPNED@TexLight?$AA@ DB 'TexLight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NGMLKGCO@TexCoord?$AA@
CONST	SEGMENT
??_C@_08NGMLKGCO@TexCoord?$AA@ DB 'TexCoord', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GCJNLIKG@Position?$AA@
CONST	SEGMENT
??_C@_08GCJNLIKG@Position?$AA@ DB 'Position', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDOBBJNA@Color?$AA@
CONST	SEGMENT
??_C@_05PDOBBJNA@Color?$AA@ DB 'Color', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NDCMMGFF@?$CFs?5fps?3?5?$CF?42f?$AA@
CONST	SEGMENT
??_C@_0N@NDCMMGFF@?$CFs?5fps?3?5?$CF?42f?$AA@ DB '%s fps: %.2f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JPOOLMEG@Log?5created?6?$AA@
CONST	SEGMENT
??_C@_0N@JPOOLMEG@Log?5created?6?$AA@ DB 'Log created', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BIGBPAJK@Engine?5started?6?$AA@
CONST	SEGMENT
??_C@_0BA@BIGBPAJK@Engine?5started?6?$AA@ DB 'Engine started', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PJPFOJIA@?$CFs?5?$CF?42f?6?$AA@
CONST	SEGMENT
??_C@_08PJPFOJIA@?$CFs?5?$CF?42f?6?$AA@ DB '%s %.2f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@CDPPCMAP@?$AAC?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@CDPPCMAP@?$AAC?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@ DB 'C'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H
	DB	'l', 00H, 'o', 00H, 'g', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@PFAEBODD@?$AAO?$AAp?$AAe?$AAn?$AAi?$AAn?$AAg?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@PFAEBODD@?$AAO?$AAp?$AAe?$AAn?$AAi?$AAn?$AAg?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@ DB 'O'
	DB	00H, 'p', 00H, 'e', 00H, 'n', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 'l', 00H, 'o', 00H, 'g', 00H, ' ', 00H, 'f', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JFHIBJMD@mgear?4log?$AA@
CONST	SEGMENT
??_C@_09JFHIBJMD@mgear?4log?$AA@ DB 'mgear.log', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNLHKJD@a?$CL?$AA@
CONST	SEGMENT
??_C@_02DPNLHKJD@a?$CL?$AA@ DB 'a+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ILLOCNCO@bad?5palette?$AA@
CONST	SEGMENT
??_C@_0M@ILLOCNCO@bad?5palette?$AA@ DB 'bad palette', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB?$AAI?$AA_?$AAr?$AAg?$AAb?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB?$AAI?$AA_?$AAr?$AAg?$AAb?$AA?$AA@ DB 't'
	DB	00H, 'g', 00H, 'a', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'm', 00H
	DB	'p', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'S', 00H, 'T'
	DB	00H, 'B', 00H, 'I', 00H, '_', 00H, 'r', 00H, 'g', 00H, 'b', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__tga_load@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__tga_load@@9@9@e7b221e1 DD 014f9H	; `stbi__tga_load'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0L@DMAPJJO@bad?5format?$AA@
CONST	SEGMENT
??_C@_0L@DMAPJJO@bad?5format?$AA@ DB 'bad format', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DAEBACAB@bad?5masks?$AA@
CONST	SEGMENT
??_C@_09DAEBACAB@bad?5masks?$AA@ DB 'bad masks', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNJHIMGH@bad?5bpp?$AA@
CONST	SEGMENT
??_C@_07JNJHIMGH@bad?5bpp?$AA@ DB 'bad bpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MALOAKCI@invalid?$AA@
CONST	SEGMENT
??_C@_07MALOAKCI@invalid?$AA@ DB 'invalid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IMHMNOIB@BMP?5RLE?$AA@
CONST	SEGMENT
??_C@_07IMHMNOIB@BMP?5RLE?$AA@ DB 'BMP RLE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FEJFGKNE@monochrome?$AA@
CONST	SEGMENT
??_C@_0L@FEJFGKNE@monochrome?$AA@ DB 'monochrome', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IEJCHBDI@bad?5BMP?$AA@
CONST	SEGMENT
??_C@_07IEJCHBDI@bad?5BMP?$AA@ DB 'bad BMP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KHBIBJBG@unknown?5BMP?$AA@
CONST	SEGMENT
??_C@_0M@KHBIBJBG@unknown?5BMP?$AA@ DB 'unknown BMP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IANEBNLB@not?5BMP?$AA@
CONST	SEGMENT
??_C@_07IANEBNLB@not?5BMP?$AA@ DB 'not BMP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MLPECBNA@no?5IDAT?$AA@
CONST	SEGMENT
??_C@_07MLPECBNA@no?5IDAT?$AA@ DB 'no IDAT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MNNCNKEO@outofdata?$AA@
CONST	SEGMENT
??_C@_09MNNCNKEO@outofdata?$AA@ DB 'outofdata', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CKIELOEH@no?5PLTE?$AA@
CONST	SEGMENT
??_C@_07CKIELOEH@no?5PLTE?$AA@ DB 'no PLTE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha?$AA@
CONST	SEGMENT
??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha?$AA@ DB 'tRNS with alpha', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDLCCKCH@bad?5tRNS?5len?$AA@
CONST	SEGMENT
??_C@_0N@KDLCCKCH@bad?5tRNS?5len?$AA@ DB 'bad tRNS len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE?$AA@
CONST	SEGMENT
??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE?$AA@ DB 'tRNS before PLTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT?$AA@
CONST	SEGMENT
??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT?$AA@ DB 'tRNS after IDAT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JCPAJAKB@invalid?5PLTE?$AA@
CONST	SEGMENT
??_C@_0N@JCPAJAKB@invalid?5PLTE?$AA@ DB 'invalid PLTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JEAFOMAF@first?5not?5IHDR?$AA@
CONST	SEGMENT
??_C@_0P@JEAFOMAF@first?5not?5IHDR?$AA@ DB 'first not IHDR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FNFBHCOO@0?9pixel?5image?$AA@
CONST	SEGMENT
??_C@_0O@FNFBHCOO@0?9pixel?5image?$AA@ DB '0-pixel image', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JCGDPBAA@bad?5interlace?5method?$AA@
CONST	SEGMENT
??_C@_0BF@JCGDPBAA@bad?5interlace?5method?$AA@ DB 'bad interlace method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GHLIKKMD@bad?5filter?5method?$AA@
CONST	SEGMENT
??_C@_0BC@GHLIKKMD@bad?5filter?5method?$AA@ DB 'bad filter method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDMBDDFG@bad?5comp?5method?$AA@
CONST	SEGMENT
??_C@_0BA@MDMBDDFG@bad?5comp?5method?$AA@ DB 'bad comp method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBBNGCKB@bad?5ctype?$AA@
CONST	SEGMENT
??_C@_09MBBNGCKB@bad?5ctype?$AA@ DB 'bad ctype', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only?$AA@
CONST	SEGMENT
??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only?$AA@ DB '1/2/4/8/16-bit only'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@POJLKMKK@bad?5IHDR?5len?$AA@
CONST	SEGMENT
??_C@_0N@POJLKMKK@bad?5IHDR?5len?$AA@ DB 'bad IHDR len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KBHBNJOK@multiple?5IHDR?$AA@
CONST	SEGMENT
??_C@_0O@KBHBNJOK@multiple?5IHDR?$AA@ DB 'multiple IHDR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@ DB 's'
	DB	00H, '-', 00H, '>', 00H, 'i', 00H, 'm', 00H, 'g', 00H, '_', 00H
	DB	'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__de_iphone@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__de_iphone@@9@9@e7b221e1 DD 0121cH ; `stbi__de_iphone'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__compute_transparency16@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__compute_transparency16@@9@9@e7b221e1 DD 011d1H ; `stbi__compute_transparency16'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@ DB 'o'
	DB	00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '2', 00H, ' ', 00H, '|', 00H, '|', 00H, ' '
	DB	00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__compute_transparency@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__compute_transparency@@9@9@e7b221e1 DD 011b8H ; `stbi__compute_transparency'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@ DB 'i'
	DB	00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '3', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@CPJBBDGC@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?$CL?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@CPJBBDGC@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?$CL?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?$AA@ DB 'i'
	DB	00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, '+', 00H, '1', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't'
	DB	00H, '_', 00H, 'n', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@EJKIMPDL@?$AAi?$AAm?$AAg?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA_?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@EJKIMPDL@?$AAi?$AAm?$AAg?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA_?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?$AA@ DB 'i'
	DB	00H, 'm', 00H, 'g', 00H, '_', 00H, 'w', 00H, 'i', 00H, 'd', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 'b', 00H, 'y', 00H, 't', 00H, 'e'
	DB	00H, 's', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FBBCPGMN@invalid?5filter?$AA@
CONST	SEGMENT
??_C@_0P@FBBCPGMN@invalid?5filter?$AA@ DB 'invalid filter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BHMPBBMG@not?5enough?5pixels?$AA@
CONST	SEGMENT
??_C@_0BC@BHMPBBMG@not?5enough?5pixels?$AA@ DB 'not enough pixels', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@ICDHLHK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9@
CONST	SEGMENT
??_C@_1FC@ICDHLHK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9@ DB 'o'
	DB	00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 's', 00H, '-', 00H, '>', 00H, 'i', 00H, 'm'
	DB	00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 's', 00H, '-', 00H, '>', 00H
	DB	'i', 00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, '+', 00H, '1'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__create_png_image_raw@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__create_png_image_raw@@9@9@e7b221e1 DD 010baH ; `stbi__create_png_image_raw'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@DMDNBACF@bad?5png?5sig?$AA@
CONST	SEGMENT
??_C@_0M@DMDNBACF@bad?5png?5sig?$AA@ DB 'bad png sig', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MCNBDLPD@bad?5compression?$AA@
CONST	SEGMENT
??_C@_0BA@MCNBDLPD@bad?5compression?$AA@ DB 'bad compression', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DOGMHEBI@no?5preset?5dict?$AA@
CONST	SEGMENT
??_C@_0P@DOGMHEBI@no?5preset?5dict?$AA@ DB 'no preset dict', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OBKOPAFL@bad?5zlib?5header?$AA@
CONST	SEGMENT
??_C@_0BA@OBKOPAFL@bad?5zlib?5header?$AA@ DB 'bad zlib header', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PIPBCKIA@read?5past?5buffer?$AA@
CONST	SEGMENT
??_C@_0BB@PIPBCKIA@read?5past?5buffer?$AA@ DB 'read past buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IECDHMDI@zlib?5corrupt?$AA@
CONST	SEGMENT
??_C@_0N@IECDHMDI@zlib?5corrupt?$AA@ DB 'zlib corrupt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@BHGGCLFF@?$AAa?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@BHGGCLFF@?$AAa?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'a'
	DB	00H, '-', 00H, '>', 00H, 'n', 00H, 'u', 00H, 'm', 00H, '_', 00H
	DB	'b', 00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__parse_uncompressed_block@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__parse_uncompressed_block@@9@9@e7b221e1 DD 0fb5H ; `stbi__parse_uncompressed_block'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BA@NKONKNHF@?$AAc?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA8?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@NKONKNHF@?$AAc?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA8?$AA?$AA@ DB 'c'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '1', 00H, '8', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__compute_huffman_codes@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__compute_huffman_codes@@9@9@e7b221e1 DD 0f84H ; `stbi__compute_huffman_codes'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_08DIAPIMGJ@bad?5dist?$AA@
CONST	SEGMENT
??_C@_08DIAPIMGJ@bad?5dist?$AA@ DB 'bad dist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IBFIPFO@output?5buffer?5limit?$AA@
CONST	SEGMENT
??_C@_0BE@IBFIPFO@output?5buffer?5limit?$AA@ DB 'output buffer limit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@BMLMNMFI@?$AAz?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$FL?$AAb?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@BMLMNMFI@?$AAz?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$FL?$AAb?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?$AA@ DB 'z'
	DB	00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	'[', 00H, 'b', 00H, ']', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__zhuffman_decode_slowpath@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__zhuffman_decode_slowpath@@9@9@e7b221e1 DD 0f19H ; `stbi__zhuffman_decode_slowpath'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EK@GAHNONBJ@?$AAz?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AA1?$AAU?$AA?5?$AA?$DM?$AA?$DM?$AA?5?$AAz?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AA_?$AAb@
CONST	SEGMENT
??_C@_1EK@GAHNONBJ@?$AAz?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AA1?$AAU?$AA?5?$AA?$DM?$AA?$DM?$AA?5?$AAz?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AA_?$AAb@ DB 'z'
	DB	00H, '-', 00H, '>', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'_', 00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, '(', 00H, '1', 00H, 'U', 00H
	DB	' ', 00H, '<', 00H, '<', 00H, ' ', 00H, 'z', 00H, '-', 00H, '>'
	DB	00H, 'n', 00H, 'u', 00H, 'm', 00H, '_', 00H, 'b', 00H, 'i', 00H
	DB	't', 00H, 's', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__fill_bits@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__fill_bits@@9@9@e7b221e1 DD 0f06H	; `stbi__fill_bits'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BA@MDNKOBMC@bad?5codelengths?$AA@
CONST	SEGMENT
??_C@_0BA@MDNKOBMC@bad?5codelengths?$AA@ DB 'bad codelengths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EOHLEIKL@bad?5sizes?$AA@
CONST	SEGMENT
??_C@_09EOHLEIKL@bad?5sizes?$AA@ DB 'bad sizes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6?$AA?$AA@ DB 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, '1', 00H, '6', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__bit_reverse@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__bit_reverse@@9@9@e7b221e1 DD 0eb5H ; `stbi__bit_reverse'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@KBPNPPBJ@bad?5req_comp?$AA@
CONST	SEGMENT
??_C@_0N@KBPNPPBJ@bad?5req_comp?$AA@ DB 'bad req_comp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PNCLKCLJ@bad?5DNL?5height?$AA@
CONST	SEGMENT
??_C@_0P@PNCLKCLJ@bad?5DNL?5height?$AA@ DB 'bad DNL height', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EPMOIECP@bad?5DNL?5len?$AA@
CONST	SEGMENT
??_C@_0M@EPMOIECP@bad?5DNL?5len?$AA@ DB 'bad DNL len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IFCEAHIA@no?5SOF?$AA@
CONST	SEGMENT
??_C@_06IFCEAHIA@no?5SOF?$AA@ DB 'no SOF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CLMBLEP@no?5SOI?$AA@
CONST	SEGMENT
??_C@_06CLMBLEP@no?5SOI?$AA@ DB 'no SOI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OJDLMMBJ@too?5large?$AA@
CONST	SEGMENT
??_C@_09OJDLMMBJ@too?5large?$AA@ DB 'too large', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LJIHDFHI@bad?5TQ?$AA@
CONST	SEGMENT
??_C@_06LJIHDFHI@bad?5TQ?$AA@ DB 'bad TQ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPLLHCJG@bad?5V?$AA@
CONST	SEGMENT
??_C@_05MPLLHCJG@bad?5V?$AA@ DB 'bad V', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BLPKENEJ@bad?5H?$AA@
CONST	SEGMENT
??_C@_05BLPKENEJ@bad?5H?$AA@ DB 'bad H', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DAPHADHL@bad?5component?5count?$AA@
CONST	SEGMENT
??_C@_0BE@DAPHADHL@bad?5component?5count?$AA@ DB 'bad component count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BIDACDEF@0?5width?$AA@
CONST	SEGMENT
??_C@_07BIDACDEF@0?5width?$AA@ DB '0 width', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LNEGOMA@no?5header?5height?$AA@
CONST	SEGMENT
??_C@_0BB@LNEGOMA@no?5header?5height?$AA@ DB 'no header height', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCINMEBJ@only?58?9bit?$AA@
CONST	SEGMENT
??_C@_0L@BCINMEBJ@only?58?9bit?$AA@ DB 'only 8-bit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DOFMJEMP@bad?5SOF?5len?$AA@
CONST	SEGMENT
??_C@_0M@DOFMJEMP@bad?5SOF?5len?$AA@ DB 'bad SOF len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EEJOMGGP@bad?5SOS?$AA@
CONST	SEGMENT
??_C@_07EEJOMGGP@bad?5SOS?$AA@ DB 'bad SOS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JGMCBLGG@bad?5AC?5huff?$AA@
CONST	SEGMENT
??_C@_0M@JGMCBLGG@bad?5AC?5huff?$AA@ DB 'bad AC huff', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NOCCBFAC@bad?5DC?5huff?$AA@
CONST	SEGMENT
??_C@_0M@NOCCBFAC@bad?5DC?5huff?$AA@ DB 'bad DC huff', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GNEHAHOH@bad?5SOS?5len?$AA@
CONST	SEGMENT
??_C@_0M@GNEHAHOH@bad?5SOS?5len?$AA@ DB 'bad SOS len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count?$AA@
CONST	SEGMENT
??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count?$AA@ DB 'bad SOS component '
	DB	'count', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NNGPHMMK@unknown?5marker?$AA@
CONST	SEGMENT
??_C@_0P@NNGPHMMK@unknown?5marker?$AA@ DB 'unknown marker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EENLKPDI@bad?5APP?5len?$AA@
CONST	SEGMENT
??_C@_0M@EENLKPDI@bad?5APP?5len?$AA@ DB 'bad APP len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CICAFFCH@bad?5COM?5len?$AA@
CONST	SEGMENT
??_C@_0M@CICAFFCH@bad?5COM?5len?$AA@ DB 'bad COM len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JLGKOCGN@bad?5DHT?5header?$AA@
CONST	SEGMENT
??_C@_0P@JLGKOCGN@bad?5DHT?5header?$AA@ DB 'bad DHT header', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CNHKKDIM@bad?5DQT?5table?$AA@
CONST	SEGMENT
??_C@_0O@CNHKKDIM@bad?5DQT?5table?$AA@ DB 'bad DQT table', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BOFJCHAP@bad?5DQT?5type?$AA@
CONST	SEGMENT
??_C@_0N@BOFJCHAP@bad?5DQT?5type?$AA@ DB 'bad DQT type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LPHNODCG@bad?5DRI?5len?$AA@
CONST	SEGMENT
??_C@_0M@LPHNODCG@bad?5DRI?5len?$AA@ DB 'bad DRI len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KLNDOKJD@expected?5marker?$AA@
CONST	SEGMENT
??_C@_0BA@KLNDOKJD@expected?5marker?$AA@ DB 'expected marker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac?$AA@
CONST	SEGMENT
??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac?$AA@ DB 'can''t merge dc an'
	DB	'd ac', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IIMLINA@bad?5huffman?5code?$AA@
CONST	SEGMENT
??_C@_0BB@IIMLINA@bad?5huffman?5code?$AA@ DB 'bad huffman code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HO@LDGMAAKB@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs?$AAt?$AAb?$AAi@
CONST	SEGMENT
??_C@_1HO@LDGMAAKB@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs?$AAt?$AAb?$AAi@ DB 'n'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'n', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, '(', 00H, 'i', 00H, 'n', 00H, 't', 00H, ')', 00H, ' ', 00H
	DB	'(', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 'o', 00H, 'f'
	DB	00H, '(', 00H, 's', 00H, 't', 00H, 'b', 00H, 'i', 00H, '_', 00H
	DB	'_', 00H, 'b', 00H, 'm', 00H, 'a', 00H, 's', 00H, 'k', 00H, ')'
	DB	00H, '/', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 'o', 00H
	DB	'f', 00H, '(', 00H, '*', 00H, 's', 00H, 't', 00H, 'b', 00H, 'i'
	DB	00H, '_', 00H, '_', 00H, 'b', 00H, 'm', 00H, 'a', 00H, 's', 00H
	DB	'k', 00H, ')', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__extend_receive@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__extend_receive@@9@9@e7b221e1 DD 073bH ; `stbi__extend_receive'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AA?$CI?$AA3?$AA2?$AA?5?$AA?9?$AA?5?$AAh?$AA?9?$AA?$DO?$AAs@
CONST	SEGMENT
??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AA?$CI?$AA3?$AA2?$AA?5?$AA?9?$AA?5?$AAh?$AA?9?$AA?$DO?$AAs@ DB '('
	DB	00H, '(', 00H, '(', 00H, 'j', 00H, '-', 00H, '>', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'b', 00H, 'u', 00H, 'f'
	DB	00H, 'f', 00H, 'e', 00H, 'r', 00H, ')', 00H, ' ', 00H, '>', 00H
	DB	'>', 00H, ' ', 00H, '(', 00H, '3', 00H, '2', 00H, ' ', 00H, '-'
	DB	00H, ' ', 00H, 'h', 00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '[', 00H, 'c', 00H, ']', 00H, ')', 00H, ')'
	DB	00H, ' ', 00H, '&', 00H, ' ', 00H, 's', 00H, 't', 00H, 'b', 00H
	DB	'i', 00H, '_', 00H, '_', 00H, 'b', 00H, 'm', 00H, 'a', 00H, 's'
	DB	00H, 'k', 00H, '[', 00H, 'h', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, '[', 00H, 'c', 00H, ']', 00H, ']'
	DB	00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'h', 00H
	DB	'-', 00H, '>', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '['
	DB	00H, 'c', 00H, ']', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__jpeg_huff_decode@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__jpeg_huff_decode@@9@9@e7b221e1 DD 0705H ; `stbi__jpeg_huff_decode'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BB@FOKGPEKG@bad?5code?5lengths?$AA@
CONST	SEGMENT
??_C@_0BB@FOKGPEKG@bad?5code?5lengths?$AA@ DB 'bad code lengths', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__convert_format16@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__convert_format16@@9@9@e7b221e1 DD 05f1H ; `stbi__convert_format16'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA4?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA4?$AA?$AA@ DB 'r'
	DB	00H, 'e', 00H, 'q', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'm', 00H
	DB	'p', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'q', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, ' ', 00H, '<'
	DB	00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__convert_format@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__convert_format@@9@9@e7b221e1 DD 05c0H ; `stbi__convert_format'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@JPDHFAGK@can?8t?5fopen?$AA@
CONST	SEGMENT
??_C@_0M@JPDHFAGK@can?8t?5fopen?$AA@ DB 'can''t fopen', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@NDPEGMEG@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA8?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@NDPEGMEG@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA8?$AA?$AA@ DB 'r'
	DB	00H, 'i', 00H, '.', 00H, 'b', 00H, 'i', 00H, 't', 00H, 's', 00H
	DB	'_', 00H, 'p', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '8', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__load_and_postprocess_16bit@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__load_and_postprocess_16bit@@9@9@e7b221e1 DD 043aH ; `stbi__load_and_postprocess_16bit'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DE@BAGIOALB@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA6?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@BAGIOALB@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA6?$AA?$AA@ DB 'r'
	DB	00H, 'i', 00H, '.', 00H, 'b', 00H, 'i', 00H, 't', 00H, 's', 00H
	DB	'_', 00H, 'p', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '1', 00H, '6', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
CONST	SEGMENT
??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'm', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 'd', 00H, 'e', 00H, 's', 00H, 'k', 00H
	DB	't', 00H, 'o', 00H, 'p', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'j'
	DB	00H, '\', 00H, 'm', 00H, 'g', 00H, 'e', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, '1', 00H, '\', 00H, 'a', 00H, 'p', 00H, 'i', 00H, 's'
	DB	00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '\', 00H, 's', 00H
	DB	't', 00H, 'b', 00H, '_', 00H, 'i', 00H, 'm', 00H, 'a', 00H, 'g'
	DB	00H, 'e', 00H, '.', 00H, 'h', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??stbi__load_and_postprocess_8bit@@9@9@e7b221e1
_DATA	SEGMENT
?__LINE__Var@?1??stbi__load_and_postprocess_8bit@@9@9@e7b221e1 DD 0422H ; `stbi__load_and_postprocess_8bit'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_08NOGIMCHF@outofmem?$AA@
CONST	SEGMENT
??_C@_08NOGIMCHF@outofmem?$AA@ DB 'outofmem', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CBEDEJPH@unknown?5image?5type?$AA@
CONST	SEGMENT
??_C@_0BD@CBEDEJPH@unknown?5image?5type?$AA@ DB 'unknown image type', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _LineData
_TEXT	SEGMENT
_i$ = -8						; size = 2
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
_r$ = 24						; size = 1
_g$ = 28						; size = 1
_b$ = 32						; size = 1
_a$ = 36						; size = 1
_linewidth$ = 40					; size = 2
_z$ = 44						; size = 4
_LineData PROC						; COMDAT

; 5849 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5850 : 	uint16 i=st.num_calls;

	mov	ax, WORD PTR _st+262
	mov	WORD PTR _i$[ebp], ax

; 5851 : 
; 5852 : 	st.renderer.ppline[i].pos.x=x;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _st[ecx+2336880], edx

; 5853 : 	st.renderer.ppline[i].pos.y=y;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _st[ecx+2336884], edx

; 5854 : 	st.renderer.ppline[i].pos.z=z;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR _st[ecx+2336888], edx

; 5855 : 	st.renderer.ppline[i].pos2.x=x2;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _x2$[ebp]
	mov	DWORD PTR _st[ecx+2336892], edx

; 5856 : 	st.renderer.ppline[i].pos2.y=y2;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _y2$[ebp]
	mov	DWORD PTR _st[ecx+2336896], edx

; 5857 : 	st.renderer.ppline[i].size.x=linewidth;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movsx	edx, WORD PTR _linewidth$[ebp]
	mov	DWORD PTR _st[ecx+2336904], edx

; 5858 : 	st.renderer.ppline[i].color.r=r;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _st[ecx+2336928], dl

; 5859 : 	st.renderer.ppline[i].color.g=g;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _st[ecx+2336929], dl

; 5860 : 	st.renderer.ppline[i].color.b=b;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _st[ecx+2336930], dl

; 5861 : 	st.renderer.ppline[i].color.a=a;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR _st[ecx+2336931], dl

; 5862 : 
; 5863 : 	st.renderer.ppline[i].type=LINE_CALL;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	BYTE PTR _st[ecx+2336876], 2

; 5864 : 
; 5865 : 	st.num_calls++;

	mov	ax, WORD PTR _st+262
	add	ax, 1
	mov	WORD PTR _st+262, ax

; 5866 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_LineData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _WindowEvents
_TEXT	SEGMENT
_WindowEvents PROC					; COMDAT

; 2276 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2277 : 	if (events.type == SDL_QUIT) st.quit = 1;

	cmp	DWORD PTR _events, 256			; 00000100H
	jne	SHORT $LN3@WindowEven
	mov	BYTE PTR _st+66668, 1
$LN3@WindowEven:

; 2278 : 
; 2279 : 	InputProcess();

	call	_InputProcess

; 2280 : 
; 2281 : 	if (events.type == SDL_WINDOWEVENT)

	cmp	DWORD PTR _events, 512			; 00000200H
	jne	SHORT $LN4@WindowEven

; 2282 : 	{
; 2283 : 		if (events.window.event == SDL_WINDOWEVENT_SIZE_CHANGED)

	movzx	eax, BYTE PTR _events+12
	cmp	eax, 6
	jne	SHORT $LN4@WindowEven

; 2284 : 		{
; 2285 : 			LogApp("Window resized to %d x %d", events.window.data1, events.window.data2);

	mov	eax, DWORD PTR _events+20
	push	eax
	mov	ecx, DWORD PTR _events+16
	push	ecx
	push	OFFSET ??_C@_0BK@MKEONLB@Window?5resized?5to?5?$CFd?5x?5?$CFd?$AA@
	call	_SDL_Log
	add	esp, 12					; 0000000cH

; 2286 : 			st.screenx = events.window.data1;

	mov	ax, WORD PTR _events+16
	mov	WORD PTR _st+228, ax

; 2287 : 			st.screeny = events.window.data2;

	mov	ax, WORD PTR _events+20
	mov	WORD PTR _st+230, ax

; 2288 : 			RestartVideo();

	call	_RestartVideo
$LN4@WindowEven:

; 2289 : 		}
; 2290 : 	}
; 2291 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_WindowEvents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CreateVBO
_TEXT	SEGMENT
_data$ = 8						; size = 4
_type$ = 12						; size = 1
_CreateVBO PROC						; COMDAT

; 1240 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1241 : 	glGenBuffers(1,&data->vbo_id);

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 8
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR _GLeeFuncPtr_glGenBuffers
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1242 : 	glGenBuffers(1,&data->ibo_id);

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 4
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR _GLeeFuncPtr_glGenBuffers
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1243 : 
; 1244 : 	glBindBuffer(GL_ARRAY_BUFFER,data->vbo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1245 : 	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,data->ibo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1246 : 
; 1247 : 	glBufferData(GL_ARRAY_BUFFER,(((data->num_elements*12)*sizeof(GLfloat)))+(((data->num_elements*8)*sizeof(GLfloat)))+(((data->num_elements*16)*sizeof(GLubyte))),NULL,GL_STREAM_DRAW);

	mov	esi, esp
	push	35040					; 000088e0H
	push	0
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+46]
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+46]
	shl	ecx, 3
	shl	ecx, 2
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+46]
	shl	ecx, 4
	add	edx, ecx
	push	edx
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1248 : 	//glBufferSubData(GL_ARRAY_BUFFER,0,(12*data->num_elements)*sizeof(GLfloat),data->vertex);
; 1249 : 	//glBufferSubData(GL_ARRAY_BUFFER,(12*data->num_elements)*sizeof(GLfloat),(8*data->num_elements)*sizeof(GLfloat),data->texcoord);
; 1250 : 	//glBufferSubData(GL_ARRAY_BUFFER,(12*data->num_elements)*sizeof(GLfloat)+(8*data->num_elements)*sizeof(GLfloat),(((data->num_elements*16)*sizeof(GLubyte))),data->color);
; 1251 : 
; 1252 : 	if(type==1)

	movzx	eax, BYTE PTR _type$[ebp]
	cmp	eax, 1
	jne	SHORT $LN2@CreateVBO

; 1253 : 		glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*data->buffer_elements)*sizeof(GLushort),data->index,GL_STATIC_DRAW);

	mov	esi, esp
	push	35044					; 000088e4H
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, WORD PTR [edx+48]
	imul	ecx, eax, 6
	shl	ecx, 1
	push	ecx
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1254 : 	else

	jmp	SHORT $LN1@CreateVBO
$LN2@CreateVBO:

; 1255 : 		glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*data->buffer_elements)*sizeof(GLushort),NULL,GL_DYNAMIC_DRAW);

	mov	esi, esp
	push	35048					; 000088e8H
	push	0
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 6
	shl	edx, 1
	push	edx
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@CreateVBO:

; 1256 : 
; 1257 : 	glBindBuffer(GL_ARRAY_BUFFER,0);

	mov	esi, esp
	push	0
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1258 : 	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);

	mov	esi, esp
	push	0
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1259 : 	/*
; 1260 : 	free(data->texcoord);
; 1261 : 	free(data->index);
; 1262 : 	free(data->color);
; 1263 : 	free(data->vertex);
; 1264 : 	*/
; 1265 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_CreateVBO ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _UpdateVAO
_TEXT	SEGMENT
_texl$ = -44						; size = 4
_col$ = -32						; size = 4
_texc$ = -20						; size = 4
_pos$ = -8						; size = 4
_data$ = 8						; size = 4
_upd_buff$ = 12						; size = 1
_upd_index$ = 16					; size = 1
_pr$ = 20						; size = 1
_UpdateVAO PROC						; COMDAT

; 1065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1066 : 	GLint pos, texc, col, texl, texr;
; 1067 : 	GLenum error;
; 1068 : 
; 1069 : 	//glUseProgram(st.renderer.Program[pr]);
; 1070 : 
; 1071 : 	if(!upd_buff)

	movzx	eax, BYTE PTR _upd_buff$[ebp]
	test	eax, eax
	jne	$LN8@UpdateVAO

; 1072 : 	{
; 1073 : 		if(data->num_elements>data->buffer_elements) return 1;

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+46]
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, WORD PTR [edx+48]
	cmp	ecx, eax
	jle	SHORT $LN7@UpdateVAO
	mov	eax, 1
	jmp	$LN9@UpdateVAO

; 1074 : 		else

	jmp	$LN6@UpdateVAO
$LN7@UpdateVAO:

; 1075 : 		{
; 1076 : 			
; 1077 : 			glBindVertexArray(data->vao_id);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1078 : 			glBindBuffer(GL_ARRAY_BUFFER,data->vbo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1079 : 
; 1080 : 			glBufferSubData(GL_ARRAY_BUFFER,0,(12*data->num_elements)*sizeof(GLfloat),data->vertex);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, WORD PTR [edx+46]
	imul	ecx, eax, 12
	shl	ecx, 2
	push	ecx
	push	0
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1081 : 			glBufferSubData(GL_ARRAY_BUFFER,(12*data->buffer_elements)*sizeof(GLfloat),(8*data->num_elements)*sizeof(GLfloat),data->texcoord);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, WORD PTR [edx+46]
	shl	eax, 3
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, WORD PTR [ecx+48]
	imul	eax, edx, 12
	shl	eax, 2
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1082 : 			glBufferSubData(GL_ARRAY_BUFFER,(((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))),(((data->num_elements*16)*sizeof(GLubyte))),data->color);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, WORD PTR [edx+46]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, WORD PTR [ecx+48]
	imul	eax, edx, 12
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, WORD PTR [ecx+48]
	shl	edx, 3
	shl	edx, 2
	lea	eax, DWORD PTR [edx+eax*4]
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1083 : 			glBufferSubData(GL_ARRAY_BUFFER,(((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((data->buffer_elements*16)*sizeof(GLubyte))),(data->num_elements*8)*sizeof(float),data->texcoordlight);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, WORD PTR [edx+46]
	shl	eax, 3
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, WORD PTR [ecx+48]
	imul	eax, edx, 12
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, WORD PTR [ecx+48]
	shl	edx, 3
	shl	edx, 2
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, WORD PTR [ecx+48]
	shl	edx, 4
	add	eax, edx
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1084 : 		//	glBufferSubData(GL_ARRAY_BUFFER,(((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((data->buffer_elements*16)*sizeof(GLubyte))+((data->num_elements*8)*sizeof(float))),(data->num_elements*4)*sizeof(float),data->texrepeat);
; 1085 : 
; 1086 : 			if(upd_index)

	movzx	eax, BYTE PTR _upd_index$[ebp]
	test	eax, eax
	je	SHORT $LN5@UpdateVAO

; 1087 : 			{
; 1088 : 				glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,data->ibo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1089 : 				glBufferSubData(GL_ELEMENT_ARRAY_BUFFER,0,(6*data->num_elements)*sizeof(GLushort),data->index);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, WORD PTR [edx+46]
	imul	ecx, eax, 6
	shl	ecx, 1
	push	ecx
	push	0
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@UpdateVAO:

; 1090 : 				//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);
; 1091 : 			}
; 1092 : 
; 1093 : 			glBindVertexArray(0);

	mov	esi, esp
	push	0
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1094 : 			
; 1095 : 			
; 1096 : 			free(data->texcoord);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_free
	add	esp, 4

; 1097 : 			free(data->index);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_free
	add	esp, 4

; 1098 : 			free(data->color);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_free
	add	esp, 4

; 1099 : 			free(data->vertex);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_free
	add	esp, 4

; 1100 : 			free(data->texcoordlight);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_free
	add	esp, 4
$LN6@UpdateVAO:

; 1101 : 			//free(data->texrepeat);
; 1102 : 			
; 1103 : 		}
; 1104 : 	}
; 1105 : 	else

	jmp	$LN4@UpdateVAO
$LN8@UpdateVAO:

; 1106 : 	if(upd_buff==1)

	movzx	eax, BYTE PTR _upd_buff$[ebp]
	cmp	eax, 1
	jne	$LN3@UpdateVAO

; 1107 : 	{
; 1108 : 		
; 1109 : 		glBindVertexArray(data->vao_id);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1110 : 
; 1111 : 		col=glGetAttribLocation(st.renderer.Program[pr],"Color");

	mov	esi, esp
	push	OFFSET ??_C@_05PDOBBJNA@Color?$AA@
	movzx	eax, BYTE PTR _pr$[ebp]
	mov	ecx, DWORD PTR _st[eax*4+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _col$[ebp], eax

; 1112 : 		pos=glGetAttribLocation(st.renderer.Program[pr],"Position");

	mov	esi, esp
	push	OFFSET ??_C@_08GCJNLIKG@Position?$AA@
	movzx	eax, BYTE PTR _pr$[ebp]
	mov	ecx, DWORD PTR _st[eax*4+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pos$[ebp], eax

; 1113 : 		texc=glGetAttribLocation(st.renderer.Program[pr],"TexCoord");

	mov	esi, esp
	push	OFFSET ??_C@_08NGMLKGCO@TexCoord?$AA@
	movzx	eax, BYTE PTR _pr$[ebp]
	mov	ecx, DWORD PTR _st[eax*4+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _texc$[ebp], eax

; 1114 : 		texl=glGetAttribLocation(st.renderer.Program[pr],"TexLight");

	mov	esi, esp
	push	OFFSET ??_C@_08DGBKPNED@TexLight?$AA@
	movzx	eax, BYTE PTR _pr$[ebp]
	mov	ecx, DWORD PTR _st[eax*4+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _texl$[ebp], eax

; 1115 : 		//texr=glGetAttribLocation(st.renderer.Program[pr],"TexRepeat");
; 1116 : 
; 1117 : 
; 1118 : 		glEnableVertexAttribArray(pos);

	mov	esi, esp
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1119 : 		glEnableVertexAttribArray(texc);

	mov	esi, esp
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1120 : 		glEnableVertexAttribArray(col);

	mov	esi, esp
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1121 : 		glEnableVertexAttribArray(texl);

	mov	esi, esp
	mov	eax, DWORD PTR _texl$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1122 : 		//glEnableVertexAttribArray(texr);
; 1123 : 
; 1124 : 		glBindBuffer(GL_ARRAY_BUFFER,data->vbo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1125 : 
; 1126 : 		glBufferData(GL_ARRAY_BUFFER,((data->buffer_elements*12)*sizeof(GLfloat))+((data->buffer_elements*8)*sizeof(GLfloat))+((data->buffer_elements*16)*sizeof(GLubyte))+((data->buffer_elements*8)*sizeof(GLfloat))+((data->buffer_elements*4)*sizeof(GLfloat)),NULL,GL_STREAM_DRAW);

	mov	esi, esp
	push	35040					; 000088e0H
	push	0
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 3
	shl	ecx, 2
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 4
	add	edx, ecx
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 3
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 2
	lea	edx, DWORD PTR [edx+ecx*4]
	push	edx
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1127 : 
; 1128 : 		glBufferSubData(GL_ARRAY_BUFFER,0,(12*data->num_elements)*sizeof(GLfloat),data->vertex);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, WORD PTR [edx+46]
	imul	ecx, eax, 12
	shl	ecx, 2
	push	ecx
	push	0
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1129 : 		glBufferSubData(GL_ARRAY_BUFFER,(12*data->buffer_elements)*sizeof(GLfloat),(8*data->num_elements)*sizeof(GLfloat),data->texcoord);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, WORD PTR [edx+46]
	shl	eax, 3
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, WORD PTR [ecx+48]
	imul	eax, edx, 12
	shl	eax, 2
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1130 : 		glBufferSubData(GL_ARRAY_BUFFER,(((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))),(((data->num_elements*16)*sizeof(GLubyte))),data->color);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, WORD PTR [edx+46]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, WORD PTR [ecx+48]
	imul	eax, edx, 12
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, WORD PTR [ecx+48]
	shl	edx, 3
	shl	edx, 2
	lea	eax, DWORD PTR [edx+eax*4]
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1131 : 		glBufferSubData(GL_ARRAY_BUFFER,(((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((data->buffer_elements*16)*sizeof(GLubyte))),(data->num_elements*8)*sizeof(float),data->texcoordlight);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, WORD PTR [edx+46]
	shl	eax, 3
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, WORD PTR [ecx+48]
	imul	eax, edx, 12
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, WORD PTR [ecx+48]
	shl	edx, 3
	shl	edx, 2
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, WORD PTR [ecx+48]
	shl	edx, 4
	add	eax, edx
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1132 : 		//glBufferSubData(GL_ARRAY_BUFFER,(((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((data->buffer_elements*16)*sizeof(GLubyte))+((data->num_elements*8)*sizeof(float))),(data->num_elements*4)*sizeof(float),data->texrepeat);
; 1133 : 
; 1134 : 
; 1135 : 		glVertexAttribPointer(pos,3,GL_FLOAT,GL_FALSE,0,0);

	mov	esi, esp
	push	0
	push	0
	push	0
	push	5126					; 00001406H
	push	3
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1136 : 		glVertexAttribPointer(texc,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) ((12*data->buffer_elements)*sizeof(GLfloat)));

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 12
	shl	edx, 2
	mov	esi, esp
	push	edx
	push	0
	push	0
	push	5126					; 00001406H
	push	2
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1137 : 		glVertexAttribPointer(col,4,GL_UNSIGNED_BYTE,GL_TRUE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))));

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 3
	shl	ecx, 2
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	esi, esp
	push	edx
	push	0
	push	1
	push	5121					; 00001401H
	push	4
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1138 : 		glVertexAttribPointer(texl,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((16*data->buffer_elements)*sizeof(GLubyte))));

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 3
	shl	ecx, 2
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 4
	add	edx, ecx
	mov	esi, esp
	push	edx
	push	0
	push	0
	push	5126					; 00001406H
	push	2
	mov	edx, DWORD PTR _texl$[ebp]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1139 : 		//glVertexAttribPointer(texr,4,GL_FLOAT,GL_FALSE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((16*data->buffer_elements)*sizeof(GLubyte))+((data->buffer_elements*8)*sizeof(GLfloat))));
; 1140 : 
; 1141 : 
; 1142 : 		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,data->ibo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1143 : 
; 1144 : 		glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*data->buffer_elements)*sizeof(GLushort),NULL,GL_DYNAMIC_DRAW);

	mov	esi, esp
	push	35048					; 000088e8H
	push	0
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 6
	shl	edx, 1
	push	edx
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1145 : 		glBufferSubData(GL_ELEMENT_ARRAY_BUFFER,0,(6*data->num_elements)*sizeof(GLushort),data->index);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, WORD PTR [edx+46]
	imul	ecx, eax, 6
	shl	ecx, 1
	push	ecx
	push	0
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1146 : 
; 1147 : 		glBindVertexArray(0);

	mov	esi, esp
	push	0
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1148 : 
; 1149 : 		glDisableVertexAttribArray(pos);

	mov	esi, esp
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1150 : 		glDisableVertexAttribArray(texc);

	mov	esi, esp
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1151 : 		glDisableVertexAttribArray(col);

	mov	esi, esp
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1152 : 		glDisableVertexAttribArray(texl);

	mov	esi, esp
	mov	eax, DWORD PTR _texl$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1153 : 		//glDisableVertexAttribArray(texr);
; 1154 : 
; 1155 : 		//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);
; 1156 : 		//glBindBuffer(GL_ARRAY_BUFFER,0);
; 1157 : 
; 1158 : 		free(data->texcoord);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_free
	add	esp, 4

; 1159 : 		free(data->index);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_free
	add	esp, 4

; 1160 : 		free(data->color);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_free
	add	esp, 4

; 1161 : 		free(data->vertex);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_free
	add	esp, 4

; 1162 : 		free(data->texcoordlight);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_free
	add	esp, 4

; 1163 : 		//free(data->texrepeat);
; 1164 : 	}
; 1165 : 	else

	jmp	$LN4@UpdateVAO
$LN3@UpdateVAO:

; 1166 : 	if(upd_buff==2)

	movzx	eax, BYTE PTR _upd_buff$[ebp]
	cmp	eax, 2
	jne	$LN4@UpdateVAO

; 1167 : 	{
; 1168 : 		glBindVertexArray(data->vao_id);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1169 : 		glBindBuffer(GL_ARRAY_BUFFER,data->vbo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1170 : 		//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,data->ibo_id);
; 1171 : 
; 1172 : 		col=glGetAttribLocation(st.renderer.Program[pr],"Color");

	mov	esi, esp
	push	OFFSET ??_C@_05PDOBBJNA@Color?$AA@
	movzx	eax, BYTE PTR _pr$[ebp]
	mov	ecx, DWORD PTR _st[eax*4+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _col$[ebp], eax

; 1173 : 		pos=glGetAttribLocation(st.renderer.Program[pr],"Position");

	mov	esi, esp
	push	OFFSET ??_C@_08GCJNLIKG@Position?$AA@
	movzx	eax, BYTE PTR _pr$[ebp]
	mov	ecx, DWORD PTR _st[eax*4+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pos$[ebp], eax

; 1174 : 		texc=glGetAttribLocation(st.renderer.Program[pr],"TexCoord");

	mov	esi, esp
	push	OFFSET ??_C@_08NGMLKGCO@TexCoord?$AA@
	movzx	eax, BYTE PTR _pr$[ebp]
	mov	ecx, DWORD PTR _st[eax*4+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _texc$[ebp], eax

; 1175 : 		texl=glGetAttribLocation(st.renderer.Program[pr],"TexLight");

	mov	esi, esp
	push	OFFSET ??_C@_08DGBKPNED@TexLight?$AA@
	movzx	eax, BYTE PTR _pr$[ebp]
	mov	ecx, DWORD PTR _st[eax*4+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _texl$[ebp], eax

; 1176 : 		//texr=glGetAttribLocation(st.renderer.Program[pr],"TexRepeat");
; 1177 : 
; 1178 : 		glEnableVertexAttribArray(pos);

	mov	esi, esp
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1179 : 		glEnableVertexAttribArray(texc);

	mov	esi, esp
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1180 : 		glEnableVertexAttribArray(col);

	mov	esi, esp
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1181 : 		glEnableVertexAttribArray(texl);

	mov	esi, esp
	mov	eax, DWORD PTR _texl$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1182 : 		//glEnableVertexAttribArray(texr);
; 1183 : 
; 1184 : 		glBufferData(GL_ARRAY_BUFFER,((data->buffer_elements*12)*sizeof(GLfloat))+((data->buffer_elements*8)*sizeof(GLfloat))+((data->buffer_elements*16)*sizeof(GLubyte))+((data->buffer_elements*8)*sizeof(GLfloat))+((data->buffer_elements*4)*sizeof(GLfloat)),NULL,GL_STREAM_DRAW);

	mov	esi, esp
	push	35040					; 000088e0H
	push	0
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 3
	shl	ecx, 2
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 4
	add	edx, ecx
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 3
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 2
	lea	edx, DWORD PTR [edx+ecx*4]
	push	edx
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1185 : 
; 1186 : 		glVertexAttribPointer(pos,3,GL_FLOAT,GL_FALSE,0,0);

	mov	esi, esp
	push	0
	push	0
	push	0
	push	5126					; 00001406H
	push	3
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1187 : 		glVertexAttribPointer(texc,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) ((12*data->buffer_elements)*sizeof(GLfloat)));

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 12
	shl	edx, 2
	mov	esi, esp
	push	edx
	push	0
	push	0
	push	5126					; 00001406H
	push	2
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1188 : 		glVertexAttribPointer(col,4,GL_UNSIGNED_BYTE,GL_TRUE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))));

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 3
	shl	ecx, 2
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	esi, esp
	push	edx
	push	0
	push	1
	push	5121					; 00001401H
	push	4
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1189 : 		glVertexAttribPointer(texl,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((16*data->buffer_elements)*sizeof(GLubyte))));

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 3
	shl	ecx, 2
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 4
	add	edx, ecx
	mov	esi, esp
	push	edx
	push	0
	push	0
	push	5126					; 00001406H
	push	2
	mov	edx, DWORD PTR _texl$[ebp]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1190 : 		//glVertexAttribPointer(texr,4,GL_FLOAT,GL_FALSE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((16*data->buffer_elements)*sizeof(GLubyte))+((data->buffer_elements*8)*sizeof(GLfloat))));
; 1191 : 
; 1192 : 		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,data->ibo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1193 : 
; 1194 : 		glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*data->buffer_elements)*sizeof(GLushort),NULL,GL_DYNAMIC_DRAW);

	mov	esi, esp
	push	35048					; 000088e8H
	push	0
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 6
	shl	edx, 1
	push	edx
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1195 : 
; 1196 : 		glDisableVertexAttribArray(pos);

	mov	esi, esp
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1197 : 		glDisableVertexAttribArray(texc);

	mov	esi, esp
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1198 : 		glDisableVertexAttribArray(col);

	mov	esi, esp
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1199 : 		glDisableVertexAttribArray(texl);

	mov	esi, esp
	mov	eax, DWORD PTR _texl$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1200 : 		//glDisableVertexAttribArray(texr);
; 1201 : 
; 1202 : 		//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);
; 1203 : 		//glBindBuffer(GL_ARRAY_BUFFER,0);
; 1204 : 		glBindVertexArray(0);

	mov	esi, esp
	push	0
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@UpdateVAO:

; 1205 : 	}
; 1206 : 
; 1207 : 	//glUseProgram(0);
; 1208 : 
; 1209 : 	return 0;

	xor	eax, eax
$LN9@UpdateVAO:

; 1210 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UpdateVAO ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CreateVAO
_TEXT	SEGMENT
_texl$ = -44						; size = 4
_col$ = -32						; size = 4
_texc$ = -20						; size = 4
_pos$ = -8						; size = 4
_data$ = 8						; size = 4
_type$ = 12						; size = 1
_pr$ = 16						; size = 1
_CreateVAO PROC						; COMDAT

; 995  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 996  : 	GLint pos, texc, col, texl, texr;
; 997  : 
; 998  : 	if(type==1)

	movzx	eax, BYTE PTR _type$[ebp]
	cmp	eax, 1
	jne	SHORT $LN3@CreateVAO

; 999  : 	{
; 1000 : 		data->buffer_elements=1;

	mov	eax, 1
	mov	ecx, DWORD PTR _data$[ebp]
	mov	WORD PTR [ecx+48], ax

; 1001 : 		data->num_elements=1;

	mov	eax, 1
	mov	ecx, DWORD PTR _data$[ebp]
	mov	WORD PTR [ecx+46], ax
$LN3@CreateVAO:

; 1002 : 	}
; 1003 : 
; 1004 : 	glGenVertexArrays(1,&data->vao_id);

	mov	eax, DWORD PTR _data$[ebp]
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR _GLeeFuncPtr_glGenVertexArrays
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1005 : 	glBindVertexArray(data->vao_id);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1006 : 
; 1007 : 	col=glGetAttribLocation(st.renderer.Program[pr],"Color");

	mov	esi, esp
	push	OFFSET ??_C@_05PDOBBJNA@Color?$AA@
	movzx	eax, BYTE PTR _pr$[ebp]
	mov	ecx, DWORD PTR _st[eax*4+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _col$[ebp], eax

; 1008 : 	pos=glGetAttribLocation(st.renderer.Program[pr],"Position");

	mov	esi, esp
	push	OFFSET ??_C@_08GCJNLIKG@Position?$AA@
	movzx	eax, BYTE PTR _pr$[ebp]
	mov	ecx, DWORD PTR _st[eax*4+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pos$[ebp], eax

; 1009 : 	texc=glGetAttribLocation(st.renderer.Program[pr],"TexCoord");

	mov	esi, esp
	push	OFFSET ??_C@_08NGMLKGCO@TexCoord?$AA@
	movzx	eax, BYTE PTR _pr$[ebp]
	mov	ecx, DWORD PTR _st[eax*4+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _texc$[ebp], eax

; 1010 : 	texl=glGetAttribLocation(st.renderer.Program[pr],"TexLight");

	mov	esi, esp
	push	OFFSET ??_C@_08DGBKPNED@TexLight?$AA@
	movzx	eax, BYTE PTR _pr$[ebp]
	mov	ecx, DWORD PTR _st[eax*4+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _texl$[ebp], eax

; 1011 : 	//texr=glGetAttribLocation(st.renderer.Program[pr],"TexRepeat");
; 1012 : 
; 1013 : 
; 1014 : 	glEnableVertexAttribArray(pos);

	mov	esi, esp
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1015 : 	glEnableVertexAttribArray(texc);

	mov	esi, esp
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1016 : 	glEnableVertexAttribArray(col);

	mov	esi, esp
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1017 : 	glEnableVertexAttribArray(texl);

	mov	esi, esp
	mov	eax, DWORD PTR _texl$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1018 : 	//glEnableVertexAttribArray(texr);
; 1019 : 
; 1020 : 	glGenBuffers(1,&data->vbo_id);

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 8
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR _GLeeFuncPtr_glGenBuffers
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1021 : 	glBindBuffer(GL_ARRAY_BUFFER,data->vbo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1022 : 
; 1023 : 	glBufferData(GL_ARRAY_BUFFER,((data->buffer_elements*12)*sizeof(GLfloat))+((data->buffer_elements*8)*sizeof(GLfloat))+((data->buffer_elements*16)*sizeof(GLubyte))+((data->buffer_elements*8)*sizeof(GLfloat))+((data->buffer_elements*4)*sizeof(GLfloat)),NULL,GL_STREAM_DRAW);

	mov	esi, esp
	push	35040					; 000088e0H
	push	0
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 3
	shl	ecx, 2
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 4
	add	edx, ecx
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 3
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 2
	lea	edx, DWORD PTR [edx+ecx*4]
	push	edx
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1024 : 	/*
; 1025 : 	glBufferSubData(GL_ARRAY_BUFFER,0,(12*data->num_elements)*sizeof(GLfloat),data->vertex);
; 1026 : 	glBufferSubData(GL_ARRAY_BUFFER,(12*data->num_elements)*sizeof(GLfloat),(8*data->num_elements)*sizeof(GLfloat),data->texcoord);
; 1027 : 	glBufferSubData(GL_ARRAY_BUFFER,(12*data->num_elements)*sizeof(GLfloat)+(8*data->num_elements)*sizeof(GLfloat),(((data->num_elements*16)*sizeof(GLubyte))),data->color);
; 1028 : 	*/
; 1029 : 
; 1030 : 	glVertexAttribPointer(pos,3,GL_FLOAT,GL_FALSE,0,0);

	mov	esi, esp
	push	0
	push	0
	push	0
	push	5126					; 00001406H
	push	3
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1031 : 	glVertexAttribPointer(texc,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) ((12*data->buffer_elements)*sizeof(GLfloat)));

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 12
	shl	edx, 2
	mov	esi, esp
	push	edx
	push	0
	push	0
	push	5126					; 00001406H
	push	2
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1032 : 	glVertexAttribPointer(col,4,GL_UNSIGNED_BYTE,GL_TRUE,0,(GLvoid*) ((12*data->buffer_elements)*sizeof(GLfloat)+(8*data->buffer_elements)*sizeof(GLfloat)));

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 3
	shl	ecx, 2
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	esi, esp
	push	edx
	push	0
	push	1
	push	5121					; 00001401H
	push	4
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1033 : 	glVertexAttribPointer(texl,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((16*data->buffer_elements)*sizeof(GLubyte))));

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 3
	shl	ecx, 2
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	shl	ecx, 4
	add	edx, ecx
	mov	esi, esp
	push	edx
	push	0
	push	0
	push	5126					; 00001406H
	push	2
	mov	edx, DWORD PTR _texl$[ebp]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1034 : 	//glVertexAttribPointer(texr,4,GL_FLOAT,GL_FALSE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((16*data->buffer_elements)*sizeof(GLubyte))+((data->buffer_elements*8)*sizeof(GLfloat))));
; 1035 : 
; 1036 : 
; 1037 : 	glGenBuffers(1,&data->ibo_id);

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 4
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR _GLeeFuncPtr_glGenBuffers
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1038 : 	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,data->ibo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1039 : 
; 1040 : 	if(type==1)

	movzx	eax, BYTE PTR _type$[ebp]
	cmp	eax, 1
	jne	SHORT $LN2@CreateVAO

; 1041 : 		glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*data->buffer_elements)*sizeof(GLushort),data->index,GL_STATIC_DRAW);

	mov	esi, esp
	push	35044					; 000088e4H
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, WORD PTR [edx+48]
	imul	ecx, eax, 6
	shl	ecx, 1
	push	ecx
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1042 : 	else

	jmp	SHORT $LN1@CreateVAO
$LN2@CreateVAO:

; 1043 : 		glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*data->buffer_elements)*sizeof(GLushort),NULL,GL_DYNAMIC_DRAW);

	mov	esi, esp
	push	35048					; 000088e8H
	push	0
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 6
	shl	edx, 1
	push	edx
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@CreateVAO:

; 1044 : 	
; 1045 : 	glBindVertexArray(0);

	mov	esi, esp
	push	0
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1046 : 
; 1047 : 	glDisableVertexAttribArray(pos);

	mov	esi, esp
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1048 : 	glDisableVertexAttribArray(texc);

	mov	esi, esp
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1049 : 	glDisableVertexAttribArray(col);

	mov	esi, esp
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1050 : 	glDisableVertexAttribArray(texl);

	mov	esi, esp
	mov	eax, DWORD PTR _texl$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1051 : 	//glDisableVertexAttribArray(texr);
; 1052 : 
; 1053 : 	data->num_elements2=0;

	xor	eax, eax
	mov	ecx, DWORD PTR _data$[ebp]
	mov	WORD PTR [ecx+50], ax

; 1054 : 	
; 1055 : 	/*
; 1056 : 	free(data->texcoord);
; 1057 : 	free(data->index);
; 1058 : 	free(data->color);
; 1059 : 	free(data->vertex);
; 1060 : 	*/
; 1061 : 
; 1062 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_CreateVAO ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__info_main
_TEXT	SEGMENT
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_stbi__info_main PROC					; COMDAT

; 6890 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 6891 :    #ifndef STBI_NO_JPEG
; 6892 :    if (stbi__jpeg_info(s, x, y, comp)) return 1;

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__jpeg_info
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN4@stbi__info
	mov	eax, 1
	jmp	SHORT $LN5@stbi__info
$LN4@stbi__info:

; 6893 :    #endif
; 6894 : 
; 6895 :    #ifndef STBI_NO_PNG
; 6896 :    if (stbi__png_info(s, x, y, comp))  return 1;

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__png_info
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN3@stbi__info
	mov	eax, 1
	jmp	SHORT $LN5@stbi__info
$LN3@stbi__info:

; 6897 :    #endif
; 6898 : 
; 6899 :    #ifndef STBI_NO_GIF
; 6900 :    if (stbi__gif_info(s, x, y, comp))  return 1;
; 6901 :    #endif
; 6902 : 
; 6903 :    #ifndef STBI_NO_BMP
; 6904 :    if (stbi__bmp_info(s, x, y, comp))  return 1;

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__bmp_info
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN2@stbi__info
	mov	eax, 1
	jmp	SHORT $LN5@stbi__info
$LN2@stbi__info:

; 6905 :    #endif
; 6906 : 
; 6907 :    #ifndef STBI_NO_PSD
; 6908 :    if (stbi__psd_info(s, x, y, comp))  return 1;
; 6909 :    #endif
; 6910 : 
; 6911 :    #ifndef STBI_NO_PIC
; 6912 :    if (stbi__pic_info(s, x, y, comp))  return 1;
; 6913 :    #endif
; 6914 : 
; 6915 :    #ifndef STBI_NO_PNM
; 6916 :    if (stbi__pnm_info(s, x, y, comp))  return 1;
; 6917 :    #endif
; 6918 : 
; 6919 :    #ifndef STBI_NO_HDR
; 6920 :    if (stbi__hdr_info(s, x, y, comp))  return 1;
; 6921 :    #endif
; 6922 : 
; 6923 :    // test tga last because it's a crappy test!
; 6924 :    #ifndef STBI_NO_TGA
; 6925 :    if (stbi__tga_info(s, x, y, comp))

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__tga_info
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@stbi__info

; 6926 :        return 1;

	mov	eax, 1
	jmp	SHORT $LN5@stbi__info
$LN1@stbi__info:

; 6927 :    #endif
; 6928 :    return stbi__err("unknown image type", "Image not of any known type, or corrupt");

	push	OFFSET ??_C@_0BD@CBEDEJPH@unknown?5image?5type?$AA@
	call	_stbi__err
	add	esp, 4
$LN5@stbi__info:

; 6929 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__info_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__tga_read_rgb16
_TEXT	SEGMENT
_b$ = -56						; size = 4
_g$ = -44						; size = 4
_r$ = -32						; size = 4
_fiveBitMask$ = -20					; size = 2
_px$ = -8						; size = 2
_s$ = 8							; size = 4
_out$ = 12						; size = 4
_stbi__tga_read_rgb16 PROC				; COMDAT

; 5350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5351 :    stbi__uint16 px = (stbi__uint16)stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	mov	WORD PTR _px$[ebp], ax

; 5352 :    stbi__uint16 fiveBitMask = 31;

	mov	eax, 31					; 0000001fH
	mov	WORD PTR _fiveBitMask$[ebp], ax

; 5353 :    // we have 3 channels with 5bits each
; 5354 :    int r = (px >> 10) & fiveBitMask;

	movzx	eax, WORD PTR _px$[ebp]
	sar	eax, 10					; 0000000aH
	movzx	ecx, WORD PTR _fiveBitMask$[ebp]
	and	eax, ecx
	mov	DWORD PTR _r$[ebp], eax

; 5355 :    int g = (px >> 5) & fiveBitMask;

	movzx	eax, WORD PTR _px$[ebp]
	sar	eax, 5
	movzx	ecx, WORD PTR _fiveBitMask$[ebp]
	and	eax, ecx
	mov	DWORD PTR _g$[ebp], eax

; 5356 :    int b = px & fiveBitMask;

	movzx	eax, WORD PTR _px$[ebp]
	movzx	ecx, WORD PTR _fiveBitMask$[ebp]
	and	eax, ecx
	mov	DWORD PTR _b$[ebp], eax

; 5357 :    // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
; 5358 :    out[0] = (stbi_uc)((r * 255)/31);

	imul	eax, DWORD PTR _r$[ebp], 255
	cdq
	mov	ecx, 31					; 0000001fH
	idiv	ecx
	mov	edx, 1
	imul	ecx, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 5359 :    out[1] = (stbi_uc)((g * 255)/31);

	imul	eax, DWORD PTR _g$[ebp], 255
	cdq
	mov	ecx, 31					; 0000001fH
	idiv	ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 5360 :    out[2] = (stbi_uc)((b * 255)/31);

	imul	eax, DWORD PTR _b$[ebp], 255
	cdq
	mov	ecx, 31					; 0000001fH
	idiv	ecx
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 5361 : 
; 5362 :    // some people claim that the most significant bit might be used for alpha
; 5363 :    // (possibly if an alpha-bit is set in the "image descriptor byte")
; 5364 :    // but that only made 16bit test images completely translucent..
; 5365 :    // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
; 5366 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__tga_read_rgb16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__tga_get_comp
_TEXT	SEGMENT
tv65 = -196						; size = 4
_bits_per_pixel$ = 8					; size = 4
_is_grey$ = 12						; size = 4
_is_rgb16$ = 16						; size = 4
_stbi__tga_get_comp PROC				; COMDAT

; 5237 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5238 :    // only RGB or RGBA (incl. 16bit) or grey allowed
; 5239 :    if(is_rgb16) *is_rgb16 = 0;

	cmp	DWORD PTR _is_rgb16$[ebp], 0
	je	SHORT $LN10@stbi__tga_
	mov	eax, DWORD PTR _is_rgb16$[ebp]
	mov	DWORD PTR [eax], 0
$LN10@stbi__tga_:

; 5240 :    switch(bits_per_pixel) {

	mov	eax, DWORD PTR _bits_per_pixel$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 8
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 24			; 00000018H
	ja	SHORT $LN1@stbi__tga_
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN13@stbi__tga_[edx]
	jmp	DWORD PTR $LN14@stbi__tga_[eax*4]
$LN7@stbi__tga_:

; 5241 :       case 8:  return STBI_grey;

	mov	eax, 1
	jmp	SHORT $LN11@stbi__tga_
$LN6@stbi__tga_:

; 5242 :       case 16: if(is_grey) return STBI_grey_alpha;

	cmp	DWORD PTR _is_grey$[ebp], 0
	je	SHORT $LN4@stbi__tga_
	mov	eax, 2
	jmp	SHORT $LN11@stbi__tga_
$LN4@stbi__tga_:

; 5243 :             // else: fall-through
; 5244 :       case 15: if(is_rgb16) *is_rgb16 = 1;

	cmp	DWORD PTR _is_rgb16$[ebp], 0
	je	SHORT $LN3@stbi__tga_
	mov	eax, DWORD PTR _is_rgb16$[ebp]
	mov	DWORD PTR [eax], 1
$LN3@stbi__tga_:

; 5245 :             return STBI_rgb;

	mov	eax, 3
	jmp	SHORT $LN11@stbi__tga_
$LN2@stbi__tga_:

; 5246 :       case 24: // fall-through
; 5247 :       case 32: return bits_per_pixel/8;

	mov	eax, DWORD PTR _bits_per_pixel$[ebp]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	jmp	SHORT $LN11@stbi__tga_
$LN1@stbi__tga_:

; 5248 :       default: return 0;

	xor	eax, eax
$LN11@stbi__tga_:

; 5249 :    }
; 5250 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN14@stbi__tga_:
	DD	$LN7@stbi__tga_
	DD	$LN4@stbi__tga_
	DD	$LN6@stbi__tga_
	DD	$LN2@stbi__tga_
	DD	$LN1@stbi__tga_
$LN13@stbi__tga_:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_stbi__tga_get_comp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__bmp_parse_header
_TEXT	SEGMENT
tv224 = -232						; size = 4
tv218 = -232						; size = 4
tv214 = -232						; size = 4
tv167 = -232						; size = 4
tv158 = -232						; size = 4
tv149 = -232						; size = 4
tv129 = -232						; size = 4
tv75 = -232						; size = 4
_i$1 = -32						; size = 4
_compress$2 = -20					; size = 4
_hsz$ = -8						; size = 4
_s$ = 8							; size = 4
_info$ = 12						; size = 4
_stbi__bmp_parse_header PROC				; COMDAT

; 4990 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4991 :    int hsz;
; 4992 :    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 66					; 00000042H
	jne	SHORT $LN27@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 77					; 0000004dH
	je	SHORT $LN28@stbi__bmp_
$LN27@stbi__bmp_:
	push	OFFSET ??_C@_07IANEBNLB@not?5BMP?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN31@stbi__bmp_
	mov	DWORD PTR tv75[ebp], 0
	jmp	SHORT $LN32@stbi__bmp_
$LN31@stbi__bmp_:
	mov	DWORD PTR tv75[ebp], 0
$LN32@stbi__bmp_:
	mov	eax, DWORD PTR tv75[ebp]
	jmp	$LN29@stbi__bmp_
$LN28@stbi__bmp_:

; 4993 :    stbi__get32le(s); // discard filesize

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4

; 4994 :    stbi__get16le(s); // discard reserved

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4

; 4995 :    stbi__get16le(s); // discard reserved

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4

; 4996 :    info->offset = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4997 :    info->hsz = hsz = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
	mov	DWORD PTR _hsz$[ebp], eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR _hsz$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 4998 :    info->mr = info->mg = info->mb = info->ma = 0;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+12], 0

; 4999 : 
; 5000 :    if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");

	cmp	DWORD PTR _hsz$[ebp], 12		; 0000000cH
	je	SHORT $LN26@stbi__bmp_
	cmp	DWORD PTR _hsz$[ebp], 40		; 00000028H
	je	SHORT $LN26@stbi__bmp_
	cmp	DWORD PTR _hsz$[ebp], 56		; 00000038H
	je	SHORT $LN26@stbi__bmp_
	cmp	DWORD PTR _hsz$[ebp], 108		; 0000006cH
	je	SHORT $LN26@stbi__bmp_
	cmp	DWORD PTR _hsz$[ebp], 124		; 0000007cH
	je	SHORT $LN26@stbi__bmp_
	push	OFFSET ??_C@_0M@KHBIBJBG@unknown?5BMP?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN33@stbi__bmp_
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN34@stbi__bmp_
$LN33@stbi__bmp_:
	mov	DWORD PTR tv129[ebp], 0
$LN34@stbi__bmp_:
	mov	eax, DWORD PTR tv129[ebp]
	jmp	$LN29@stbi__bmp_
$LN26@stbi__bmp_:

; 5001 :    if (hsz == 12) {

	cmp	DWORD PTR _hsz$[ebp], 12		; 0000000cH
	jne	SHORT $LN25@stbi__bmp_

; 5002 :       s->img_x = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 5003 :       s->img_y = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 5004 :    } else {

	jmp	SHORT $LN24@stbi__bmp_
$LN25@stbi__bmp_:

; 5005 :       s->img_x = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 5006 :       s->img_y = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN24@stbi__bmp_:

; 5007 :    }
; 5008 :    if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	cmp	eax, 1
	je	SHORT $LN23@stbi__bmp_
	push	OFFSET ??_C@_07IEJCHBDI@bad?5BMP?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN35@stbi__bmp_
	mov	DWORD PTR tv149[ebp], 0
	jmp	SHORT $LN36@stbi__bmp_
$LN35@stbi__bmp_:
	mov	DWORD PTR tv149[ebp], 0
$LN36@stbi__bmp_:
	mov	eax, DWORD PTR tv149[ebp]
	jmp	$LN29@stbi__bmp_
$LN23@stbi__bmp_:

; 5009 :    info->bpp = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx], eax

; 5010 :    if (info->bpp == 1) return stbi__errpuc("monochrome", "BMP type not supported: 1-bit");

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN22@stbi__bmp_
	push	OFFSET ??_C@_0L@FEJFGKNE@monochrome?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN37@stbi__bmp_
	mov	DWORD PTR tv158[ebp], 0
	jmp	SHORT $LN38@stbi__bmp_
$LN37@stbi__bmp_:
	mov	DWORD PTR tv158[ebp], 0
$LN38@stbi__bmp_:
	mov	eax, DWORD PTR tv158[ebp]
	jmp	$LN29@stbi__bmp_
$LN22@stbi__bmp_:

; 5011 :    if (hsz != 12) {

	cmp	DWORD PTR _hsz$[ebp], 12		; 0000000cH
	je	$LN21@stbi__bmp_

; 5012 :       int compress = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
	mov	DWORD PTR _compress$2[ebp], eax

; 5013 :       if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");

	cmp	DWORD PTR _compress$2[ebp], 1
	je	SHORT $LN19@stbi__bmp_
	cmp	DWORD PTR _compress$2[ebp], 2
	jne	SHORT $LN20@stbi__bmp_
$LN19@stbi__bmp_:
	push	OFFSET ??_C@_07IMHMNOIB@BMP?5RLE?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN39@stbi__bmp_
	mov	DWORD PTR tv167[ebp], 0
	jmp	SHORT $LN40@stbi__bmp_
$LN39@stbi__bmp_:
	mov	DWORD PTR tv167[ebp], 0
$LN40@stbi__bmp_:
	mov	eax, DWORD PTR tv167[ebp]
	jmp	$LN29@stbi__bmp_
$LN20@stbi__bmp_:

; 5014 :       stbi__get32le(s); // discard sizeof

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4

; 5015 :       stbi__get32le(s); // discard hres

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4

; 5016 :       stbi__get32le(s); // discard vres

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4

; 5017 :       stbi__get32le(s); // discard colorsused

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4

; 5018 :       stbi__get32le(s); // discard max important

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4

; 5019 :       if (hsz == 40 || hsz == 56) {

	cmp	DWORD PTR _hsz$[ebp], 40		; 00000028H
	je	SHORT $LN17@stbi__bmp_
	cmp	DWORD PTR _hsz$[ebp], 56		; 00000038H
	jne	$LN18@stbi__bmp_
$LN17@stbi__bmp_:

; 5020 :          if (hsz == 56) {

	cmp	DWORD PTR _hsz$[ebp], 56		; 00000038H
	jne	SHORT $LN16@stbi__bmp_

; 5021 :             stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4

; 5022 :             stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4

; 5023 :             stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4

; 5024 :             stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
$LN16@stbi__bmp_:

; 5025 :          }
; 5026 :          if (info->bpp == 16 || info->bpp == 32) {

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 16			; 00000010H
	je	SHORT $LN14@stbi__bmp_
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 32			; 00000020H
	jne	$LN15@stbi__bmp_
$LN14@stbi__bmp_:

; 5027 :             if (compress == 0) {

	cmp	DWORD PTR _compress$2[ebp], 0
	jne	SHORT $LN13@stbi__bmp_

; 5028 :                if (info->bpp == 32) {

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 32			; 00000020H
	jne	SHORT $LN12@stbi__bmp_

; 5029 :                   info->mr = 0xffu << 16;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+12], 16711680		; 00ff0000H

; 5030 :                   info->mg = 0xffu <<  8;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+16], 65280		; 0000ff00H

; 5031 :                   info->mb = 0xffu <<  0;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+20], 255			; 000000ffH

; 5032 :                   info->ma = 0xffu << 24;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+24], -16777216		; ff000000H

; 5033 :                   info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+28], 0

; 5034 :                } else {

	jmp	SHORT $LN11@stbi__bmp_
$LN12@stbi__bmp_:

; 5035 :                   info->mr = 31u << 10;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+12], 31744		; 00007c00H

; 5036 :                   info->mg = 31u <<  5;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+16], 992			; 000003e0H

; 5037 :                   info->mb = 31u <<  0;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+20], 31			; 0000001fH
$LN11@stbi__bmp_:

; 5038 :                }

	jmp	$LN15@stbi__bmp_
$LN13@stbi__bmp_:

; 5039 :             } else if (compress == 3) {

	cmp	DWORD PTR _compress$2[ebp], 3
	jne	$LN9@stbi__bmp_

; 5040 :                info->mr = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 5041 :                info->mg = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 5042 :                info->mb = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 5043 :                // not documented, but generated by photoshop and handled by mspaint
; 5044 :                if (info->mr == info->mg && info->mg == info->mb) {

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+16]
	jne	SHORT $LN8@stbi__bmp_
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN8@stbi__bmp_

; 5045 :                   // ?!?!?
; 5046 :                   return stbi__errpuc("bad BMP", "bad BMP");

	push	OFFSET ??_C@_07IEJCHBDI@bad?5BMP?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN41@stbi__bmp_
	mov	DWORD PTR tv214[ebp], 0
	jmp	SHORT $LN42@stbi__bmp_
$LN41@stbi__bmp_:
	mov	DWORD PTR tv214[ebp], 0
$LN42@stbi__bmp_:
	mov	eax, DWORD PTR tv214[ebp]
	jmp	$LN29@stbi__bmp_
$LN8@stbi__bmp_:

; 5047 :                }
; 5048 :             } else

	jmp	SHORT $LN15@stbi__bmp_
$LN9@stbi__bmp_:

; 5049 :                return stbi__errpuc("bad BMP", "bad BMP");

	push	OFFSET ??_C@_07IEJCHBDI@bad?5BMP?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN43@stbi__bmp_
	mov	DWORD PTR tv218[ebp], 0
	jmp	SHORT $LN44@stbi__bmp_
$LN43@stbi__bmp_:
	mov	DWORD PTR tv218[ebp], 0
$LN44@stbi__bmp_:
	mov	eax, DWORD PTR tv218[ebp]
	jmp	$LN29@stbi__bmp_
$LN15@stbi__bmp_:

; 5050 :          }
; 5051 :       } else {

	jmp	$LN21@stbi__bmp_
$LN18@stbi__bmp_:

; 5052 :          int i;
; 5053 :          if (hsz != 108 && hsz != 124)

	cmp	DWORD PTR _hsz$[ebp], 108		; 0000006cH
	je	SHORT $LN5@stbi__bmp_
	cmp	DWORD PTR _hsz$[ebp], 124		; 0000007cH
	je	SHORT $LN5@stbi__bmp_

; 5054 :             return stbi__errpuc("bad BMP", "bad BMP");

	push	OFFSET ??_C@_07IEJCHBDI@bad?5BMP?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN45@stbi__bmp_
	mov	DWORD PTR tv224[ebp], 0
	jmp	SHORT $LN46@stbi__bmp_
$LN45@stbi__bmp_:
	mov	DWORD PTR tv224[ebp], 0
$LN46@stbi__bmp_:
	mov	eax, DWORD PTR tv224[ebp]
	jmp	$LN29@stbi__bmp_
$LN5@stbi__bmp_:

; 5055 :          info->mr = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 5056 :          info->mg = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 5057 :          info->mb = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 5058 :          info->ma = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 5059 :          stbi__get32le(s); // discard color space

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4

; 5060 :          for (i=0; i < 12; ++i)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@stbi__bmp_
$LN3@stbi__bmp_:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@stbi__bmp_:
	cmp	DWORD PTR _i$1[ebp], 12			; 0000000cH
	jge	SHORT $LN2@stbi__bmp_

; 5061 :             stbi__get32le(s); // discard color space parameters

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
	jmp	SHORT $LN3@stbi__bmp_
$LN2@stbi__bmp_:

; 5062 :          if (hsz == 124) {

	cmp	DWORD PTR _hsz$[ebp], 124		; 0000007cH
	jne	SHORT $LN21@stbi__bmp_

; 5063 :             stbi__get32le(s); // discard rendering intent

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4

; 5064 :             stbi__get32le(s); // discard offset of profile data

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4

; 5065 :             stbi__get32le(s); // discard size of profile data

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4

; 5066 :             stbi__get32le(s); // discard reserved

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
$LN21@stbi__bmp_:

; 5067 :          }
; 5068 :       }
; 5069 :    }
; 5070 :    return (void *) 1;

	mov	eax, 1
$LN29@stbi__bmp_:

; 5071 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__bmp_parse_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__shiftsigned
_TEXT	SEGMENT
_z$ = -20						; size = 4
_result$ = -8						; size = 4
_v$ = 8							; size = 4
_shift$ = 12						; size = 4
_bits$ = 16						; size = 4
_stbi__shiftsigned PROC					; COMDAT

; 4967 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4968 :    int result;
; 4969 :    int z=0;

	mov	DWORD PTR _z$[ebp], 0

; 4970 : 
; 4971 :    if (shift < 0) v <<= -shift;

	cmp	DWORD PTR _shift$[ebp], 0
	jge	SHORT $LN4@stbi__shif
	mov	ecx, DWORD PTR _shift$[ebp]
	neg	ecx
	mov	eax, DWORD PTR _v$[ebp]
	shl	eax, cl
	mov	DWORD PTR _v$[ebp], eax
	jmp	SHORT $LN3@stbi__shif
$LN4@stbi__shif:

; 4972 :    else v >>= shift;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	sar	eax, cl
	mov	DWORD PTR _v$[ebp], eax
$LN3@stbi__shif:

; 4973 :    result = v;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR _result$[ebp], eax

; 4974 : 
; 4975 :    z = bits;

	mov	eax, DWORD PTR _bits$[ebp]
	mov	DWORD PTR _z$[ebp], eax
$LN2@stbi__shif:

; 4976 :    while (z < 8) {

	cmp	DWORD PTR _z$[ebp], 8
	jge	SHORT $LN1@stbi__shif

; 4977 :       result += v >> z;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	sar	eax, cl
	add	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR _result$[ebp], eax

; 4978 :       z += bits;

	mov	eax, DWORD PTR _z$[ebp]
	add	eax, DWORD PTR _bits$[ebp]
	mov	DWORD PTR _z$[ebp], eax

; 4979 :    }

	jmp	SHORT $LN2@stbi__shif
$LN1@stbi__shif:

; 4980 :    return result;

	mov	eax, DWORD PTR _result$[ebp]

; 4981 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__shiftsigned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__bitcount
_TEXT	SEGMENT
_a$ = 8							; size = 4
_stbi__bitcount PROC					; COMDAT

; 4957 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4958 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2

	mov	eax, DWORD PTR _a$[ebp]
	and	eax, 1431655765				; 55555555H
	mov	ecx, DWORD PTR _a$[ebp]
	shr	ecx, 1
	and	ecx, 1431655765				; 55555555H
	add	eax, ecx
	mov	DWORD PTR _a$[ebp], eax

; 4959 :    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4

	mov	eax, DWORD PTR _a$[ebp]
	and	eax, 858993459				; 33333333H
	mov	ecx, DWORD PTR _a$[ebp]
	shr	ecx, 2
	and	ecx, 858993459				; 33333333H
	add	eax, ecx
	mov	DWORD PTR _a$[ebp], eax

; 4960 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

	mov	eax, DWORD PTR _a$[ebp]
	shr	eax, 4
	add	eax, DWORD PTR _a$[ebp]
	and	eax, 252645135				; 0f0f0f0fH
	mov	DWORD PTR _a$[ebp], eax

; 4961 :    a = (a + (a >> 8)); // max 16 per 8 bits

	mov	eax, DWORD PTR _a$[ebp]
	shr	eax, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 4962 :    a = (a + (a >> 16)); // max 32 per 8 bits

	mov	eax, DWORD PTR _a$[ebp]
	shr	eax, 16					; 00000010H
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 4963 :    return a & 0xff;

	mov	eax, DWORD PTR _a$[ebp]
	and	eax, 255				; 000000ffH

; 4964 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__bitcount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__high_bit
_TEXT	SEGMENT
_n$ = -8						; size = 4
_z$ = 8							; size = 4
_stbi__high_bit PROC					; COMDAT

; 4945 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4946 :    int n=0;

	mov	DWORD PTR _n$[ebp], 0

; 4947 :    if (z == 0) return -1;

	cmp	DWORD PTR _z$[ebp], 0
	jne	SHORT $LN6@stbi__high
	or	eax, -1
	jmp	$LN7@stbi__high
$LN6@stbi__high:

; 4948 :    if (z >= 0x10000) n += 16, z >>= 16;

	cmp	DWORD PTR _z$[ebp], 65536		; 00010000H
	jb	SHORT $LN5@stbi__high
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _n$[ebp], eax
	mov	ecx, DWORD PTR _z$[ebp]
	shr	ecx, 16					; 00000010H
	mov	DWORD PTR _z$[ebp], ecx
$LN5@stbi__high:

; 4949 :    if (z >= 0x00100) n +=  8, z >>=  8;

	cmp	DWORD PTR _z$[ebp], 256			; 00000100H
	jb	SHORT $LN4@stbi__high
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 8
	mov	DWORD PTR _n$[ebp], eax
	mov	ecx, DWORD PTR _z$[ebp]
	shr	ecx, 8
	mov	DWORD PTR _z$[ebp], ecx
$LN4@stbi__high:

; 4950 :    if (z >= 0x00010) n +=  4, z >>=  4;

	cmp	DWORD PTR _z$[ebp], 16			; 00000010H
	jb	SHORT $LN3@stbi__high
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 4
	mov	DWORD PTR _n$[ebp], eax
	mov	ecx, DWORD PTR _z$[ebp]
	shr	ecx, 4
	mov	DWORD PTR _z$[ebp], ecx
$LN3@stbi__high:

; 4951 :    if (z >= 0x00004) n +=  2, z >>=  2;

	cmp	DWORD PTR _z$[ebp], 4
	jb	SHORT $LN2@stbi__high
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 2
	mov	DWORD PTR _n$[ebp], eax
	mov	ecx, DWORD PTR _z$[ebp]
	shr	ecx, 2
	mov	DWORD PTR _z$[ebp], ecx
$LN2@stbi__high:

; 4952 :    if (z >= 0x00002) n +=  1, z >>=  1;

	cmp	DWORD PTR _z$[ebp], 2
	jb	SHORT $LN1@stbi__high
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	mov	ecx, DWORD PTR _z$[ebp]
	shr	ecx, 1
	mov	DWORD PTR _z$[ebp], ecx
$LN1@stbi__high:

; 4953 :    return n;

	mov	eax, DWORD PTR _n$[ebp]
$LN7@stbi__high:

; 4954 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__high_bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__bmp_test_raw
_TEXT	SEGMENT
tv83 = -220						; size = 4
_sz$ = -20						; size = 4
_r$ = -8						; size = 4
_s$ = 8							; size = 4
_stbi__bmp_test_raw PROC				; COMDAT

; 4921 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4922 :    int r;
; 4923 :    int sz;
; 4924 :    if (stbi__get8(s) != 'B') return 0;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 66					; 00000042H
	je	SHORT $LN2@stbi__bmp_
	xor	eax, eax
	jmp	$LN3@stbi__bmp_
$LN2@stbi__bmp_:

; 4925 :    if (stbi__get8(s) != 'M') return 0;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 77					; 0000004dH
	je	SHORT $LN1@stbi__bmp_
	xor	eax, eax
	jmp	SHORT $LN3@stbi__bmp_
$LN1@stbi__bmp_:

; 4926 :    stbi__get32le(s); // discard filesize

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4

; 4927 :    stbi__get16le(s); // discard reserved

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4

; 4928 :    stbi__get16le(s); // discard reserved

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4

; 4929 :    stbi__get32le(s); // discard data offset

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4

; 4930 :    sz = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32le
	add	esp, 4
	mov	DWORD PTR _sz$[ebp], eax

; 4931 :    r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);

	cmp	DWORD PTR _sz$[ebp], 12			; 0000000cH
	je	SHORT $LN5@stbi__bmp_
	cmp	DWORD PTR _sz$[ebp], 40			; 00000028H
	je	SHORT $LN5@stbi__bmp_
	cmp	DWORD PTR _sz$[ebp], 56			; 00000038H
	je	SHORT $LN5@stbi__bmp_
	cmp	DWORD PTR _sz$[ebp], 108		; 0000006cH
	je	SHORT $LN5@stbi__bmp_
	cmp	DWORD PTR _sz$[ebp], 124		; 0000007cH
	je	SHORT $LN5@stbi__bmp_
	mov	DWORD PTR tv83[ebp], 0
	jmp	SHORT $LN6@stbi__bmp_
$LN5@stbi__bmp_:
	mov	DWORD PTR tv83[ebp], 1
$LN6@stbi__bmp_:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _r$[ebp], eax

; 4932 :    return r;

	mov	eax, DWORD PTR _r$[ebp]
$LN3@stbi__bmp_:

; 4933 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__bmp_test_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__png_info_raw
_TEXT	SEGMENT
_p$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_stbi__png_info_raw PROC				; COMDAT

; 4898 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4899 :    if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {

	push	0
	push	2
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_stbi__parse_png_file
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@stbi__png_

; 4900 :       stbi__rewind( p->s );

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__rewind
	add	esp, 4

; 4901 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN5@stbi__png_
$LN4@stbi__png_:

; 4902 :    }
; 4903 :    if (x) *x = p->s->img_x;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@stbi__png_
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
$LN3@stbi__png_:

; 4904 :    if (y) *y = p->s->img_y;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN2@stbi__png_
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN2@stbi__png_:

; 4905 :    if (comp) *comp = p->s->img_n;

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN1@stbi__png_
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax
$LN1@stbi__png_:

; 4906 :    return 1;

	mov	eax, 1
$LN5@stbi__png_:

; 4907 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__png_info_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__do_png
_TEXT	SEGMENT
tv69 = -208						; size = 4
_result$ = -8						; size = 4
_p$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_n$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
_stbi__do_png PROC					; COMDAT

; 4853 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4854 :    void *result=NULL;

	mov	DWORD PTR _result$[ebp], 0

; 4855 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

	cmp	DWORD PTR _req_comp$[ebp], 0
	jl	SHORT $LN9@stbi__do_p
	cmp	DWORD PTR _req_comp$[ebp], 4
	jle	SHORT $LN10@stbi__do_p
$LN9@stbi__do_p:
	push	OFFSET ??_C@_0N@KBPNPPBJ@bad?5req_comp?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@stbi__do_p
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN14@stbi__do_p
$LN13@stbi__do_p:
	mov	DWORD PTR tv69[ebp], 0
$LN14@stbi__do_p:
	mov	eax, DWORD PTR tv69[ebp]
	jmp	$LN11@stbi__do_p
$LN10@stbi__do_p:

; 4856 :    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_stbi__parse_png_file
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN8@stbi__do_p

; 4857 :       if (p->depth < 8)

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax+16], 8
	jge	SHORT $LN7@stbi__do_p

; 4858 :          ri->bits_per_channel = 8;

	mov	eax, DWORD PTR _ri$[ebp]
	mov	DWORD PTR [eax], 8

; 4859 :       else

	jmp	SHORT $LN6@stbi__do_p
$LN7@stbi__do_p:

; 4860 :          ri->bits_per_channel = p->depth;

	mov	eax, DWORD PTR _ri$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax], edx
$LN6@stbi__do_p:

; 4861 :       result = p->out;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _result$[ebp], ecx

; 4862 :       p->out = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+12], 0

; 4863 :       if (req_comp && req_comp != p->s->img_out_n) {

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	$LN5@stbi__do_p
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _req_comp$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN5@stbi__do_p

; 4864 :          if (ri->bits_per_channel == 8)

	mov	eax, DWORD PTR _ri$[ebp]
	cmp	DWORD PTR [eax], 8
	jne	SHORT $LN4@stbi__do_p

; 4865 :             result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _result$[ebp]
	push	ecx
	call	_stbi__convert_format
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax

; 4866 :          else

	jmp	SHORT $LN3@stbi__do_p
$LN4@stbi__do_p:

; 4867 :             result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _result$[ebp]
	push	ecx
	call	_stbi__convert_format16
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax
$LN3@stbi__do_p:

; 4868 :          p->s->img_out_n = req_comp;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 4869 :          if (result == NULL) return result;

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN5@stbi__do_p
	mov	eax, DWORD PTR _result$[ebp]
	jmp	SHORT $LN11@stbi__do_p
$LN5@stbi__do_p:

; 4870 :       }
; 4871 :       *x = p->s->img_x;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 4872 :       *y = p->s->img_y;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax

; 4873 :       if (n) *n = p->s->img_n;

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN8@stbi__do_p
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax
$LN8@stbi__do_p:

; 4874 :    }
; 4875 :    STBI_FREE(p->out);      p->out      = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_free
	add	esp, 4
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+12], 0

; 4876 :    STBI_FREE(p->expanded); p->expanded = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_free
	add	esp, 4
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+8], 0

; 4877 :    STBI_FREE(p->idata);    p->idata    = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_free
	add	esp, 4
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], 0

; 4878 : 
; 4879 :    return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN11@stbi__do_p:

; 4880 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__do_png ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__parse_png_file
_TEXT	SEGMENT
tv193 = -1496						; size = 4
tv369 = -1492						; size = 4
tv325 = -1492						; size = 4
tv190 = -1492						; size = 4
tv74 = -1492						; size = 4
_bpl$1 = -1292						; size = 4
_raw_len$2 = -1280					; size = 4
_p$3 = -1268						; size = 4
_idata_limit_old$4 = -1256				; size = 4
_filter$5 = -1244					; size = 4
_comp$6 = -1232						; size = 4
_c$7 = -1220						; size = 8
_s$ = -1204						; size = 4
_is_iphone$ = -1192					; size = 4
_color$ = -1180						; size = 4
_interlace$ = -1168					; size = 4
_k$ = -1156						; size = 4
_first$ = -1144						; size = 4
_pal_len$ = -1132					; size = 4
_i$ = -1120						; size = 4
_idata_limit$ = -1108					; size = 4
_ioff$ = -1096						; size = 4
_tc16$ = -1084						; size = 6
_tc$ = -1068						; size = 3
_has_trans$ = -1053					; size = 1
_pal_img_n$ = -1041					; size = 1
_palette$ = -1032					; size = 1024
__$ArrayPad$ = -4					; size = 4
_z$ = 8							; size = 4
_scan$ = 12						; size = 4
_req_comp$ = 16						; size = 4
_stbi__parse_png_file PROC				; COMDAT

; 4681 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1496				; 000005d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1496]
	mov	ecx, 374				; 00000176H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4682 :    stbi_uc palette[1024], pal_img_n=0;

	mov	BYTE PTR _pal_img_n$[ebp], 0

; 4683 :    stbi_uc has_trans=0, tc[3];

	mov	BYTE PTR _has_trans$[ebp], 0

; 4684 :    stbi__uint16 tc16[3];
; 4685 :    stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;

	mov	DWORD PTR _ioff$[ebp], 0
	mov	DWORD PTR _idata_limit$[ebp], 0
	mov	DWORD PTR _pal_len$[ebp], 0

; 4686 :    int first=1,k,interlace=0, color=0, is_iphone=0;

	mov	DWORD PTR _first$[ebp], 1
	mov	DWORD PTR _interlace$[ebp], 0
	mov	DWORD PTR _color$[ebp], 0
	mov	DWORD PTR _is_iphone$[ebp], 0

; 4687 :    stbi__context *s = z->s;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$[ebp], ecx

; 4688 : 
; 4689 :    z->expanded = NULL;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+8], 0

; 4690 :    z->idata = NULL;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+4], 0

; 4691 :    z->out = NULL;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+12], 0

; 4692 : 
; 4693 :    if (!stbi__check_png_header(s)) return 0;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__check_png_header
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN91@stbi__pars
	xor	eax, eax
	jmp	$LN92@stbi__pars
$LN91@stbi__pars:

; 4694 : 
; 4695 :    if (scan == STBI__SCAN_type) return 1;

	cmp	DWORD PTR _scan$[ebp], 1
	jne	SHORT $LN89@stbi__pars
	mov	eax, 1
	jmp	$LN92@stbi__pars
$LN89@stbi__pars:

; 4696 : 
; 4697 :    for (;;) {
; 4698 :       stbi__pngchunk c = stbi__get_chunk_header(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get_chunk_header
	add	esp, 4
	mov	DWORD PTR _c$7[ebp], eax
	mov	DWORD PTR _c$7[ebp+4], edx

; 4699 :       switch (c.type) {

	mov	eax, DWORD PTR _c$7[ebp+4]
	mov	DWORD PTR tv74[ebp], eax
	cmp	DWORD PTR tv74[ebp], 1229472850		; 49484452H
	ja	SHORT $LN102@stbi__pars
	cmp	DWORD PTR tv74[ebp], 1229472850		; 49484452H
	je	SHORT $LN84@stbi__pars
	cmp	DWORD PTR tv74[ebp], 1130840649		; 43674249H
	je	SHORT $LN85@stbi__pars
	cmp	DWORD PTR tv74[ebp], 1229209940		; 49444154H
	je	$LN35@stbi__pars
	cmp	DWORD PTR tv74[ebp], 1229278788		; 49454e44H
	je	$LN24@stbi__pars
	jmp	$LN3@stbi__pars
$LN102@stbi__pars:
	cmp	DWORD PTR tv74[ebp], 1347179589		; 504c5445H
	je	$LN63@stbi__pars
	cmp	DWORD PTR tv74[ebp], 1951551059		; 74524e53H
	je	$LN56@stbi__pars
	jmp	$LN3@stbi__pars
$LN85@stbi__pars:

; 4700 :          case STBI__PNG_TYPE('C','g','B','I'):
; 4701 :             is_iphone = 1;

	mov	DWORD PTR _is_iphone$[ebp], 1

; 4702 :             stbi__skip(s, c.length);

	mov	eax, DWORD PTR _c$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__skip
	add	esp, 8

; 4703 :             break;

	jmp	$LN86@stbi__pars
$LN84@stbi__pars:

; 4704 :          case STBI__PNG_TYPE('I','H','D','R'): {
; 4705 :             int comp,filter;
; 4706 :             if (!first) return stbi__err("multiple IHDR","Corrupt PNG");

	cmp	DWORD PTR _first$[ebp], 0
	jne	SHORT $LN83@stbi__pars
	push	OFFSET ??_C@_0O@KBHBNJOK@multiple?5IHDR?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN83@stbi__pars:

; 4707 :             first = 0;

	mov	DWORD PTR _first$[ebp], 0

; 4708 :             if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");

	cmp	DWORD PTR _c$7[ebp], 13			; 0000000dH
	je	SHORT $LN82@stbi__pars
	push	OFFSET ??_C@_0N@POJLKMKK@bad?5IHDR?5len?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN82@stbi__pars:

; 4709 :             s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err("too large","Very large image (corrupt?)");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32be
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax], 16777216		; 01000000H
	jbe	SHORT $LN81@stbi__pars
	push	OFFSET ??_C@_09OJDLMMBJ@too?5large?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN81@stbi__pars:

; 4710 :             s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err("too large","Very large image (corrupt?)");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32be
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+4], 16777216		; 01000000H
	jbe	SHORT $LN80@stbi__pars
	push	OFFSET ??_C@_09OJDLMMBJ@too?5large?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN80@stbi__pars:

; 4711 :             z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+16], ecx
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 1
	je	SHORT $LN79@stbi__pars
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 2
	je	SHORT $LN79@stbi__pars
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 4
	je	SHORT $LN79@stbi__pars
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 8
	je	SHORT $LN79@stbi__pars
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 16			; 00000010H
	je	SHORT $LN79@stbi__pars
	push	OFFSET ??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN79@stbi__pars:

; 4712 :             color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _color$[ebp], ecx
	cmp	DWORD PTR _color$[ebp], 6
	jle	SHORT $LN78@stbi__pars
	push	OFFSET ??_C@_09MBBNGCKB@bad?5ctype?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN78@stbi__pars:

; 4713 :             if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");

	cmp	DWORD PTR _color$[ebp], 3
	jne	SHORT $LN77@stbi__pars
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 16			; 00000010H
	jne	SHORT $LN77@stbi__pars
	push	OFFSET ??_C@_09MBBNGCKB@bad?5ctype?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN77@stbi__pars:

; 4714 :             if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");

	cmp	DWORD PTR _color$[ebp], 3
	jne	SHORT $LN76@stbi__pars
	mov	BYTE PTR _pal_img_n$[ebp], 3
	jmp	SHORT $LN75@stbi__pars
$LN76@stbi__pars:
	mov	eax, DWORD PTR _color$[ebp]
	and	eax, 1
	je	SHORT $LN75@stbi__pars
	push	OFFSET ??_C@_09MBBNGCKB@bad?5ctype?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN75@stbi__pars:

; 4715 :             comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _comp$6[ebp], ecx
	cmp	DWORD PTR _comp$6[ebp], 0
	je	SHORT $LN73@stbi__pars
	push	OFFSET ??_C@_0BA@MDMBDDFG@bad?5comp?5method?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN73@stbi__pars:

; 4716 :             filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _filter$5[ebp], ecx
	cmp	DWORD PTR _filter$5[ebp], 0
	je	SHORT $LN72@stbi__pars
	push	OFFSET ??_C@_0BC@GHLIKKMD@bad?5filter?5method?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN72@stbi__pars:

; 4717 :             interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _interlace$[ebp], ecx
	cmp	DWORD PTR _interlace$[ebp], 1
	jle	SHORT $LN71@stbi__pars
	push	OFFSET ??_C@_0BF@JCGDPBAA@bad?5interlace?5method?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN71@stbi__pars:

; 4718 :             if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN69@stbi__pars
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN70@stbi__pars
$LN69@stbi__pars:
	push	OFFSET ??_C@_0O@FNFBHCOO@0?9pixel?5image?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN70@stbi__pars:

; 4719 :             if (!pal_img_n) {

	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	test	eax, eax
	jne	$LN68@stbi__pars

; 4720 :                s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);

	mov	eax, DWORD PTR _color$[ebp]
	and	eax, 2
	je	SHORT $LN94@stbi__pars
	mov	DWORD PTR tv190[ebp], 3
	jmp	SHORT $LN95@stbi__pars
$LN94@stbi__pars:
	mov	DWORD PTR tv190[ebp], 1
$LN95@stbi__pars:
	mov	ecx, DWORD PTR _color$[ebp]
	and	ecx, 4
	je	SHORT $LN96@stbi__pars
	mov	DWORD PTR tv193[ebp], 1
	jmp	SHORT $LN97@stbi__pars
$LN96@stbi__pars:
	mov	DWORD PTR tv193[ebp], 0
$LN97@stbi__pars:
	mov	edx, DWORD PTR tv190[ebp]
	add	edx, DWORD PTR tv193[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+8], edx

; 4721 :                if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");

	mov	ecx, DWORD PTR _s$[ebp]
	mov	eax, 1073741824				; 40000000H
	xor	edx, edx
	div	DWORD PTR [ecx]
	mov	ecx, DWORD PTR _s$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN67@stbi__pars
	push	OFFSET ??_C@_09OJDLMMBJ@too?5large?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN67@stbi__pars:

; 4722 :                if (scan == STBI__SCAN_header) return 1;

	cmp	DWORD PTR _scan$[ebp], 2
	jne	SHORT $LN66@stbi__pars
	mov	eax, 1
	jmp	$LN92@stbi__pars
$LN66@stbi__pars:

; 4723 :             } else {

	jmp	SHORT $LN65@stbi__pars
$LN68@stbi__pars:

; 4724 :                // if paletted, then pal_n is our final components, and
; 4725 :                // img_n is # components to decompress/filter.
; 4726 :                s->img_n = 1;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+8], 1

; 4727 :                if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");

	mov	ecx, DWORD PTR _s$[ebp]
	mov	eax, 1073741824				; 40000000H
	xor	edx, edx
	div	DWORD PTR [ecx]
	shr	eax, 2
	mov	edx, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN65@stbi__pars
	push	OFFSET ??_C@_09OJDLMMBJ@too?5large?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN65@stbi__pars:

; 4728 :                // if SCAN_header, have to scan to see if we have a tRNS
; 4729 :             }
; 4730 :             break;

	jmp	$LN86@stbi__pars
$LN63@stbi__pars:

; 4731 :          }
; 4732 : 
; 4733 :          case STBI__PNG_TYPE('P','L','T','E'):  {
; 4734 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	cmp	DWORD PTR _first$[ebp], 0
	je	SHORT $LN62@stbi__pars
	push	OFFSET ??_C@_0P@JEAFOMAF@first?5not?5IHDR?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN62@stbi__pars:

; 4735 :             if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");

	cmp	DWORD PTR _c$7[ebp], 768		; 00000300H
	jbe	SHORT $LN61@stbi__pars
	push	OFFSET ??_C@_0N@JCPAJAKB@invalid?5PLTE?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN61@stbi__pars:

; 4736 :             pal_len = c.length / 3;

	mov	eax, DWORD PTR _c$7[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	DWORD PTR _pal_len$[ebp], eax

; 4737 :             if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");

	imul	eax, DWORD PTR _pal_len$[ebp], 3
	cmp	eax, DWORD PTR _c$7[ebp]
	je	SHORT $LN60@stbi__pars
	push	OFFSET ??_C@_0N@JCPAJAKB@invalid?5PLTE?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN60@stbi__pars:

; 4738 :             for (i=0; i < pal_len; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN59@stbi__pars
$LN58@stbi__pars:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN59@stbi__pars:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pal_len$[ebp]
	jae	SHORT $LN57@stbi__pars

; 4739 :                palette[i*4+0] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _palette$[ebp+ecx*4], al

; 4740 :                palette[i*4+1] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _palette$[ebp+ecx*4+1], al

; 4741 :                palette[i*4+2] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _palette$[ebp+ecx*4+2], al

; 4742 :                palette[i*4+3] = 255;

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _palette$[ebp+eax*4+3], 255	; 000000ffH

; 4743 :             }

	jmp	$LN58@stbi__pars
$LN57@stbi__pars:

; 4744 :             break;

	jmp	$LN86@stbi__pars
$LN56@stbi__pars:

; 4745 :          }
; 4746 : 
; 4747 :          case STBI__PNG_TYPE('t','R','N','S'): {
; 4748 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	cmp	DWORD PTR _first$[ebp], 0
	je	SHORT $LN55@stbi__pars
	push	OFFSET ??_C@_0P@JEAFOMAF@first?5not?5IHDR?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN55@stbi__pars:

; 4749 :             if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN54@stbi__pars
	push	OFFSET ??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN54@stbi__pars:

; 4750 :             if (pal_img_n) {

	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	test	eax, eax
	je	$LN53@stbi__pars

; 4751 :                if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }

	cmp	DWORD PTR _scan$[ebp], 2
	jne	SHORT $LN52@stbi__pars
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+8], 4
	mov	eax, 1
	jmp	$LN92@stbi__pars
$LN52@stbi__pars:

; 4752 :                if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");

	cmp	DWORD PTR _pal_len$[ebp], 0
	jne	SHORT $LN51@stbi__pars
	push	OFFSET ??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN51@stbi__pars:

; 4753 :                if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");

	mov	eax, DWORD PTR _c$7[ebp]
	cmp	eax, DWORD PTR _pal_len$[ebp]
	jbe	SHORT $LN50@stbi__pars
	push	OFFSET ??_C@_0N@KDLCCKCH@bad?5tRNS?5len?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN50@stbi__pars:

; 4754 :                pal_img_n = 4;

	mov	BYTE PTR _pal_img_n$[ebp], 4

; 4755 :                for (i=0; i < c.length; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN49@stbi__pars
$LN48@stbi__pars:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN49@stbi__pars:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _c$7[ebp]
	jae	SHORT $LN47@stbi__pars

; 4756 :                   palette[i*4+3] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _palette$[ebp+ecx*4+3], al
	jmp	SHORT $LN48@stbi__pars
$LN47@stbi__pars:

; 4757 :             } else {

	jmp	$LN46@stbi__pars
$LN53@stbi__pars:

; 4758 :                if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1
	jne	SHORT $LN45@stbi__pars
	push	OFFSET ??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN45@stbi__pars:

; 4759 :                if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	cmp	DWORD PTR _c$7[ebp], ecx
	je	SHORT $LN44@stbi__pars
	push	OFFSET ??_C@_0N@KDLCCKCH@bad?5tRNS?5len?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN44@stbi__pars:

; 4760 :                has_trans = 1;

	mov	BYTE PTR _has_trans$[ebp], 1

; 4761 :                if (z->depth == 16) {

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 16			; 00000010H
	jne	SHORT $LN43@stbi__pars

; 4762 :                   for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN42@stbi__pars
$LN41@stbi__pars:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN42@stbi__pars:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	SHORT $LN40@stbi__pars
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16be
	add	esp, 4
	mov	ecx, DWORD PTR _k$[ebp]
	mov	WORD PTR _tc16$[ebp+ecx*2], ax
	jmp	SHORT $LN41@stbi__pars
$LN40@stbi__pars:

; 4763 :                } else {

	jmp	SHORT $LN46@stbi__pars
$LN43@stbi__pars:

; 4764 :                   for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN38@stbi__pars
$LN37@stbi__pars:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN38@stbi__pars:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	SHORT $LN46@stbi__pars
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16be
	add	esp, 4
	and	eax, 255				; 000000ffH
	movzx	ecx, al
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR _stbi__depth_scale_table[eax]
	imul	ecx, edx
	mov	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR _tc$[ebp+eax], cl
	jmp	SHORT $LN37@stbi__pars
$LN46@stbi__pars:

; 4765 :                }
; 4766 :             }
; 4767 :             break;

	jmp	$LN86@stbi__pars
$LN35@stbi__pars:

; 4768 :          }
; 4769 : 
; 4770 :          case STBI__PNG_TYPE('I','D','A','T'): {
; 4771 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	cmp	DWORD PTR _first$[ebp], 0
	je	SHORT $LN34@stbi__pars
	push	OFFSET ??_C@_0P@JEAFOMAF@first?5not?5IHDR?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN34@stbi__pars:

; 4772 :             if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");

	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	test	eax, eax
	je	SHORT $LN33@stbi__pars
	cmp	DWORD PTR _pal_len$[ebp], 0
	jne	SHORT $LN33@stbi__pars
	push	OFFSET ??_C@_07CKIELOEH@no?5PLTE?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN33@stbi__pars:

; 4773 :             if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }

	cmp	DWORD PTR _scan$[ebp], 2
	jne	SHORT $LN32@stbi__pars
	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, 1
	jmp	$LN92@stbi__pars
$LN32@stbi__pars:

; 4774 :             if ((int)(ioff + c.length) < (int)ioff) return 0;

	mov	eax, DWORD PTR _ioff$[ebp]
	add	eax, DWORD PTR _c$7[ebp]
	cmp	eax, DWORD PTR _ioff$[ebp]
	jge	SHORT $LN31@stbi__pars
	xor	eax, eax
	jmp	$LN92@stbi__pars
$LN31@stbi__pars:

; 4775 :             if (ioff + c.length > idata_limit) {

	mov	eax, DWORD PTR _ioff$[ebp]
	add	eax, DWORD PTR _c$7[ebp]
	cmp	eax, DWORD PTR _idata_limit$[ebp]
	jbe	$LN30@stbi__pars

; 4776 :                stbi__uint32 idata_limit_old = idata_limit;

	mov	eax, DWORD PTR _idata_limit$[ebp]
	mov	DWORD PTR _idata_limit_old$4[ebp], eax

; 4777 :                stbi_uc *p;
; 4778 :                if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;

	cmp	DWORD PTR _idata_limit$[ebp], 0
	jne	SHORT $LN28@stbi__pars
	cmp	DWORD PTR _c$7[ebp], 4096		; 00001000H
	jbe	SHORT $LN98@stbi__pars
	mov	eax, DWORD PTR _c$7[ebp]
	mov	DWORD PTR tv325[ebp], eax
	jmp	SHORT $LN99@stbi__pars
$LN98@stbi__pars:
	mov	DWORD PTR tv325[ebp], 4096		; 00001000H
$LN99@stbi__pars:
	mov	ecx, DWORD PTR tv325[ebp]
	mov	DWORD PTR _idata_limit$[ebp], ecx
$LN28@stbi__pars:

; 4779 :                while (ioff + c.length > idata_limit)

	mov	eax, DWORD PTR _ioff$[ebp]
	add	eax, DWORD PTR _c$7[ebp]
	cmp	eax, DWORD PTR _idata_limit$[ebp]
	jbe	SHORT $LN27@stbi__pars

; 4780 :                   idata_limit *= 2;

	mov	eax, DWORD PTR _idata_limit$[ebp]
	shl	eax, 1
	mov	DWORD PTR _idata_limit$[ebp], eax
	jmp	SHORT $LN28@stbi__pars
$LN27@stbi__pars:

; 4781 :                STBI_NOTUSED(idata_limit_old);
; 4782 :                p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");

	mov	eax, DWORD PTR _idata_limit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _p$3[ebp], eax
	cmp	DWORD PTR _p$3[ebp], 0
	jne	SHORT $LN26@stbi__pars
	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN26@stbi__pars:

; 4783 :                z->idata = p;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _p$3[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN30@stbi__pars:

; 4784 :             }
; 4785 :             if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");

	mov	eax, DWORD PTR _c$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _ioff$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__getn
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@stbi__pars
	push	OFFSET ??_C@_09MNNCNKEO@outofdata?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN25@stbi__pars:

; 4786 :             ioff += c.length;

	mov	eax, DWORD PTR _ioff$[ebp]
	add	eax, DWORD PTR _c$7[ebp]
	mov	DWORD PTR _ioff$[ebp], eax

; 4787 :             break;

	jmp	$LN86@stbi__pars
$LN24@stbi__pars:

; 4788 :          }
; 4789 : 
; 4790 :          case STBI__PNG_TYPE('I','E','N','D'): {
; 4791 :             stbi__uint32 raw_len, bpl;
; 4792 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	cmp	DWORD PTR _first$[ebp], 0
	je	SHORT $LN23@stbi__pars
	push	OFFSET ??_C@_0P@JEAFOMAF@first?5not?5IHDR?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN23@stbi__pars:

; 4793 :             if (scan != STBI__SCAN_load) return 1;

	cmp	DWORD PTR _scan$[ebp], 0
	je	SHORT $LN22@stbi__pars
	mov	eax, 1
	jmp	$LN92@stbi__pars
$LN22@stbi__pars:

; 4794 :             if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN21@stbi__pars
	push	OFFSET ??_C@_07MLPECBNA@no?5IDAT?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN21@stbi__pars:

; 4795 :             // initial guess for decoded data size to avoid unnecessary reallocs
; 4796 :             bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [eax]
	imul	edx, DWORD PTR [ecx+16]
	add	edx, 7
	shr	edx, 3
	mov	DWORD PTR _bpl$1[ebp], edx

; 4797 :             raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _bpl$1[ebp]
	imul	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _s$[ebp]
	imul	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _s$[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _raw_len$2[ebp], ecx

; 4798 :             z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);

	cmp	DWORD PTR _is_iphone$[ebp], 0
	jne	SHORT $LN100@stbi__pars
	mov	DWORD PTR tv369[ebp], 1
	jmp	SHORT $LN101@stbi__pars
$LN100@stbi__pars:
	mov	DWORD PTR tv369[ebp], 0
$LN101@stbi__pars:
	mov	eax, DWORD PTR tv369[ebp]
	push	eax
	lea	ecx, DWORD PTR _raw_len$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _raw_len$2[ebp]
	push	edx
	mov	eax, DWORD PTR _ioff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_stbi_zlib_decode_malloc_guesssize_headerflag
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 4799 :             if (z->expanded == NULL) return 0; // zlib should set error

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN20@stbi__pars
	xor	eax, eax
	jmp	$LN92@stbi__pars
$LN20@stbi__pars:

; 4800 :             STBI_FREE(z->idata); z->idata = NULL;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_free
	add	esp, 4
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+4], 0

; 4801 :             if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	cmp	DWORD PTR _req_comp$[ebp], ecx
	jne	SHORT $LN17@stbi__pars
	cmp	DWORD PTR _req_comp$[ebp], 3
	je	SHORT $LN17@stbi__pars
	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	test	eax, eax
	je	SHORT $LN18@stbi__pars
$LN17@stbi__pars:
	movzx	eax, BYTE PTR _has_trans$[ebp]
	test	eax, eax
	je	SHORT $LN19@stbi__pars
$LN18@stbi__pars:

; 4802 :                s->img_out_n = s->img_n+1;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 4803 :             else

	jmp	SHORT $LN16@stbi__pars
$LN19@stbi__pars:

; 4804 :                s->img_out_n = s->img_n;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx
$LN16@stbi__pars:

; 4805 :             if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;

	mov	eax, DWORD PTR _interlace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _raw_len$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_stbi__create_png_image
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN15@stbi__pars
	xor	eax, eax
	jmp	$LN92@stbi__pars
$LN15@stbi__pars:

; 4806 :             if (has_trans) {

	movzx	eax, BYTE PTR _has_trans$[ebp]
	test	eax, eax
	je	SHORT $LN14@stbi__pars

; 4807 :                if (z->depth == 16) {

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 16			; 00000010H
	jne	SHORT $LN13@stbi__pars

; 4808 :                   if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	lea	edx, DWORD PTR _tc16$[ebp]
	push	edx
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_stbi__compute_transparency16
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@stbi__pars
	xor	eax, eax
	jmp	$LN92@stbi__pars
$LN12@stbi__pars:

; 4809 :                } else {

	jmp	SHORT $LN14@stbi__pars
$LN13@stbi__pars:

; 4810 :                   if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	lea	edx, DWORD PTR _tc$[ebp]
	push	edx
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_stbi__compute_transparency
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@stbi__pars
	xor	eax, eax
	jmp	$LN92@stbi__pars
$LN14@stbi__pars:

; 4811 :                }
; 4812 :             }
; 4813 :             if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)

	cmp	DWORD PTR _is_iphone$[ebp], 0
	je	SHORT $LN9@stbi__pars
	cmp	DWORD PTR _stbi__de_iphone_flag, 0
	je	SHORT $LN9@stbi__pars
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+12], 2
	jle	SHORT $LN9@stbi__pars

; 4814 :                stbi__de_iphone(z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_stbi__de_iphone
	add	esp, 4
$LN9@stbi__pars:

; 4815 :             if (pal_img_n) {

	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	test	eax, eax
	je	SHORT $LN8@stbi__pars

; 4816 :                // pal_img_n == 3 or 4
; 4817 :                s->img_n = pal_img_n; // record the actual colors we had

	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 4818 :                s->img_out_n = pal_img_n;

	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 4819 :                if (req_comp >= 3) s->img_out_n = req_comp;

	cmp	DWORD PTR _req_comp$[ebp], 3
	jl	SHORT $LN7@stbi__pars
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN7@stbi__pars:

; 4820 :                if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _pal_len$[ebp]
	push	edx
	lea	eax, DWORD PTR _palette$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	push	ecx
	call	_stbi__expand_png_palette
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN6@stbi__pars

; 4821 :                   return 0;

	xor	eax, eax
	jmp	$LN92@stbi__pars
$LN6@stbi__pars:

; 4822 :             } else if (has_trans) {

	jmp	SHORT $LN5@stbi__pars
$LN8@stbi__pars:
	movzx	eax, BYTE PTR _has_trans$[ebp]
	test	eax, eax
	je	SHORT $LN5@stbi__pars

; 4823 :                // non-paletted image with tRNS -> source image has (constant) alpha
; 4824 :                ++s->img_n;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN5@stbi__pars:

; 4825 :             }
; 4826 :             STBI_FREE(z->expanded); z->expanded = NULL;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_free
	add	esp, 4
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+8], 0

; 4827 :             return 1;

	mov	eax, 1
	jmp	$LN92@stbi__pars
$LN3@stbi__pars:

; 4828 :          }
; 4829 : 
; 4830 :          default:
; 4831 :             // if critical, fail
; 4832 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	cmp	DWORD PTR _first$[ebp], 0
	je	SHORT $LN2@stbi__pars
	push	OFFSET ??_C@_0P@JEAFOMAF@first?5not?5IHDR?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN92@stbi__pars
$LN2@stbi__pars:

; 4833 :             if ((c.type & (1 << 29)) == 0) {

	mov	eax, DWORD PTR _c$7[ebp+4]
	and	eax, 536870912				; 20000000H
	jne	SHORT $LN1@stbi__pars

; 4834 :                #ifndef STBI_NO_FAILURE_STRINGS
; 4835 :                // not threadsafe
; 4836 :                static char invalid_chunk[] = "XXXX PNG chunk not known";
; 4837 :                invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);

	mov	eax, DWORD PTR _c$7[ebp+4]
	shr	eax, 24					; 00000018H
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR ?invalid_chunk@?BO@??stbi__parse_png_file@@9@9[edx], al

; 4838 :                invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);

	mov	eax, DWORD PTR _c$7[ebp+4]
	shr	eax, 16					; 00000010H
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR ?invalid_chunk@?BO@??stbi__parse_png_file@@9@9[ecx], al

; 4839 :                invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);

	mov	eax, DWORD PTR _c$7[ebp+4]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	shl	ecx, 1
	mov	BYTE PTR ?invalid_chunk@?BO@??stbi__parse_png_file@@9@9[ecx], al

; 4840 :                invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);

	mov	eax, DWORD PTR _c$7[ebp+4]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR ?invalid_chunk@?BO@??stbi__parse_png_file@@9@9[edx], al

; 4841 :                #endif
; 4842 :                return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");

	push	OFFSET ?invalid_chunk@?BO@??stbi__parse_png_file@@9@9
	call	_stbi__err
	add	esp, 4
	jmp	SHORT $LN92@stbi__pars
$LN1@stbi__pars:

; 4843 :             }
; 4844 :             stbi__skip(s, c.length);

	mov	eax, DWORD PTR _c$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__skip
	add	esp, 8
$LN86@stbi__pars:

; 4845 :             break;
; 4846 :       }
; 4847 :       // end of PNG chunk, read and skip CRC
; 4848 :       stbi__get32be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32be
	add	esp, 4

; 4849 :    }

	jmp	$LN89@stbi__pars
$LN92@stbi__pars:

; 4850 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN109@stbi__pars
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1496				; 000005d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN109@stbi__pars:
	DD	5
	DD	$LN108@stbi__pars
$LN108@stbi__pars:
	DD	-1032					; fffffbf8H
	DD	1024					; 00000400H
	DD	$LN103@stbi__pars
	DD	-1068					; fffffbd4H
	DD	3
	DD	$LN104@stbi__pars
	DD	-1084					; fffffbc4H
	DD	6
	DD	$LN105@stbi__pars
	DD	-1220					; fffffb3cH
	DD	8
	DD	$LN106@stbi__pars
	DD	-1280					; fffffb00H
	DD	4
	DD	$LN107@stbi__pars
$LN107@stbi__pars:
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN106@stbi__pars:
	DB	99					; 00000063H
	DB	0
$LN105@stbi__pars:
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	0
$LN104@stbi__pars:
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	0
$LN103@stbi__pars:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
_stbi__parse_png_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__de_iphone
_TEXT	SEGMENT
_t$1 = -101						; size = 1
_half$2 = -89						; size = 1
_t$3 = -77						; size = 1
_a$4 = -65						; size = 1
_t$5 = -53						; size = 1
_p$ = -44						; size = 4
_pixel_count$ = -32					; size = 4
_i$ = -20						; size = 4
_s$ = -8						; size = 4
_z$ = 8							; size = 4
_stbi__de_iphone PROC					; COMDAT

; 4636 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4637 :    stbi__context *s = z->s;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$[ebp], ecx

; 4638 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax]
	imul	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pixel_count$[ebp], edx

; 4639 :    stbi_uc *p = z->out;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _p$[ebp], ecx

; 4640 : 
; 4641 :    if (s->img_out_n == 3) {  // convert bgr to rgb

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+12], 3
	jne	SHORT $LN15@stbi__de_i

; 4642 :       for (i=0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@stbi__de_i
$LN13@stbi__de_i:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN14@stbi__de_i:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	SHORT $LN12@stbi__de_i

; 4643 :          stbi_uc t = p[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _t$5[ebp], al

; 4644 :          p[0] = p[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al

; 4645 :          p[2] = t;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR _t$5[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 4646 :          p += 3;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 3
	mov	DWORD PTR _p$[ebp], eax

; 4647 :       }

	jmp	SHORT $LN13@stbi__de_i
$LN12@stbi__de_i:

; 4648 :    } else {

	jmp	$LN16@stbi__de_i
$LN15@stbi__de_i:

; 4649 :       STBI_ASSERT(s->img_out_n == 4);

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+12], 4
	je	SHORT $LN18@stbi__de_i
	mov	ecx, DWORD PTR ?__LINE__Var@?1??stbi__de_iphone@@9@9@e7b221e1
	add	ecx, 13					; 0000000dH
	push	ecx
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN18@stbi__de_i:

; 4650 :       if (stbi__unpremultiply_on_load) {

	cmp	DWORD PTR _stbi__unpremultiply_on_load, 0
	je	$LN10@stbi__de_i

; 4651 :          // convert bgr to rgb and unpremultiply
; 4652 :          for (i=0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@stbi__de_i
$LN8@stbi__de_i:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@stbi__de_i:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	$LN7@stbi__de_i

; 4653 :             stbi_uc a = p[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _a$4[ebp], al

; 4654 :             stbi_uc t = p[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _t$3[ebp], al

; 4655 :             if (a) {

	movzx	eax, BYTE PTR _a$4[ebp]
	test	eax, eax
	je	$LN6@stbi__de_i

; 4656 :                stbi_uc half = a / 2;

	movzx	eax, BYTE PTR _a$4[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	BYTE PTR _half$2[ebp], al

; 4657 :                p[0] = (p[2] * 255 + half) / a;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	imul	eax, edx, 255
	movzx	ecx, BYTE PTR _half$2[ebp]
	add	eax, ecx
	movzx	ecx, BYTE PTR _a$4[ebp]
	cdq
	idiv	ecx
	mov	edx, 1
	imul	ecx, edx, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 4658 :                p[1] = (p[1] * 255 + half) / a;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	imul	eax, edx, 255
	movzx	ecx, BYTE PTR _half$2[ebp]
	add	eax, ecx
	movzx	ecx, BYTE PTR _a$4[ebp]
	cdq
	idiv	ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 4659 :                p[2] = ( t   * 255 + half) / a;

	movzx	eax, BYTE PTR _t$3[ebp]
	imul	eax, eax, 255
	movzx	ecx, BYTE PTR _half$2[ebp]
	add	eax, ecx
	movzx	ecx, BYTE PTR _a$4[ebp]
	cdq
	idiv	ecx
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 4660 :             } else {

	jmp	SHORT $LN5@stbi__de_i
$LN6@stbi__de_i:

; 4661 :                p[0] = p[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al

; 4662 :                p[2] = t;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR _t$3[ebp]
	mov	BYTE PTR [ecx+eax], dl
$LN5@stbi__de_i:

; 4663 :             }
; 4664 :             p += 4;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 4665 :          }

	jmp	$LN8@stbi__de_i
$LN7@stbi__de_i:

; 4666 :       } else {

	jmp	SHORT $LN16@stbi__de_i
$LN10@stbi__de_i:

; 4667 :          // convert bgr to rgb
; 4668 :          for (i=0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@stbi__de_i
$LN2@stbi__de_i:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@stbi__de_i:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	SHORT $LN16@stbi__de_i

; 4669 :             stbi_uc t = p[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _t$1[ebp], al

; 4670 :             p[0] = p[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al

; 4671 :             p[2] = t;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR _t$1[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 4672 :             p += 4;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 4673 :          }

	jmp	SHORT $LN2@stbi__de_i
$LN16@stbi__de_i:

; 4674 :       }
; 4675 :    }
; 4676 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__de_iphone ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__expand_png_palette
_TEXT	SEGMENT
_n$1 = -80						; size = 4
_n$2 = -68						; size = 4
_orig$ = -56						; size = 4
_temp_out$ = -44					; size = 4
_p$ = -32						; size = 4
_pixel_count$ = -20					; size = 4
_i$ = -8						; size = 4
_a$ = 8							; size = 4
_palette$ = 12						; size = 4
_len$ = 16						; size = 4
_pal_img_n$ = 20					; size = 4
_stbi__expand_png_palette PROC				; COMDAT

; 4586 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4587 :    stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	imul	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pixel_count$[ebp], ecx

; 4588 :    stbi_uc *p, *temp_out, *orig = a->out;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _orig$[ebp], ecx

; 4589 : 
; 4590 :    p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);

	push	0
	mov	eax, DWORD PTR _pal_img_n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pixel_count$[ebp]
	push	ecx
	call	_stbi__malloc_mad2
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _p$[ebp], eax

; 4591 :    if (p == NULL) return stbi__err("outofmem", "Out of memory");

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN9@stbi__expa
	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN10@stbi__expa
$LN9@stbi__expa:

; 4592 : 
; 4593 :    // between here and free(out) below, exitting would leak
; 4594 :    temp_out = p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _temp_out$[ebp], eax

; 4595 : 
; 4596 :    if (pal_img_n == 3) {

	cmp	DWORD PTR _pal_img_n$[ebp], 3
	jne	SHORT $LN8@stbi__expa

; 4597 :       for (i=0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@stbi__expa
$LN6@stbi__expa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@stbi__expa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	SHORT $LN5@stbi__expa

; 4598 :          int n = orig[i]*4;

	mov	eax, DWORD PTR _orig$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 2
	mov	DWORD PTR _n$2[ebp], ecx

; 4599 :          p[0] = palette[n  ];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _palette$[ebp]
	add	edx, DWORD PTR _n$2[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR [eax+ecx], dl

; 4600 :          p[1] = palette[n+1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _palette$[ebp]
	add	ecx, DWORD PTR _n$2[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [ecx+1]
	mov	BYTE PTR [edx+eax], cl

; 4601 :          p[2] = palette[n+2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _palette$[ebp]
	add	ecx, DWORD PTR _n$2[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [ecx+2]
	mov	BYTE PTR [edx+eax], cl

; 4602 :          p += 3;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 3
	mov	DWORD PTR _p$[ebp], eax

; 4603 :       }

	jmp	SHORT $LN6@stbi__expa
$LN5@stbi__expa:

; 4604 :    } else {

	jmp	$LN4@stbi__expa
$LN8@stbi__expa:

; 4605 :       for (i=0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@stbi__expa
$LN2@stbi__expa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@stbi__expa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	SHORT $LN4@stbi__expa

; 4606 :          int n = orig[i]*4;

	mov	eax, DWORD PTR _orig$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 2
	mov	DWORD PTR _n$1[ebp], ecx

; 4607 :          p[0] = palette[n  ];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _palette$[ebp]
	add	edx, DWORD PTR _n$1[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR [eax+ecx], dl

; 4608 :          p[1] = palette[n+1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _palette$[ebp]
	add	ecx, DWORD PTR _n$1[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [ecx+1]
	mov	BYTE PTR [edx+eax], cl

; 4609 :          p[2] = palette[n+2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _palette$[ebp]
	add	ecx, DWORD PTR _n$1[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [ecx+2]
	mov	BYTE PTR [edx+eax], cl

; 4610 :          p[3] = palette[n+3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _palette$[ebp]
	add	edx, DWORD PTR _n$1[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [edx+3]
	mov	BYTE PTR [eax+ecx], dl

; 4611 :          p += 4;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 4612 :       }

	jmp	$LN2@stbi__expa
$LN4@stbi__expa:

; 4613 :    }
; 4614 :    STBI_FREE(a->out);

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_free
	add	esp, 4

; 4615 :    a->out = temp_out;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _temp_out$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 4616 : 
; 4617 :    STBI_NOTUSED(len);
; 4618 : 
; 4619 :    return 1;

	mov	eax, 1
$LN10@stbi__expa:

; 4620 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__expand_png_palette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__compute_transparency16
_TEXT	SEGMENT
tv88 = -244						; size = 4
_p$ = -44						; size = 4
_pixel_count$ = -32					; size = 4
_i$ = -20						; size = 4
_s$ = -8						; size = 4
_z$ = 8							; size = 4
_tc$ = 12						; size = 4
_out_n$ = 16						; size = 4
_stbi__compute_transparency16 PROC			; COMDAT

; 4561 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4562 :    stbi__context *s = z->s;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$[ebp], ecx

; 4563 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax]
	imul	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pixel_count$[ebp], edx

; 4564 :    stbi__uint16 *p = (stbi__uint16*) z->out;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _p$[ebp], ecx

; 4565 : 
; 4566 :    // compute color-based transparency, assuming we've
; 4567 :    // already got 65535 as the alpha value in the output
; 4568 :    STBI_ASSERT(out_n == 2 || out_n == 4);

	cmp	DWORD PTR _out_n$[ebp], 2
	je	SHORT $LN12@stbi__comp
	cmp	DWORD PTR _out_n$[ebp], 4
	je	SHORT $LN12@stbi__comp
	mov	eax, DWORD PTR ?__LINE__Var@?1??stbi__compute_transparency16@@9@9@e7b221e1
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN12@stbi__comp:

; 4569 : 
; 4570 :    if (out_n == 2) {

	cmp	DWORD PTR _out_n$[ebp], 2
	jne	SHORT $LN9@stbi__comp

; 4571 :       for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@stbi__comp
$LN7@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	SHORT $LN6@stbi__comp

; 4572 :          p[1] = (p[0] == tc[0] ? 0 : 65535);

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	edx, WORD PTR [ecx+edx]
	cmp	eax, edx
	jne	SHORT $LN13@stbi__comp
	mov	DWORD PTR tv88[ebp], 0
	jmp	SHORT $LN14@stbi__comp
$LN13@stbi__comp:
	mov	DWORD PTR tv88[ebp], 65535		; 0000ffffH
$LN14@stbi__comp:
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dx, WORD PTR tv88[ebp]
	mov	WORD PTR [ecx+eax], dx

; 4573 :          p += 2;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 4574 :       }

	jmp	SHORT $LN7@stbi__comp
$LN6@stbi__comp:

; 4575 :    } else {

	jmp	$LN5@stbi__comp
$LN9@stbi__comp:

; 4576 :       for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__comp
$LN3@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	$LN5@stbi__comp

; 4577 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	edx, WORD PTR [ecx+edx]
	cmp	eax, edx
	jne	SHORT $LN1@stbi__comp
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	eax, WORD PTR [ecx+eax]
	cmp	edx, eax
	jne	SHORT $LN1@stbi__comp
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	eax, WORD PTR [ecx+eax]
	cmp	edx, eax
	jne	SHORT $LN1@stbi__comp

; 4578 :             p[3] = 0;

	mov	eax, 2
	imul	ecx, eax, 3
	xor	edx, edx
	mov	eax, DWORD PTR _p$[ebp]
	mov	WORD PTR [eax+ecx], dx
$LN1@stbi__comp:

; 4579 :          p += 4;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 8
	mov	DWORD PTR _p$[ebp], eax

; 4580 :       }

	jmp	$LN3@stbi__comp
$LN5@stbi__comp:

; 4581 :    }
; 4582 :    return 1;

	mov	eax, 1

; 4583 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__compute_transparency16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__compute_transparency
_TEXT	SEGMENT
tv88 = -244						; size = 4
_p$ = -44						; size = 4
_pixel_count$ = -32					; size = 4
_i$ = -20						; size = 4
_s$ = -8						; size = 4
_z$ = 8							; size = 4
_tc$ = 12						; size = 4
_out_n$ = 16						; size = 4
_stbi__compute_transparency PROC			; COMDAT

; 4536 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4537 :    stbi__context *s = z->s;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$[ebp], ecx

; 4538 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax]
	imul	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pixel_count$[ebp], edx

; 4539 :    stbi_uc *p = z->out;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _p$[ebp], ecx

; 4540 : 
; 4541 :    // compute color-based transparency, assuming we've
; 4542 :    // already got 255 as the alpha value in the output
; 4543 :    STBI_ASSERT(out_n == 2 || out_n == 4);

	cmp	DWORD PTR _out_n$[ebp], 2
	je	SHORT $LN12@stbi__comp
	cmp	DWORD PTR _out_n$[ebp], 4
	je	SHORT $LN12@stbi__comp
	mov	eax, DWORD PTR ?__LINE__Var@?1??stbi__compute_transparency@@9@9@e7b221e1
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN12@stbi__comp:

; 4544 : 
; 4545 :    if (out_n == 2) {

	cmp	DWORD PTR _out_n$[ebp], 2
	jne	SHORT $LN9@stbi__comp

; 4546 :       for (i=0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@stbi__comp
$LN7@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	SHORT $LN6@stbi__comp

; 4547 :          p[1] = (p[0] == tc[0] ? 0 : 255);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	eax, edx
	jne	SHORT $LN13@stbi__comp
	mov	DWORD PTR tv88[ebp], 0
	jmp	SHORT $LN14@stbi__comp
$LN13@stbi__comp:
	mov	DWORD PTR tv88[ebp], 255		; 000000ffH
$LN14@stbi__comp:
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR tv88[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 4548 :          p += 2;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 2
	mov	DWORD PTR _p$[ebp], eax

; 4549 :       }

	jmp	SHORT $LN7@stbi__comp
$LN6@stbi__comp:

; 4550 :    } else {

	jmp	$LN5@stbi__comp
$LN9@stbi__comp:

; 4551 :       for (i=0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__comp
$LN3@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	$LN5@stbi__comp

; 4552 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	eax, edx
	jne	SHORT $LN1@stbi__comp
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	cmp	edx, eax
	jne	SHORT $LN1@stbi__comp
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	cmp	edx, eax
	jne	SHORT $LN1@stbi__comp

; 4553 :             p[3] = 0;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN1@stbi__comp:

; 4554 :          p += 4;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 4555 :       }

	jmp	$LN3@stbi__comp
$LN5@stbi__comp:

; 4556 :    }
; 4557 :    return 1;

	mov	eax, 1

; 4558 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__compute_transparency ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__create_png_image
_TEXT	SEGMENT
tv65 = -476						; size = 4
_out_x$1 = -276						; size = 4
_out_y$2 = -264						; size = 4
_img_len$3 = -252					; size = 4
_y$4 = -240						; size = 4
_x$5 = -228						; size = 4
_j$6 = -216						; size = 4
_i$7 = -204						; size = 4
_yspc$8 = -192						; size = 28
_xspc$9 = -156						; size = 28
_yorig$10 = -120					; size = 28
_xorig$11 = -84						; size = 28
_p$ = -48						; size = 4
_final$ = -36						; size = 4
_out_bytes$ = -24					; size = 4
_bytes$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_image_data$ = 12					; size = 4
_image_data_len$ = 16					; size = 4
_out_n$ = 20						; size = 4
_depth$ = 24						; size = 4
_color$ = 28						; size = 4
_interlaced$ = 32					; size = 4
_stbi__create_png_image PROC				; COMDAT

; 4492 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 476				; 000001dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-476]
	mov	ecx, 119				; 00000077H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4493 :    int bytes = (depth == 16 ? 2 : 1);

	cmp	DWORD PTR _depth$[ebp], 16		; 00000010H
	jne	SHORT $LN15@stbi__crea
	mov	DWORD PTR tv65[ebp], 2
	jmp	SHORT $LN16@stbi__crea
$LN15@stbi__crea:
	mov	DWORD PTR tv65[ebp], 1
$LN16@stbi__crea:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _bytes$[ebp], eax

; 4494 :    int out_bytes = out_n * bytes;

	mov	eax, DWORD PTR _out_n$[ebp]
	imul	eax, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _out_bytes$[ebp], eax

; 4495 :    stbi_uc *final;
; 4496 :    int p;
; 4497 :    if (!interlaced)

	cmp	DWORD PTR _interlaced$[ebp], 0
	jne	SHORT $LN12@stbi__crea

; 4498 :       return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _depth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _out_n$[ebp]
	push	edx
	mov	eax, DWORD PTR _image_data_len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _image_data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	call	_stbi__create_png_image_raw
	add	esp, 32					; 00000020H
	jmp	$LN13@stbi__crea
$LN12@stbi__crea:

; 4499 : 
; 4500 :    // de-interlacing
; 4501 :    final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);

	push	0
	mov	eax, DWORD PTR _out_bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	DWORD PTR _final$[ebp], eax

; 4502 :    for (p=0; p < 7; ++p) {

	mov	DWORD PTR _p$[ebp], 0
	jmp	SHORT $LN11@stbi__crea
$LN10@stbi__crea:
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax
$LN11@stbi__crea:
	cmp	DWORD PTR _p$[ebp], 7
	jge	$LN9@stbi__crea

; 4503 :       int xorig[] = { 0,4,0,2,0,1,0 };

	mov	DWORD PTR _xorig$11[ebp], 0
	mov	DWORD PTR _xorig$11[ebp+4], 4
	mov	DWORD PTR _xorig$11[ebp+8], 0
	mov	DWORD PTR _xorig$11[ebp+12], 2
	mov	DWORD PTR _xorig$11[ebp+16], 0
	mov	DWORD PTR _xorig$11[ebp+20], 1
	mov	DWORD PTR _xorig$11[ebp+24], 0

; 4504 :       int yorig[] = { 0,0,4,0,2,0,1 };

	mov	DWORD PTR _yorig$10[ebp], 0
	mov	DWORD PTR _yorig$10[ebp+4], 0
	mov	DWORD PTR _yorig$10[ebp+8], 4
	mov	DWORD PTR _yorig$10[ebp+12], 0
	mov	DWORD PTR _yorig$10[ebp+16], 2
	mov	DWORD PTR _yorig$10[ebp+20], 0
	mov	DWORD PTR _yorig$10[ebp+24], 1

; 4505 :       int xspc[]  = { 8,8,4,4,2,2,1 };

	mov	DWORD PTR _xspc$9[ebp], 8
	mov	DWORD PTR _xspc$9[ebp+4], 8
	mov	DWORD PTR _xspc$9[ebp+8], 4
	mov	DWORD PTR _xspc$9[ebp+12], 4
	mov	DWORD PTR _xspc$9[ebp+16], 2
	mov	DWORD PTR _xspc$9[ebp+20], 2
	mov	DWORD PTR _xspc$9[ebp+24], 1

; 4506 :       int yspc[]  = { 8,8,8,4,4,2,2 };

	mov	DWORD PTR _yspc$8[ebp], 8
	mov	DWORD PTR _yspc$8[ebp+4], 8
	mov	DWORD PTR _yspc$8[ebp+8], 8
	mov	DWORD PTR _yspc$8[ebp+12], 4
	mov	DWORD PTR _yspc$8[ebp+16], 4
	mov	DWORD PTR _yspc$8[ebp+20], 2
	mov	DWORD PTR _yspc$8[ebp+24], 2

; 4507 :       int i,j,x,y;
; 4508 :       // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4509 :       x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR _xorig$11[ebp+edx*4]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _xspc$9[ebp+ecx*4]
	lea	eax, DWORD PTR [eax+edx-1]
	mov	ecx, DWORD PTR _p$[ebp]
	xor	edx, edx
	div	DWORD PTR _xspc$9[ebp+ecx*4]
	mov	DWORD PTR _x$5[ebp], eax

; 4510 :       y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR _yorig$10[ebp+edx*4]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _yspc$8[ebp+ecx*4]
	lea	eax, DWORD PTR [eax+edx-1]
	mov	ecx, DWORD PTR _p$[ebp]
	xor	edx, edx
	div	DWORD PTR _yspc$8[ebp+ecx*4]
	mov	DWORD PTR _y$4[ebp], eax

; 4511 :       if (x && y) {

	cmp	DWORD PTR _x$5[ebp], 0
	je	$LN8@stbi__crea
	cmp	DWORD PTR _y$4[ebp], 0
	je	$LN8@stbi__crea

; 4512 :          stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	imul	edx, DWORD PTR _x$5[ebp]
	imul	edx, DWORD PTR _depth$[ebp]
	add	edx, 7
	sar	edx, 3
	add	edx, 1
	imul	edx, DWORD PTR _y$4[ebp]
	mov	DWORD PTR _img_len$3[ebp], edx

; 4513 :          if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _depth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$4[ebp]
	push	edx
	mov	eax, DWORD PTR _x$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _out_n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image_data_len$[ebp]
	push	edx
	mov	eax, DWORD PTR _image_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_stbi__create_png_image_raw
	add	esp, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN7@stbi__crea

; 4514 :             STBI_FREE(final);

	mov	eax, DWORD PTR _final$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 4515 :             return 0;

	xor	eax, eax
	jmp	$LN13@stbi__crea
$LN7@stbi__crea:

; 4516 :          }
; 4517 :          for (j=0; j < y; ++j) {

	mov	DWORD PTR _j$6[ebp], 0
	jmp	SHORT $LN6@stbi__crea
$LN5@stbi__crea:
	mov	eax, DWORD PTR _j$6[ebp]
	add	eax, 1
	mov	DWORD PTR _j$6[ebp], eax
$LN6@stbi__crea:
	mov	eax, DWORD PTR _j$6[ebp]
	cmp	eax, DWORD PTR _y$4[ebp]
	jge	$LN4@stbi__crea

; 4518 :             for (i=0; i < x; ++i) {

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN3@stbi__crea
$LN2@stbi__crea:
	mov	eax, DWORD PTR _i$7[ebp]
	add	eax, 1
	mov	DWORD PTR _i$7[ebp], eax
$LN3@stbi__crea:
	mov	eax, DWORD PTR _i$7[ebp]
	cmp	eax, DWORD PTR _x$5[ebp]
	jge	$LN1@stbi__crea

; 4519 :                int out_y = j*yspc[p]+yorig[p];

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _j$6[ebp]
	imul	ecx, DWORD PTR _yspc$8[ebp+eax*4]
	mov	edx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _yorig$10[ebp+edx*4]
	mov	DWORD PTR _out_y$2[ebp], ecx

; 4520 :                int out_x = i*xspc[p]+xorig[p];

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _i$7[ebp]
	imul	ecx, DWORD PTR _xspc$9[ebp+eax*4]
	mov	edx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _xorig$11[ebp+edx*4]
	mov	DWORD PTR _out_x$1[ebp], ecx

; 4521 :                memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
; 4522 :                       a->out + (j*x+i)*out_bytes, out_bytes);

	mov	eax, DWORD PTR _out_bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$6[ebp]
	imul	ecx, DWORD PTR _x$5[ebp]
	add	ecx, DWORD PTR _i$7[ebp]
	imul	ecx, DWORD PTR _out_bytes$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	add	ecx, DWORD PTR [edx+12]
	push	ecx
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _out_y$2[ebp]
	imul	edx, DWORD PTR [ecx]
	imul	edx, DWORD PTR _out_bytes$[ebp]
	add	edx, DWORD PTR _final$[ebp]
	mov	eax, DWORD PTR _out_x$1[ebp]
	imul	eax, DWORD PTR _out_bytes$[ebp]
	add	edx, eax
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4523 :             }

	jmp	$LN2@stbi__crea
$LN1@stbi__crea:

; 4524 :          }

	jmp	$LN5@stbi__crea
$LN4@stbi__crea:

; 4525 :          STBI_FREE(a->out);

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_free
	add	esp, 4

; 4526 :          image_data += img_len;

	mov	eax, DWORD PTR _image_data$[ebp]
	add	eax, DWORD PTR _img_len$3[ebp]
	mov	DWORD PTR _image_data$[ebp], eax

; 4527 :          image_data_len -= img_len;

	mov	eax, DWORD PTR _image_data_len$[ebp]
	sub	eax, DWORD PTR _img_len$3[ebp]
	mov	DWORD PTR _image_data_len$[ebp], eax
$LN8@stbi__crea:

; 4528 :       }
; 4529 :    }

	jmp	$LN10@stbi__crea
$LN9@stbi__crea:

; 4530 :    a->out = final;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _final$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 4531 : 
; 4532 :    return 1;

	mov	eax, 1
$LN13@stbi__crea:

; 4533 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@stbi__crea
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 476				; 000001dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN22@stbi__crea:
	DD	4
	DD	$LN21@stbi__crea
$LN21@stbi__crea:
	DD	-84					; ffffffacH
	DD	28					; 0000001cH
	DD	$LN17@stbi__crea
	DD	-120					; ffffff88H
	DD	28					; 0000001cH
	DD	$LN18@stbi__crea
	DD	-156					; ffffff64H
	DD	28					; 0000001cH
	DD	$LN19@stbi__crea
	DD	-192					; ffffff40H
	DD	28					; 0000001cH
	DD	$LN20@stbi__crea
$LN20@stbi__crea:
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	99					; 00000063H
	DB	0
$LN19@stbi__crea:
	DB	120					; 00000078H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	99					; 00000063H
	DB	0
$LN18@stbi__crea:
	DB	121					; 00000079H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	0
$LN17@stbi__crea:
	DB	120					; 00000078H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	0
_stbi__create_png_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__create_png_image_raw
_TEXT	SEGMENT
tv551 = -460						; size = 4
tv357 = -460						; size = 4
tv240 = -460						; size = 4
tv160 = -460						; size = 4
tv65 = -460						; size = 4
_cur16$1 = -260						; size = 4
_cur$2 = -248						; size = 4
_q$3 = -236						; size = 4
_scale$4 = -221						; size = 1
_in$5 = -212						; size = 4
_cur$6 = -200						; size = 4
_nk$7 = -188						; size = 4
_filter$8 = -176					; size = 4
_prior$9 = -164						; size = 4
_cur$10 = -152						; size = 4
_width$ = -140						; size = 4
_filter_bytes$ = -128					; size = 4
_output_bytes$ = -116					; size = 4
_img_n$ = -104						; size = 4
_k$ = -92						; size = 4
_img_width_bytes$ = -80					; size = 4
_img_len$ = -68						; size = 4
_stride$ = -56						; size = 4
_j$ = -44						; size = 4
_i$ = -32						; size = 4
_s$ = -20						; size = 4
_bytes$ = -8						; size = 4
_a$ = 8							; size = 4
_raw$ = 12						; size = 4
_raw_len$ = 16						; size = 4
_out_n$ = 20						; size = 4
_x$ = 24						; size = 4
_y$ = 28						; size = 4
_depth$ = 32						; size = 4
_color$ = 36						; size = 4
_stbi__create_png_image_raw PROC			; COMDAT

; 4282 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 460				; 000001ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-460]
	mov	ecx, 115				; 00000073H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4283 :    int bytes = (depth == 16? 2 : 1);

	cmp	DWORD PTR _depth$[ebp], 16		; 00000010H
	jne	SHORT $LN157@stbi__crea
	mov	DWORD PTR tv65[ebp], 2
	jmp	SHORT $LN158@stbi__crea
$LN157@stbi__crea:
	mov	DWORD PTR tv65[ebp], 1
$LN158@stbi__crea:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _bytes$[ebp], eax

; 4284 :    stbi__context *s = a->s;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$[ebp], ecx

; 4285 :    stbi__uint32 i,j,stride = x*out_n*bytes;

	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _out_n$[ebp]
	imul	eax, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _stride$[ebp], eax

; 4286 :    stbi__uint32 img_len, img_width_bytes;
; 4287 :    int k;
; 4288 :    int img_n = s->img_n; // copy it into a local for later

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _img_n$[ebp], ecx

; 4289 : 
; 4290 :    int output_bytes = out_n*bytes;

	mov	eax, DWORD PTR _out_n$[ebp]
	imul	eax, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _output_bytes$[ebp], eax

; 4291 :    int filter_bytes = img_n*bytes;

	mov	eax, DWORD PTR _img_n$[ebp]
	imul	eax, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _filter_bytes$[ebp], eax

; 4292 :    int width = x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _width$[ebp], eax

; 4293 : 
; 4294 :    STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _out_n$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN159@stbi__crea
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	cmp	DWORD PTR _out_n$[ebp], eax
	je	SHORT $LN159@stbi__crea
	mov	ecx, DWORD PTR ?__LINE__Var@?1??stbi__create_png_image_raw@@9@9@e7b221e1
	add	ecx, 12					; 0000000cH
	push	ecx
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1FC@ICDHLHK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN159@stbi__crea:

; 4295 :    a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into

	push	0
	mov	eax, DWORD PTR _output_bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 4296 :    if (!a->out) return stbi__err("outofmem", "Out of memory");

	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN154@stbi__crea
	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN155@stbi__crea
$LN154@stbi__crea:

; 4297 : 
; 4298 :    img_width_bytes = (((img_n * x * depth) + 7) >> 3);

	mov	eax, DWORD PTR _img_n$[ebp]
	imul	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	add	eax, 7
	shr	eax, 3
	mov	DWORD PTR _img_width_bytes$[ebp], eax

; 4299 :    img_len = (img_width_bytes + 1) * y;

	mov	eax, DWORD PTR _img_width_bytes$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _img_len$[ebp], eax

; 4300 :    // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4301 :    // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4302 :    // so just check for raw_len < img_len always.
; 4303 :    if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");

	mov	eax, DWORD PTR _raw_len$[ebp]
	cmp	eax, DWORD PTR _img_len$[ebp]
	jae	SHORT $LN153@stbi__crea
	push	OFFSET ??_C@_0BC@BHMPBBMG@not?5enough?5pixels?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN155@stbi__crea
$LN153@stbi__crea:

; 4304 : 
; 4305 :    for (j=0; j < y; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN152@stbi__crea
$LN151@stbi__crea:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN152@stbi__crea:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _y$[ebp]
	jae	$LN150@stbi__crea

; 4306 :       stbi_uc *cur = a->out + stride*j;

	mov	eax, DWORD PTR _stride$[ebp]
	imul	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$10[ebp], eax

; 4307 :       stbi_uc *prior;
; 4308 :       int filter = *raw++;

	mov	eax, DWORD PTR _raw$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _filter$8[ebp], ecx
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, 1
	mov	DWORD PTR _raw$[ebp], edx

; 4309 : 
; 4310 :       if (filter > 4)

	cmp	DWORD PTR _filter$8[ebp], 4
	jle	SHORT $LN149@stbi__crea

; 4311 :          return stbi__err("invalid filter","Corrupt PNG");

	push	OFFSET ??_C@_0P@FBBCPGMN@invalid?5filter?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN155@stbi__crea
$LN149@stbi__crea:

; 4312 : 
; 4313 :       if (depth < 8) {

	cmp	DWORD PTR _depth$[ebp], 8
	jge	SHORT $LN148@stbi__crea

; 4314 :          STBI_ASSERT(img_width_bytes <= x);

	mov	eax, DWORD PTR _img_width_bytes$[ebp]
	cmp	eax, DWORD PTR _x$[ebp]
	jbe	SHORT $LN160@stbi__crea
	mov	ecx, DWORD PTR ?__LINE__Var@?1??stbi__create_png_image_raw@@9@9@e7b221e1
	add	ecx, 32					; 00000020H
	push	ecx
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1CK@EJKIMPDL@?$AAi?$AAm?$AAg?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA_?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN160@stbi__crea:

; 4315 :          cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place

	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _out_n$[ebp]
	sub	eax, DWORD PTR _img_width_bytes$[ebp]
	add	eax, DWORD PTR _cur$10[ebp]
	mov	DWORD PTR _cur$10[ebp], eax

; 4316 :          filter_bytes = 1;

	mov	DWORD PTR _filter_bytes$[ebp], 1

; 4317 :          width = img_width_bytes;

	mov	eax, DWORD PTR _img_width_bytes$[ebp]
	mov	DWORD PTR _width$[ebp], eax
$LN148@stbi__crea:

; 4318 :       }
; 4319 :       prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above

	mov	eax, DWORD PTR _cur$10[ebp]
	sub	eax, DWORD PTR _stride$[ebp]
	mov	DWORD PTR _prior$9[ebp], eax

; 4320 : 
; 4321 :       // if first row, use special filter that doesn't sample previous row
; 4322 :       if (j == 0) filter = first_row_filter[filter];

	cmp	DWORD PTR _j$[ebp], 0
	jne	SHORT $LN147@stbi__crea
	mov	eax, DWORD PTR _filter$8[ebp]
	movzx	ecx, BYTE PTR _first_row_filter[eax]
	mov	DWORD PTR _filter$8[ebp], ecx
$LN147@stbi__crea:

; 4323 : 
; 4324 :       // handle first byte explicitly
; 4325 :       for (k=0; k < filter_bytes; ++k) {

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN146@stbi__crea
$LN145@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN146@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	$LN144@stbi__crea

; 4326 :          switch (filter) {

	mov	eax, DWORD PTR _filter$8[ebp]
	mov	DWORD PTR tv160[ebp], eax
	cmp	DWORD PTR tv160[ebp], 6
	ja	$LN142@stbi__crea
	mov	ecx, DWORD PTR tv160[ebp]
	jmp	DWORD PTR $LN165@stbi__crea[ecx*4]
$LN141@stbi__crea:

; 4327 :             case STBI__F_none       : cur[k] = raw[k]; break;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _raw$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	jmp	$LN142@stbi__crea
$LN140@stbi__crea:

; 4328 :             case STBI__F_sub        : cur[k] = raw[k]; break;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _raw$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	jmp	$LN142@stbi__crea
$LN139@stbi__crea:

; 4329 :             case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;

	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _prior$9[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [edx]
	add	ecx, eax
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _cur$10[ebp]
	add	edx, DWORD PTR _k$[ebp]
	mov	BYTE PTR [edx], cl
	jmp	$LN142@stbi__crea
$LN138@stbi__crea:

; 4330 :             case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;

	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _prior$9[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [edx]
	sar	eax, 1
	add	ecx, eax
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _cur$10[ebp]
	add	edx, DWORD PTR _k$[ebp]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN142@stbi__crea
$LN137@stbi__crea:

; 4331 :             case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;

	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ebx, BYTE PTR [eax]
	push	0
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	push	0
	call	_stbi__paeth
	add	esp, 12					; 0000000cH
	add	ebx, eax
	and	ebx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], bl
	jmp	SHORT $LN142@stbi__crea
$LN136@stbi__crea:

; 4332 :             case STBI__F_avg_first  : cur[k] = raw[k]; break;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _raw$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN142@stbi__crea
$LN135@stbi__crea:

; 4333 :             case STBI__F_paeth_first: cur[k] = raw[k]; break;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _raw$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
$LN142@stbi__crea:

; 4334 :          }
; 4335 :       }

	jmp	$LN145@stbi__crea
$LN144@stbi__crea:

; 4336 : 
; 4337 :       if (depth == 8) {

	cmp	DWORD PTR _depth$[ebp], 8
	jne	SHORT $LN134@stbi__crea

; 4338 :          if (img_n != out_n)

	mov	eax, DWORD PTR _img_n$[ebp]
	cmp	eax, DWORD PTR _out_n$[ebp]
	je	SHORT $LN133@stbi__crea

; 4339 :             cur[img_n] = 255; // first pixel

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _img_n$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
$LN133@stbi__crea:

; 4340 :          raw += img_n;

	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _img_n$[ebp]
	mov	DWORD PTR _raw$[ebp], eax

; 4341 :          cur += out_n;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _out_n$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax

; 4342 :          prior += out_n;

	mov	eax, DWORD PTR _prior$9[ebp]
	add	eax, DWORD PTR _out_n$[ebp]
	mov	DWORD PTR _prior$9[ebp], eax
	jmp	SHORT $LN132@stbi__crea
$LN134@stbi__crea:

; 4343 :       } else if (depth == 16) {

	cmp	DWORD PTR _depth$[ebp], 16		; 00000010H
	jne	SHORT $LN131@stbi__crea

; 4344 :          if (img_n != out_n) {

	mov	eax, DWORD PTR _img_n$[ebp]
	cmp	eax, DWORD PTR _out_n$[ebp]
	je	SHORT $LN130@stbi__crea

; 4345 :             cur[filter_bytes]   = 255; // first pixel top byte

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH

; 4346 :             cur[filter_bytes+1] = 255; // first pixel bottom byte

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [eax+1], 255			; 000000ffH
$LN130@stbi__crea:

; 4347 :          }
; 4348 :          raw += filter_bytes;

	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], eax

; 4349 :          cur += output_bytes;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax

; 4350 :          prior += output_bytes;

	mov	eax, DWORD PTR _prior$9[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], eax

; 4351 :       } else {

	jmp	SHORT $LN132@stbi__crea
$LN131@stbi__crea:

; 4352 :          raw += 1;

	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, 1
	mov	DWORD PTR _raw$[ebp], eax

; 4353 :          cur += 1;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$10[ebp], eax

; 4354 :          prior += 1;

	mov	eax, DWORD PTR _prior$9[ebp]
	add	eax, 1
	mov	DWORD PTR _prior$9[ebp], eax
$LN132@stbi__crea:

; 4355 :       }
; 4356 : 
; 4357 :       // this is a little gross, so that we don't switch per-pixel or per-component
; 4358 :       if (depth < 8 || img_n == out_n) {

	cmp	DWORD PTR _depth$[ebp], 8
	jl	SHORT $LN127@stbi__crea
	mov	eax, DWORD PTR _img_n$[ebp]
	cmp	eax, DWORD PTR _out_n$[ebp]
	jne	$LN128@stbi__crea
$LN127@stbi__crea:

; 4359 :          int nk = (width - 1)*filter_bytes;

	mov	eax, DWORD PTR _width$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _nk$7[ebp], eax

; 4360 :          #define STBI__CASE(f) \
; 4361 :              case f:     \
; 4362 :                 for (k=0; k < nk; ++k)
; 4363 :          switch (filter) {

	mov	eax, DWORD PTR _filter$8[ebp]
	mov	DWORD PTR tv240[ebp], eax
	cmp	DWORD PTR tv240[ebp], 6
	ja	$LN125@stbi__crea
	mov	ecx, DWORD PTR tv240[ebp]
	jmp	DWORD PTR $LN166@stbi__crea[ecx*4]
$LN124@stbi__crea:

; 4364 :             // "none" filter turns into a memcpy here; make that explicit.
; 4365 :             case STBI__F_none:         memcpy(cur, raw, nk); break;

	mov	eax, DWORD PTR _nk$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _raw$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$10[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	$LN125@stbi__crea
$LN123@stbi__crea:

; 4366 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN122@stbi__crea
$LN121@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN122@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _nk$7[ebp]
	jge	SHORT $LN120@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, DWORD PTR _filter_bytes$[ebp]
	mov	eax, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	add	ecx, edx
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $LN121@stbi__crea
$LN120@stbi__crea:
	jmp	$LN125@stbi__crea
$LN119@stbi__crea:

; 4367 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN118@stbi__crea
$LN117@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN118@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _nk$7[ebp]
	jge	SHORT $LN116@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _prior$9[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [edx]
	add	ecx, eax
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _cur$10[ebp]
	add	edx, DWORD PTR _k$[ebp]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN117@stbi__crea
$LN116@stbi__crea:
	jmp	$LN125@stbi__crea
$LN115@stbi__crea:

; 4368 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN114@stbi__crea
$LN113@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN114@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _nk$7[ebp]
	jge	SHORT $LN112@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _prior$9[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, DWORD PTR _filter_bytes$[ebp]
	mov	esi, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [esi+edx]
	add	eax, edx
	sar	eax, 1
	add	ecx, eax
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $LN113@stbi__crea
$LN112@stbi__crea:
	jmp	$LN125@stbi__crea
$LN111@stbi__crea:

; 4369 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN110@stbi__crea
$LN109@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN110@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _nk$7[ebp]
	jge	SHORT $LN108@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ebx, BYTE PTR [eax]
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	edx, DWORD PTR _prior$9[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, DWORD PTR _filter_bytes$[ebp]
	mov	ecx, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	_stbi__paeth
	add	esp, 12					; 0000000cH
	add	ebx, eax
	and	ebx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], bl
	jmp	SHORT $LN109@stbi__crea
$LN108@stbi__crea:
	jmp	$LN125@stbi__crea
$LN107@stbi__crea:

; 4370 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN106@stbi__crea
$LN105@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN106@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _nk$7[ebp]
	jge	SHORT $LN104@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, DWORD PTR _filter_bytes$[ebp]
	mov	eax, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	sar	edx, 1
	add	ecx, edx
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $LN105@stbi__crea
$LN104@stbi__crea:
	jmp	SHORT $LN125@stbi__crea
$LN103@stbi__crea:

; 4371 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN102@stbi__crea
$LN101@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN102@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _nk$7[ebp]
	jge	SHORT $LN125@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ebx, BYTE PTR [eax]
	push	0
	push	0
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	edx, DWORD PTR _cur$10[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	_stbi__paeth
	add	esp, 12					; 0000000cH
	add	ebx, eax
	and	ebx, 255				; 000000ffH
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	BYTE PTR [ecx], bl
	jmp	SHORT $LN101@stbi__crea
$LN125@stbi__crea:

; 4372 :          }
; 4373 :          #undef STBI__CASE
; 4374 :          raw += nk;

	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _nk$7[ebp]
	mov	DWORD PTR _raw$[ebp], eax

; 4375 :       } else {

	jmp	$LN99@stbi__crea
$LN128@stbi__crea:

; 4376 :          STBI_ASSERT(img_n+1 == out_n);

	mov	eax, DWORD PTR _img_n$[ebp]
	add	eax, 1
	cmp	eax, DWORD PTR _out_n$[ebp]
	je	SHORT $LN161@stbi__crea
	mov	ecx, DWORD PTR ?__LINE__Var@?1??stbi__create_png_image_raw@@9@9@e7b221e1
	add	ecx, 94					; 0000005eH
	push	ecx
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1CC@CPJBBDGC@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?$CL?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN161@stbi__crea:

; 4377 :          #define STBI__CASE(f) \
; 4378 :              case f:     \
; 4379 :                 for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
; 4380 :                    for (k=0; k < filter_bytes; ++k)
; 4381 :          switch (filter) {

	mov	eax, DWORD PTR _filter$8[ebp]
	mov	DWORD PTR tv357[ebp], eax
	cmp	DWORD PTR tv357[ebp], 6
	ja	$LN97@stbi__crea
	mov	ecx, DWORD PTR tv357[ebp]
	jmp	DWORD PTR $LN167@stbi__crea[ecx*4]
$LN96@stbi__crea:

; 4382 :             STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN95@stbi__crea
$LN94@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], edx
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], ecx
$LN95@stbi__crea:
	cmp	DWORD PTR _i$[ebp], 1
	jb	SHORT $LN93@stbi__crea
	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN92@stbi__crea
$LN91@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN92@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	SHORT $LN90@stbi__crea
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _raw$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN91@stbi__crea
$LN90@stbi__crea:
	jmp	SHORT $LN94@stbi__crea
$LN93@stbi__crea:
	jmp	$LN97@stbi__crea
$LN89@stbi__crea:

; 4383 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN88@stbi__crea
$LN87@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], edx
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], ecx
$LN88@stbi__crea:
	cmp	DWORD PTR _i$[ebp], 1
	jb	SHORT $LN86@stbi__crea
	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN85@stbi__crea
$LN84@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN85@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	SHORT $LN83@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, DWORD PTR _output_bytes$[ebp]
	mov	eax, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	add	ecx, edx
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $LN84@stbi__crea
$LN83@stbi__crea:
	jmp	$LN87@stbi__crea
$LN86@stbi__crea:
	jmp	$LN97@stbi__crea
$LN82@stbi__crea:

; 4384 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN81@stbi__crea
$LN80@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], edx
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], ecx
$LN81@stbi__crea:
	cmp	DWORD PTR _i$[ebp], 1
	jb	SHORT $LN79@stbi__crea
	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN78@stbi__crea
$LN77@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN78@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	SHORT $LN76@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _prior$9[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [edx]
	add	ecx, eax
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _cur$10[ebp]
	add	edx, DWORD PTR _k$[ebp]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN77@stbi__crea
$LN76@stbi__crea:
	jmp	$LN80@stbi__crea
$LN79@stbi__crea:
	jmp	$LN97@stbi__crea
$LN75@stbi__crea:

; 4385 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN74@stbi__crea
$LN73@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], edx
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], ecx
$LN74@stbi__crea:
	cmp	DWORD PTR _i$[ebp], 1
	jb	SHORT $LN72@stbi__crea
	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN71@stbi__crea
$LN70@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN71@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	SHORT $LN69@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _prior$9[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, DWORD PTR _output_bytes$[ebp]
	mov	esi, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [esi+edx]
	add	eax, edx
	sar	eax, 1
	add	ecx, eax
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $LN70@stbi__crea
$LN69@stbi__crea:
	jmp	$LN73@stbi__crea
$LN72@stbi__crea:
	jmp	$LN97@stbi__crea
$LN68@stbi__crea:

; 4386 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN67@stbi__crea
$LN66@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], edx
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], ecx
$LN67@stbi__crea:
	cmp	DWORD PTR _i$[ebp], 1
	jb	SHORT $LN65@stbi__crea
	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN64@stbi__crea
$LN63@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN64@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	SHORT $LN62@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ebx, BYTE PTR [eax]
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, DWORD PTR _output_bytes$[ebp]
	mov	edx, DWORD PTR _prior$9[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, DWORD PTR _output_bytes$[ebp]
	mov	ecx, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	_stbi__paeth
	add	esp, 12					; 0000000cH
	add	ebx, eax
	and	ebx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], bl
	jmp	SHORT $LN63@stbi__crea
$LN62@stbi__crea:
	jmp	$LN66@stbi__crea
$LN65@stbi__crea:
	jmp	$LN97@stbi__crea
$LN61@stbi__crea:

; 4387 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN60@stbi__crea
$LN59@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], edx
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], ecx
$LN60@stbi__crea:
	cmp	DWORD PTR _i$[ebp], 1
	jb	SHORT $LN58@stbi__crea
	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN57@stbi__crea
$LN56@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN57@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	SHORT $LN55@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, DWORD PTR _output_bytes$[ebp]
	mov	eax, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	sar	edx, 1
	add	ecx, edx
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $LN56@stbi__crea
$LN55@stbi__crea:
	jmp	$LN59@stbi__crea
$LN58@stbi__crea:
	jmp	$LN97@stbi__crea
$LN54@stbi__crea:

; 4388 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN53@stbi__crea
$LN52@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], edx
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], ecx
$LN53@stbi__crea:
	cmp	DWORD PTR _i$[ebp], 1
	jb	SHORT $LN97@stbi__crea
	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN50@stbi__crea
$LN49@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN50@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	SHORT $LN48@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ebx, BYTE PTR [eax]
	push	0
	push	0
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, DWORD PTR _output_bytes$[ebp]
	mov	edx, DWORD PTR _cur$10[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	_stbi__paeth
	add	esp, 12					; 0000000cH
	add	ebx, eax
	and	ebx, 255				; 000000ffH
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	BYTE PTR [ecx], bl
	jmp	SHORT $LN49@stbi__crea
$LN48@stbi__crea:
	jmp	$LN52@stbi__crea
$LN97@stbi__crea:

; 4389 :          }
; 4390 :          #undef STBI__CASE
; 4391 : 
; 4392 :          // the loop above sets the high byte of the pixels' alpha, but for
; 4393 :          // 16 bit png files we also need the low byte set. we'll do that here.
; 4394 :          if (depth == 16) {

	cmp	DWORD PTR _depth$[ebp], 16		; 00000010H
	jne	SHORT $LN99@stbi__crea

; 4395 :             cur = a->out + stride*j; // start at the beginning of the row again

	mov	eax, DWORD PTR _stride$[ebp]
	imul	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$10[ebp], eax

; 4396 :             for (i=0; i < x; ++i,cur+=output_bytes) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN46@stbi__crea
$LN45@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], ecx
$LN46@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _x$[ebp]
	jae	SHORT $LN99@stbi__crea

; 4397 :                cur[filter_bytes+1] = 255;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [eax+1], 255			; 000000ffH

; 4398 :             }

	jmp	SHORT $LN45@stbi__crea
$LN99@stbi__crea:

; 4399 :          }
; 4400 :       }
; 4401 :    }

	jmp	$LN151@stbi__crea
$LN150@stbi__crea:

; 4402 : 
; 4403 :    // we make a separate pass to expand bits to pixels; for performance,
; 4404 :    // this could run two scanlines behind the above code, so it won't
; 4405 :    // intefere with filtering but will still be in the cache.
; 4406 :    if (depth < 8) {

	cmp	DWORD PTR _depth$[ebp], 8
	jge	$LN43@stbi__crea

; 4407 :       for (j=0; j < y; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN42@stbi__crea
$LN41@stbi__crea:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN42@stbi__crea:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _y$[ebp]
	jae	$LN40@stbi__crea

; 4408 :          stbi_uc *cur = a->out + stride*j;

	mov	eax, DWORD PTR _stride$[ebp]
	imul	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$6[ebp], eax

; 4409 :          stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;

	mov	eax, DWORD PTR _stride$[ebp]
	imul	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _out_n$[ebp]
	add	edx, eax
	sub	edx, DWORD PTR _img_width_bytes$[ebp]
	mov	DWORD PTR _in$5[ebp], edx

; 4410 :          // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4411 :          // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4412 :          stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

	cmp	DWORD PTR _color$[ebp], 0
	jne	SHORT $LN162@stbi__crea
	mov	eax, DWORD PTR _depth$[ebp]
	movzx	ecx, BYTE PTR _stbi__depth_scale_table[eax]
	mov	DWORD PTR tv551[ebp], ecx
	jmp	SHORT $LN163@stbi__crea
$LN162@stbi__crea:
	mov	DWORD PTR tv551[ebp], 1
$LN163@stbi__crea:
	mov	dl, BYTE PTR tv551[ebp]
	mov	BYTE PTR _scale$4[ebp], dl

; 4413 : 
; 4414 :          // note that the final byte might overshoot and write more data than desired.
; 4415 :          // we can allocate enough data that this never writes out of memory, but it
; 4416 :          // could also overwrite the next scanline. can it overwrite non-empty data
; 4417 :          // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
; 4418 :          // so we need to explicitly clamp the final ones
; 4419 : 
; 4420 :          if (depth == 4) {

	cmp	DWORD PTR _depth$[ebp], 4
	jne	$LN39@stbi__crea

; 4421 :             for (k=x*img_n; k >= 2; k-=2, ++in) {

	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _img_n$[ebp]
	mov	DWORD PTR _k$[ebp], eax
	jmp	SHORT $LN38@stbi__crea
$LN37@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 2
	mov	DWORD PTR _k$[ebp], eax
	mov	ecx, DWORD PTR _in$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$5[ebp], ecx
$LN38@stbi__crea:
	cmp	DWORD PTR _k$[ebp], 2
	jl	SHORT $LN36@stbi__crea

; 4422 :                *cur++ = scale * ((*in >> 4)       );

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 4
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4423 :                *cur++ = scale * ((*in     ) & 0x0f);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 15					; 0000000fH
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4424 :             }

	jmp	SHORT $LN37@stbi__crea
$LN36@stbi__crea:

; 4425 :             if (k > 0) *cur++ = scale * ((*in >> 4)       );

	cmp	DWORD PTR _k$[ebp], 0
	jle	SHORT $LN35@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 4
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN35@stbi__crea:

; 4426 :          } else if (depth == 2) {

	jmp	$LN34@stbi__crea
$LN39@stbi__crea:
	cmp	DWORD PTR _depth$[ebp], 2
	jne	$LN33@stbi__crea

; 4427 :             for (k=x*img_n; k >= 4; k-=4, ++in) {

	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _img_n$[ebp]
	mov	DWORD PTR _k$[ebp], eax
	jmp	SHORT $LN32@stbi__crea
$LN31@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 4
	mov	DWORD PTR _k$[ebp], eax
	mov	ecx, DWORD PTR _in$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$5[ebp], ecx
$LN32@stbi__crea:
	cmp	DWORD PTR _k$[ebp], 4
	jl	$LN30@stbi__crea

; 4428 :                *cur++ = scale * ((*in >> 6)       );

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 6
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4429 :                *cur++ = scale * ((*in >> 4) & 0x03);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 4
	and	edx, 3
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4430 :                *cur++ = scale * ((*in >> 2) & 0x03);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 2
	and	edx, 3
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4431 :                *cur++ = scale * ((*in     ) & 0x03);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 3
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4432 :             }

	jmp	$LN31@stbi__crea
$LN30@stbi__crea:

; 4433 :             if (k > 0) *cur++ = scale * ((*in >> 6)       );

	cmp	DWORD PTR _k$[ebp], 0
	jle	SHORT $LN29@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 6
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN29@stbi__crea:

; 4434 :             if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);

	cmp	DWORD PTR _k$[ebp], 1
	jle	SHORT $LN28@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 4
	and	edx, 3
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN28@stbi__crea:

; 4435 :             if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);

	cmp	DWORD PTR _k$[ebp], 2
	jle	SHORT $LN27@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 2
	and	edx, 3
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN27@stbi__crea:

; 4436 :          } else if (depth == 1) {

	jmp	$LN34@stbi__crea
$LN33@stbi__crea:
	cmp	DWORD PTR _depth$[ebp], 1
	jne	$LN34@stbi__crea

; 4437 :             for (k=x*img_n; k >= 8; k-=8, ++in) {

	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _img_n$[ebp]
	mov	DWORD PTR _k$[ebp], eax
	jmp	SHORT $LN24@stbi__crea
$LN23@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 8
	mov	DWORD PTR _k$[ebp], eax
	mov	ecx, DWORD PTR _in$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$5[ebp], ecx
$LN24@stbi__crea:
	cmp	DWORD PTR _k$[ebp], 8
	jl	$LN22@stbi__crea

; 4438 :                *cur++ = scale * ((*in >> 7)       );

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 7
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4439 :                *cur++ = scale * ((*in >> 6) & 0x01);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 6
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4440 :                *cur++ = scale * ((*in >> 5) & 0x01);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 5
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4441 :                *cur++ = scale * ((*in >> 4) & 0x01);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 4
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4442 :                *cur++ = scale * ((*in >> 3) & 0x01);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 3
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4443 :                *cur++ = scale * ((*in >> 2) & 0x01);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 2
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4444 :                *cur++ = scale * ((*in >> 1) & 0x01);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 1
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4445 :                *cur++ = scale * ((*in     ) & 0x01);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4446 :             }

	jmp	$LN23@stbi__crea
$LN22@stbi__crea:

; 4447 :             if (k > 0) *cur++ = scale * ((*in >> 7)       );

	cmp	DWORD PTR _k$[ebp], 0
	jle	SHORT $LN21@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 7
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN21@stbi__crea:

; 4448 :             if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);

	cmp	DWORD PTR _k$[ebp], 1
	jle	SHORT $LN20@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 6
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN20@stbi__crea:

; 4449 :             if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);

	cmp	DWORD PTR _k$[ebp], 2
	jle	SHORT $LN19@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 5
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN19@stbi__crea:

; 4450 :             if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);

	cmp	DWORD PTR _k$[ebp], 3
	jle	SHORT $LN18@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 4
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN18@stbi__crea:

; 4451 :             if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);

	cmp	DWORD PTR _k$[ebp], 4
	jle	SHORT $LN17@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 3
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN17@stbi__crea:

; 4452 :             if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);

	cmp	DWORD PTR _k$[ebp], 5
	jle	SHORT $LN16@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 2
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN16@stbi__crea:

; 4453 :             if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);

	cmp	DWORD PTR _k$[ebp], 6
	jle	SHORT $LN34@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 1
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN34@stbi__crea:

; 4454 :          }
; 4455 :          if (img_n != out_n) {

	mov	eax, DWORD PTR _img_n$[ebp]
	cmp	eax, DWORD PTR _out_n$[ebp]
	je	$LN14@stbi__crea

; 4456 :             int q;
; 4457 :             // insert alpha = 255
; 4458 :             cur = a->out + stride*j;

	mov	eax, DWORD PTR _stride$[ebp]
	imul	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$6[ebp], eax

; 4459 :             if (img_n == 1) {

	cmp	DWORD PTR _img_n$[ebp], 1
	jne	SHORT $LN13@stbi__crea

; 4460 :                for (q=x-1; q >= 0; --q) {

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _q$3[ebp], eax
	jmp	SHORT $LN12@stbi__crea
$LN11@stbi__crea:
	mov	eax, DWORD PTR _q$3[ebp]
	sub	eax, 1
	mov	DWORD PTR _q$3[ebp], eax
$LN12@stbi__crea:
	cmp	DWORD PTR _q$3[ebp], 0
	jl	SHORT $LN10@stbi__crea

; 4461 :                   cur[q*2+1] = 255;

	mov	eax, DWORD PTR _q$3[ebp]
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx+eax*2+1], 255		; 000000ffH

; 4462 :                   cur[q*2+0] = cur[q];

	mov	eax, DWORD PTR _cur$6[ebp]
	add	eax, DWORD PTR _q$3[ebp]
	mov	ecx, DWORD PTR _q$3[ebp]
	mov	edx, DWORD PTR _cur$6[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edx+ecx*2], al

; 4463 :                }

	jmp	SHORT $LN11@stbi__crea
$LN10@stbi__crea:

; 4464 :             } else {

	jmp	$LN14@stbi__crea
$LN13@stbi__crea:

; 4465 :                STBI_ASSERT(img_n == 3);

	cmp	DWORD PTR _img_n$[ebp], 3
	je	SHORT $LN164@stbi__crea
	mov	eax, DWORD PTR ?__LINE__Var@?1??stbi__create_png_image_raw@@9@9@e7b221e1
	add	eax, 183				; 000000b7H
	push	eax
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN164@stbi__crea:

; 4466 :                for (q=x-1; q >= 0; --q) {

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _q$3[ebp], eax
	jmp	SHORT $LN8@stbi__crea
$LN7@stbi__crea:
	mov	eax, DWORD PTR _q$3[ebp]
	sub	eax, 1
	mov	DWORD PTR _q$3[ebp], eax
$LN8@stbi__crea:
	cmp	DWORD PTR _q$3[ebp], 0
	jl	SHORT $LN14@stbi__crea

; 4467 :                   cur[q*4+3] = 255;

	mov	eax, DWORD PTR _q$3[ebp]
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx+eax*4+3], 255		; 000000ffH

; 4468 :                   cur[q*4+2] = cur[q*3+2];

	imul	eax, DWORD PTR _q$3[ebp], 3
	mov	ecx, DWORD PTR _q$3[ebp]
	mov	edx, DWORD PTR _cur$6[ebp]
	mov	esi, DWORD PTR _cur$6[ebp]
	mov	al, BYTE PTR [esi+eax+2]
	mov	BYTE PTR [edx+ecx*4+2], al

; 4469 :                   cur[q*4+1] = cur[q*3+1];

	imul	eax, DWORD PTR _q$3[ebp], 3
	mov	ecx, DWORD PTR _q$3[ebp]
	mov	edx, DWORD PTR _cur$6[ebp]
	mov	esi, DWORD PTR _cur$6[ebp]
	mov	al, BYTE PTR [esi+eax+1]
	mov	BYTE PTR [edx+ecx*4+1], al

; 4470 :                   cur[q*4+0] = cur[q*3+0];

	imul	eax, DWORD PTR _q$3[ebp], 3
	mov	ecx, DWORD PTR _q$3[ebp]
	mov	edx, DWORD PTR _cur$6[ebp]
	mov	esi, DWORD PTR _cur$6[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx*4], al

; 4471 :                }

	jmp	$LN7@stbi__crea
$LN14@stbi__crea:

; 4472 :             }
; 4473 :          }
; 4474 :       }

	jmp	$LN41@stbi__crea
$LN40@stbi__crea:

; 4475 :    } else if (depth == 16) {

	jmp	$LN5@stbi__crea
$LN43@stbi__crea:
	cmp	DWORD PTR _depth$[ebp], 16		; 00000010H
	jne	$LN5@stbi__crea

; 4476 :       // force the image data from big-endian to platform-native.
; 4477 :       // this is done in a separate pass due to the decoding relying
; 4478 :       // on the data being untouched, but could probably be done
; 4479 :       // per-line during decode if care is taken.
; 4480 :       stbi_uc *cur = a->out;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$2[ebp], ecx

; 4481 :       stbi__uint16 *cur16 = (stbi__uint16*)cur;

	mov	eax, DWORD PTR _cur$2[ebp]
	mov	DWORD PTR _cur16$1[ebp], eax

; 4482 : 
; 4483 :       for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@stbi__crea
$LN2@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur16$1[ebp]
	add	ecx, 2
	mov	DWORD PTR _cur16$1[ebp], ecx
	mov	edx, DWORD PTR _cur$2[ebp]
	add	edx, 2
	mov	DWORD PTR _cur$2[ebp], edx
$LN3@stbi__crea:
	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR _out_n$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN5@stbi__crea

; 4484 :          *cur16 = (cur[0] << 8) | cur[1];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$2[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	shl	eax, 8
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$2[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	or	eax, ecx
	mov	edx, DWORD PTR _cur16$1[ebp]
	mov	WORD PTR [edx], ax

; 4485 :       }

	jmp	SHORT $LN2@stbi__crea
$LN5@stbi__crea:

; 4486 :    }
; 4487 : 
; 4488 :    return 1;

	mov	eax, 1
$LN155@stbi__crea:

; 4489 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 460				; 000001ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN165@stbi__crea:
	DD	$LN141@stbi__crea
	DD	$LN140@stbi__crea
	DD	$LN139@stbi__crea
	DD	$LN138@stbi__crea
	DD	$LN137@stbi__crea
	DD	$LN136@stbi__crea
	DD	$LN135@stbi__crea
$LN166@stbi__crea:
	DD	$LN124@stbi__crea
	DD	$LN123@stbi__crea
	DD	$LN119@stbi__crea
	DD	$LN115@stbi__crea
	DD	$LN111@stbi__crea
	DD	$LN107@stbi__crea
	DD	$LN103@stbi__crea
$LN167@stbi__crea:
	DD	$LN96@stbi__crea
	DD	$LN89@stbi__crea
	DD	$LN82@stbi__crea
	DD	$LN75@stbi__crea
	DD	$LN68@stbi__crea
	DD	$LN61@stbi__crea
	DD	$LN54@stbi__crea
_stbi__create_png_image_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__paeth
_TEXT	SEGMENT
_pc$ = -44						; size = 4
_pb$ = -32						; size = 4
_pa$ = -20						; size = 4
_p$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_stbi__paeth PROC					; COMDAT

; 4268 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4269 :    int p = a + b - c;

	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	sub	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 4270 :    int pa = abs(p-a);

	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR _pa$[ebp], eax

; 4271 :    int pb = abs(p-b);

	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, DWORD PTR _b$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR _pb$[ebp], eax

; 4272 :    int pc = abs(p-c);

	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR _pc$[ebp], eax

; 4273 :    if (pa <= pb && pa <= pc) return a;

	mov	eax, DWORD PTR _pa$[ebp]
	cmp	eax, DWORD PTR _pb$[ebp]
	jg	SHORT $LN2@stbi__paet
	mov	eax, DWORD PTR _pa$[ebp]
	cmp	eax, DWORD PTR _pc$[ebp]
	jg	SHORT $LN2@stbi__paet
	mov	eax, DWORD PTR _a$[ebp]
	jmp	SHORT $LN3@stbi__paet
$LN2@stbi__paet:

; 4274 :    if (pb <= pc) return b;

	mov	eax, DWORD PTR _pb$[ebp]
	cmp	eax, DWORD PTR _pc$[ebp]
	jg	SHORT $LN1@stbi__paet
	mov	eax, DWORD PTR _b$[ebp]
	jmp	SHORT $LN3@stbi__paet
$LN1@stbi__paet:

; 4275 :    return c;

	mov	eax, DWORD PTR _c$[ebp]
$LN3@stbi__paet:

; 4276 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__paeth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__check_png_header
_TEXT	SEGMENT
_i$ = -8						; size = 4
_s$ = 8							; size = 4
_stbi__check_png_header PROC				; COMDAT

; 4231 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4232 :    static stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 4233 :    int i;
; 4234 :    for (i=0; i < 8; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__chec
$LN3@stbi__chec:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__chec:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN2@stbi__chec

; 4235 :       if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR ?png_sig@?1??stbi__check_png_header@@9@9[edx]
	cmp	ecx, eax
	je	SHORT $LN1@stbi__chec
	push	OFFSET ??_C@_0M@DMDNBACF@bad?5png?5sig?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	SHORT $LN5@stbi__chec
$LN1@stbi__chec:

; 4236 :    return 1;

	jmp	SHORT $LN3@stbi__chec
$LN2@stbi__chec:
	mov	eax, 1
$LN5@stbi__chec:

; 4237 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__check_png_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__get_chunk_header
_TEXT	SEGMENT
_c$ = -12						; size = 8
_s$ = 8							; size = 4
_stbi__get_chunk_header PROC				; COMDAT

; 4223 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4224 :    stbi__pngchunk c;
; 4225 :    c.length = stbi__get32be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32be
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 4226 :    c.type   = stbi__get32be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get32be
	add	esp, 4
	mov	DWORD PTR _c$[ebp+4], eax

; 4227 :    return c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _c$[ebp+4]

; 4228 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi__get_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi__get_:
	DD	1
	DD	$LN4@stbi__get_
$LN4@stbi__get_:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN3@stbi__get_
$LN3@stbi__get_:
	DB	99					; 00000063H
	DB	0
_stbi__get_chunk_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__do_zlib
_TEXT	SEGMENT
_a$ = 8							; size = 4
_obuf$ = 12						; size = 4
_olen$ = 16						; size = 4
_exp$ = 20						; size = 4
_parse_header$ = 24					; size = 4
_stbi__do_zlib PROC					; COMDAT

; 4120 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4121 :    a->zout_start = obuf;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _obuf$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 4122 :    a->zout       = obuf;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _obuf$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 4123 :    a->zout_end   = obuf + olen;

	mov	eax, DWORD PTR _obuf$[ebp]
	add	eax, DWORD PTR _olen$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 4124 :    a->z_expandable = exp;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 4125 : 
; 4126 :    return stbi__parse_zlib(a, parse_header);

	mov	eax, DWORD PTR _parse_header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_stbi__parse_zlib
	add	esp, 8

; 4127 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__do_zlib ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__parse_zlib
_TEXT	SEGMENT
_type$ = -20						; size = 4
_final$ = -8						; size = 4
_a$ = 8							; size = 4
_parse_header$ = 12					; size = 4
_stbi__parse_zlib PROC					; COMDAT

; 4092 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4093 :    int final, type;
; 4094 :    if (parse_header)

	cmp	DWORD PTR _parse_header$[ebp], 0
	je	SHORT $LN16@stbi__pars

; 4095 :       if (!stbi__parse_zlib_header(a)) return 0;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__parse_zlib_header
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@stbi__pars
	xor	eax, eax
	jmp	$LN17@stbi__pars
$LN16@stbi__pars:

; 4096 :    a->num_bits = 0;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR [eax+8], 0

; 4097 :    a->code_buffer = 0;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN14@stbi__pars:

; 4098 :    do {
; 4099 :       final = stbi__zreceive(a,1);

	push	1
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__zreceive
	add	esp, 8
	mov	DWORD PTR _final$[ebp], eax

; 4100 :       type = stbi__zreceive(a,2);

	push	2
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__zreceive
	add	esp, 8
	mov	DWORD PTR _type$[ebp], eax

; 4101 :       if (type == 0) {

	cmp	DWORD PTR _type$[ebp], 0
	jne	SHORT $LN11@stbi__pars

; 4102 :          if (!stbi__parse_uncompressed_block(a)) return 0;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__parse_uncompressed_block
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@stbi__pars
	xor	eax, eax
	jmp	$LN17@stbi__pars
$LN10@stbi__pars:

; 4103 :       } else if (type == 3) {

	jmp	$LN13@stbi__pars
$LN11@stbi__pars:
	cmp	DWORD PTR _type$[ebp], 3
	jne	SHORT $LN8@stbi__pars

; 4104 :          return 0;

	xor	eax, eax
	jmp	$LN17@stbi__pars

; 4105 :       } else {

	jmp	SHORT $LN13@stbi__pars
$LN8@stbi__pars:

; 4106 :          if (type == 1) {

	cmp	DWORD PTR _type$[ebp], 1
	jne	SHORT $LN6@stbi__pars

; 4107 :             // use fixed code lengths
; 4108 :             if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , 288)) return 0;

	push	288					; 00000120H
	push	OFFSET _stbi__zdefault_length
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	call	_stbi__zbuild_huffman
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN17@stbi__pars
$LN5@stbi__pars:

; 4109 :             if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;

	push	32					; 00000020H
	push	OFFSET _stbi__zdefault_distance
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 2052				; 00000804H
	push	eax
	call	_stbi__zbuild_huffman
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN17@stbi__pars
$LN4@stbi__pars:

; 4110 :          } else {

	jmp	SHORT $LN3@stbi__pars
$LN6@stbi__pars:

; 4111 :             if (!stbi__compute_huffman_codes(a)) return 0;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__compute_huffman_codes
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN17@stbi__pars
$LN3@stbi__pars:

; 4112 :          }
; 4113 :          if (!stbi__parse_huffman_block(a)) return 0;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__parse_huffman_block
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN17@stbi__pars
$LN13@stbi__pars:

; 4114 :       }
; 4115 :    } while (!final);

	cmp	DWORD PTR _final$[ebp], 0
	je	$LN14@stbi__pars

; 4116 :    return 1;

	mov	eax, 1
$LN17@stbi__pars:

; 4117 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__parse_zlib ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__parse_zlib_header
_TEXT	SEGMENT
_flg$ = -32						; size = 4
_cm$ = -20						; size = 4
_cmf$ = -8						; size = 4
_a$ = 8							; size = 4
_stbi__parse_zlib_header PROC				; COMDAT

; 4050 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4051 :    int cmf   = stbi__zget8(a);

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__zget8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _cmf$[ebp], ecx

; 4052 :    int cm    = cmf & 15;

	mov	eax, DWORD PTR _cmf$[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _cm$[ebp], eax

; 4053 :    /* int cinfo = cmf >> 4; */
; 4054 :    int flg   = stbi__zget8(a);

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__zget8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _flg$[ebp], ecx

; 4055 :    if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec

	mov	eax, DWORD PTR _cmf$[ebp]
	shl	eax, 8
	add	eax, DWORD PTR _flg$[ebp]
	cdq
	mov	ecx, 31					; 0000001fH
	idiv	ecx
	test	edx, edx
	je	SHORT $LN3@stbi__pars
	push	OFFSET ??_C@_0BA@OBKOPAFL@bad?5zlib?5header?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	SHORT $LN4@stbi__pars
$LN3@stbi__pars:

; 4056 :    if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png

	mov	eax, DWORD PTR _flg$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN2@stbi__pars
	push	OFFSET ??_C@_0P@DOGMHEBI@no?5preset?5dict?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	SHORT $LN4@stbi__pars
$LN2@stbi__pars:

; 4057 :    if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png

	cmp	DWORD PTR _cm$[ebp], 8
	je	SHORT $LN1@stbi__pars
	push	OFFSET ??_C@_0BA@MCNBDLPD@bad?5compression?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	SHORT $LN4@stbi__pars
$LN1@stbi__pars:

; 4058 :    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 4059 :    return 1;

	mov	eax, 1
$LN4@stbi__pars:

; 4060 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__parse_zlib_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__parse_uncompressed_block
_TEXT	SEGMENT
_k$ = -44						; size = 4
_nlen$ = -32						; size = 4
_len$ = -20						; size = 4
_header$ = -8						; size = 4
_a$ = 8							; size = 4
_stbi__parse_uncompressed_block PROC			; COMDAT

; 4021 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4022 :    stbi_uc header[4];
; 4023 :    int len,nlen,k;
; 4024 :    if (a->num_bits & 7)

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 7
	je	SHORT $LN9@stbi__pars

; 4025 :       stbi__zreceive(a, a->num_bits & 7); // discard

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 7
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	call	_stbi__zreceive
	add	esp, 8
$LN9@stbi__pars:

; 4026 :    // drain the bit-packed data into header
; 4027 :    k = 0;

	mov	DWORD PTR _k$[ebp], 0
$LN8@stbi__pars:

; 4028 :    while (a->num_bits > 0) {

	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jle	SHORT $LN7@stbi__pars

; 4029 :       header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _k$[ebp]
	mov	BYTE PTR _header$[ebp+edx], cl
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax

; 4030 :       a->code_buffer >>= 8;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 8
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 4031 :       a->num_bits -= 8;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 8
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 4032 :    }

	jmp	SHORT $LN8@stbi__pars
$LN7@stbi__pars:

; 4033 :    STBI_ASSERT(a->num_bits == 0);

	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN6@stbi__pars
	mov	ecx, DWORD PTR ?__LINE__Var@?1??stbi__parse_uncompressed_block@@9@9@e7b221e1
	add	ecx, 12					; 0000000cH
	push	ecx
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1CC@BHGGCLFF@?$AAa?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@stbi__pars:

; 4034 :    // now fill header the normal way
; 4035 :    while (k < 4)

	cmp	DWORD PTR _k$[ebp], 4
	jge	SHORT $LN5@stbi__pars

; 4036 :       header[k++] = stbi__zget8(a);

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__zget8
	add	esp, 4
	mov	ecx, DWORD PTR _k$[ebp]
	mov	BYTE PTR _header$[ebp+ecx], al
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
	jmp	SHORT $LN6@stbi__pars
$LN5@stbi__pars:

; 4037 :    len  = header[1] * 256 + header[0];

	mov	eax, 1
	shl	eax, 0
	movzx	ecx, BYTE PTR _header$[ebp+eax]
	shl	ecx, 8
	mov	edx, 1
	imul	eax, edx, 0
	movzx	edx, BYTE PTR _header$[ebp+eax]
	add	ecx, edx
	mov	DWORD PTR _len$[ebp], ecx

; 4038 :    nlen = header[3] * 256 + header[2];

	mov	eax, 1
	imul	ecx, eax, 3
	movzx	edx, BYTE PTR _header$[ebp+ecx]
	shl	edx, 8
	mov	eax, 1
	shl	eax, 1
	movzx	ecx, BYTE PTR _header$[ebp+eax]
	add	edx, ecx
	mov	DWORD PTR _nlen$[ebp], edx

; 4039 :    if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");

	mov	eax, DWORD PTR _len$[ebp]
	xor	eax, 65535				; 0000ffffH
	cmp	DWORD PTR _nlen$[ebp], eax
	je	SHORT $LN4@stbi__pars
	push	OFFSET ??_C@_0N@IECDHMDI@zlib?5corrupt?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN10@stbi__pars
$LN4@stbi__pars:

; 4040 :    if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	cmp	ecx, DWORD PTR [edx+4]
	jbe	SHORT $LN3@stbi__pars
	push	OFFSET ??_C@_0BB@PIPBCKIA@read?5past?5buffer?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	SHORT $LN10@stbi__pars
$LN3@stbi__pars:

; 4041 :    if (a->zout + len > a->zout_end)

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	cmp	ecx, DWORD PTR [edx+24]
	jbe	SHORT $LN2@stbi__pars

; 4042 :       if (!stbi__zexpand(a, a->zout, len)) return 0;

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__zexpand
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN10@stbi__pars
$LN2@stbi__pars:

; 4043 :    memcpy(a->zout, a->zbuffer, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4044 :    a->zbuffer += len;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx], ecx

; 4045 :    a->zout += len;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 4046 :    return 1;

	mov	eax, 1
$LN10@stbi__pars:

; 4047 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@stbi__pars
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@stbi__pars:
	DD	1
	DD	$LN14@stbi__pars
$LN14@stbi__pars:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN13@stbi__pars
$LN13@stbi__pars:
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_stbi__parse_uncompressed_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__compute_huffman_codes
_TEXT	SEGMENT
_fill$1 = -2625						; size = 1
_c$2 = -2616						; size = 4
_s$3 = -2604						; size = 4
_ntot$ = -2592						; size = 4
_hclen$ = -2580						; size = 4
_hdist$ = -2568						; size = 4
_hlit$ = -2556						; size = 4
_n$ = -2544						; size = 4
_i$ = -2532						; size = 4
_codelength_sizes$ = -2520				; size = 19
_lencodes$ = -2492					; size = 455
_z_codelength$ = -2028					; size = 2020
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_stbi__compute_huffman_codes PROC			; COMDAT

; 3972 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2824				; 00000b08H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2824]
	mov	ecx, 706				; 000002c2H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3973 :    static stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 3974 :    stbi__zhuffman z_codelength;
; 3975 :    stbi_uc lencodes[286+32+137];//padding for maximum single op
; 3976 :    stbi_uc codelength_sizes[19];
; 3977 :    int i,n;
; 3978 : 
; 3979 :    int hlit  = stbi__zreceive(a,5) + 257;

	push	5
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__zreceive
	add	esp, 8
	add	eax, 257				; 00000101H
	mov	DWORD PTR _hlit$[ebp], eax

; 3980 :    int hdist = stbi__zreceive(a,5) + 1;

	push	5
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__zreceive
	add	esp, 8
	add	eax, 1
	mov	DWORD PTR _hdist$[ebp], eax

; 3981 :    int hclen = stbi__zreceive(a,4) + 4;

	push	4
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__zreceive
	add	esp, 8
	add	eax, 4
	mov	DWORD PTR _hclen$[ebp], eax

; 3982 :    int ntot  = hlit + hdist;

	mov	eax, DWORD PTR _hlit$[ebp]
	add	eax, DWORD PTR _hdist$[ebp]
	mov	DWORD PTR _ntot$[ebp], eax

; 3983 : 
; 3984 :    memset(codelength_sizes, 0, sizeof(codelength_sizes));

	push	19					; 00000013H
	push	0
	lea	eax, DWORD PTR _codelength_sizes$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3985 :    for (i=0; i < hclen; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN19@stbi__comp
$LN18@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN19@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _hclen$[ebp]
	jge	SHORT $LN17@stbi__comp

; 3986 :       int s = stbi__zreceive(a,3);

	push	3
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__zreceive
	add	esp, 8
	mov	DWORD PTR _s$3[ebp], eax

; 3987 :       codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;

	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR ?length_dezigzag@?1??stbi__compute_huffman_codes@@9@9[eax]
	mov	dl, BYTE PTR _s$3[ebp]
	mov	BYTE PTR _codelength_sizes$[ebp+ecx], dl

; 3988 :    }

	jmp	SHORT $LN18@stbi__comp
$LN17@stbi__comp:

; 3989 :    if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

	push	19					; 00000013H
	lea	eax, DWORD PTR _codelength_sizes$[ebp]
	push	eax
	lea	ecx, DWORD PTR _z_codelength$[ebp]
	push	ecx
	call	_stbi__zbuild_huffman
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@stbi__comp
	xor	eax, eax
	jmp	$LN20@stbi__comp
$LN16@stbi__comp:

; 3990 : 
; 3991 :    n = 0;

	mov	DWORD PTR _n$[ebp], 0
$LN15@stbi__comp:

; 3992 :    while (n < ntot) {

	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _ntot$[ebp]
	jge	$LN14@stbi__comp

; 3993 :       int c = stbi__zhuffman_decode(a, &z_codelength);

	lea	eax, DWORD PTR _z_codelength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_stbi__zhuffman_decode
	add	esp, 8
	mov	DWORD PTR _c$2[ebp], eax

; 3994 :       if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");

	cmp	DWORD PTR _c$2[ebp], 0
	jl	SHORT $LN12@stbi__comp
	cmp	DWORD PTR _c$2[ebp], 19			; 00000013H
	jl	SHORT $LN13@stbi__comp
$LN12@stbi__comp:
	push	OFFSET ??_C@_0BA@MDNKOBMC@bad?5codelengths?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN20@stbi__comp
$LN13@stbi__comp:

; 3995 :       if (c < 16)

	cmp	DWORD PTR _c$2[ebp], 16			; 00000010H
	jge	SHORT $LN11@stbi__comp

; 3996 :          lencodes[n++] = (stbi_uc) c;

	mov	eax, DWORD PTR _n$[ebp]
	mov	cl, BYTE PTR _c$2[ebp]
	mov	BYTE PTR _lencodes$[ebp+eax], cl
	mov	edx, DWORD PTR _n$[ebp]
	add	edx, 1
	mov	DWORD PTR _n$[ebp], edx

; 3997 :       else {

	jmp	$LN10@stbi__comp
$LN11@stbi__comp:

; 3998 :          stbi_uc fill = 0;

	mov	BYTE PTR _fill$1[ebp], 0

; 3999 :          if (c == 16) {

	cmp	DWORD PTR _c$2[ebp], 16			; 00000010H
	jne	SHORT $LN9@stbi__comp

; 4000 :             c = stbi__zreceive(a,2)+3;

	push	2
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__zreceive
	add	esp, 8
	add	eax, 3
	mov	DWORD PTR _c$2[ebp], eax

; 4001 :             if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN8@stbi__comp
	push	OFFSET ??_C@_0BA@MDNKOBMC@bad?5codelengths?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN20@stbi__comp
$LN8@stbi__comp:

; 4002 :             fill = lencodes[n-1];

	mov	eax, DWORD PTR _n$[ebp]
	mov	cl, BYTE PTR _lencodes$[ebp+eax-1]
	mov	BYTE PTR _fill$1[ebp], cl
	jmp	SHORT $LN7@stbi__comp
$LN9@stbi__comp:

; 4003 :          } else if (c == 17)

	cmp	DWORD PTR _c$2[ebp], 17			; 00000011H
	jne	SHORT $LN6@stbi__comp

; 4004 :             c = stbi__zreceive(a,3)+3;

	push	3
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__zreceive
	add	esp, 8
	add	eax, 3
	mov	DWORD PTR _c$2[ebp], eax

; 4005 :          else {

	jmp	SHORT $LN7@stbi__comp
$LN6@stbi__comp:

; 4006 :             STBI_ASSERT(c == 18);

	cmp	DWORD PTR _c$2[ebp], 18			; 00000012H
	je	SHORT $LN22@stbi__comp
	mov	eax, DWORD PTR ?__LINE__Var@?1??stbi__compute_huffman_codes@@9@9@e7b221e1
	add	eax, 34					; 00000022H
	push	eax
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1BA@NKONKNHF@?$AAc?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA8?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN22@stbi__comp:

; 4007 :             c = stbi__zreceive(a,7)+11;

	push	7
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__zreceive
	add	esp, 8
	add	eax, 11					; 0000000bH
	mov	DWORD PTR _c$2[ebp], eax
$LN7@stbi__comp:

; 4008 :          }
; 4009 :          if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");

	mov	eax, DWORD PTR _ntot$[ebp]
	sub	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _c$2[ebp]
	jge	SHORT $LN4@stbi__comp
	push	OFFSET ??_C@_0BA@MDNKOBMC@bad?5codelengths?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN20@stbi__comp
$LN4@stbi__comp:

; 4010 :          memset(lencodes+n, fill, c);

	mov	eax, DWORD PTR _c$2[ebp]
	push	eax
	movzx	ecx, BYTE PTR _fill$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	lea	eax, DWORD PTR _lencodes$[ebp+edx]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4011 :          n += c;

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, DWORD PTR _c$2[ebp]
	mov	DWORD PTR _n$[ebp], eax
$LN10@stbi__comp:

; 4012 :       }
; 4013 :    }

	jmp	$LN15@stbi__comp
$LN14@stbi__comp:

; 4014 :    if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");

	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _ntot$[ebp]
	je	SHORT $LN3@stbi__comp
	push	OFFSET ??_C@_0BA@MDNKOBMC@bad?5codelengths?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	SHORT $LN20@stbi__comp
$LN3@stbi__comp:

; 4015 :    if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;

	mov	eax, DWORD PTR _hlit$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lencodes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	call	_stbi__zbuild_huffman
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@stbi__comp
	xor	eax, eax
	jmp	SHORT $LN20@stbi__comp
$LN2@stbi__comp:

; 4016 :    if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;

	mov	eax, DWORD PTR _hdist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hlit$[ebp]
	lea	edx, DWORD PTR _lencodes$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 2052				; 00000804H
	push	eax
	call	_stbi__zbuild_huffman
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@stbi__comp
	xor	eax, eax
	jmp	SHORT $LN20@stbi__comp
$LN1@stbi__comp:

; 4017 :    return 1;

	mov	eax, 1
$LN20@stbi__comp:

; 4018 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN27@stbi__comp
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 2824				; 00000b08H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN27@stbi__comp:
	DD	3
	DD	$LN26@stbi__comp
$LN26@stbi__comp:
	DD	-2028					; fffff814H
	DD	2020					; 000007e4H
	DD	$LN23@stbi__comp
	DD	-2492					; fffff644H
	DD	455					; 000001c7H
	DD	$LN24@stbi__comp
	DD	-2520					; fffff628H
	DD	19					; 00000013H
	DD	$LN25@stbi__comp
$LN25@stbi__comp:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN24@stbi__comp:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN23@stbi__comp:
	DB	122					; 0000007aH
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
_stbi__compute_huffman_codes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__parse_huffman_block
_TEXT	SEGMENT
_v$1 = -65						; size = 1
_dist$2 = -56						; size = 4
_len$3 = -44						; size = 4
_p$4 = -32						; size = 4
_z$5 = -20						; size = 4
_zout$ = -8						; size = 4
_a$ = 8							; size = 4
_stbi__parse_huffman_block PROC				; COMDAT

; 3930 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3931 :    char *zout = a->zout;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _zout$[ebp], ecx
$LN24@stbi__pars:

; 3932 :    for(;;) {
; 3933 :       int z = stbi__zhuffman_decode(a, &a->z_length);

	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_stbi__zhuffman_decode
	add	esp, 8
	mov	DWORD PTR _z$5[ebp], eax

; 3934 :       if (z < 256) {

	cmp	DWORD PTR _z$5[ebp], 256		; 00000100H
	jge	SHORT $LN22@stbi__pars

; 3935 :          if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes

	cmp	DWORD PTR _z$5[ebp], 0
	jge	SHORT $LN21@stbi__pars
	push	OFFSET ??_C@_0BB@IIMLINA@bad?5huffman?5code?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN25@stbi__pars
$LN21@stbi__pars:

; 3936 :          if (zout >= a->zout_end) {

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _zout$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jb	SHORT $LN20@stbi__pars

; 3937 :             if (!stbi__zexpand(a, zout, 1)) return 0;

	push	1
	mov	eax, DWORD PTR _zout$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_stbi__zexpand
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@stbi__pars
	xor	eax, eax
	jmp	$LN25@stbi__pars
$LN19@stbi__pars:

; 3938 :             zout = a->zout;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _zout$[ebp], ecx
$LN20@stbi__pars:

; 3939 :          }
; 3940 :          *zout++ = (char) z;

	mov	eax, DWORD PTR _zout$[ebp]
	mov	cl, BYTE PTR _z$5[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _zout$[ebp]
	add	edx, 1
	mov	DWORD PTR _zout$[ebp], edx

; 3941 :       } else {

	jmp	$LN18@stbi__pars
$LN22@stbi__pars:

; 3942 :          stbi_uc *p;
; 3943 :          int len,dist;
; 3944 :          if (z == 256) {

	cmp	DWORD PTR _z$5[ebp], 256		; 00000100H
	jne	SHORT $LN17@stbi__pars

; 3945 :             a->zout = zout;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _zout$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 3946 :             return 1;

	mov	eax, 1
	jmp	$LN25@stbi__pars
$LN17@stbi__pars:

; 3947 :          }
; 3948 :          z -= 257;

	mov	eax, DWORD PTR _z$5[ebp]
	sub	eax, 257				; 00000101H
	mov	DWORD PTR _z$5[ebp], eax

; 3949 :          len = stbi__zlength_base[z];

	mov	eax, DWORD PTR _z$5[ebp]
	mov	ecx, DWORD PTR _stbi__zlength_base[eax*4]
	mov	DWORD PTR _len$3[ebp], ecx

; 3950 :          if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);

	mov	eax, DWORD PTR _z$5[ebp]
	cmp	DWORD PTR _stbi__zlength_extra[eax*4], 0
	je	SHORT $LN16@stbi__pars
	mov	eax, DWORD PTR _z$5[ebp]
	mov	ecx, DWORD PTR _stbi__zlength_extra[eax*4]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	call	_stbi__zreceive
	add	esp, 8
	add	eax, DWORD PTR _len$3[ebp]
	mov	DWORD PTR _len$3[ebp], eax
$LN16@stbi__pars:

; 3951 :          z = stbi__zhuffman_decode(a, &a->z_distance);

	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 2052				; 00000804H
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_stbi__zhuffman_decode
	add	esp, 8
	mov	DWORD PTR _z$5[ebp], eax

; 3952 :          if (z < 0) return stbi__err("bad huffman code","Corrupt PNG");

	cmp	DWORD PTR _z$5[ebp], 0
	jge	SHORT $LN15@stbi__pars
	push	OFFSET ??_C@_0BB@IIMLINA@bad?5huffman?5code?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN25@stbi__pars
$LN15@stbi__pars:

; 3953 :          dist = stbi__zdist_base[z];

	mov	eax, DWORD PTR _z$5[ebp]
	mov	ecx, DWORD PTR _stbi__zdist_base[eax*4]
	mov	DWORD PTR _dist$2[ebp], ecx

; 3954 :          if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);

	mov	eax, DWORD PTR _z$5[ebp]
	cmp	DWORD PTR _stbi__zdist_extra[eax*4], 0
	je	SHORT $LN14@stbi__pars
	mov	eax, DWORD PTR _z$5[ebp]
	mov	ecx, DWORD PTR _stbi__zdist_extra[eax*4]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	call	_stbi__zreceive
	add	esp, 8
	add	eax, DWORD PTR _dist$2[ebp]
	mov	DWORD PTR _dist$2[ebp], eax
$LN14@stbi__pars:

; 3955 :          if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _zout$[ebp]
	sub	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR _dist$2[ebp]
	jge	SHORT $LN13@stbi__pars
	push	OFFSET ??_C@_08DIAPIMGJ@bad?5dist?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN25@stbi__pars
$LN13@stbi__pars:

; 3956 :          if (zout + len > a->zout_end) {

	mov	eax, DWORD PTR _zout$[ebp]
	add	eax, DWORD PTR _len$3[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	cmp	eax, DWORD PTR [ecx+24]
	jbe	SHORT $LN12@stbi__pars

; 3957 :             if (!stbi__zexpand(a, zout, len)) return 0;

	mov	eax, DWORD PTR _len$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _zout$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	call	_stbi__zexpand
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN25@stbi__pars
$LN11@stbi__pars:

; 3958 :             zout = a->zout;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _zout$[ebp], ecx
$LN12@stbi__pars:

; 3959 :          }
; 3960 :          p = (stbi_uc *) (zout - dist);

	mov	eax, DWORD PTR _zout$[ebp]
	sub	eax, DWORD PTR _dist$2[ebp]
	mov	DWORD PTR _p$4[ebp], eax

; 3961 :          if (dist == 1) { // run of one byte; common in images.

	cmp	DWORD PTR _dist$2[ebp], 1
	jne	SHORT $LN10@stbi__pars

; 3962 :             stbi_uc v = *p;

	mov	eax, DWORD PTR _p$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _v$1[ebp], cl

; 3963 :             if (len) { do *zout++ = v; while (--len); }

	cmp	DWORD PTR _len$3[ebp], 0
	je	SHORT $LN9@stbi__pars
$LN8@stbi__pars:
	mov	eax, DWORD PTR _zout$[ebp]
	mov	cl, BYTE PTR _v$1[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _zout$[ebp]
	add	edx, 1
	mov	DWORD PTR _zout$[ebp], edx
	mov	eax, DWORD PTR _len$3[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$3[ebp], eax
	jne	SHORT $LN8@stbi__pars
$LN9@stbi__pars:

; 3964 :          } else {

	jmp	SHORT $LN18@stbi__pars
$LN10@stbi__pars:

; 3965 :             if (len) { do *zout++ = *p++; while (--len); }

	cmp	DWORD PTR _len$3[ebp], 0
	je	SHORT $LN18@stbi__pars
$LN3@stbi__pars:
	mov	eax, DWORD PTR _zout$[ebp]
	mov	ecx, DWORD PTR _p$4[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _zout$[ebp]
	add	eax, 1
	mov	DWORD PTR _zout$[ebp], eax
	mov	ecx, DWORD PTR _p$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$4[ebp], ecx
	mov	eax, DWORD PTR _len$3[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$3[ebp], eax
	jne	SHORT $LN3@stbi__pars
$LN18@stbi__pars:

; 3966 :          }
; 3967 :       }
; 3968 :    }

	jmp	$LN24@stbi__pars
$LN25@stbi__pars:

; 3969 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__parse_huffman_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__zexpand
_TEXT	SEGMENT
_old_limit$ = -44					; size = 4
_limit$ = -32						; size = 4
_cur$ = -20						; size = 4
_q$ = -8						; size = 4
_z$ = 8							; size = 4
_zout$ = 12						; size = 4
_n$ = 16						; size = 4
_stbi__zexpand PROC					; COMDAT

; 3897 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3898 :    char *q;
; 3899 :    int cur, limit, old_limit;
; 3900 :    z->zout = zout;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _zout$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 3901 :    if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN4@stbi__zexp
	push	OFFSET ??_C@_0BE@IBFIPFO@output?5buffer?5limit?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN5@stbi__zexp
$LN4@stbi__zexp:

; 3902 :    cur   = (int) (z->zout     - z->zout_start);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [eax+16]
	sub	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _cur$[ebp], edx

; 3903 :    limit = old_limit = (int) (z->zout_end - z->zout_start);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [eax+24]
	sub	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _old_limit$[ebp], edx
	mov	eax, DWORD PTR _old_limit$[ebp]
	mov	DWORD PTR _limit$[ebp], eax
$LN3@stbi__zexp:

; 3904 :    while (cur + n > limit)

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _limit$[ebp]
	jle	SHORT $LN2@stbi__zexp

; 3905 :       limit *= 2;

	mov	eax, DWORD PTR _limit$[ebp]
	shl	eax, 1
	mov	DWORD PTR _limit$[ebp], eax
	jmp	SHORT $LN3@stbi__zexp
$LN2@stbi__zexp:

; 3906 :    q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);

	mov	eax, DWORD PTR _limit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _q$[ebp], eax

; 3907 :    STBI_NOTUSED(old_limit);
; 3908 :    if (q == NULL) return stbi__err("outofmem", "Out of memory");

	cmp	DWORD PTR _q$[ebp], 0
	jne	SHORT $LN1@stbi__zexp
	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	SHORT $LN5@stbi__zexp
$LN1@stbi__zexp:

; 3909 :    z->zout_start = q;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 3910 :    z->zout       = q + cur;

	mov	eax, DWORD PTR _q$[ebp]
	add	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 3911 :    z->zout_end   = q + limit;

	mov	eax, DWORD PTR _q$[ebp]
	add	eax, DWORD PTR _limit$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 3912 :    return 1;

	mov	eax, 1
$LN5@stbi__zexp:

; 3913 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__zexpand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__zhuffman_decode
_TEXT	SEGMENT
_s$ = -20						; size = 4
_b$ = -8						; size = 4
_a$ = 8							; size = 4
_z$ = 12						; size = 4
_stbi__zhuffman_decode PROC				; COMDAT

; 3883 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3884 :    int b,s;
; 3885 :    if (a->num_bits < 16) stbi__fill_bits(a);

	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax+8], 16			; 00000010H
	jge	SHORT $LN2@stbi__zhuf
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__fill_bits
	add	esp, 4
$LN2@stbi__zhuf:

; 3886 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 511				; 000001ffH
	mov	edx, DWORD PTR _z$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2]
	mov	DWORD PTR _b$[ebp], eax

; 3887 :    if (b) {

	cmp	DWORD PTR _b$[ebp], 0
	je	SHORT $LN1@stbi__zhuf

; 3888 :       s = b >> 9;

	mov	eax, DWORD PTR _b$[ebp]
	sar	eax, 9
	mov	DWORD PTR _s$[ebp], eax

; 3889 :       a->code_buffer >>= s;

	mov	eax, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _s$[ebp]
	shr	edx, cl
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR [eax+12], edx

; 3890 :       a->num_bits -= s;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 3891 :       return b & 511;

	mov	eax, DWORD PTR _b$[ebp]
	and	eax, 511				; 000001ffH
	jmp	SHORT $LN3@stbi__zhuf
$LN1@stbi__zhuf:

; 3892 :    }
; 3893 :    return stbi__zhuffman_decode_slowpath(a, z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_stbi__zhuffman_decode_slowpath
	add	esp, 8
$LN3@stbi__zhuf:

; 3894 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__zhuffman_decode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__zhuffman_decode_slowpath
_TEXT	SEGMENT
_k$ = -32						; size = 4
_s$ = -20						; size = 4
_b$ = -8						; size = 4
_a$ = 8							; size = 4
_z$ = 12						; size = 4
_stbi__zhuffman_decode_slowpath PROC			; COMDAT

; 3865 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3866 :    int b,s,k;
; 3867 :    // not resolved by fast table, so compute it the slow way
; 3868 :    // use jpeg approach, which requires MSbits at top
; 3869 :    k = stbi__bit_reverse(a->code_buffer, 16);

	push	16					; 00000010H
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_stbi__bit_reverse
	add	esp, 8
	mov	DWORD PTR _k$[ebp], eax

; 3870 :    for (s=STBI__ZFAST_BITS+1; ; ++s)

	mov	DWORD PTR _s$[ebp], 10			; 0000000aH
	jmp	SHORT $LN5@stbi__zhuf
$LN4@stbi__zhuf:
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN5@stbi__zhuf:

; 3871 :       if (k < z->maxcode[s])

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4+1056]
	jge	SHORT $LN2@stbi__zhuf

; 3872 :          break;

	jmp	SHORT $LN3@stbi__zhuf
$LN2@stbi__zhuf:

; 3873 :    if (s == 16) return -1; // invalid code!

	jmp	SHORT $LN4@stbi__zhuf
$LN3@stbi__zhuf:
	cmp	DWORD PTR _s$[ebp], 16			; 00000010H
	jne	SHORT $LN1@stbi__zhuf
	or	eax, -1
	jmp	$LN6@stbi__zhuf
$LN1@stbi__zhuf:

; 3874 :    // code size is s, so:
; 3875 :    b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];

	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
	sar	eax, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	movzx	ecx, WORD PTR [edx+ecx*2+1024]
	sub	eax, ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	movzx	edx, WORD PTR [ecx+edx*2+1124]
	add	eax, edx
	mov	DWORD PTR _b$[ebp], eax

; 3876 :    STBI_ASSERT(z->size[b] == s);

	mov	eax, DWORD PTR _z$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	movzx	ecx, BYTE PTR [eax+1156]
	cmp	ecx, DWORD PTR _s$[ebp]
	je	SHORT $LN8@stbi__zhuf
	mov	edx, DWORD PTR ?__LINE__Var@?1??stbi__zhuffman_decode_slowpath@@9@9@e7b221e1
	add	edx, 11					; 0000000bH
	push	edx
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1CA@BMLMNMFI@?$AAz?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$FL?$AAb?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN8@stbi__zhuf:

; 3877 :    a->code_buffer >>= s;

	mov	eax, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _s$[ebp]
	shr	edx, cl
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR [eax+12], edx

; 3878 :    a->num_bits -= s;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 3879 :    return z->value[b];

	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	movzx	eax, WORD PTR [ecx+eax*2+1444]
$LN6@stbi__zhuf:

; 3880 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__zhuffman_decode_slowpath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__zreceive
_TEXT	SEGMENT
_k$ = -8						; size = 4
_z$ = 8							; size = 4
_n$ = 12						; size = 4
_stbi__zreceive PROC					; COMDAT

; 3855 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3856 :    unsigned int k;
; 3857 :    if (z->num_bits < n) stbi__fill_bits(z);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _n$[ebp]
	jge	SHORT $LN1@stbi__zrec
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_stbi__fill_bits
	add	esp, 4
$LN1@stbi__zrec:

; 3858 :    k = z->code_buffer & ((1 << n) - 1);

	mov	eax, 1
	mov	ecx, DWORD PTR _n$[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	ecx, DWORD PTR _z$[ebp]
	and	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _k$[ebp], eax

; 3859 :    z->code_buffer >>= n;

	mov	eax, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _n$[ebp]
	shr	edx, cl
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+12], edx

; 3860 :    z->num_bits -= n;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 3861 :    return k;

	mov	eax, DWORD PTR _k$[ebp]

; 3862 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__zreceive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__fill_bits
_TEXT	SEGMENT
_z$ = 8							; size = 4
_stbi__fill_bits PROC					; COMDAT

; 3846 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN3@stbi__fill:

; 3847 :    do {
; 3848 :       STBI_ASSERT(z->code_buffer < (1U << z->num_bits));

	mov	eax, DWORD PTR _z$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+8]
	shl	edx, cl
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+12], edx
	jb	SHORT $LN6@stbi__fill
	mov	ecx, DWORD PTR ?__LINE__Var@?1??stbi__fill_bits@@9@9@e7b221e1
	add	ecx, 2
	push	ecx
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1EK@GAHNONBJ@?$AAz?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AA1?$AAU?$AA?5?$AA?$DM?$AA?$DM?$AA?5?$AAz?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AA_?$AAb@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@stbi__fill:

; 3849 :       z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_stbi__zget8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	edx, cl
	mov	ecx, DWORD PTR _z$[ebp]
	or	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+12], edx

; 3850 :       z->num_bits += 8;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 8
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 3851 :    } while (z->num_bits <= 24);

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+8], 24			; 00000018H
	jle	SHORT $LN3@stbi__fill

; 3852 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__fill_bits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__zget8
_TEXT	SEGMENT
tv72 = -193						; size = 1
_z$ = 8							; size = 4
_stbi__zget8 PROC					; COMDAT

; 3840 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3841 :    if (z->zbuffer >= z->zbuffer_end) return 0;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	jb	SHORT $LN1@stbi__zget
	xor	al, al
	jmp	SHORT $LN2@stbi__zget
$LN1@stbi__zget:

; 3842 :    return *z->zbuffer++;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv72[ebp], dl
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	al, BYTE PTR tv72[ebp]
$LN2@stbi__zget:

; 3843 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__zget8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__zbuild_huffman
_TEXT	SEGMENT
_j$1 = -232						; size = 4
_fastv$2 = -220						; size = 2
_c$3 = -208						; size = 4
_s$4 = -196						; size = 4
_sizes$ = -184						; size = 68
_next_code$ = -108					; size = 64
_code$ = -36						; size = 4
_k$ = -24						; size = 4
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_z$ = 8							; size = 4
_sizelist$ = 12						; size = 4
_num$ = 16						; size = 4
_stbi__zbuild_huffman PROC				; COMDAT

; 3773 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 428				; 000001acH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-428]
	mov	ecx, 107				; 0000006bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3774 :    int i,k=0;

	mov	DWORD PTR _k$[ebp], 0

; 3775 :    int code, next_code[16], sizes[17];
; 3776 : 
; 3777 :    // DEFLATE spec for generating codes
; 3778 :    memset(sizes, 0, sizeof(sizes));

	push	68					; 00000044H
	push	0
	lea	eax, DWORD PTR _sizes$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3779 :    memset(z->fast, 0, sizeof(z->fast));

	push	1024					; 00000400H
	push	0
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3780 :    for (i=0; i < num; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN19@stbi__zbui
$LN18@stbi__zbui:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN19@stbi__zbui:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _num$[ebp]
	jge	SHORT $LN17@stbi__zbui

; 3781 :       ++sizes[sizelist[i]];

	mov	eax, DWORD PTR _sizelist$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _sizes$[ebp+ecx*4]
	add	edx, 1
	mov	eax, DWORD PTR _sizelist$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _sizes$[ebp+ecx*4], edx
	jmp	SHORT $LN18@stbi__zbui
$LN17@stbi__zbui:

; 3782 :    sizes[0] = 0;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	DWORD PTR _sizes$[ebp+ecx], 0

; 3783 :    for (i=1; i < 16; ++i)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN16@stbi__zbui
$LN15@stbi__zbui:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN16@stbi__zbui:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN14@stbi__zbui

; 3784 :       if (sizes[i] > (1 << i))

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _sizes$[ebp+ecx*4], eax
	jle	SHORT $LN13@stbi__zbui

; 3785 :          return stbi__err("bad sizes", "Corrupt PNG");

	push	OFFSET ??_C@_09EOHLEIKL@bad?5sizes?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN20@stbi__zbui
$LN13@stbi__zbui:

; 3786 :    code = 0;

	jmp	SHORT $LN15@stbi__zbui
$LN14@stbi__zbui:
	mov	DWORD PTR _code$[ebp], 0

; 3787 :    for (i=1; i < 16; ++i) {

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN12@stbi__zbui
$LN11@stbi__zbui:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@stbi__zbui:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	$LN10@stbi__zbui

; 3788 :       next_code[i] = code;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _code$[ebp]
	mov	DWORD PTR _next_code$[ebp+eax*4], ecx

; 3789 :       z->firstcode[i] = (stbi__uint16) code;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	dx, WORD PTR _code$[ebp]
	mov	WORD PTR [ecx+eax*2+1024], dx

; 3790 :       z->firstsymbol[i] = (stbi__uint16) k;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	dx, WORD PTR _k$[ebp]
	mov	WORD PTR [ecx+eax*2+1124], dx

; 3791 :       code = (code + sizes[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _code$[ebp]
	add	ecx, DWORD PTR _sizes$[ebp+eax*4]
	mov	DWORD PTR _code$[ebp], ecx

; 3792 :       if (sizes[i])

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _sizes$[ebp+eax*4], 0
	je	SHORT $LN9@stbi__zbui

; 3793 :          if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");

	mov	eax, DWORD PTR _code$[ebp]
	sub	eax, 1
	mov	edx, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	edx, cl
	cmp	eax, edx
	jl	SHORT $LN9@stbi__zbui
	push	OFFSET ??_C@_0BA@MDNKOBMC@bad?5codelengths?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN20@stbi__zbui
$LN9@stbi__zbui:

; 3794 :       z->maxcode[i] = code << (16-i); // preshift for inner loop

	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _code$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx*4+1056], eax

; 3795 :       code <<= 1;

	mov	eax, DWORD PTR _code$[ebp]
	shl	eax, 1
	mov	DWORD PTR _code$[ebp], eax

; 3796 :       k += sizes[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, DWORD PTR _sizes$[ebp+eax*4]
	mov	DWORD PTR _k$[ebp], ecx

; 3797 :    }

	jmp	$LN11@stbi__zbui
$LN10@stbi__zbui:

; 3798 :    z->maxcode[16] = 0x10000; // sentinel

	mov	eax, 4
	shl	eax, 4
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+1056], 65536		; 00010000H

; 3799 :    for (i=0; i < num; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@stbi__zbui
$LN6@stbi__zbui:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@stbi__zbui:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _num$[ebp]
	jge	$LN5@stbi__zbui

; 3800 :       int s = sizelist[i];

	mov	eax, DWORD PTR _sizelist$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _s$4[ebp], ecx

; 3801 :       if (s) {

	cmp	DWORD PTR _s$4[ebp], 0
	je	$LN4@stbi__zbui

; 3802 :          int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];

	mov	eax, DWORD PTR _s$4[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2+1024]
	mov	eax, DWORD PTR _s$4[ebp]
	mov	ecx, DWORD PTR _next_code$[ebp+eax*4]
	sub	ecx, edx
	mov	edx, DWORD PTR _s$4[ebp]
	mov	eax, DWORD PTR _z$[ebp]
	movzx	edx, WORD PTR [eax+edx*2+1124]
	add	ecx, edx
	mov	DWORD PTR _c$3[ebp], ecx

; 3803 :          stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);

	mov	eax, DWORD PTR _s$4[ebp]
	shl	eax, 9
	or	eax, DWORD PTR _i$[ebp]
	mov	WORD PTR _fastv$2[ebp], ax

; 3804 :          z->size [c] = (stbi_uc     ) s;

	mov	eax, DWORD PTR _z$[ebp]
	add	eax, DWORD PTR _c$3[ebp]
	mov	cl, BYTE PTR _s$4[ebp]
	mov	BYTE PTR [eax+1156], cl

; 3805 :          z->value[c] = (stbi__uint16) i;

	mov	eax, DWORD PTR _c$3[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	dx, WORD PTR _i$[ebp]
	mov	WORD PTR [ecx+eax*2+1444], dx

; 3806 :          if (s <= STBI__ZFAST_BITS) {

	cmp	DWORD PTR _s$4[ebp], 9
	jg	SHORT $LN3@stbi__zbui

; 3807 :             int j = stbi__bit_reverse(next_code[s],s);

	mov	eax, DWORD PTR _s$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$4[ebp]
	mov	edx, DWORD PTR _next_code$[ebp+ecx*4]
	push	edx
	call	_stbi__bit_reverse
	add	esp, 8
	mov	DWORD PTR _j$1[ebp], eax
$LN2@stbi__zbui:

; 3808 :             while (j < (1 << STBI__ZFAST_BITS)) {

	cmp	DWORD PTR _j$1[ebp], 512		; 00000200H
	jge	SHORT $LN3@stbi__zbui

; 3809 :                z->fast[j] = fastv;

	mov	eax, DWORD PTR _j$1[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	dx, WORD PTR _fastv$2[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 3810 :                j += (1 << s);

	mov	eax, 1
	mov	ecx, DWORD PTR _s$4[ebp]
	shl	eax, cl
	add	eax, DWORD PTR _j$1[ebp]
	mov	DWORD PTR _j$1[ebp], eax

; 3811 :             }

	jmp	SHORT $LN2@stbi__zbui
$LN3@stbi__zbui:

; 3812 :          }
; 3813 :          ++next_code[s];

	mov	eax, DWORD PTR _s$4[ebp]
	mov	ecx, DWORD PTR _next_code$[ebp+eax*4]
	add	ecx, 1
	mov	edx, DWORD PTR _s$4[ebp]
	mov	DWORD PTR _next_code$[ebp+edx*4], ecx
$LN4@stbi__zbui:

; 3814 :       }
; 3815 :    }

	jmp	$LN6@stbi__zbui
$LN5@stbi__zbui:

; 3816 :    return 1;

	mov	eax, 1
$LN20@stbi__zbui:

; 3817 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN25@stbi__zbui
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 428				; 000001acH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN25@stbi__zbui:
	DD	2
	DD	$LN24@stbi__zbui
$LN24@stbi__zbui:
	DD	-108					; ffffff94H
	DD	64					; 00000040H
	DD	$LN22@stbi__zbui
	DD	-184					; ffffff48H
	DD	68					; 00000044H
	DD	$LN23@stbi__zbui
$LN23@stbi__zbui:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN22@stbi__zbui:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
_stbi__zbuild_huffman ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__bit_reverse
_TEXT	SEGMENT
_v$ = 8							; size = 4
_bits$ = 12						; size = 4
_stbi__bit_reverse PROC					; COMDAT

; 3765 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3766 :    STBI_ASSERT(bits <= 16);

	cmp	DWORD PTR _bits$[ebp], 16		; 00000010H
	jle	SHORT $LN3@stbi__bit_
	mov	eax, DWORD PTR ?__LINE__Var@?1??stbi__bit_reverse@@9@9@e7b221e1
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@stbi__bit_:

; 3767 :    // to bit reverse n bits, reverse 16 and shift
; 3768 :    // e.g. 11 bits, bit reverse and shift away 5
; 3769 :    return stbi__bitreverse16(v) >> (16-bits);

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	call	_stbi__bitreverse16
	add	esp, 4
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _bits$[ebp]
	sar	eax, cl

; 3770 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__bit_reverse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__bitreverse16
_TEXT	SEGMENT
_n$ = 8							; size = 4
_stbi__bitreverse16 PROC				; COMDAT

; 3756 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3757 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);

	mov	eax, DWORD PTR _n$[ebp]
	and	eax, 43690				; 0000aaaaH
	sar	eax, 1
	mov	ecx, DWORD PTR _n$[ebp]
	and	ecx, 21845				; 00005555H
	shl	ecx, 1
	or	eax, ecx
	mov	DWORD PTR _n$[ebp], eax

; 3758 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);

	mov	eax, DWORD PTR _n$[ebp]
	and	eax, 52428				; 0000ccccH
	sar	eax, 2
	mov	ecx, DWORD PTR _n$[ebp]
	and	ecx, 13107				; 00003333H
	shl	ecx, 2
	or	eax, ecx
	mov	DWORD PTR _n$[ebp], eax

; 3759 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);

	mov	eax, DWORD PTR _n$[ebp]
	and	eax, 61680				; 0000f0f0H
	sar	eax, 4
	mov	ecx, DWORD PTR _n$[ebp]
	and	ecx, 3855				; 00000f0fH
	shl	ecx, 4
	or	eax, ecx
	mov	DWORD PTR _n$[ebp], eax

; 3760 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);

	mov	eax, DWORD PTR _n$[ebp]
	and	eax, 65280				; 0000ff00H
	sar	eax, 8
	mov	ecx, DWORD PTR _n$[ebp]
	and	ecx, 255				; 000000ffH
	shl	ecx, 8
	or	eax, ecx
	mov	DWORD PTR _n$[ebp], eax

; 3761 :   return n;

	mov	eax, DWORD PTR _n$[ebp]

; 3762 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__bitreverse16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__jpeg_info_raw
_TEXT	SEGMENT
tv80 = -196						; size = 4
_j$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_stbi__jpeg_info_raw PROC				; COMDAT

; 3708 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3709 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {

	push	2
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__decode_jpeg_header
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@stbi__jpeg

; 3710 :       stbi__rewind( j->s );

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__rewind
	add	esp, 4

; 3711 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN5@stbi__jpeg
$LN4@stbi__jpeg:

; 3712 :    }
; 3713 :    if (x) *x = j->s->img_x;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
$LN3@stbi__jpeg:

; 3714 :    if (y) *y = j->s->img_y;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN2@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN2@stbi__jpeg:

; 3715 :    if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN1@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 3
	jl	SHORT $LN7@stbi__jpeg
	mov	DWORD PTR tv80[ebp], 3
	jmp	SHORT $LN8@stbi__jpeg
$LN7@stbi__jpeg:
	mov	DWORD PTR tv80[ebp], 1
$LN8@stbi__jpeg:
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR tv80[ebp]
	mov	DWORD PTR [edx], eax
$LN1@stbi__jpeg:

; 3716 :    return 1;

	mov	eax, 1
$LN5@stbi__jpeg:

; 3717 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__jpeg_info_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _load_jpeg_image
_TEXT	SEGMENT
tv258 = -592						; size = 4
tv79 = -592						; size = 4
tv616 = -588						; size = 4
tv275 = -588						; size = 4
tv267 = -588						; size = 4
tv253 = -588						; size = 4
tv241 = -588						; size = 4
tv223 = -588						; size = 4
tv153 = -588						; size = 4
tv91 = -588						; size = 4
tv81 = -588						; size = 4
tv71 = -588						; size = 4
_y$1 = -388						; size = 4
_b$2 = -373						; size = 1
_g$3 = -361						; size = 1
_r$4 = -349						; size = 1
_m$5 = -337						; size = 1
_m$6 = -325						; size = 1
_m$7 = -313						; size = 1
_y$8 = -304						; size = 4
_y_bot$9 = -292						; size = 4
_r$10 = -280						; size = 4
_out$11 = -268						; size = 4
_r$12 = -256						; size = 4
_res_comp$13 = -244					; size = 128
_coutput$14 = -108					; size = 16
_output$15 = -84					; size = 4
_j$16 = -72						; size = 4
_i$17 = -60						; size = 4
_k$18 = -48						; size = 4
_is_rgb$ = -36						; size = 4
_decode_n$ = -24					; size = 4
_n$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_z$ = 8							; size = 4
_out_x$ = 12						; size = 4
_out_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_load_jpeg_image PROC					; COMDAT

; 3525 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 592				; 00000250H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-592]
	mov	ecx, 148				; 00000094H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3526 :    int n, decode_n, is_rgb;
; 3527 :    z->s->img_n = 0; // make stbi__cleanup_jpeg safe

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+8], 0

; 3528 : 
; 3529 :    // validate req_comp
; 3530 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

	cmp	DWORD PTR _req_comp$[ebp], 0
	jl	SHORT $LN78@load_jpeg_
	cmp	DWORD PTR _req_comp$[ebp], 4
	jle	SHORT $LN79@load_jpeg_
$LN78@load_jpeg_:
	push	OFFSET ??_C@_0N@KBPNPPBJ@bad?5req_comp?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN82@load_jpeg_
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN83@load_jpeg_
$LN82@load_jpeg_:
	mov	DWORD PTR tv71[ebp], 0
$LN83@load_jpeg_:
	mov	eax, DWORD PTR tv71[ebp]
	jmp	$LN80@load_jpeg_
$LN79@load_jpeg_:

; 3531 : 
; 3532 :    // load a jpeg image from whichever source, but leave in YCbCr format
; 3533 :    if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_stbi__decode_jpeg_image
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN77@load_jpeg_
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_stbi__cleanup_jpeg
	add	esp, 4
	xor	eax, eax
	jmp	$LN80@load_jpeg_
$LN77@load_jpeg_:

; 3534 : 
; 3535 :    // determine actual number of components to generate
; 3536 :    n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN86@load_jpeg_
	mov	eax, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN87@load_jpeg_
$LN86@load_jpeg_:
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+8], 3
	jl	SHORT $LN84@load_jpeg_
	mov	DWORD PTR tv79[ebp], 3
	jmp	SHORT $LN85@load_jpeg_
$LN84@load_jpeg_:
	mov	DWORD PTR tv79[ebp], 1
$LN85@load_jpeg_:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv81[ebp], eax
$LN87@load_jpeg_:
	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _n$[ebp], ecx

; 3537 : 
; 3538 :    is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 3
	jne	SHORT $LN88@load_jpeg_
	mov	edx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [edx+18412], 3
	je	SHORT $LN89@load_jpeg_
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18408], 0
	jne	SHORT $LN88@load_jpeg_
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+18404], 0
	jne	SHORT $LN88@load_jpeg_
$LN89@load_jpeg_:
	mov	DWORD PTR tv91[ebp], 1
	jmp	SHORT $LN91@load_jpeg_
$LN88@load_jpeg_:
	mov	DWORD PTR tv91[ebp], 0
$LN91@load_jpeg_:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _is_rgb$[ebp], edx

; 3539 : 
; 3540 :    if (z->s->img_n == 3 && n < 3 && !is_rgb)

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 3
	jne	SHORT $LN76@load_jpeg_
	cmp	DWORD PTR _n$[ebp], 3
	jge	SHORT $LN76@load_jpeg_
	cmp	DWORD PTR _is_rgb$[ebp], 0
	jne	SHORT $LN76@load_jpeg_

; 3541 :       decode_n = 1;

	mov	DWORD PTR _decode_n$[ebp], 1

; 3542 :    else

	jmp	SHORT $LN75@load_jpeg_
$LN76@load_jpeg_:

; 3543 :       decode_n = z->s->img_n;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _decode_n$[ebp], edx
$LN75@load_jpeg_:

; 3544 : 
; 3545 :    // resample and color-convert
; 3546 :    {
; 3547 :       int k;
; 3548 :       unsigned int i,j;
; 3549 :       stbi_uc *output;
; 3550 :       stbi_uc *coutput[4];
; 3551 : 
; 3552 :       stbi__resample res_comp[4];
; 3553 : 
; 3554 :       for (k=0; k < decode_n; ++k) {

	mov	DWORD PTR _k$18[ebp], 0
	jmp	SHORT $LN74@load_jpeg_
$LN73@load_jpeg_:
	mov	eax, DWORD PTR _k$18[ebp]
	add	eax, 1
	mov	DWORD PTR _k$18[ebp], eax
$LN74@load_jpeg_:
	mov	eax, DWORD PTR _k$18[ebp]
	cmp	eax, DWORD PTR _decode_n$[ebp]
	jge	$LN72@load_jpeg_

; 3555 :          stbi__resample *r = &res_comp[k];

	mov	eax, DWORD PTR _k$18[ebp]
	shl	eax, 5
	lea	ecx, DWORD PTR _res_comp$13[ebp+eax]
	mov	DWORD PTR _r$12[ebp], ecx

; 3556 : 
; 3557 :          // allocate line buffer big enough for upsampling off the edges
; 3558 :          // with upsample factor of 4
; 3559 :          z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	add	edx, 3
	push	edx
	call	_stbi__malloc
	add	esp, 4
	imul	ecx, DWORD PTR _k$18[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18132], eax

; 3560 :          if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

	imul	eax, DWORD PTR _k$18[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18132], 0
	jne	SHORT $LN71@load_jpeg_
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_stbi__cleanup_jpeg
	add	esp, 4
	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN92@load_jpeg_
	mov	DWORD PTR tv153[ebp], 0
	jmp	SHORT $LN93@load_jpeg_
$LN92@load_jpeg_:
	mov	DWORD PTR tv153[ebp], 0
$LN93@load_jpeg_:
	mov	eax, DWORD PTR tv153[ebp]
	jmp	$LN80@load_jpeg_
$LN71@load_jpeg_:

; 3561 : 
; 3562 :          r->hs      = z->img_h_max / z->img_comp[k].h;

	imul	ecx, DWORD PTR _k$18[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	esi, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+18052]
	cdq
	idiv	DWORD PTR [esi+ecx+18080]
	mov	ecx, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [ecx+12], eax

; 3563 :          r->vs      = z->img_v_max / z->img_comp[k].v;

	imul	ecx, DWORD PTR _k$18[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	esi, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+18056]
	cdq
	idiv	DWORD PTR [esi+ecx+18084]
	mov	ecx, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [ecx+16], eax

; 3564 :          r->ystep   = r->vs >> 1;

	mov	eax, DWORD PTR _r$12[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sar	ecx, 1
	mov	edx, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [edx+24], ecx

; 3565 :          r->w_lores = (z->s->img_x + r->hs-1) / r->hs;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _r$12[ebp]
	mov	ecx, DWORD PTR [eax+12]
	lea	eax, DWORD PTR [edx+ecx-1]
	mov	ecx, DWORD PTR _r$12[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [edx+20], eax

; 3566 :          r->ypos    = 0;

	mov	eax, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [eax+28], 0

; 3567 :          r->line0   = r->line1 = z->img_comp[k].data;

	imul	eax, DWORD PTR _k$18[ebp], 72
	mov	ecx, DWORD PTR _r$12[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+eax+18120]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _r$12[ebp]
	mov	edx, DWORD PTR _r$12[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+4], eax

; 3568 : 
; 3569 :          if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;

	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+12], 1
	jne	SHORT $LN70@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+16], 1
	jne	SHORT $LN70@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [eax], OFFSET _resample_row_1
	jmp	$LN69@load_jpeg_
$LN70@load_jpeg_:

; 3570 :          else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;

	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+12], 1
	jne	SHORT $LN68@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+16], 2
	jne	SHORT $LN68@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [eax], OFFSET _stbi__resample_row_v_2
	jmp	SHORT $LN69@load_jpeg_
$LN68@load_jpeg_:

; 3571 :          else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;

	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+12], 2
	jne	SHORT $LN66@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+16], 1
	jne	SHORT $LN66@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [eax], OFFSET _stbi__resample_row_h_2
	jmp	SHORT $LN69@load_jpeg_
$LN66@load_jpeg_:

; 3572 :          else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;

	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+12], 2
	jne	SHORT $LN64@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+16], 2
	jne	SHORT $LN64@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+18452]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN69@load_jpeg_
$LN64@load_jpeg_:

; 3573 :          else                               r->resample = stbi__resample_row_generic;

	mov	eax, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [eax], OFFSET _stbi__resample_row_generic
$LN69@load_jpeg_:

; 3574 :       }

	jmp	$LN73@load_jpeg_
$LN72@load_jpeg_:

; 3575 : 
; 3576 :       // can't error after this so, this is safe
; 3577 :       output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);

	push	1
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	call	_stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	DWORD PTR _output$15[ebp], eax

; 3578 :       if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

	cmp	DWORD PTR _output$15[ebp], 0
	jne	SHORT $LN62@load_jpeg_
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_stbi__cleanup_jpeg
	add	esp, 4
	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN94@load_jpeg_
	mov	DWORD PTR tv223[ebp], 0
	jmp	SHORT $LN95@load_jpeg_
$LN94@load_jpeg_:
	mov	DWORD PTR tv223[ebp], 0
$LN95@load_jpeg_:
	mov	eax, DWORD PTR tv223[ebp]
	jmp	$LN80@load_jpeg_
$LN62@load_jpeg_:

; 3579 : 
; 3580 :       // now go ahead and resample
; 3581 :       for (j=0; j < z->s->img_y; ++j) {

	mov	DWORD PTR _j$16[ebp], 0
	jmp	SHORT $LN61@load_jpeg_
$LN60@load_jpeg_:
	mov	eax, DWORD PTR _j$16[ebp]
	add	eax, 1
	mov	DWORD PTR _j$16[ebp], eax
$LN61@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _j$16[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	$LN59@load_jpeg_

; 3582 :          stbi_uc *out = output + n * z->s->img_x * j;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _n$[ebp]
	imul	edx, DWORD PTR [ecx]
	imul	edx, DWORD PTR _j$16[ebp]
	add	edx, DWORD PTR _output$15[ebp]
	mov	DWORD PTR _out$11[ebp], edx

; 3583 :          for (k=0; k < decode_n; ++k) {

	mov	DWORD PTR _k$18[ebp], 0
	jmp	SHORT $LN58@load_jpeg_
$LN57@load_jpeg_:
	mov	eax, DWORD PTR _k$18[ebp]
	add	eax, 1
	mov	DWORD PTR _k$18[ebp], eax
$LN58@load_jpeg_:
	mov	eax, DWORD PTR _k$18[ebp]
	cmp	eax, DWORD PTR _decode_n$[ebp]
	jge	$LN56@load_jpeg_

; 3584 :             stbi__resample *r = &res_comp[k];

	mov	eax, DWORD PTR _k$18[ebp]
	shl	eax, 5
	lea	ecx, DWORD PTR _res_comp$13[ebp+eax]
	mov	DWORD PTR _r$10[ebp], ecx

; 3585 :             int y_bot = r->ystep >= (r->vs >> 1);

	mov	eax, DWORD PTR _r$10[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sar	ecx, 1
	mov	edx, DWORD PTR _r$10[ebp]
	cmp	DWORD PTR [edx+24], ecx
	jl	SHORT $LN96@load_jpeg_
	mov	DWORD PTR tv241[ebp], 1
	jmp	SHORT $LN97@load_jpeg_
$LN96@load_jpeg_:
	mov	DWORD PTR tv241[ebp], 0
$LN97@load_jpeg_:
	mov	eax, DWORD PTR tv241[ebp]
	mov	DWORD PTR _y_bot$9[ebp], eax

; 3586 :             coutput[k] = r->resample(z->img_comp[k].linebuf,
; 3587 :                                      y_bot ? r->line1 : r->line0,
; 3588 :                                      y_bot ? r->line0 : r->line1,
; 3589 :                                      r->w_lores, r->hs);

	cmp	DWORD PTR _y_bot$9[ebp], 0
	je	SHORT $LN98@load_jpeg_
	mov	eax, DWORD PTR _r$10[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv253[ebp], ecx
	jmp	SHORT $LN99@load_jpeg_
$LN98@load_jpeg_:
	mov	edx, DWORD PTR _r$10[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv253[ebp], eax
$LN99@load_jpeg_:
	cmp	DWORD PTR _y_bot$9[ebp], 0
	je	SHORT $LN100@load_jpeg_
	mov	ecx, DWORD PTR _r$10[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv258[ebp], edx
	jmp	SHORT $LN101@load_jpeg_
$LN100@load_jpeg_:
	mov	eax, DWORD PTR _r$10[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv258[ebp], ecx
$LN101@load_jpeg_:
	mov	esi, esp
	mov	edx, DWORD PTR _r$10[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _r$10[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR tv253[ebp]
	push	eax
	mov	ecx, DWORD PTR tv258[ebp]
	push	ecx
	imul	edx, DWORD PTR _k$18[ebp], 72
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+edx+18132]
	push	ecx
	mov	edx, DWORD PTR _r$10[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _k$18[ebp]
	mov	DWORD PTR _coutput$14[ebp+ecx*4], eax

; 3590 :             if (++r->ystep >= r->vs) {

	mov	eax, DWORD PTR _r$10[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	DWORD PTR tv267[ebp], ecx
	mov	edx, DWORD PTR _r$10[ebp]
	mov	eax, DWORD PTR tv267[ebp]
	mov	DWORD PTR [edx+24], eax
	mov	ecx, DWORD PTR _r$10[ebp]
	mov	edx, DWORD PTR tv267[ebp]
	cmp	edx, DWORD PTR [ecx+16]
	jl	SHORT $LN55@load_jpeg_

; 3591 :                r->ystep = 0;

	mov	eax, DWORD PTR _r$10[ebp]
	mov	DWORD PTR [eax+24], 0

; 3592 :                r->line0 = r->line1;

	mov	eax, DWORD PTR _r$10[ebp]
	mov	ecx, DWORD PTR _r$10[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx

; 3593 :                if (++r->ypos < z->img_comp[k].y)

	mov	eax, DWORD PTR _r$10[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	DWORD PTR tv275[ebp], ecx
	mov	edx, DWORD PTR _r$10[ebp]
	mov	eax, DWORD PTR tv275[ebp]
	mov	DWORD PTR [edx+28], eax
	imul	ecx, DWORD PTR _k$18[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR tv275[ebp]
	cmp	eax, DWORD PTR [edx+ecx+18108]
	jge	SHORT $LN55@load_jpeg_

; 3594 :                   r->line1 += z->img_comp[k].w2;

	imul	eax, DWORD PTR _k$18[ebp], 72
	mov	ecx, DWORD PTR _r$10[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _z$[ebp]
	add	edx, DWORD PTR [ecx+eax+18112]
	mov	eax, DWORD PTR _r$10[ebp]
	mov	DWORD PTR [eax+8], edx
$LN55@load_jpeg_:

; 3595 :             }
; 3596 :          }

	jmp	$LN57@load_jpeg_
$LN56@load_jpeg_:

; 3597 :          if (n >= 3) {

	cmp	DWORD PTR _n$[ebp], 3
	jl	$LN53@load_jpeg_

; 3598 :             stbi_uc *y = coutput[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	DWORD PTR _y$8[ebp], edx

; 3599 :             if (z->s->img_n == 3) {

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 3
	jne	$LN52@load_jpeg_

; 3600 :                if (is_rgb) {

	cmp	DWORD PTR _is_rgb$[ebp], 0
	je	$LN51@load_jpeg_

; 3601 :                   for (i=0; i < z->s->img_x; ++i) {

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN50@load_jpeg_
$LN49@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN50@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	$LN48@load_jpeg_

; 3602 :                      out[0] = y[i];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _y$8[ebp]
	add	edx, DWORD PTR _i$17[ebp]
	mov	eax, DWORD PTR _out$11[ebp]
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR [eax+ecx], dl

; 3603 :                      out[1] = coutput[1][i];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$11[ebp]
	mov	esi, DWORD PTR _i$17[ebp]
	mov	cl, BYTE PTR [ecx+esi]
	mov	BYTE PTR [eax+edx], cl

; 3604 :                      out[2] = coutput[2][i];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _out$11[ebp]
	mov	esi, DWORD PTR _i$17[ebp]
	mov	cl, BYTE PTR [ecx+esi]
	mov	BYTE PTR [eax+edx], cl

; 3605 :                      out[3] = 255;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 3606 :                      out += n;

	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _out$11[ebp], eax

; 3607 :                   }

	jmp	$LN49@load_jpeg_
$LN48@load_jpeg_:

; 3608 :                } else {

	jmp	SHORT $LN47@load_jpeg_
$LN51@load_jpeg_:

; 3609 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _y$8[ebp]
	push	edx
	mov	eax, DWORD PTR _out$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+18448]
	call	edx
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN47@load_jpeg_:

; 3610 :                }

	jmp	$LN46@load_jpeg_
$LN52@load_jpeg_:

; 3611 :             } else if (z->s->img_n == 4) {

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 4
	jne	$LN45@load_jpeg_

; 3612 :                if (z->app14_color_transform == 0) { // CMYK

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18408], 0
	jne	$LN44@load_jpeg_

; 3613 :                   for (i=0; i < z->s->img_x; ++i) {

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN43@load_jpeg_
$LN42@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN43@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	$LN41@load_jpeg_

; 3614 :                      stbi_uc m = coutput[3][i];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR _m$7[ebp], cl

; 3615 :                      out[0] = stbi__blinn_8x8(coutput[0][i], m);

	movzx	eax, BYTE PTR _m$7[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _coutput$14[ebp+edx]
	mov	ecx, DWORD PTR _i$17[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	push	edx
	call	_stbi__blinn_8x8
	add	esp, 8
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3616 :                      out[1] = stbi__blinn_8x8(coutput[1][i], m);

	movzx	eax, BYTE PTR _m$7[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	push	ecx
	call	_stbi__blinn_8x8
	add	esp, 8
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3617 :                      out[2] = stbi__blinn_8x8(coutput[2][i], m);

	movzx	eax, BYTE PTR _m$7[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	push	ecx
	call	_stbi__blinn_8x8
	add	esp, 8
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3618 :                      out[3] = 255;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 3619 :                      out += n;

	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _out$11[ebp], eax

; 3620 :                   }

	jmp	$LN42@load_jpeg_
$LN41@load_jpeg_:

; 3621 :                } else if (z->app14_color_transform == 2) { // YCCK

	jmp	$LN40@load_jpeg_
$LN44@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18408], 2
	jne	$LN39@load_jpeg_

; 3622 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _y$8[ebp]
	push	edx
	mov	eax, DWORD PTR _out$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+18448]
	call	edx
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3623 :                   for (i=0; i < z->s->img_x; ++i) {

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN38@load_jpeg_
$LN37@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN38@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	$LN36@load_jpeg_

; 3624 :                      stbi_uc m = coutput[3][i];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR _m$6[ebp], cl

; 3625 :                      out[0] = stbi__blinn_8x8(255 - out[0], m);

	movzx	eax, BYTE PTR _m$6[ebp]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _out$11[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 255				; 000000ffH
	sub	edx, ecx
	push	edx
	call	_stbi__blinn_8x8
	add	esp, 8
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3626 :                      out[1] = stbi__blinn_8x8(255 - out[1], m);

	movzx	eax, BYTE PTR _m$6[ebp]
	push	eax
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _out$11[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	push	ecx
	call	_stbi__blinn_8x8
	add	esp, 8
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3627 :                      out[2] = stbi__blinn_8x8(255 - out[2], m);

	movzx	eax, BYTE PTR _m$6[ebp]
	push	eax
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _out$11[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	push	ecx
	call	_stbi__blinn_8x8
	add	esp, 8
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3628 :                      out += n;

	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _out$11[ebp], eax

; 3629 :                   }

	jmp	$LN37@load_jpeg_
$LN36@load_jpeg_:

; 3630 :                } else { // YCbCr + alpha?  Ignore the fourth channel for now

	jmp	SHORT $LN40@load_jpeg_
$LN39@load_jpeg_:

; 3631 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _y$8[ebp]
	push	edx
	mov	eax, DWORD PTR _out$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+18448]
	call	edx
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN40@load_jpeg_:

; 3632 :                }
; 3633 :             } else

	jmp	$LN46@load_jpeg_
$LN45@load_jpeg_:

; 3634 :                for (i=0; i < z->s->img_x; ++i) {

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN33@load_jpeg_
$LN32@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN33@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	$LN46@load_jpeg_

; 3635 :                   out[0] = out[1] = out[2] = y[i];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _y$8[ebp]
	add	ecx, DWORD PTR _i$17[ebp]
	mov	edx, DWORD PTR _out$11[ebp]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [edx+eax], cl
	mov	edx, 1
	shl	edx, 1
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	esi, DWORD PTR _out$11[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	esi, DWORD PTR _out$11[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al

; 3636 :                   out[3] = 255; // not used if n==3

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 3637 :                   out += n;

	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _out$11[ebp], eax

; 3638 :                }

	jmp	$LN32@load_jpeg_
$LN46@load_jpeg_:

; 3639 :          } else {

	jmp	$LN30@load_jpeg_
$LN53@load_jpeg_:

; 3640 :             if (is_rgb) {

	cmp	DWORD PTR _is_rgb$[ebp], 0
	je	$LN29@load_jpeg_

; 3641 :                if (n == 1)

	cmp	DWORD PTR _n$[ebp], 1
	jne	SHORT $LN28@load_jpeg_

; 3642 :                   for (i=0; i < z->s->img_x; ++i)

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN27@load_jpeg_
$LN26@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN27@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN25@load_jpeg_

; 3643 :                      *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	mov	edx, DWORD PTR _i$17[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	mov	edx, DWORD PTR _i$17[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	push	eax
	call	_stbi__compute_y
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$11[ebp]
	add	edx, 1
	mov	DWORD PTR _out$11[ebp], edx
	jmp	SHORT $LN26@load_jpeg_
$LN25@load_jpeg_:

; 3644 :                else {

	jmp	$LN24@load_jpeg_
$LN28@load_jpeg_:

; 3645 :                   for (i=0; i < z->s->img_x; ++i, out += 2) {

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN23@load_jpeg_
$LN22@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
	mov	ecx, DWORD PTR _out$11[ebp]
	add	ecx, 2
	mov	DWORD PTR _out$11[ebp], ecx
$LN23@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN24@load_jpeg_

; 3646 :                      out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	mov	edx, DWORD PTR _i$17[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	mov	edx, DWORD PTR _i$17[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	push	eax
	call	_stbi__compute_y
	add	esp, 12					; 0000000cH
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3647 :                      out[1] = 255;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 3648 :                   }

	jmp	$LN22@load_jpeg_
$LN24@load_jpeg_:

; 3649 :                }

	jmp	$LN30@load_jpeg_
$LN29@load_jpeg_:

; 3650 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 4
	jne	$LN19@load_jpeg_
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18408], 0
	jne	$LN19@load_jpeg_

; 3651 :                for (i=0; i < z->s->img_x; ++i) {

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN18@load_jpeg_
$LN17@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN18@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	$LN16@load_jpeg_

; 3652 :                   stbi_uc m = coutput[3][i];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR _m$5[ebp], cl

; 3653 :                   stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);

	movzx	eax, BYTE PTR _m$5[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _coutput$14[ebp+edx]
	mov	ecx, DWORD PTR _i$17[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	push	edx
	call	_stbi__blinn_8x8
	add	esp, 8
	mov	BYTE PTR _r$4[ebp], al

; 3654 :                   stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);

	movzx	eax, BYTE PTR _m$5[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	push	ecx
	call	_stbi__blinn_8x8
	add	esp, 8
	mov	BYTE PTR _g$3[ebp], al

; 3655 :                   stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);

	movzx	eax, BYTE PTR _m$5[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	push	ecx
	call	_stbi__blinn_8x8
	add	esp, 8
	mov	BYTE PTR _b$2[ebp], al

; 3656 :                   out[0] = stbi__compute_y(r, g, b);

	movzx	eax, BYTE PTR _b$2[ebp]
	push	eax
	movzx	ecx, BYTE PTR _g$3[ebp]
	push	ecx
	movzx	edx, BYTE PTR _r$4[ebp]
	push	edx
	call	_stbi__compute_y
	add	esp, 12					; 0000000cH
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3657 :                   out[1] = 255;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 3658 :                   out += n;

	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _out$11[ebp], eax

; 3659 :                }

	jmp	$LN17@load_jpeg_
$LN16@load_jpeg_:

; 3660 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {

	jmp	$LN30@load_jpeg_
$LN19@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 4
	jne	$LN14@load_jpeg_
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18408], 2
	jne	$LN14@load_jpeg_

; 3661 :                for (i=0; i < z->s->img_x; ++i) {

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN13@load_jpeg_
$LN12@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN13@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN11@load_jpeg_

; 3662 :                   out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	mov	edx, DWORD PTR _i$17[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	push	ecx
	call	_stbi__blinn_8x8
	add	esp, 8
	mov	edx, 1
	imul	ecx, edx, 0
	mov	edx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [edx+ecx], al

; 3663 :                   out[1] = 255;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 3664 :                   out += n;

	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _out$11[ebp], eax

; 3665 :                }

	jmp	SHORT $LN12@load_jpeg_
$LN11@load_jpeg_:

; 3666 :             } else {

	jmp	$LN30@load_jpeg_
$LN14@load_jpeg_:

; 3667 :                stbi_uc *y = coutput[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	DWORD PTR _y$1[ebp], edx

; 3668 :                if (n == 1)

	cmp	DWORD PTR _n$[ebp], 1
	jne	SHORT $LN9@load_jpeg_

; 3669 :                   for (i=0; i < z->s->img_x; ++i) out[i] = y[i];

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN8@load_jpeg_
$LN7@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN8@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN6@load_jpeg_
	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, DWORD PTR _i$17[ebp]
	mov	ecx, DWORD PTR _y$1[ebp]
	add	ecx, DWORD PTR _i$17[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN7@load_jpeg_
$LN6@load_jpeg_:

; 3670 :                else

	jmp	SHORT $LN30@load_jpeg_
$LN9@load_jpeg_:

; 3671 :                   for (i=0; i < z->s->img_x; ++i) *out++ = y[i], *out++ = 255;

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN4@load_jpeg_
$LN3@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN4@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN30@load_jpeg_
	mov	eax, DWORD PTR _y$1[ebp]
	add	eax, DWORD PTR _i$17[ebp]
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, 1
	mov	DWORD PTR _out$11[ebp], eax
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	edx, DWORD PTR _out$11[ebp]
	add	edx, 1
	mov	DWORD PTR _out$11[ebp], edx
	jmp	SHORT $LN3@load_jpeg_
$LN30@load_jpeg_:

; 3672 :             }
; 3673 :          }
; 3674 :       }

	jmp	$LN60@load_jpeg_
$LN59@load_jpeg_:

; 3675 :       stbi__cleanup_jpeg(z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_stbi__cleanup_jpeg
	add	esp, 4

; 3676 :       *out_x = z->s->img_x;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _out_x$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 3677 :       *out_y = z->s->img_y;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _out_y$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax

; 3678 :       if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN1@load_jpeg_
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 3
	jl	SHORT $LN102@load_jpeg_
	mov	DWORD PTR tv616[ebp], 3
	jmp	SHORT $LN103@load_jpeg_
$LN102@load_jpeg_:
	mov	DWORD PTR tv616[ebp], 1
$LN103@load_jpeg_:
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR tv616[ebp]
	mov	DWORD PTR [edx], eax
$LN1@load_jpeg_:

; 3679 :       return output;

	mov	eax, DWORD PTR _output$15[ebp]
$LN80@load_jpeg_:

; 3680 :    }
; 3681 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN107@load_jpeg_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 592				; 00000250H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN107@load_jpeg_:
	DD	2
	DD	$LN106@load_jpeg_
$LN106@load_jpeg_:
	DD	-108					; ffffff94H
	DD	16					; 00000010H
	DD	$LN104@load_jpeg_
	DD	-244					; ffffff0cH
	DD	128					; 00000080H
	DD	$LN105@load_jpeg_
$LN105@load_jpeg_:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
$LN104@load_jpeg_:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
_load_jpeg_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__blinn_8x8
_TEXT	SEGMENT
_t$ = -8						; size = 4
_x$ = 8							; size = 1
_y$ = 12						; size = 1
_stbi__blinn_8x8 PROC					; COMDAT

; 3519 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3520 :    unsigned int t = x*y + 128;

	movzx	eax, BYTE PTR _x$[ebp]
	movzx	ecx, BYTE PTR _y$[ebp]
	imul	eax, ecx
	add	eax, 128				; 00000080H
	mov	DWORD PTR _t$[ebp], eax

; 3521 :    return (stbi_uc) ((t + (t >>8)) >> 8);

	mov	eax, DWORD PTR _t$[ebp]
	shr	eax, 8
	add	eax, DWORD PTR _t$[ebp]
	shr	eax, 8

; 3522 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__blinn_8x8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__cleanup_jpeg
_TEXT	SEGMENT
_j$ = 8							; size = 4
_stbi__cleanup_jpeg PROC				; COMDAT

; 3503 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3504 :    stbi__free_jpeg_components(j, j->s->img_n, 0);

	push	0
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__free_jpeg_components
	add	esp, 12					; 0000000cH

; 3505 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__cleanup_jpeg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__setup_jpeg
_TEXT	SEGMENT
_j$ = 8							; size = 4
_stbi__setup_jpeg PROC					; COMDAT

; 3481 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3482 :    j->idct_block_kernel = stbi__idct_block;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18444], OFFSET _stbi__idct_block

; 3483 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18448], OFFSET _stbi__YCbCr_to_RGB_row

; 3484 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18452], OFFSET _stbi__resample_row_hv_2

; 3485 : 
; 3486 : #ifdef STBI_SSE2
; 3487 :    if (stbi__sse2_available()) {

	call	_stbi__sse2_available
	test	eax, eax
	je	SHORT $LN2@stbi__setu

; 3488 :       j->idct_block_kernel = stbi__idct_simd;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18444], OFFSET _stbi__idct_simd

; 3489 :       j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18448], OFFSET _stbi__YCbCr_to_RGB_simd

; 3490 :       j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18452], OFFSET _stbi__resample_row_hv_2_simd
$LN2@stbi__setu:

; 3491 :    }
; 3492 : #endif
; 3493 : 
; 3494 : #ifdef STBI_NEON
; 3495 :    j->idct_block_kernel = stbi__idct_simd;
; 3496 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3497 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3498 : #endif
; 3499 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__setup_jpeg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__YCbCr_to_RGB_simd
_TEXT	SEGMENT
_cb$1 = -1128						; size = 4
_cr$2 = -1116						; size = 4
_b$3 = -1104						; size = 4
_g$4 = -1092						; size = 4
_r$5 = -1080						; size = 4
_y_fixed$6 = -1068					; size = 4
_o1$7 = -1056						; size = 16
_o0$8 = -1024						; size = 16
_t1$9 = -992						; size = 16
_t0$10 = -960						; size = 16
_gxb$11 = -928						; size = 16
_brb$12 = -896						; size = 16
_gw$13 = -864						; size = 16
_bw$14 = -832						; size = 16
_rw$15 = -800						; size = 16
_gws$16 = -768						; size = 16
_bws$17 = -736						; size = 16
_gwt$18 = -704						; size = 16
_rws$19 = -672						; size = 16
_cr1$20 = -640						; size = 16
_cb1$21 = -608						; size = 16
_cb0$22 = -576						; size = 16
_cr0$23 = -544						; size = 16
_yws$24 = -512						; size = 16
_cbw$25 = -480						; size = 16
_crw$26 = -448						; size = 16
_yw$27 = -416						; size = 16
_cb_biased$28 = -384					; size = 16
_cr_biased$29 = -352					; size = 16
_cb_bytes$30 = -320					; size = 16
_cr_bytes$31 = -288					; size = 16
_y_bytes$32 = -256					; size = 16
_xw$33 = -224						; size = 16
_y_bias$34 = -192					; size = 16
_cb_const1$35 = -160					; size = 16
_cb_const0$36 = -128					; size = 16
_cr_const1$37 = -96					; size = 16
_cr_const0$38 = -64					; size = 16
_signflip$39 = -32					; size = 16
_i$ = -8						; size = 4
_out$ = 8						; size = 4
_y$ = 12						; size = 4
_pcb$ = 16						; size = 4
_pcr$ = 20						; size = 4
_count$ = 24						; size = 4
_step$ = 28						; size = 4
_stbi__YCbCr_to_RGB_simd PROC				; COMDAT

; 3346 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 1336				; 00000538H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1336]
	mov	ecx, 334				; 0000014eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3347 :    int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 3348 : 
; 3349 : #ifdef STBI_SSE2
; 3350 :    // step == 3 is pretty ugly on the final interleave, and i'm not convinced
; 3351 :    // it's useful in practice (you wouldn't use it for textures, for example).
; 3352 :    // so just accelerate step == 4 case.
; 3353 :    if (step == 4) {

	cmp	DWORD PTR _step$[ebx], 4
	jne	$LN16@stbi__YCbC

; 3354 :       // this is a fairly straightforward implementation and not super-optimized.
; 3355 :       __m128i signflip  = _mm_set1_epi8(-0x80);

	movdqa	xmm0, XMMWORD PTR __xmm@80808080808080808080808080808080
	movdqa	XMMWORD PTR _signflip$39[ebp], xmm0

; 3356 :       __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));

	movdqa	xmm0, XMMWORD PTR __xmm@166f166f166f166f166f166f166f166f
	movdqa	XMMWORD PTR _cr_const0$38[ebp], xmm0

; 3357 :       __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));

	movdqa	xmm0, XMMWORD PTR __xmm@f493f493f493f493f493f493f493f493
	movdqa	XMMWORD PTR _cr_const1$37[ebp], xmm0

; 3358 :       __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));

	movdqa	xmm0, XMMWORD PTR __xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
	movdqa	XMMWORD PTR _cb_const0$36[ebp], xmm0

; 3359 :       __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));

	movdqa	xmm0, XMMWORD PTR __xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
	movdqa	XMMWORD PTR _cb_const1$35[ebp], xmm0

; 3360 :       __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);

	movdqa	xmm0, XMMWORD PTR __xmm@80808080808080808080808080808080
	movdqa	XMMWORD PTR _y_bias$34[ebp], xmm0

; 3361 :       __m128i xw = _mm_set1_epi16(255); // alpha channel

	movdqa	xmm0, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	movdqa	XMMWORD PTR _xw$33[ebp], xmm0

; 3362 : 
; 3363 :       for (; i+7 < count; i += 8) {

	jmp	SHORT $LN15@stbi__YCbC
$LN14@stbi__YCbC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 8
	mov	DWORD PTR _i$[ebp], eax
$LN15@stbi__YCbC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 7
	cmp	eax, DWORD PTR _count$[ebx]
	jge	$LN16@stbi__YCbC

; 3364 :          // load
; 3365 :          __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));

	mov	eax, DWORD PTR _y$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movdqa	XMMWORD PTR _y_bytes$32[ebp], xmm0

; 3366 :          __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));

	mov	eax, DWORD PTR _pcr$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movdqa	XMMWORD PTR _cr_bytes$31[ebp], xmm0

; 3367 :          __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));

	mov	eax, DWORD PTR _pcb$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movdqa	XMMWORD PTR _cb_bytes$30[ebp], xmm0

; 3368 :          __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128

	movdqa	xmm0, XMMWORD PTR _cr_bytes$31[ebp]
	pxor	xmm0, XMMWORD PTR _signflip$39[ebp]
	movdqa	XMMWORD PTR _cr_biased$29[ebp], xmm0

; 3369 :          __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

	movdqa	xmm0, XMMWORD PTR _cb_bytes$30[ebp]
	pxor	xmm0, XMMWORD PTR _signflip$39[ebp]
	movdqa	XMMWORD PTR _cb_biased$28[ebp], xmm0

; 3370 : 
; 3371 :          // unpack to short (and left-shift cr, cb by 8)
; 3372 :          __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);

	movdqa	xmm0, XMMWORD PTR _y_bias$34[ebp]
	punpcklbw xmm0, XMMWORD PTR _y_bytes$32[ebp]
	movdqa	XMMWORD PTR _yw$27[ebp], xmm0

; 3373 :          __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);

	pxor	xmm0, xmm0
	punpcklbw xmm0, XMMWORD PTR _cr_biased$29[ebp]
	movdqa	XMMWORD PTR _crw$26[ebp], xmm0

; 3374 :          __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

	pxor	xmm0, xmm0
	punpcklbw xmm0, XMMWORD PTR _cb_biased$28[ebp]
	movdqa	XMMWORD PTR _cbw$25[ebp], xmm0

; 3375 : 
; 3376 :          // color transform
; 3377 :          __m128i yws = _mm_srli_epi16(yw, 4);

	movdqa	xmm0, XMMWORD PTR _yw$27[ebp]
	psrlw	xmm0, 4
	movdqa	XMMWORD PTR _yws$24[ebp], xmm0

; 3378 :          __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);

	movdqa	xmm0, XMMWORD PTR _cr_const0$38[ebp]
	pmulhw	xmm0, XMMWORD PTR _crw$26[ebp]
	movdqa	XMMWORD PTR _cr0$23[ebp], xmm0

; 3379 :          __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);

	movdqa	xmm0, XMMWORD PTR _cb_const0$36[ebp]
	pmulhw	xmm0, XMMWORD PTR _cbw$25[ebp]
	movdqa	XMMWORD PTR _cb0$22[ebp], xmm0

; 3380 :          __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);

	movdqa	xmm0, XMMWORD PTR _cbw$25[ebp]
	pmulhw	xmm0, XMMWORD PTR _cb_const1$35[ebp]
	movdqa	XMMWORD PTR _cb1$21[ebp], xmm0

; 3381 :          __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);

	movdqa	xmm0, XMMWORD PTR _crw$26[ebp]
	pmulhw	xmm0, XMMWORD PTR _cr_const1$37[ebp]
	movdqa	XMMWORD PTR _cr1$20[ebp], xmm0

; 3382 :          __m128i rws = _mm_add_epi16(cr0, yws);

	movdqa	xmm0, XMMWORD PTR _cr0$23[ebp]
	paddw	xmm0, XMMWORD PTR _yws$24[ebp]
	movdqa	XMMWORD PTR _rws$19[ebp], xmm0

; 3383 :          __m128i gwt = _mm_add_epi16(cb0, yws);

	movdqa	xmm0, XMMWORD PTR _cb0$22[ebp]
	paddw	xmm0, XMMWORD PTR _yws$24[ebp]
	movdqa	XMMWORD PTR _gwt$18[ebp], xmm0

; 3384 :          __m128i bws = _mm_add_epi16(yws, cb1);

	movdqa	xmm0, XMMWORD PTR _yws$24[ebp]
	paddw	xmm0, XMMWORD PTR _cb1$21[ebp]
	movdqa	XMMWORD PTR _bws$17[ebp], xmm0

; 3385 :          __m128i gws = _mm_add_epi16(gwt, cr1);

	movdqa	xmm0, XMMWORD PTR _gwt$18[ebp]
	paddw	xmm0, XMMWORD PTR _cr1$20[ebp]
	movdqa	XMMWORD PTR _gws$16[ebp], xmm0

; 3386 : 
; 3387 :          // descale
; 3388 :          __m128i rw = _mm_srai_epi16(rws, 4);

	movdqa	xmm0, XMMWORD PTR _rws$19[ebp]
	psraw	xmm0, 4
	movdqa	XMMWORD PTR _rw$15[ebp], xmm0

; 3389 :          __m128i bw = _mm_srai_epi16(bws, 4);

	movdqa	xmm0, XMMWORD PTR _bws$17[ebp]
	psraw	xmm0, 4
	movdqa	XMMWORD PTR _bw$14[ebp], xmm0

; 3390 :          __m128i gw = _mm_srai_epi16(gws, 4);

	movdqa	xmm0, XMMWORD PTR _gws$16[ebp]
	psraw	xmm0, 4
	movdqa	XMMWORD PTR _gw$13[ebp], xmm0

; 3391 : 
; 3392 :          // back to byte, set up for transpose
; 3393 :          __m128i brb = _mm_packus_epi16(rw, bw);

	movdqa	xmm0, XMMWORD PTR _rw$15[ebp]
	packuswb xmm0, XMMWORD PTR _bw$14[ebp]
	movdqa	XMMWORD PTR _brb$12[ebp], xmm0

; 3394 :          __m128i gxb = _mm_packus_epi16(gw, xw);

	movdqa	xmm0, XMMWORD PTR _gw$13[ebp]
	packuswb xmm0, XMMWORD PTR _xw$33[ebp]
	movdqa	XMMWORD PTR _gxb$11[ebp], xmm0

; 3395 : 
; 3396 :          // transpose to interleave channels
; 3397 :          __m128i t0 = _mm_unpacklo_epi8(brb, gxb);

	movdqa	xmm0, XMMWORD PTR _brb$12[ebp]
	punpcklbw xmm0, XMMWORD PTR _gxb$11[ebp]
	movdqa	XMMWORD PTR _t0$10[ebp], xmm0

; 3398 :          __m128i t1 = _mm_unpackhi_epi8(brb, gxb);

	movdqa	xmm0, XMMWORD PTR _brb$12[ebp]
	punpckhbw xmm0, XMMWORD PTR _gxb$11[ebp]
	movdqa	XMMWORD PTR _t1$9[ebp], xmm0

; 3399 :          __m128i o0 = _mm_unpacklo_epi16(t0, t1);

	movdqa	xmm0, XMMWORD PTR _t0$10[ebp]
	punpcklwd xmm0, XMMWORD PTR _t1$9[ebp]
	movdqa	XMMWORD PTR _o0$8[ebp], xmm0

; 3400 :          __m128i o1 = _mm_unpackhi_epi16(t0, t1);

	movdqa	xmm0, XMMWORD PTR _t0$10[ebp]
	punpckhwd xmm0, XMMWORD PTR _t1$9[ebp]
	movdqa	XMMWORD PTR _o1$7[ebp], xmm0

; 3401 : 
; 3402 :          // store
; 3403 :          _mm_storeu_si128((__m128i *) (out + 0), o0);

	movdqu	xmm0, XMMWORD PTR _o0$8[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	movdqu	XMMWORD PTR [eax], xmm0

; 3404 :          _mm_storeu_si128((__m128i *) (out + 16), o1);

	movdqu	xmm0, XMMWORD PTR _o1$7[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, 16					; 00000010H
	movdqu	XMMWORD PTR [eax], xmm0

; 3405 :          out += 32;

	mov	eax, DWORD PTR _out$[ebx]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _out$[ebx], eax

; 3406 :       }

	jmp	$LN14@stbi__YCbC
$LN16@stbi__YCbC:

; 3407 :    }
; 3408 : #endif
; 3409 : 
; 3410 : #ifdef STBI_NEON
; 3411 :    // in this version, step=3 support would be easy to add. but is there demand?
; 3412 :    if (step == 4) {
; 3413 :       // this is a fairly straightforward implementation and not super-optimized.
; 3414 :       uint8x8_t signflip = vdup_n_u8(0x80);
; 3415 :       int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3416 :       int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3417 :       int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3418 :       int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3419 : 
; 3420 :       for (; i+7 < count; i += 8) {
; 3421 :          // load
; 3422 :          uint8x8_t y_bytes  = vld1_u8(y + i);
; 3423 :          uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3424 :          uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3425 :          int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3426 :          int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3427 : 
; 3428 :          // expand to s16
; 3429 :          int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3430 :          int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3431 :          int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3432 : 
; 3433 :          // color transform
; 3434 :          int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3435 :          int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3436 :          int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3437 :          int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3438 :          int16x8_t rws = vaddq_s16(yws, cr0);
; 3439 :          int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3440 :          int16x8_t bws = vaddq_s16(yws, cb1);
; 3441 : 
; 3442 :          // undo scaling, round, convert to byte
; 3443 :          uint8x8x4_t o;
; 3444 :          o.val[0] = vqrshrun_n_s16(rws, 4);
; 3445 :          o.val[1] = vqrshrun_n_s16(gws, 4);
; 3446 :          o.val[2] = vqrshrun_n_s16(bws, 4);
; 3447 :          o.val[3] = vdup_n_u8(255);
; 3448 : 
; 3449 :          // store, interleaving r/g/b/a
; 3450 :          vst4_u8(out, o);
; 3451 :          out += 8*4;
; 3452 :       }
; 3453 :    }
; 3454 : #endif
; 3455 : 
; 3456 :    for (; i < count; ++i) {

	jmp	SHORT $LN12@stbi__YCbC
$LN11@stbi__YCbC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@stbi__YCbC:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebx]
	jge	$LN17@stbi__YCbC

; 3457 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding

	mov	eax, DWORD PTR _y$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 20					; 00000014H
	add	ecx, 524288				; 00080000H
	mov	DWORD PTR _y_fixed$6[ebp], ecx

; 3458 :       int r,g,b;
; 3459 :       int cr = pcr[i] - 128;

	mov	eax, DWORD PTR _pcr$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	ecx, 128				; 00000080H
	mov	DWORD PTR _cr$2[ebp], ecx

; 3460 :       int cb = pcb[i] - 128;

	mov	eax, DWORD PTR _pcb$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	ecx, 128				; 00000080H
	mov	DWORD PTR _cb$1[ebp], ecx

; 3461 :       r = y_fixed + cr* stbi__float2fixed(1.40200f);

	imul	eax, DWORD PTR _cr$2[ebp], 1470208
	add	eax, DWORD PTR _y_fixed$6[ebp]
	mov	DWORD PTR _r$5[ebp], eax

; 3462 :       g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);

	imul	eax, DWORD PTR _cr$2[ebp], -748800
	add	eax, DWORD PTR _y_fixed$6[ebp]
	imul	ecx, DWORD PTR _cb$1[ebp], -360960
	and	ecx, -65536				; ffff0000H
	add	eax, ecx
	mov	DWORD PTR _g$4[ebp], eax

; 3463 :       b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);

	imul	eax, DWORD PTR _cb$1[ebp], 1858048
	add	eax, DWORD PTR _y_fixed$6[ebp]
	mov	DWORD PTR _b$3[ebp], eax

; 3464 :       r >>= 20;

	mov	eax, DWORD PTR _r$5[ebp]
	sar	eax, 20					; 00000014H
	mov	DWORD PTR _r$5[ebp], eax

; 3465 :       g >>= 20;

	mov	eax, DWORD PTR _g$4[ebp]
	sar	eax, 20					; 00000014H
	mov	DWORD PTR _g$4[ebp], eax

; 3466 :       b >>= 20;

	mov	eax, DWORD PTR _b$3[ebp]
	sar	eax, 20					; 00000014H
	mov	DWORD PTR _b$3[ebp], eax

; 3467 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }

	cmp	DWORD PTR _r$5[ebp], 255		; 000000ffH
	jbe	SHORT $LN9@stbi__YCbC
	cmp	DWORD PTR _r$5[ebp], 0
	jge	SHORT $LN8@stbi__YCbC
	mov	DWORD PTR _r$5[ebp], 0
	jmp	SHORT $LN9@stbi__YCbC
$LN8@stbi__YCbC:
	mov	DWORD PTR _r$5[ebp], 255		; 000000ffH
$LN9@stbi__YCbC:

; 3468 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }

	cmp	DWORD PTR _g$4[ebp], 255		; 000000ffH
	jbe	SHORT $LN6@stbi__YCbC
	cmp	DWORD PTR _g$4[ebp], 0
	jge	SHORT $LN5@stbi__YCbC
	mov	DWORD PTR _g$4[ebp], 0
	jmp	SHORT $LN6@stbi__YCbC
$LN5@stbi__YCbC:
	mov	DWORD PTR _g$4[ebp], 255		; 000000ffH
$LN6@stbi__YCbC:

; 3469 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }

	cmp	DWORD PTR _b$3[ebp], 255		; 000000ffH
	jbe	SHORT $LN3@stbi__YCbC
	cmp	DWORD PTR _b$3[ebp], 0
	jge	SHORT $LN2@stbi__YCbC
	mov	DWORD PTR _b$3[ebp], 0
	jmp	SHORT $LN3@stbi__YCbC
$LN2@stbi__YCbC:
	mov	DWORD PTR _b$3[ebp], 255		; 000000ffH
$LN3@stbi__YCbC:

; 3470 :       out[0] = (stbi_uc)r;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebx]
	mov	al, BYTE PTR _r$5[ebp]
	mov	BYTE PTR [edx+ecx], al

; 3471 :       out[1] = (stbi_uc)g;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebx]
	mov	dl, BYTE PTR _g$4[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 3472 :       out[2] = (stbi_uc)b;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebx]
	mov	dl, BYTE PTR _b$3[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 3473 :       out[3] = 255;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$[ebx]
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 3474 :       out += step;

	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _step$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 3475 :    }

	jmp	$LN11@stbi__YCbC
$LN17@stbi__YCbC:

; 3476 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
_stbi__YCbCr_to_RGB_simd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__YCbCr_to_RGB_row
_TEXT	SEGMENT
_cb$1 = -80						; size = 4
_cr$2 = -68						; size = 4
_b$3 = -56						; size = 4
_g$4 = -44						; size = 4
_r$5 = -32						; size = 4
_y_fixed$6 = -20					; size = 4
_i$ = -8						; size = 4
_out$ = 8						; size = 4
_y$ = 12						; size = 4
_pcb$ = 16						; size = 4
_pcr$ = 20						; size = 4
_count$ = 24						; size = 4
_step$ = 28						; size = 4
_stbi__YCbCr_to_RGB_row PROC				; COMDAT

; 3320 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3321 :    int i;
; 3322 :    for (i=0; i < count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@stbi__YCbC
$LN11@stbi__YCbC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@stbi__YCbC:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN13@stbi__YCbC

; 3323 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 20					; 00000014H
	add	ecx, 524288				; 00080000H
	mov	DWORD PTR _y_fixed$6[ebp], ecx

; 3324 :       int r,g,b;
; 3325 :       int cr = pcr[i] - 128;

	mov	eax, DWORD PTR _pcr$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	ecx, 128				; 00000080H
	mov	DWORD PTR _cr$2[ebp], ecx

; 3326 :       int cb = pcb[i] - 128;

	mov	eax, DWORD PTR _pcb$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	ecx, 128				; 00000080H
	mov	DWORD PTR _cb$1[ebp], ecx

; 3327 :       r = y_fixed +  cr* stbi__float2fixed(1.40200f);

	imul	eax, DWORD PTR _cr$2[ebp], 1470208
	add	eax, DWORD PTR _y_fixed$6[ebp]
	mov	DWORD PTR _r$5[ebp], eax

; 3328 :       g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);

	imul	eax, DWORD PTR _cr$2[ebp], -748800
	add	eax, DWORD PTR _y_fixed$6[ebp]
	imul	ecx, DWORD PTR _cb$1[ebp], -360960
	and	ecx, -65536				; ffff0000H
	add	eax, ecx
	mov	DWORD PTR _g$4[ebp], eax

; 3329 :       b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);

	imul	eax, DWORD PTR _cb$1[ebp], 1858048
	add	eax, DWORD PTR _y_fixed$6[ebp]
	mov	DWORD PTR _b$3[ebp], eax

; 3330 :       r >>= 20;

	mov	eax, DWORD PTR _r$5[ebp]
	sar	eax, 20					; 00000014H
	mov	DWORD PTR _r$5[ebp], eax

; 3331 :       g >>= 20;

	mov	eax, DWORD PTR _g$4[ebp]
	sar	eax, 20					; 00000014H
	mov	DWORD PTR _g$4[ebp], eax

; 3332 :       b >>= 20;

	mov	eax, DWORD PTR _b$3[ebp]
	sar	eax, 20					; 00000014H
	mov	DWORD PTR _b$3[ebp], eax

; 3333 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }

	cmp	DWORD PTR _r$5[ebp], 255		; 000000ffH
	jbe	SHORT $LN9@stbi__YCbC
	cmp	DWORD PTR _r$5[ebp], 0
	jge	SHORT $LN8@stbi__YCbC
	mov	DWORD PTR _r$5[ebp], 0
	jmp	SHORT $LN9@stbi__YCbC
$LN8@stbi__YCbC:
	mov	DWORD PTR _r$5[ebp], 255		; 000000ffH
$LN9@stbi__YCbC:

; 3334 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }

	cmp	DWORD PTR _g$4[ebp], 255		; 000000ffH
	jbe	SHORT $LN6@stbi__YCbC
	cmp	DWORD PTR _g$4[ebp], 0
	jge	SHORT $LN5@stbi__YCbC
	mov	DWORD PTR _g$4[ebp], 0
	jmp	SHORT $LN6@stbi__YCbC
$LN5@stbi__YCbC:
	mov	DWORD PTR _g$4[ebp], 255		; 000000ffH
$LN6@stbi__YCbC:

; 3335 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }

	cmp	DWORD PTR _b$3[ebp], 255		; 000000ffH
	jbe	SHORT $LN3@stbi__YCbC
	cmp	DWORD PTR _b$3[ebp], 0
	jge	SHORT $LN2@stbi__YCbC
	mov	DWORD PTR _b$3[ebp], 0
	jmp	SHORT $LN3@stbi__YCbC
$LN2@stbi__YCbC:
	mov	DWORD PTR _b$3[ebp], 255		; 000000ffH
$LN3@stbi__YCbC:

; 3336 :       out[0] = (stbi_uc)r;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR _r$5[ebp]
	mov	BYTE PTR [edx+ecx], al

; 3337 :       out[1] = (stbi_uc)g;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR _g$4[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 3338 :       out[2] = (stbi_uc)b;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR _b$3[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 3339 :       out[3] = 255;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 3340 :       out += step;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _step$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 3341 :    }

	jmp	$LN11@stbi__YCbC
$LN13@stbi__YCbC:

; 3342 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__YCbCr_to_RGB_row ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__resample_row_generic
_TEXT	SEGMENT
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
_stbi__resample_row_generic PROC			; COMDAT

; 3306 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3307 :    // resample with nearest-neighbor
; 3308 :    int i,j;
; 3309 :    STBI_NOTUSED(in_far);
; 3310 :    for (i=0; i < w; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@stbi__resa
$LN5@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _w$[ebp]
	jge	SHORT $LN4@stbi__resa

; 3311 :       for (j=0; j < hs; ++j)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN3@stbi__resa
$LN2@stbi__resa:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN3@stbi__resa:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _hs$[ebp]
	jge	SHORT $LN1@stbi__resa

; 3312 :          out[i*hs+j] = in_near[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _hs$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in_near$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [edx+eax], cl
	jmp	SHORT $LN2@stbi__resa
$LN1@stbi__resa:
	jmp	SHORT $LN5@stbi__resa
$LN4@stbi__resa:

; 3313 :    return out;

	mov	eax, DWORD PTR _out$[ebp]

; 3314 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__resample_row_generic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__resample_row_hv_2_simd
_TEXT	SEGMENT
tv78 = -1000						; size = 4
_outv$1 = -800						; size = 16
_de1$2 = -768						; size = 16
_de0$3 = -736						; size = 16
_int1$4 = -704						; size = 16
_int0$5 = -672						; size = 16
_odd$6 = -640						; size = 16
_even$7 = -608						; size = 16
_curb$8 = -576						; size = 16
_nxtd$9 = -544						; size = 16
_prvd$10 = -512						; size = 16
_curs$11 = -480						; size = 16
_bias$12 = -448						; size = 16
_next$13 = -416						; size = 16
_prev$14 = -384						; size = 16
_nxt0$15 = -352						; size = 16
_prv0$16 = -320						; size = 16
_curr$17 = -288						; size = 16
_nears$18 = -256					; size = 16
_diff$19 = -224						; size = 16
_nearw$20 = -192					; size = 16
_farw$21 = -160						; size = 16
_nearb$22 = -128					; size = 16
_farb$23 = -96						; size = 16
_zero$24 = -64						; size = 16
_t1$ = -32						; size = 4
_t0$ = -20						; size = 4
_i$ = -8						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
_stbi__resample_row_hv_2_simd PROC			; COMDAT

; 3190 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 1000				; 000003e8H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1000]
	mov	ecx, 250				; 000000faH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3191 :    // need to generate 2x2 samples for every one in input
; 3192 :    int i=0,t0,t1;

	mov	DWORD PTR _i$[ebp], 0

; 3193 : 
; 3194 :    if (w == 1) {

	cmp	DWORD PTR _w$[ebx], 1
	jne	SHORT $LN7@stbi__resa

; 3195 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in_near$[ebx]
	movzx	eax, BYTE PTR [edx+ecx]
	imul	ecx, eax, 3
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _in_far$[ebx]
	movzx	eax, BYTE PTR [edx+eax]
	lea	ecx, DWORD PTR [ecx+eax+2]
	sar	ecx, 2
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebx]
	mov	cl, BYTE PTR tv78[ebp]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _out$[ebx]
	mov	dl, BYTE PTR tv78[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 3196 :       return out;

	mov	eax, DWORD PTR _out$[ebx]
	jmp	$LN8@stbi__resa
$LN7@stbi__resa:

; 3197 :    }
; 3198 : 
; 3199 :    t1 = 3*in_near[0] + in_far[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in_near$[ebx]
	movzx	eax, BYTE PTR [edx+ecx]
	imul	ecx, eax, 3
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _in_far$[ebx]
	movzx	eax, BYTE PTR [edx+eax]
	add	ecx, eax
	mov	DWORD PTR _t1$[ebp], ecx

; 3200 :    // process groups of 8 pixels for as long as we can.
; 3201 :    // note we can't handle the last pixel in a row in this loop
; 3202 :    // because we need to handle the filter boundary conditions.
; 3203 :    for (; i < ((w-1) & ~7); i += 8) {

	jmp	SHORT $LN6@stbi__resa
$LN5@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 8
	mov	DWORD PTR _i$[ebp], eax
$LN6@stbi__resa:
	mov	eax, DWORD PTR _w$[ebx]
	sub	eax, 1
	and	eax, -8					; fffffff8H
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN4@stbi__resa

; 3204 : #if defined(STBI_SSE2)
; 3205 :       // load and perform the vertical filtering pass
; 3206 :       // this uses 3*x + y = 4*x + (y - x)
; 3207 :       __m128i zero  = _mm_setzero_si128();

	pxor	xmm0, xmm0
	movdqa	XMMWORD PTR _zero$24[ebp], xmm0

; 3208 :       __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));

	mov	eax, DWORD PTR _in_far$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movdqa	XMMWORD PTR _farb$23[ebp], xmm0

; 3209 :       __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));

	mov	eax, DWORD PTR _in_near$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movdqa	XMMWORD PTR _nearb$22[ebp], xmm0

; 3210 :       __m128i farw  = _mm_unpacklo_epi8(farb, zero);

	movdqa	xmm0, XMMWORD PTR _farb$23[ebp]
	punpcklbw xmm0, XMMWORD PTR _zero$24[ebp]
	movdqa	XMMWORD PTR _farw$21[ebp], xmm0

; 3211 :       __m128i nearw = _mm_unpacklo_epi8(nearb, zero);

	movdqa	xmm0, XMMWORD PTR _nearb$22[ebp]
	punpcklbw xmm0, XMMWORD PTR _zero$24[ebp]
	movdqa	XMMWORD PTR _nearw$20[ebp], xmm0

; 3212 :       __m128i diff  = _mm_sub_epi16(farw, nearw);

	movdqa	xmm0, XMMWORD PTR _farw$21[ebp]
	psubw	xmm0, XMMWORD PTR _nearw$20[ebp]
	movdqa	XMMWORD PTR _diff$19[ebp], xmm0

; 3213 :       __m128i nears = _mm_slli_epi16(nearw, 2);

	movdqa	xmm0, XMMWORD PTR _nearw$20[ebp]
	psllw	xmm0, 2
	movdqa	XMMWORD PTR _nears$18[ebp], xmm0

; 3214 :       __m128i curr  = _mm_add_epi16(nears, diff); // current row

	movdqa	xmm0, XMMWORD PTR _nears$18[ebp]
	paddw	xmm0, XMMWORD PTR _diff$19[ebp]
	movdqa	XMMWORD PTR _curr$17[ebp], xmm0

; 3215 : 
; 3216 :       // horizontal filter works the same based on shifted vers of current
; 3217 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3218 :       // insert the previous pixel value (from t1).
; 3219 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3220 :       // of next block of 8 pixels added in.
; 3221 :       __m128i prv0 = _mm_slli_si128(curr, 2);

	movdqa	xmm0, XMMWORD PTR _curr$17[ebp]
	pslldq	xmm0, 2
	movdqa	XMMWORD PTR _prv0$16[ebp], xmm0

; 3222 :       __m128i nxt0 = _mm_srli_si128(curr, 2);

	movdqa	xmm0, XMMWORD PTR _curr$17[ebp]
	psrldq	xmm0, 2
	movdqa	XMMWORD PTR _nxt0$15[ebp], xmm0

; 3223 :       __m128i prev = _mm_insert_epi16(prv0, t1, 0);

	movdqa	xmm0, XMMWORD PTR _prv0$16[ebp]
	pinsrw	xmm0, DWORD PTR _t1$[ebp], 0
	movdqa	XMMWORD PTR _prev$14[ebp], xmm0

; 3224 :       __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

	mov	eax, DWORD PTR _in_near$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in_far$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	add	edx, ecx
	movdqa	xmm0, XMMWORD PTR _nxt0$15[ebp]
	pinsrw	xmm0, edx, 7
	movdqa	XMMWORD PTR _next$13[ebp], xmm0

; 3225 : 
; 3226 :       // horizontal filter, polyphase implementation since it's convenient:
; 3227 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3228 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3229 :       // note the shared term.
; 3230 :       __m128i bias  = _mm_set1_epi16(8);

	movdqa	xmm0, XMMWORD PTR __xmm@00080008000800080008000800080008
	movdqa	XMMWORD PTR _bias$12[ebp], xmm0

; 3231 :       __m128i curs = _mm_slli_epi16(curr, 2);

	movdqa	xmm0, XMMWORD PTR _curr$17[ebp]
	psllw	xmm0, 2
	movdqa	XMMWORD PTR _curs$11[ebp], xmm0

; 3232 :       __m128i prvd = _mm_sub_epi16(prev, curr);

	movdqa	xmm0, XMMWORD PTR _prev$14[ebp]
	psubw	xmm0, XMMWORD PTR _curr$17[ebp]
	movdqa	XMMWORD PTR _prvd$10[ebp], xmm0

; 3233 :       __m128i nxtd = _mm_sub_epi16(next, curr);

	movdqa	xmm0, XMMWORD PTR _next$13[ebp]
	psubw	xmm0, XMMWORD PTR _curr$17[ebp]
	movdqa	XMMWORD PTR _nxtd$9[ebp], xmm0

; 3234 :       __m128i curb = _mm_add_epi16(curs, bias);

	movdqa	xmm0, XMMWORD PTR _curs$11[ebp]
	paddw	xmm0, XMMWORD PTR _bias$12[ebp]
	movdqa	XMMWORD PTR _curb$8[ebp], xmm0

; 3235 :       __m128i even = _mm_add_epi16(prvd, curb);

	movdqa	xmm0, XMMWORD PTR _prvd$10[ebp]
	paddw	xmm0, XMMWORD PTR _curb$8[ebp]
	movdqa	XMMWORD PTR _even$7[ebp], xmm0

; 3236 :       __m128i odd  = _mm_add_epi16(nxtd, curb);

	movdqa	xmm0, XMMWORD PTR _nxtd$9[ebp]
	paddw	xmm0, XMMWORD PTR _curb$8[ebp]
	movdqa	XMMWORD PTR _odd$6[ebp], xmm0

; 3237 : 
; 3238 :       // interleave even and odd pixels, then undo scaling.
; 3239 :       __m128i int0 = _mm_unpacklo_epi16(even, odd);

	movdqa	xmm0, XMMWORD PTR _even$7[ebp]
	punpcklwd xmm0, XMMWORD PTR _odd$6[ebp]
	movdqa	XMMWORD PTR _int0$5[ebp], xmm0

; 3240 :       __m128i int1 = _mm_unpackhi_epi16(even, odd);

	movdqa	xmm0, XMMWORD PTR _even$7[ebp]
	punpckhwd xmm0, XMMWORD PTR _odd$6[ebp]
	movdqa	XMMWORD PTR _int1$4[ebp], xmm0

; 3241 :       __m128i de0  = _mm_srli_epi16(int0, 4);

	movdqa	xmm0, XMMWORD PTR _int0$5[ebp]
	psrlw	xmm0, 4
	movdqa	XMMWORD PTR _de0$3[ebp], xmm0

; 3242 :       __m128i de1  = _mm_srli_epi16(int1, 4);

	movdqa	xmm0, XMMWORD PTR _int1$4[ebp]
	psrlw	xmm0, 4
	movdqa	XMMWORD PTR _de1$2[ebp], xmm0

; 3243 : 
; 3244 :       // pack and write output
; 3245 :       __m128i outv = _mm_packus_epi16(de0, de1);

	movdqa	xmm0, XMMWORD PTR _de0$3[ebp]
	packuswb xmm0, XMMWORD PTR _de1$2[ebp]
	movdqa	XMMWORD PTR _outv$1[ebp], xmm0

; 3246 :       _mm_storeu_si128((__m128i *) (out + i*2), outv);

	movdqu	xmm0, XMMWORD PTR _outv$1[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebx]
	movdqu	XMMWORD PTR [ecx+eax*2], xmm0

; 3247 : #elif defined(STBI_NEON)
; 3248 :       // load and perform the vertical filtering pass
; 3249 :       // this uses 3*x + y = 4*x + (y - x)
; 3250 :       uint8x8_t farb  = vld1_u8(in_far + i);
; 3251 :       uint8x8_t nearb = vld1_u8(in_near + i);
; 3252 :       int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
; 3253 :       int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
; 3254 :       int16x8_t curr  = vaddq_s16(nears, diff); // current row
; 3255 : 
; 3256 :       // horizontal filter works the same based on shifted vers of current
; 3257 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3258 :       // insert the previous pixel value (from t1).
; 3259 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3260 :       // of next block of 8 pixels added in.
; 3261 :       int16x8_t prv0 = vextq_s16(curr, curr, 7);
; 3262 :       int16x8_t nxt0 = vextq_s16(curr, curr, 1);
; 3263 :       int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
; 3264 :       int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
; 3265 : 
; 3266 :       // horizontal filter, polyphase implementation since it's convenient:
; 3267 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3268 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3269 :       // note the shared term.
; 3270 :       int16x8_t curs = vshlq_n_s16(curr, 2);
; 3271 :       int16x8_t prvd = vsubq_s16(prev, curr);
; 3272 :       int16x8_t nxtd = vsubq_s16(next, curr);
; 3273 :       int16x8_t even = vaddq_s16(curs, prvd);
; 3274 :       int16x8_t odd  = vaddq_s16(curs, nxtd);
; 3275 : 
; 3276 :       // undo scaling and round, then store with even/odd phases interleaved
; 3277 :       uint8x8x2_t o;
; 3278 :       o.val[0] = vqrshrun_n_s16(even, 4);
; 3279 :       o.val[1] = vqrshrun_n_s16(odd,  4);
; 3280 :       vst2_u8(out + i*2, o);
; 3281 : #endif
; 3282 : 
; 3283 :       // "previous" value for next iter
; 3284 :       t1 = 3*in_near[i+7] + in_far[i+7];

	mov	eax, DWORD PTR _in_near$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax+7]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in_far$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax+7]
	add	edx, ecx
	mov	DWORD PTR _t1$[ebp], edx

; 3285 :    }

	jmp	$LN5@stbi__resa
$LN4@stbi__resa:

; 3286 : 
; 3287 :    t0 = t1;

	mov	eax, DWORD PTR _t1$[ebp]
	mov	DWORD PTR _t0$[ebp], eax

; 3288 :    t1 = 3*in_near[i] + in_far[i];

	mov	eax, DWORD PTR _in_near$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in_far$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	edx, ecx
	mov	DWORD PTR _t1$[ebp], edx

; 3289 :    out[i*2] = stbi__div16(3*t1 + t0 + 8);

	imul	eax, DWORD PTR _t1$[ebp], 3
	mov	ecx, DWORD PTR _t0$[ebp]
	lea	edx, DWORD PTR [eax+ecx+8]
	sar	edx, 4
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebx]
	mov	BYTE PTR [ecx+eax*2], dl

; 3290 : 
; 3291 :    for (++i; i < w; ++i) {

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN3@stbi__resa
$LN2@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _w$[ebx]
	jge	SHORT $LN1@stbi__resa

; 3292 :       t0 = t1;

	mov	eax, DWORD PTR _t1$[ebp]
	mov	DWORD PTR _t0$[ebp], eax

; 3293 :       t1 = 3*in_near[i]+in_far[i];

	mov	eax, DWORD PTR _in_near$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in_far$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	edx, ecx
	mov	DWORD PTR _t1$[ebp], edx

; 3294 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);

	imul	eax, DWORD PTR _t0$[ebp], 3
	mov	ecx, DWORD PTR _t1$[ebp]
	lea	edx, DWORD PTR [eax+ecx+8]
	sar	edx, 4
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebx]
	mov	BYTE PTR [ecx+eax*2-1], dl

; 3295 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);

	imul	eax, DWORD PTR _t1$[ebp], 3
	mov	ecx, DWORD PTR _t0$[ebp]
	lea	edx, DWORD PTR [eax+ecx+8]
	sar	edx, 4
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebx]
	mov	BYTE PTR [ecx+eax*2], dl

; 3296 :    }

	jmp	SHORT $LN2@stbi__resa
$LN1@stbi__resa:

; 3297 :    out[w*2-1] = stbi__div4(t1+2);

	mov	eax, DWORD PTR _t1$[ebp]
	add	eax, 2
	sar	eax, 2
	mov	ecx, DWORD PTR _w$[ebx]
	mov	edx, DWORD PTR _out$[ebx]
	mov	BYTE PTR [edx+ecx*2-1], al

; 3298 : 
; 3299 :    STBI_NOTUSED(hs);
; 3300 : 
; 3301 :    return out;

	mov	eax, DWORD PTR _out$[ebx]
$LN8@stbi__resa:

; 3302 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
_stbi__resample_row_hv_2_simd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__resample_row_hv_2
_TEXT	SEGMENT
tv78 = -232						; size = 4
_t1$ = -32						; size = 4
_t0$ = -20						; size = 4
_i$ = -8						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
_stbi__resample_row_hv_2 PROC				; COMDAT

; 3165 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3166 :    // need to generate 2x2 samples for every one in input
; 3167 :    int i,t0,t1;
; 3168 :    if (w == 1) {

	cmp	DWORD PTR _w$[ebp], 1
	jne	SHORT $LN4@stbi__resa

; 3169 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in_near$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	imul	ecx, eax, 3
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _in_far$[ebp]
	movzx	eax, BYTE PTR [edx+eax]
	lea	ecx, DWORD PTR [ecx+eax+2]
	sar	ecx, 2
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	cl, BYTE PTR tv78[ebp]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR tv78[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 3170 :       return out;

	mov	eax, DWORD PTR _out$[ebp]
	jmp	$LN5@stbi__resa
$LN4@stbi__resa:

; 3171 :    }
; 3172 : 
; 3173 :    t1 = 3*in_near[0] + in_far[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in_near$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	imul	ecx, eax, 3
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _in_far$[ebp]
	movzx	eax, BYTE PTR [edx+eax]
	add	ecx, eax
	mov	DWORD PTR _t1$[ebp], ecx

; 3174 :    out[0] = stbi__div4(t1+2);

	mov	eax, DWORD PTR _t1$[ebp]
	add	eax, 2
	sar	eax, 2
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3175 :    for (i=1; i < w; ++i) {

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN3@stbi__resa
$LN2@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _w$[ebp]
	jge	SHORT $LN1@stbi__resa

; 3176 :       t0 = t1;

	mov	eax, DWORD PTR _t1$[ebp]
	mov	DWORD PTR _t0$[ebp], eax

; 3177 :       t1 = 3*in_near[i]+in_far[i];

	mov	eax, DWORD PTR _in_near$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in_far$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	edx, ecx
	mov	DWORD PTR _t1$[ebp], edx

; 3178 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);

	imul	eax, DWORD PTR _t0$[ebp], 3
	mov	ecx, DWORD PTR _t1$[ebp]
	lea	edx, DWORD PTR [eax+ecx+8]
	sar	edx, 4
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax*2-1], dl

; 3179 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);

	imul	eax, DWORD PTR _t1$[ebp], 3
	mov	ecx, DWORD PTR _t0$[ebp]
	lea	edx, DWORD PTR [eax+ecx+8]
	sar	edx, 4
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax*2], dl

; 3180 :    }

	jmp	SHORT $LN2@stbi__resa
$LN1@stbi__resa:

; 3181 :    out[w*2-1] = stbi__div4(t1+2);

	mov	eax, DWORD PTR _t1$[ebp]
	add	eax, 2
	sar	eax, 2
	mov	ecx, DWORD PTR _w$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx*2-1], al

; 3182 : 
; 3183 :    STBI_NOTUSED(hs);
; 3184 : 
; 3185 :    return out;

	mov	eax, DWORD PTR _out$[ebp]
$LN5@stbi__resa:

; 3186 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__resample_row_hv_2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__resample_row_h_2
_TEXT	SEGMENT
_n$1 = -32						; size = 4
_input$ = -20						; size = 4
_i$ = -8						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
_stbi__resample_row_h_2 PROC				; COMDAT

; 3135 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3136 :    // need to generate two samples horizontally for every one in input
; 3137 :    int i;
; 3138 :    stbi_uc *input = in_near;

	mov	eax, DWORD PTR _in_near$[ebp]
	mov	DWORD PTR _input$[ebp], eax

; 3139 : 
; 3140 :    if (w == 1) {

	cmp	DWORD PTR _w$[ebp], 1
	jne	SHORT $LN4@stbi__resa

; 3141 :       // if only one sample, can't do any interpolation
; 3142 :       out[0] = out[1] = input[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _input$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, 1
	shl	edx, 0
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [eax+ecx], dl

; 3143 :       return out;

	mov	eax, DWORD PTR _out$[ebp]
	jmp	$LN5@stbi__resa
$LN4@stbi__resa:

; 3144 :    }
; 3145 : 
; 3146 :    out[0] = input[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _input$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl

; 3147 :    out[1] = stbi__div4(input[0]*3 + input[1] + 2);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _input$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	imul	ecx, eax, 3
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _input$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	lea	eax, DWORD PTR [ecx+edx+2]
	sar	eax, 2
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 3148 :    for (i=1; i < w-1; ++i) {

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN3@stbi__resa
$LN2@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@stbi__resa:
	mov	eax, DWORD PTR _w$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN1@stbi__resa

; 3149 :       int n = 3*input[i]+2;

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	edx, ecx, 3
	add	edx, 2
	mov	DWORD PTR _n$1[ebp], edx

; 3150 :       out[i*2+0] = stbi__div4(n+input[i-1]);

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax-1]
	add	ecx, DWORD PTR _n$1[ebp]
	sar	ecx, 2
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx*2], cl

; 3151 :       out[i*2+1] = stbi__div4(n+input[i+1]);

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	add	ecx, DWORD PTR _n$1[ebp]
	sar	ecx, 2
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx*2+1], cl

; 3152 :    }

	jmp	SHORT $LN2@stbi__resa
$LN1@stbi__resa:

; 3153 :    out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _w$[ebp]
	movzx	ecx, BYTE PTR [eax-2]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _w$[ebp]
	movzx	ecx, BYTE PTR [eax-1]
	lea	edx, DWORD PTR [edx+ecx+2]
	sar	edx, 2
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax*2], dl

; 3154 :    out[i*2+1] = input[w-1];

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR [eax-1]
	mov	BYTE PTR [edx+ecx*2+1], al

; 3155 : 
; 3156 :    STBI_NOTUSED(in_far);
; 3157 :    STBI_NOTUSED(hs);
; 3158 : 
; 3159 :    return out;

	mov	eax, DWORD PTR _out$[ebp]
$LN5@stbi__resa:

; 3160 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__resample_row_h_2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__resample_row_v_2
_TEXT	SEGMENT
_i$ = -8						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
_stbi__resample_row_v_2 PROC				; COMDAT

; 3125 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3126 :    // need to generate two samples vertically for every one in input
; 3127 :    int i;
; 3128 :    STBI_NOTUSED(hs);
; 3129 :    for (i=0; i < w; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@stbi__resa
$LN2@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _w$[ebp]
	jge	SHORT $LN1@stbi__resa

; 3130 :       out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);

	mov	eax, DWORD PTR _in_near$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in_far$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	lea	edx, DWORD PTR [edx+ecx+2]
	sar	edx, 2
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN2@stbi__resa
$LN1@stbi__resa:

; 3131 :    return out;

	mov	eax, DWORD PTR _out$[ebp]

; 3132 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__resample_row_v_2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _resample_row_1
_TEXT	SEGMENT
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
_resample_row_1 PROC					; COMDAT

; 3116 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3117 :    STBI_NOTUSED(out);
; 3118 :    STBI_NOTUSED(in_far);
; 3119 :    STBI_NOTUSED(w);
; 3120 :    STBI_NOTUSED(hs);
; 3121 :    return in_near;

	mov	eax, DWORD PTR _in_near$[ebp]

; 3122 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_resample_row_1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__decode_jpeg_image
_TEXT	SEGMENT
_NL$1 = -44						; size = 4
_Ld$2 = -32						; size = 4
_x$3 = -20						; size = 4
_m$ = -8						; size = 4
_j$ = 8							; size = 4
_stbi__decode_jpeg_image PROC				; COMDAT

; 3069 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3070 :    int m;
; 3071 :    for (m = 0; m < 4; m++) {

	mov	DWORD PTR _m$[ebp], 0
	jmp	SHORT $LN20@stbi__deco
$LN19@stbi__deco:
	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 1
	mov	DWORD PTR _m$[ebp], eax
$LN20@stbi__deco:
	cmp	DWORD PTR _m$[ebp], 4
	jge	SHORT $LN18@stbi__deco

; 3072 :       j->img_comp[m].raw_data = NULL;

	imul	eax, DWORD PTR _m$[ebp], 72
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+eax+18124], 0

; 3073 :       j->img_comp[m].raw_coeff = NULL;

	imul	eax, DWORD PTR _m$[ebp], 72
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+eax+18128], 0

; 3074 :    }

	jmp	SHORT $LN19@stbi__deco
$LN18@stbi__deco:

; 3075 :    j->restart_interval = 0;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18436], 0

; 3076 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;

	push	0
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__decode_jpeg_header
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@stbi__deco
	xor	eax, eax
	jmp	$LN21@stbi__deco
$LN17@stbi__deco:

; 3077 :    m = stbi__get_marker(j);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__get_marker
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _m$[ebp], ecx
$LN16@stbi__deco:

; 3078 :    while (!stbi__EOI(m)) {

	cmp	DWORD PTR _m$[ebp], 217			; 000000d9H
	je	$LN15@stbi__deco

; 3079 :       if (stbi__SOS(m)) {

	cmp	DWORD PTR _m$[ebp], 218			; 000000daH
	jne	$LN14@stbi__deco

; 3080 :          if (!stbi__process_scan_header(j)) return 0;

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__process_scan_header
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@stbi__deco
	xor	eax, eax
	jmp	$LN21@stbi__deco
$LN13@stbi__deco:

; 3081 :          if (!stbi__parse_entropy_coded_data(j)) return 0;

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__parse_entropy_coded_data
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN12@stbi__deco
	xor	eax, eax
	jmp	$LN21@stbi__deco
$LN12@stbi__deco:

; 3082 :          if (j->marker == STBI__MARKER_none ) {

	mov	eax, DWORD PTR _j$[ebp]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $LN11@stbi__deco
$LN10@stbi__deco:

; 3083 :             // handle 0s at the end of image data from IP Kamera 9060
; 3084 :             while (!stbi__at_eof(j->s)) {

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__at_eof
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@stbi__deco

; 3085 :                int x = stbi__get8(j->s);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _x$3[ebp], edx

; 3086 :                if (x == 255) {

	cmp	DWORD PTR _x$3[ebp], 255		; 000000ffH
	jne	SHORT $LN8@stbi__deco

; 3087 :                   j->marker = stbi__get8(j->s);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	mov	edx, DWORD PTR _j$[ebp]
	mov	BYTE PTR [edx+18372], al

; 3088 :                   break;

	jmp	SHORT $LN11@stbi__deco
$LN8@stbi__deco:

; 3089 :                }
; 3090 :             }

	jmp	SHORT $LN10@stbi__deco
$LN11@stbi__deco:

; 3091 :             // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
; 3092 :          }

	jmp	SHORT $LN7@stbi__deco
$LN14@stbi__deco:

; 3093 :       } else if (stbi__DNL(m)) {

	cmp	DWORD PTR _m$[ebp], 220			; 000000dcH
	jne	SHORT $LN6@stbi__deco

; 3094 :          int Ld = stbi__get16be(j->s);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get16be
	add	esp, 4
	mov	DWORD PTR _Ld$2[ebp], eax

; 3095 :          stbi__uint32 NL = stbi__get16be(j->s);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get16be
	add	esp, 4
	mov	DWORD PTR _NL$1[ebp], eax

; 3096 :          if (Ld != 4) stbi__err("bad DNL len", "Corrupt JPEG");

	cmp	DWORD PTR _Ld$2[ebp], 4
	je	SHORT $LN5@stbi__deco
	push	OFFSET ??_C@_0M@EPMOIECP@bad?5DNL?5len?$AA@
	call	_stbi__err
	add	esp, 4
$LN5@stbi__deco:

; 3097 :          if (NL != j->s->img_y) stbi__err("bad DNL height", "Corrupt JPEG");

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _NL$1[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN4@stbi__deco
	push	OFFSET ??_C@_0P@PNCLKCLJ@bad?5DNL?5height?$AA@
	call	_stbi__err
	add	esp, 4
$LN4@stbi__deco:

; 3098 :       } else {

	jmp	SHORT $LN7@stbi__deco
$LN6@stbi__deco:

; 3099 :          if (!stbi__process_marker(j, m)) return 0;

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	_stbi__process_marker
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@stbi__deco
	xor	eax, eax
	jmp	SHORT $LN21@stbi__deco
$LN7@stbi__deco:

; 3100 :       }
; 3101 :       m = stbi__get_marker(j);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__get_marker
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _m$[ebp], ecx

; 3102 :    }

	jmp	$LN16@stbi__deco
$LN15@stbi__deco:

; 3103 :    if (j->progressive)

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18380], 0
	je	SHORT $LN1@stbi__deco

; 3104 :       stbi__jpeg_finish(j);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__jpeg_finish
	add	esp, 4
$LN1@stbi__deco:

; 3105 :    return 1;

	mov	eax, 1
$LN21@stbi__deco:

; 3106 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__decode_jpeg_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__decode_jpeg_header
_TEXT	SEGMENT
tv131 = -208						; size = 4
_m$ = -8						; size = 4
_z$ = 8							; size = 4
_scan$ = 12						; size = 4
_stbi__decode_jpeg_header PROC				; COMDAT

; 3044 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3045 :    int m;
; 3046 :    z->jfif = 0;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18404], 0

; 3047 :    z->app14_color_transform = -1; // valid values are 0,1,2

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18408], -1

; 3048 :    z->marker = STBI__MARKER_none; // initialize cached marker to empty

	mov	eax, DWORD PTR _z$[ebp]
	mov	BYTE PTR [eax+18372], 255		; 000000ffH

; 3049 :    m = stbi__get_marker(z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_stbi__get_marker
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _m$[ebp], ecx

; 3050 :    if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");

	cmp	DWORD PTR _m$[ebp], 216			; 000000d8H
	je	SHORT $LN9@stbi__deco
	push	OFFSET ??_C@_06CLMBLEP@no?5SOI?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN10@stbi__deco
$LN9@stbi__deco:

; 3051 :    if (scan == STBI__SCAN_type) return 1;

	cmp	DWORD PTR _scan$[ebp], 1
	jne	SHORT $LN8@stbi__deco
	mov	eax, 1
	jmp	$LN10@stbi__deco
$LN8@stbi__deco:

; 3052 :    m = stbi__get_marker(z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_stbi__get_marker
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _m$[ebp], ecx
$LN7@stbi__deco:

; 3053 :    while (!stbi__SOF(m)) {

	cmp	DWORD PTR _m$[ebp], 192			; 000000c0H
	je	$LN6@stbi__deco
	cmp	DWORD PTR _m$[ebp], 193			; 000000c1H
	je	SHORT $LN6@stbi__deco
	cmp	DWORD PTR _m$[ebp], 194			; 000000c2H
	je	SHORT $LN6@stbi__deco

; 3054 :       if (!stbi__process_marker(z,m)) return 0;

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	push	ecx
	call	_stbi__process_marker
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@stbi__deco
	xor	eax, eax
	jmp	$LN10@stbi__deco
$LN5@stbi__deco:

; 3055 :       m = stbi__get_marker(z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_stbi__get_marker
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _m$[ebp], ecx
$LN4@stbi__deco:

; 3056 :       while (m == STBI__MARKER_none) {

	cmp	DWORD PTR _m$[ebp], 255			; 000000ffH
	jne	SHORT $LN3@stbi__deco

; 3057 :          // some files have extra padding after their blocks, so ok, we'll scan
; 3058 :          if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__at_eof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@stbi__deco
	push	OFFSET ??_C@_06IFCEAHIA@no?5SOF?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	SHORT $LN10@stbi__deco
$LN2@stbi__deco:

; 3059 :          m = stbi__get_marker(z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_stbi__get_marker
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _m$[ebp], ecx

; 3060 :       }

	jmp	SHORT $LN4@stbi__deco
$LN3@stbi__deco:

; 3061 :    }

	jmp	$LN7@stbi__deco
$LN6@stbi__deco:

; 3062 :    z->progressive = stbi__SOF_progressive(m);

	cmp	DWORD PTR _m$[ebp], 194			; 000000c2H
	jne	SHORT $LN12@stbi__deco
	mov	DWORD PTR tv131[ebp], 1
	jmp	SHORT $LN13@stbi__deco
$LN12@stbi__deco:
	mov	DWORD PTR tv131[ebp], 0
$LN13@stbi__deco:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR tv131[ebp]
	mov	DWORD PTR [eax+18380], ecx

; 3063 :    if (!stbi__process_frame_header(z, scan)) return 0;

	mov	eax, DWORD PTR _scan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	push	ecx
	call	_stbi__process_frame_header
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@stbi__deco
	xor	eax, eax
	jmp	SHORT $LN10@stbi__deco
$LN1@stbi__deco:

; 3064 :    return 1;

	mov	eax, 1
$LN10@stbi__deco:

; 3065 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__decode_jpeg_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__process_frame_header
_TEXT	SEGMENT
_c$ = -92						; size = 4
_v_max$ = -80						; size = 4
_h_max$ = -68						; size = 4
_q$ = -56						; size = 4
_i$ = -44						; size = 4
_p$ = -32						; size = 4
_Lf$ = -20						; size = 4
_s$ = -8						; size = 4
_z$ = 8							; size = 4
_scan$ = 12						; size = 4
_stbi__process_frame_header PROC			; COMDAT

; 2952 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2953 :    stbi__context *s = z->s;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$[ebp], ecx

; 2954 :    int Lf,p,i,q, h_max=1,v_max=1,c;

	mov	DWORD PTR _h_max$[ebp], 1
	mov	DWORD PTR _v_max$[ebp], 1

; 2955 :    Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16be
	add	esp, 4
	mov	DWORD PTR _Lf$[ebp], eax
	cmp	DWORD PTR _Lf$[ebp], 11			; 0000000bH
	jge	SHORT $LN31@stbi__proc
	push	OFFSET ??_C@_0M@DOFMJEMP@bad?5SOF?5len?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN32@stbi__proc
$LN31@stbi__proc:

; 2956 :    p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _p$[ebp], ecx
	cmp	DWORD PTR _p$[ebp], 8
	je	SHORT $LN30@stbi__proc
	push	OFFSET ??_C@_0L@BCINMEBJ@only?58?9bit?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN32@stbi__proc
$LN30@stbi__proc:

; 2957 :    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16be
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@stbi__proc
	push	OFFSET ??_C@_0BB@LNEGOMA@no?5header?5height?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN32@stbi__proc
$LN29@stbi__proc:

; 2958 :    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16be
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN28@stbi__proc
	push	OFFSET ??_C@_07BIDACDEF@0?5width?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN32@stbi__proc
$LN28@stbi__proc:

; 2959 :    c = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _c$[ebp], ecx

; 2960 :    if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");

	cmp	DWORD PTR _c$[ebp], 3
	je	SHORT $LN27@stbi__proc
	cmp	DWORD PTR _c$[ebp], 1
	je	SHORT $LN27@stbi__proc
	cmp	DWORD PTR _c$[ebp], 4
	je	SHORT $LN27@stbi__proc
	push	OFFSET ??_C@_0BE@DAPHADHL@bad?5component?5count?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN32@stbi__proc
$LN27@stbi__proc:

; 2961 :    s->img_n = c;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 2962 :    for (i=0; i < c; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN26@stbi__proc
$LN25@stbi__proc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN26@stbi__proc:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _c$[ebp]
	jge	SHORT $LN24@stbi__proc

; 2963 :       z->img_comp[i].data = NULL;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18120], 0

; 2964 :       z->img_comp[i].linebuf = NULL;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18132], 0

; 2965 :    }

	jmp	SHORT $LN25@stbi__proc
$LN24@stbi__proc:

; 2966 : 
; 2967 :    if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");

	mov	eax, DWORD PTR _s$[ebp]
	imul	ecx, DWORD PTR [eax+8], 3
	add	ecx, 8
	cmp	DWORD PTR _Lf$[ebp], ecx
	je	SHORT $LN23@stbi__proc
	push	OFFSET ??_C@_0M@DOFMJEMP@bad?5SOF?5len?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN32@stbi__proc
$LN23@stbi__proc:

; 2968 : 
; 2969 :    z->rgb = 0;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18412], 0

; 2970 :    for (i=0; i < s->img_n; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN22@stbi__proc
$LN21@stbi__proc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN22@stbi__proc:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	$LN20@stbi__proc

; 2971 :       static unsigned char rgb[3] = { 'R', 'G', 'B' };
; 2972 :       z->img_comp[i].id = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	imul	ecx, DWORD PTR _i$[ebp], 72
	movzx	edx, al
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+ecx+18076], edx

; 2973 :       if (s->img_n == 3 && z->img_comp[i].id == rgb[i])

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+8], 3
	jne	SHORT $LN19@stbi__proc
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR ?rgb@?5??stbi__process_frame_header@@9@9[ecx]
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18076], edx
	jne	SHORT $LN19@stbi__proc

; 2974 :          ++z->rgb;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+18412]
	add	ecx, 1
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+18412], ecx
$LN19@stbi__proc:

; 2975 :       q = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _q$[ebp], ecx

; 2976 :       z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");

	mov	eax, DWORD PTR _q$[ebp]
	sar	eax, 4
	imul	ecx, DWORD PTR _i$[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18080], eax
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18080], 0
	je	SHORT $LN17@stbi__proc
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18080], 4
	jle	SHORT $LN18@stbi__proc
$LN17@stbi__proc:
	push	OFFSET ??_C@_05BLPKENEJ@bad?5H?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN32@stbi__proc
$LN18@stbi__proc:

; 2977 :       z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");

	mov	eax, DWORD PTR _q$[ebp]
	and	eax, 15					; 0000000fH
	imul	ecx, DWORD PTR _i$[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18084], eax
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18084], 0
	je	SHORT $LN15@stbi__proc
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18084], 4
	jle	SHORT $LN16@stbi__proc
$LN15@stbi__proc:
	push	OFFSET ??_C@_05MPLLHCJG@bad?5V?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN32@stbi__proc
$LN16@stbi__proc:

; 2978 :       z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	imul	ecx, DWORD PTR _i$[ebp], 72
	movzx	edx, al
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+ecx+18088], edx
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18088], 3
	jle	SHORT $LN14@stbi__proc
	push	OFFSET ??_C@_06LJIHDFHI@bad?5TQ?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN32@stbi__proc
$LN14@stbi__proc:

; 2979 :    }

	jmp	$LN21@stbi__proc
$LN20@stbi__proc:

; 2980 : 
; 2981 :    if (scan != STBI__SCAN_load) return 1;

	cmp	DWORD PTR _scan$[ebp], 0
	je	SHORT $LN13@stbi__proc
	mov	eax, 1
	jmp	$LN32@stbi__proc
$LN13@stbi__proc:

; 2982 : 
; 2983 :    if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

	push	0
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_stbi__mad3sizes_valid
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN12@stbi__proc
	push	OFFSET ??_C@_09OJDLMMBJ@too?5large?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN32@stbi__proc
$LN12@stbi__proc:

; 2984 : 
; 2985 :    for (i=0; i < s->img_n; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@stbi__proc
$LN10@stbi__proc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@stbi__proc:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	SHORT $LN9@stbi__proc

; 2986 :       if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18080]
	cmp	edx, DWORD PTR _h_max$[ebp]
	jle	SHORT $LN8@stbi__proc
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18080]
	mov	DWORD PTR _h_max$[ebp], edx
$LN8@stbi__proc:

; 2987 :       if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18084]
	cmp	edx, DWORD PTR _v_max$[ebp]
	jle	SHORT $LN7@stbi__proc
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18084]
	mov	DWORD PTR _v_max$[ebp], edx
$LN7@stbi__proc:

; 2988 :    }

	jmp	SHORT $LN10@stbi__proc
$LN9@stbi__proc:

; 2989 : 
; 2990 :    // compute interleaved mcu info
; 2991 :    z->img_h_max = h_max;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _h_max$[ebp]
	mov	DWORD PTR [eax+18052], ecx

; 2992 :    z->img_v_max = v_max;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _v_max$[ebp]
	mov	DWORD PTR [eax+18056], ecx

; 2993 :    z->img_mcu_w = h_max * 8;

	mov	eax, DWORD PTR _h_max$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+18068], eax

; 2994 :    z->img_mcu_h = v_max * 8;

	mov	eax, DWORD PTR _v_max$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+18072], eax

; 2995 :    // these sizes can't be more than 17 bits
; 2996 :    z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+18068]
	lea	eax, DWORD PTR [ecx+eax-1]
	mov	ecx, DWORD PTR _z$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+18068]
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+18060], eax

; 2997 :    z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+18072]
	lea	eax, DWORD PTR [ecx+eax-1]
	mov	ecx, DWORD PTR _z$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+18072]
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+18064], eax

; 2998 : 
; 2999 :    for (i=0; i < s->img_n; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@stbi__proc
$LN5@stbi__proc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@stbi__proc:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	$LN4@stbi__proc

; 3000 :       // number of effective pixels (e.g. for non-interleaved MCU)
; 3001 :       z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [ecx]
	imul	ecx, DWORD PTR [edx+eax+18080]
	mov	edx, DWORD PTR _h_max$[ebp]
	lea	eax, DWORD PTR [ecx+edx-1]
	xor	edx, edx
	div	DWORD PTR _h_max$[ebp]
	imul	ecx, DWORD PTR _i$[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18104], eax

; 3002 :       z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	imul	ecx, DWORD PTR [edx+eax+18084]
	mov	edx, DWORD PTR _v_max$[ebp]
	lea	eax, DWORD PTR [ecx+edx-1]
	xor	edx, edx
	div	DWORD PTR _v_max$[ebp]
	imul	ecx, DWORD PTR _i$[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18108], eax

; 3003 :       // to simplify generation, we'll allocate enough memory to decode
; 3004 :       // the bogus oversized data from using interleaved MCUs and their
; 3005 :       // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 3006 :       // discard the extra data until colorspace conversion
; 3007 :       //
; 3008 :       // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
; 3009 :       // so these muls can't overflow with 32-bit ints (which we require)
; 3010 :       z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [ecx+18060]
	imul	ecx, DWORD PTR [edx+eax+18080]
	shl	ecx, 3
	imul	edx, DWORD PTR _i$[ebp], 72
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+edx+18112], ecx

; 3011 :       z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [ecx+18064]
	imul	ecx, DWORD PTR [edx+eax+18084]
	shl	ecx, 3
	imul	edx, DWORD PTR _i$[ebp], 72
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+edx+18116], ecx

; 3012 :       z->img_comp[i].coeff = 0;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18136], 0

; 3013 :       z->img_comp[i].raw_coeff = 0;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18128], 0

; 3014 :       z->img_comp[i].linebuf = NULL;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18132], 0

; 3015 :       z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);

	push	15					; 0000000fH
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18116]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18112]
	push	edx
	call	_stbi__malloc_mad2
	add	esp, 12					; 0000000cH
	imul	ecx, DWORD PTR _i$[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18124], eax

; 3016 :       if (z->img_comp[i].raw_data == NULL)

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18124], 0
	jne	SHORT $LN3@stbi__proc

; 3017 :          return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));

	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	push	ecx
	call	_stbi__free_jpeg_components
	add	esp, 12					; 0000000cH
	jmp	$LN32@stbi__proc
$LN3@stbi__proc:

; 3018 :       // align blocks for idct using mmx/sse
; 3019 :       z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18124]
	add	edx, 15					; 0000000fH
	and	edx, -16				; fffffff0H
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18120], edx

; 3020 :       if (z->progressive) {

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18380], 0
	je	$LN2@stbi__proc

; 3021 :          // w2, h2 are multiples of 8 (see above)
; 3022 :          z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [ecx+eax+18112]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	imul	edx, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+edx+18140], eax

; 3023 :          z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [ecx+eax+18116]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	imul	edx, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+edx+18144], eax

; 3024 :          z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);

	push	15					; 0000000fH
	push	2
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18116]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18112]
	push	edx
	call	_stbi__malloc_mad3
	add	esp, 16					; 00000010H
	imul	ecx, DWORD PTR _i$[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18128], eax

; 3025 :          if (z->img_comp[i].raw_coeff == NULL)

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18128], 0
	jne	SHORT $LN1@stbi__proc

; 3026 :             return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));

	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	push	ecx
	call	_stbi__free_jpeg_components
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN32@stbi__proc
$LN1@stbi__proc:

; 3027 :          z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18128]
	add	edx, 15					; 0000000fH
	and	edx, -16				; fffffff0H
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18136], edx
$LN2@stbi__proc:

; 3028 :       }
; 3029 :    }

	jmp	$LN5@stbi__proc
$LN4@stbi__proc:

; 3030 : 
; 3031 :    return 1;

	mov	eax, 1
$LN32@stbi__proc:

; 3032 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__process_frame_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__free_jpeg_components
_TEXT	SEGMENT
_i$ = -8						; size = 4
_z$ = 8							; size = 4
_ncomp$ = 12						; size = 4
_why$ = 16						; size = 4
_stbi__free_jpeg_components PROC			; COMDAT

; 2930 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2931 :    int i;
; 2932 :    for (i=0; i < ncomp; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@stbi__free
$LN5@stbi__free:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@stbi__free:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _ncomp$[ebp]
	jge	$LN4@stbi__free

; 2933 :       if (z->img_comp[i].raw_data) {

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18124], 0
	je	SHORT $LN3@stbi__free

; 2934 :          STBI_FREE(z->img_comp[i].raw_data);

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18124]
	push	edx
	call	_free
	add	esp, 4

; 2935 :          z->img_comp[i].raw_data = NULL;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18124], 0

; 2936 :          z->img_comp[i].data = NULL;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18120], 0
$LN3@stbi__free:

; 2937 :       }
; 2938 :       if (z->img_comp[i].raw_coeff) {

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18128], 0
	je	SHORT $LN2@stbi__free

; 2939 :          STBI_FREE(z->img_comp[i].raw_coeff);

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18128]
	push	edx
	call	_free
	add	esp, 4

; 2940 :          z->img_comp[i].raw_coeff = 0;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18128], 0

; 2941 :          z->img_comp[i].coeff = 0;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18136], 0
$LN2@stbi__free:

; 2942 :       }
; 2943 :       if (z->img_comp[i].linebuf) {

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18132], 0
	je	SHORT $LN1@stbi__free

; 2944 :          STBI_FREE(z->img_comp[i].linebuf);

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18132]
	push	edx
	call	_free
	add	esp, 4

; 2945 :          z->img_comp[i].linebuf = NULL;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18132], 0
$LN1@stbi__free:

; 2946 :       }
; 2947 :    }

	jmp	$LN5@stbi__free
$LN4@stbi__free:

; 2948 :    return why;

	mov	eax, DWORD PTR _why$[ebp]

; 2949 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__free_jpeg_components ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__process_scan_header
_TEXT	SEGMENT
_aa$1 = -68						; size = 4
_q$2 = -56						; size = 4
_which$3 = -44						; size = 4
_id$4 = -32						; size = 4
_Ls$ = -20						; size = 4
_i$ = -8						; size = 4
_z$ = 8							; size = 4
_stbi__process_scan_header PROC				; COMDAT

; 2891 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2892 :    int i;
; 2893 :    int Ls = stbi__get16be(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get16be
	add	esp, 4
	mov	DWORD PTR _Ls$[ebp], eax

; 2894 :    z->scan_n = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18416], edx

; 2895 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18416], 1
	jl	SHORT $LN19@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18416], 4
	jg	SHORT $LN19@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+18416]
	cmp	eax, DWORD PTR [ecx+8]
	jle	SHORT $LN20@stbi__proc
$LN19@stbi__proc:
	push	OFFSET ??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN21@stbi__proc
$LN20@stbi__proc:

; 2896 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+18416]
	lea	edx, DWORD PTR [ecx+ecx+6]
	cmp	DWORD PTR _Ls$[ebp], edx
	je	SHORT $LN18@stbi__proc
	push	OFFSET ??_C@_0M@GNEHAHOH@bad?5SOS?5len?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN21@stbi__proc
$LN18@stbi__proc:

; 2897 :    for (i=0; i < z->scan_n; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN17@stbi__proc
$LN16@stbi__proc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN17@stbi__proc:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+18416]
	jge	$LN15@stbi__proc

; 2898 :       int id = stbi__get8(z->s), which;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _id$4[ebp], edx

; 2899 :       int q = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _q$2[ebp], edx

; 2900 :       for (which = 0; which < z->s->img_n; ++which)

	mov	DWORD PTR _which$3[ebp], 0
	jmp	SHORT $LN14@stbi__proc
$LN13@stbi__proc:
	mov	eax, DWORD PTR _which$3[ebp]
	add	eax, 1
	mov	DWORD PTR _which$3[ebp], eax
$LN14@stbi__proc:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _which$3[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN12@stbi__proc

; 2901 :          if (z->img_comp[which].id == id)

	imul	eax, DWORD PTR _which$3[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18076]
	cmp	edx, DWORD PTR _id$4[ebp]
	jne	SHORT $LN11@stbi__proc

; 2902 :             break;

	jmp	SHORT $LN12@stbi__proc
$LN11@stbi__proc:

; 2903 :       if (which == z->s->img_n) return 0; // no match

	jmp	SHORT $LN13@stbi__proc
$LN12@stbi__proc:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _which$3[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN10@stbi__proc
	xor	eax, eax
	jmp	$LN21@stbi__proc
$LN10@stbi__proc:

; 2904 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");

	mov	eax, DWORD PTR _q$2[ebp]
	sar	eax, 4
	imul	ecx, DWORD PTR _which$3[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18092], eax
	imul	eax, DWORD PTR _which$3[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18092], 3
	jle	SHORT $LN9@stbi__proc
	push	OFFSET ??_C@_0M@NOCCBFAC@bad?5DC?5huff?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN21@stbi__proc
$LN9@stbi__proc:

; 2905 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");

	mov	eax, DWORD PTR _q$2[ebp]
	and	eax, 15					; 0000000fH
	imul	ecx, DWORD PTR _which$3[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18096], eax
	imul	eax, DWORD PTR _which$3[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18096], 3
	jle	SHORT $LN8@stbi__proc
	push	OFFSET ??_C@_0M@JGMCBLGG@bad?5AC?5huff?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN21@stbi__proc
$LN8@stbi__proc:

; 2906 :       z->order[i] = which;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _which$3[ebp]
	mov	DWORD PTR [ecx+eax*4+18420], edx

; 2907 :    }

	jmp	$LN16@stbi__proc
$LN15@stbi__proc:

; 2908 : 
; 2909 :    {
; 2910 :       int aa;
; 2911 :       z->spec_start = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18384], edx

; 2912 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18388], edx

; 2913 :       aa = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _aa$1[ebp], edx

; 2914 :       z->succ_high = (aa >> 4);

	mov	eax, DWORD PTR _aa$1[ebp]
	sar	eax, 4
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+18392], eax

; 2915 :       z->succ_low  = (aa & 15);

	mov	eax, DWORD PTR _aa$1[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+18396], eax

; 2916 :       if (z->progressive) {

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18380], 0
	je	SHORT $LN7@stbi__proc

; 2917 :          if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18384], 63		; 0000003fH
	jg	SHORT $LN5@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18388], 63		; 0000003fH
	jg	SHORT $LN5@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [eax+18384]
	cmp	edx, DWORD PTR [ecx+18388]
	jg	SHORT $LN5@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18392], 13		; 0000000dH
	jg	SHORT $LN5@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18396], 13		; 0000000dH
	jle	SHORT $LN6@stbi__proc
$LN5@stbi__proc:

; 2918 :             return stbi__err("bad SOS", "Corrupt JPEG");

	push	OFFSET ??_C@_07EEJOMGGP@bad?5SOS?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	SHORT $LN21@stbi__proc
$LN6@stbi__proc:

; 2919 :       } else {

	jmp	SHORT $LN4@stbi__proc
$LN7@stbi__proc:

; 2920 :          if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18384], 0
	je	SHORT $LN3@stbi__proc
	push	OFFSET ??_C@_07EEJOMGGP@bad?5SOS?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	SHORT $LN21@stbi__proc
$LN3@stbi__proc:

; 2921 :          if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18392], 0
	jne	SHORT $LN1@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18396], 0
	je	SHORT $LN2@stbi__proc
$LN1@stbi__proc:
	push	OFFSET ??_C@_07EEJOMGGP@bad?5SOS?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	SHORT $LN21@stbi__proc
$LN2@stbi__proc:

; 2922 :          z->spec_end = 63;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18388], 63		; 0000003fH
$LN4@stbi__proc:

; 2923 :       }
; 2924 :    }
; 2925 : 
; 2926 :    return 1;

	mov	eax, 1
$LN21@stbi__proc:

; 2927 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__process_scan_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__process_marker
_TEXT	SEGMENT
tv222 = -464						; size = 4
tv153 = -464						; size = 4
tv150 = -464						; size = 4
tv147 = -464						; size = 4
tv88 = -464						; size = 4
tv64 = -464						; size = 4
_i$1 = -264						; size = 4
_ok$2 = -252						; size = 4
_i$3 = -240						; size = 4
_ok$4 = -228						; size = 4
_th$5 = -216						; size = 4
_tc$6 = -204						; size = 4
_q$7 = -192						; size = 4
_n$8 = -180						; size = 4
_i$9 = -168						; size = 4
_sizes$10 = -156					; size = 64
_v$11 = -84						; size = 4
_i$12 = -72						; size = 4
_t$13 = -60						; size = 4
_sixteen$14 = -48					; size = 4
_p$15 = -36						; size = 4
_q$16 = -24						; size = 4
_L$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_z$ = 8							; size = 4
_m$ = 12						; size = 4
_stbi__process_marker PROC				; COMDAT

; 2788 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 464				; 000001d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-464]
	mov	ecx, 116				; 00000074H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2789 :    int L;
; 2790 :    switch (m) {

	mov	eax, DWORD PTR _m$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 196				; 000000c4H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 59			; 0000003bH
	ja	$LN47@stbi__proc
	mov	edx, DWORD PTR tv64[ebp]
	movzx	eax, BYTE PTR $LN61@stbi__proc[edx]
	jmp	DWORD PTR $LN65@stbi__proc[eax*4]
$LN46@stbi__proc:

; 2791 :       case STBI__MARKER_none: // no marker found
; 2792 :          return stbi__err("expected marker","Corrupt JPEG");

	push	OFFSET ??_C@_0BA@KLNDOKJD@expected?5marker?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN49@stbi__proc
$LN45@stbi__proc:

; 2793 : 
; 2794 :       case 0xDD: // DRI - specify restart interval
; 2795 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get16be
	add	esp, 4
	cmp	eax, 4
	je	SHORT $LN44@stbi__proc
	push	OFFSET ??_C@_0M@LPHNODCG@bad?5DRI?5len?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN49@stbi__proc
$LN44@stbi__proc:

; 2796 :          z->restart_interval = stbi__get16be(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get16be
	add	esp, 4
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+18436], eax

; 2797 :          return 1;

	mov	eax, 1
	jmp	$LN49@stbi__proc
$LN43@stbi__proc:

; 2798 : 
; 2799 :       case 0xDB: // DQT - define quantization table
; 2800 :          L = stbi__get16be(z->s)-2;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get16be
	add	esp, 4
	sub	eax, 2
	mov	DWORD PTR _L$[ebp], eax
$LN42@stbi__proc:

; 2801 :          while (L > 0) {

	cmp	DWORD PTR _L$[ebp], 0
	jle	$LN41@stbi__proc

; 2802 :             int q = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _q$16[ebp], edx

; 2803 :             int p = q >> 4, sixteen = (p != 0);

	mov	eax, DWORD PTR _q$16[ebp]
	sar	eax, 4
	mov	DWORD PTR _p$15[ebp], eax
	cmp	DWORD PTR _p$15[ebp], 0
	je	SHORT $LN51@stbi__proc
	mov	DWORD PTR tv88[ebp], 1
	jmp	SHORT $LN52@stbi__proc
$LN51@stbi__proc:
	mov	DWORD PTR tv88[ebp], 0
$LN52@stbi__proc:
	mov	eax, DWORD PTR tv88[ebp]
	mov	DWORD PTR _sixteen$14[ebp], eax

; 2804 :             int t = q & 15,i;

	mov	eax, DWORD PTR _q$16[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _t$13[ebp], eax

; 2805 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");

	cmp	DWORD PTR _p$15[ebp], 0
	je	SHORT $LN40@stbi__proc
	cmp	DWORD PTR _p$15[ebp], 1
	je	SHORT $LN40@stbi__proc
	push	OFFSET ??_C@_0N@BOFJCHAP@bad?5DQT?5type?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN49@stbi__proc
$LN40@stbi__proc:

; 2806 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");

	cmp	DWORD PTR _t$13[ebp], 3
	jle	SHORT $LN39@stbi__proc
	push	OFFSET ??_C@_0O@CNHKKDIM@bad?5DQT?5table?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN49@stbi__proc
$LN39@stbi__proc:

; 2807 : 
; 2808 :             for (i=0; i < 64; ++i)

	mov	DWORD PTR _i$12[ebp], 0
	jmp	SHORT $LN38@stbi__proc
$LN37@stbi__proc:
	mov	eax, DWORD PTR _i$12[ebp]
	add	eax, 1
	mov	DWORD PTR _i$12[ebp], eax
$LN38@stbi__proc:
	cmp	DWORD PTR _i$12[ebp], 64		; 00000040H
	jge	SHORT $LN36@stbi__proc

; 2809 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));

	cmp	DWORD PTR _sixteen$14[ebp], 0
	je	SHORT $LN53@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get16be
	add	esp, 4
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN54@stbi__proc
$LN53@stbi__proc:
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR tv147[ebp], ecx
$LN54@stbi__proc:
	mov	edx, DWORD PTR _t$13[ebp]
	shl	edx, 7
	mov	eax, DWORD PTR _z$[ebp]
	lea	ecx, DWORD PTR [eax+edx+13444]
	mov	edx, DWORD PTR _i$12[ebp]
	movzx	eax, BYTE PTR _stbi__jpeg_dezigzag[edx]
	mov	dx, WORD PTR tv147[ebp]
	mov	WORD PTR [ecx+eax*2], dx
	jmp	SHORT $LN37@stbi__proc
$LN36@stbi__proc:

; 2810 :             L -= (sixteen ? 129 : 65);

	cmp	DWORD PTR _sixteen$14[ebp], 0
	je	SHORT $LN55@stbi__proc
	mov	DWORD PTR tv150[ebp], 129		; 00000081H
	jmp	SHORT $LN56@stbi__proc
$LN55@stbi__proc:
	mov	DWORD PTR tv150[ebp], 65		; 00000041H
$LN56@stbi__proc:
	mov	eax, DWORD PTR _L$[ebp]
	sub	eax, DWORD PTR tv150[ebp]
	mov	DWORD PTR _L$[ebp], eax

; 2811 :          }

	jmp	$LN42@stbi__proc
$LN41@stbi__proc:

; 2812 :          return L==0;

	cmp	DWORD PTR _L$[ebp], 0
	jne	SHORT $LN57@stbi__proc
	mov	DWORD PTR tv153[ebp], 1
	jmp	SHORT $LN58@stbi__proc
$LN57@stbi__proc:
	mov	DWORD PTR tv153[ebp], 0
$LN58@stbi__proc:
	mov	eax, DWORD PTR tv153[ebp]
	jmp	$LN49@stbi__proc
$LN35@stbi__proc:

; 2813 : 
; 2814 :       case 0xC4: // DHT - define huffman table
; 2815 :          L = stbi__get16be(z->s)-2;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get16be
	add	esp, 4
	sub	eax, 2
	mov	DWORD PTR _L$[ebp], eax
$LN34@stbi__proc:

; 2816 :          while (L > 0) {

	cmp	DWORD PTR _L$[ebp], 0
	jle	$LN33@stbi__proc

; 2817 :             stbi_uc *v;
; 2818 :             int sizes[16],i,n=0;

	mov	DWORD PTR _n$8[ebp], 0

; 2819 :             int q = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _q$7[ebp], edx

; 2820 :             int tc = q >> 4;

	mov	eax, DWORD PTR _q$7[ebp]
	sar	eax, 4
	mov	DWORD PTR _tc$6[ebp], eax

; 2821 :             int th = q & 15;

	mov	eax, DWORD PTR _q$7[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _th$5[ebp], eax

; 2822 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");

	cmp	DWORD PTR _tc$6[ebp], 1
	jg	SHORT $LN31@stbi__proc
	cmp	DWORD PTR _th$5[ebp], 3
	jle	SHORT $LN32@stbi__proc
$LN31@stbi__proc:
	push	OFFSET ??_C@_0P@JLGKOCGN@bad?5DHT?5header?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN49@stbi__proc
$LN32@stbi__proc:

; 2823 :             for (i=0; i < 16; ++i) {

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN30@stbi__proc
$LN29@stbi__proc:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN30@stbi__proc:
	cmp	DWORD PTR _i$9[ebp], 16			; 00000010H
	jge	SHORT $LN28@stbi__proc

; 2824 :                sizes[i] = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _i$9[ebp]
	mov	DWORD PTR _sizes$10[ebp+eax*4], edx

; 2825 :                n += sizes[i];

	mov	eax, DWORD PTR _i$9[ebp]
	mov	ecx, DWORD PTR _n$8[ebp]
	add	ecx, DWORD PTR _sizes$10[ebp+eax*4]
	mov	DWORD PTR _n$8[ebp], ecx

; 2826 :             }

	jmp	SHORT $LN29@stbi__proc
$LN28@stbi__proc:

; 2827 :             L -= 17;

	mov	eax, DWORD PTR _L$[ebp]
	sub	eax, 17					; 00000011H
	mov	DWORD PTR _L$[ebp], eax

; 2828 :             if (tc == 0) {

	cmp	DWORD PTR _tc$6[ebp], 0
	jne	SHORT $LN27@stbi__proc

; 2829 :                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;

	lea	eax, DWORD PTR _sizes$10[ebp]
	push	eax
	imul	ecx, DWORD PTR _th$5[ebp], 1680
	mov	edx, DWORD PTR _z$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	push	eax
	call	_stbi__build_huffman
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@stbi__proc
	xor	eax, eax
	jmp	$LN49@stbi__proc
$LN26@stbi__proc:

; 2830 :                v = z->huff_dc[th].values;

	imul	eax, DWORD PTR _th$5[ebp], 1680
	mov	ecx, DWORD PTR _z$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1028]
	mov	DWORD PTR _v$11[ebp], edx

; 2831 :             } else {

	jmp	SHORT $LN25@stbi__proc
$LN27@stbi__proc:

; 2832 :                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;

	lea	eax, DWORD PTR _sizes$10[ebp]
	push	eax
	imul	ecx, DWORD PTR _th$5[ebp], 1680
	mov	edx, DWORD PTR _z$[ebp]
	lea	eax, DWORD PTR [edx+ecx+6724]
	push	eax
	call	_stbi__build_huffman
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN24@stbi__proc
	xor	eax, eax
	jmp	$LN49@stbi__proc
$LN24@stbi__proc:

; 2833 :                v = z->huff_ac[th].values;

	imul	eax, DWORD PTR _th$5[ebp], 1680
	mov	ecx, DWORD PTR _z$[ebp]
	lea	edx, DWORD PTR [ecx+eax+7748]
	mov	DWORD PTR _v$11[ebp], edx
$LN25@stbi__proc:

; 2834 :             }
; 2835 :             for (i=0; i < n; ++i)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN23@stbi__proc
$LN22@stbi__proc:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN23@stbi__proc:
	mov	eax, DWORD PTR _i$9[ebp]
	cmp	eax, DWORD PTR _n$8[ebp]
	jge	SHORT $LN21@stbi__proc

; 2836 :                v[i] = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	mov	edx, DWORD PTR _v$11[ebp]
	add	edx, DWORD PTR _i$9[ebp]
	mov	BYTE PTR [edx], al
	jmp	SHORT $LN22@stbi__proc
$LN21@stbi__proc:

; 2837 :             if (tc != 0)

	cmp	DWORD PTR _tc$6[ebp], 0
	je	SHORT $LN20@stbi__proc

; 2838 :                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);

	imul	eax, DWORD PTR _th$5[ebp], 1680
	mov	ecx, DWORD PTR _z$[ebp]
	lea	edx, DWORD PTR [ecx+eax+6724]
	push	edx
	mov	eax, DWORD PTR _th$5[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _z$[ebp]
	lea	edx, DWORD PTR [ecx+eax+13956]
	push	edx
	call	_stbi__build_fast_ac
	add	esp, 8
$LN20@stbi__proc:

; 2839 :             L -= n;

	mov	eax, DWORD PTR _L$[ebp]
	sub	eax, DWORD PTR _n$8[ebp]
	mov	DWORD PTR _L$[ebp], eax

; 2840 :          }

	jmp	$LN34@stbi__proc
$LN33@stbi__proc:

; 2841 :          return L==0;

	cmp	DWORD PTR _L$[ebp], 0
	jne	SHORT $LN59@stbi__proc
	mov	DWORD PTR tv222[ebp], 1
	jmp	SHORT $LN60@stbi__proc
$LN59@stbi__proc:
	mov	DWORD PTR tv222[ebp], 0
$LN60@stbi__proc:
	mov	eax, DWORD PTR tv222[ebp]
	jmp	$LN49@stbi__proc
$LN47@stbi__proc:

; 2842 :    }
; 2843 : 
; 2844 :    // check for comment block or APP blocks
; 2845 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {

	cmp	DWORD PTR _m$[ebp], 224			; 000000e0H
	jl	SHORT $LN17@stbi__proc
	cmp	DWORD PTR _m$[ebp], 239			; 000000efH
	jle	SHORT $LN18@stbi__proc
$LN17@stbi__proc:
	cmp	DWORD PTR _m$[ebp], 254			; 000000feH
	jne	$LN19@stbi__proc
$LN18@stbi__proc:

; 2846 :       L = stbi__get16be(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get16be
	add	esp, 4
	mov	DWORD PTR _L$[ebp], eax

; 2847 :       if (L < 2) {

	cmp	DWORD PTR _L$[ebp], 2
	jge	SHORT $LN16@stbi__proc

; 2848 :          if (m == 0xFE)

	cmp	DWORD PTR _m$[ebp], 254			; 000000feH
	jne	SHORT $LN15@stbi__proc

; 2849 :             return stbi__err("bad COM len","Corrupt JPEG");

	push	OFFSET ??_C@_0M@CICAFFCH@bad?5COM?5len?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN49@stbi__proc

; 2850 :          else

	jmp	SHORT $LN16@stbi__proc
$LN15@stbi__proc:

; 2851 :             return stbi__err("bad APP len","Corrupt JPEG");

	push	OFFSET ??_C@_0M@EENLKPDI@bad?5APP?5len?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN49@stbi__proc
$LN16@stbi__proc:

; 2852 :       }
; 2853 :       L -= 2;

	mov	eax, DWORD PTR _L$[ebp]
	sub	eax, 2
	mov	DWORD PTR _L$[ebp], eax

; 2854 : 
; 2855 :       if (m == 0xE0 && L >= 5) { // JFIF APP0 segment

	cmp	DWORD PTR _m$[ebp], 224			; 000000e0H
	jne	$LN13@stbi__proc
	cmp	DWORD PTR _L$[ebp], 5
	jl	$LN13@stbi__proc

; 2856 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 2857 :          int ok = 1;

	mov	DWORD PTR _ok$4[ebp], 1

; 2858 :          int i;
; 2859 :          for (i=0; i < 5; ++i)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN12@stbi__proc
$LN11@stbi__proc:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN12@stbi__proc:
	cmp	DWORD PTR _i$3[ebp], 5
	jge	SHORT $LN10@stbi__proc

; 2860 :             if (stbi__get8(z->s) != tag[i])

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _i$3[ebp]
	movzx	ecx, BYTE PTR ?tag@?O@??stbi__process_marker@@9@9[eax]
	cmp	edx, ecx
	je	SHORT $LN9@stbi__proc

; 2861 :                ok = 0;

	mov	DWORD PTR _ok$4[ebp], 0
$LN9@stbi__proc:

; 2862 :          L -= 5;

	jmp	SHORT $LN11@stbi__proc
$LN10@stbi__proc:
	mov	eax, DWORD PTR _L$[ebp]
	sub	eax, 5
	mov	DWORD PTR _L$[ebp], eax

; 2863 :          if (ok)

	cmp	DWORD PTR _ok$4[ebp], 0
	je	SHORT $LN8@stbi__proc

; 2864 :             z->jfif = 1;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18404], 1
$LN8@stbi__proc:

; 2865 :       } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment

	jmp	$LN7@stbi__proc
$LN13@stbi__proc:
	cmp	DWORD PTR _m$[ebp], 238			; 000000eeH
	jne	$LN7@stbi__proc
	cmp	DWORD PTR _L$[ebp], 12			; 0000000cH
	jl	$LN7@stbi__proc

; 2866 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 2867 :          int ok = 1;

	mov	DWORD PTR _ok$2[ebp], 1

; 2868 :          int i;
; 2869 :          for (i=0; i < 6; ++i)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN5@stbi__proc
$LN4@stbi__proc:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN5@stbi__proc:
	cmp	DWORD PTR _i$1[ebp], 6
	jge	SHORT $LN3@stbi__proc

; 2870 :             if (stbi__get8(z->s) != tag[i])

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _i$1[ebp]
	movzx	ecx, BYTE PTR ?tag@?BA@??stbi__process_marker@@9@9[eax]
	cmp	edx, ecx
	je	SHORT $LN2@stbi__proc

; 2871 :                ok = 0;

	mov	DWORD PTR _ok$2[ebp], 0
$LN2@stbi__proc:

; 2872 :          L -= 6;

	jmp	SHORT $LN4@stbi__proc
$LN3@stbi__proc:
	mov	eax, DWORD PTR _L$[ebp]
	sub	eax, 6
	mov	DWORD PTR _L$[ebp], eax

; 2873 :          if (ok) {

	cmp	DWORD PTR _ok$2[ebp], 0
	je	SHORT $LN7@stbi__proc

; 2874 :             stbi__get8(z->s); // version

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4

; 2875 :             stbi__get16be(z->s); // flags0

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get16be
	add	esp, 4

; 2876 :             stbi__get16be(z->s); // flags1

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get16be
	add	esp, 4

; 2877 :             z->app14_color_transform = stbi__get8(z->s); // color transform

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18408], edx

; 2878 :             L -= 6;

	mov	eax, DWORD PTR _L$[ebp]
	sub	eax, 6
	mov	DWORD PTR _L$[ebp], eax
$LN7@stbi__proc:

; 2879 :          }
; 2880 :       }
; 2881 : 
; 2882 :       stbi__skip(z->s, L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_stbi__skip
	add	esp, 8

; 2883 :       return 1;

	mov	eax, 1
	jmp	SHORT $LN49@stbi__proc
$LN19@stbi__proc:

; 2884 :    }
; 2885 : 
; 2886 :    return stbi__err("unknown marker","Corrupt JPEG");

	push	OFFSET ??_C@_0P@NNGPHMMK@unknown?5marker?$AA@
	call	_stbi__err
	add	esp, 4
$LN49@stbi__proc:

; 2887 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN64@stbi__proc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 464				; 000001d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN64@stbi__proc:
	DD	1
	DD	$LN63@stbi__proc
$LN63@stbi__proc:
	DD	-156					; ffffff64H
	DD	64					; 00000040H
	DD	$LN62@stbi__proc
$LN62@stbi__proc:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
	npad	2
$LN65@stbi__proc:
	DD	$LN35@stbi__proc
	DD	$LN43@stbi__proc
	DD	$LN45@stbi__proc
	DD	$LN46@stbi__proc
	DD	$LN47@stbi__proc
$LN61@stbi__proc:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_stbi__process_marker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__jpeg_finish
_TEXT	SEGMENT
_data$1 = -68						; size = 4
_h$2 = -56						; size = 4
_w$3 = -44						; size = 4
_n$4 = -32						; size = 4
_j$5 = -20						; size = 4
_i$6 = -8						; size = 4
_z$ = 8							; size = 4
_stbi__jpeg_finish PROC					; COMDAT

; 2769 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2770 :    if (z->progressive) {

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18380], 0
	je	$LN11@stbi__jpeg

; 2771 :       // dequantize and idct the data
; 2772 :       int i,j,n;
; 2773 :       for (n=0; n < z->s->img_n; ++n) {

	mov	DWORD PTR _n$4[ebp], 0
	jmp	SHORT $LN9@stbi__jpeg
$LN8@stbi__jpeg:
	mov	eax, DWORD PTR _n$4[ebp]
	add	eax, 1
	mov	DWORD PTR _n$4[ebp], eax
$LN9@stbi__jpeg:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _n$4[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	$LN11@stbi__jpeg

; 2774 :          int w = (z->img_comp[n].x+7) >> 3;

	imul	eax, DWORD PTR _n$4[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18104]
	add	edx, 7
	sar	edx, 3
	mov	DWORD PTR _w$3[ebp], edx

; 2775 :          int h = (z->img_comp[n].y+7) >> 3;

	imul	eax, DWORD PTR _n$4[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18108]
	add	edx, 7
	sar	edx, 3
	mov	DWORD PTR _h$2[ebp], edx

; 2776 :          for (j=0; j < h; ++j) {

	mov	DWORD PTR _j$5[ebp], 0
	jmp	SHORT $LN6@stbi__jpeg
$LN5@stbi__jpeg:
	mov	eax, DWORD PTR _j$5[ebp]
	add	eax, 1
	mov	DWORD PTR _j$5[ebp], eax
$LN6@stbi__jpeg:
	mov	eax, DWORD PTR _j$5[ebp]
	cmp	eax, DWORD PTR _h$2[ebp]
	jge	$LN4@stbi__jpeg

; 2777 :             for (i=0; i < w; ++i) {

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN3@stbi__jpeg
$LN2@stbi__jpeg:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN3@stbi__jpeg:
	mov	eax, DWORD PTR _i$6[ebp]
	cmp	eax, DWORD PTR _w$3[ebp]
	jge	$LN1@stbi__jpeg

; 2778 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

	imul	eax, DWORD PTR _n$4[ebp], 72
	imul	ecx, DWORD PTR _n$4[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	esi, DWORD PTR _j$5[ebp]
	imul	esi, DWORD PTR [edx+ecx+18140]
	add	esi, DWORD PTR _i$6[ebp]
	shl	esi, 6
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18136]
	lea	eax, DWORD PTR [edx+esi*2]
	mov	DWORD PTR _data$1[ebp], eax

; 2779 :                stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);

	imul	eax, DWORD PTR _n$4[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18088]
	shl	edx, 7
	mov	eax, DWORD PTR _z$[ebp]
	lea	ecx, DWORD PTR [eax+edx+13444]
	push	ecx
	mov	edx, DWORD PTR _data$1[ebp]
	push	edx
	call	_stbi__jpeg_dequantize
	add	esp, 8

; 2780 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);

	mov	esi, esp
	mov	eax, DWORD PTR _data$1[ebp]
	push	eax
	imul	ecx, DWORD PTR _n$4[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+ecx+18112]
	push	eax
	imul	ecx, DWORD PTR _n$4[ebp], 72
	imul	edx, DWORD PTR _n$4[ebp], 72
	mov	eax, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [eax+edx+18112]
	imul	edx, DWORD PTR _j$5[ebp]
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+18120]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	eax, DWORD PTR _i$6[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	push	ecx
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+18444]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2781 :             }

	jmp	$LN2@stbi__jpeg
$LN1@stbi__jpeg:

; 2782 :          }

	jmp	$LN5@stbi__jpeg
$LN4@stbi__jpeg:

; 2783 :       }

	jmp	$LN8@stbi__jpeg
$LN11@stbi__jpeg:

; 2784 :    }
; 2785 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__jpeg_finish ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__jpeg_dequantize
_TEXT	SEGMENT
_i$ = -8						; size = 4
_data$ = 8						; size = 4
_dequant$ = 12						; size = 4
_stbi__jpeg_dequantize PROC				; COMDAT

; 2762 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2763 :    int i;
; 2764 :    for (i=0; i < 64; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@stbi__jpeg
$LN2@stbi__jpeg:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@stbi__jpeg:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN4@stbi__jpeg

; 2765 :       data[i] *= dequant[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _dequant$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	movsx	eax, WORD PTR [ecx+eax*2]
	imul	eax, edx
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
	jmp	SHORT $LN2@stbi__jpeg
$LN4@stbi__jpeg:

; 2766 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__jpeg_dequantize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__parse_entropy_coded_data
_TEXT	SEGMENT
tv467 = -856						; size = 4
tv359 = -856						; size = 4
tv280 = -856						; size = 4
tv176 = -856						; size = 4
_data$1 = -656						; size = 4
_y2$2 = -644						; size = 4
_x2$3 = -632						; size = 4
_n$4 = -620						; size = 4
_y$5 = -608						; size = 4
_x$6 = -596						; size = 4
_k$7 = -584						; size = 4
_j$8 = -572						; size = 4
_i$9 = -560						; size = 4
_ha$10 = -548						; size = 4
_data$11 = -536						; size = 4
_h$12 = -524						; size = 4
_w$13 = -512						; size = 4
_n$14 = -500						; size = 4
_j$15 = -488						; size = 4
_i$16 = -476						; size = 4
_ha$17 = -464						; size = 4
_y2$18 = -452						; size = 4
_x2$19 = -440						; size = 4
_n$20 = -428						; size = 4
_data$21 = -416						; size = 128
_y$22 = -268						; size = 4
_x$23 = -256						; size = 4
_k$24 = -244						; size = 4
_j$25 = -232						; size = 4
_i$26 = -220						; size = 4
_ha$27 = -208						; size = 4
_h$28 = -196						; size = 4
_w$29 = -184						; size = 4
_n$30 = -172						; size = 4
_data$31 = -160						; size = 128
_j$32 = -24						; size = 4
_i$33 = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_z$ = 8							; size = 4
_stbi__parse_entropy_coded_data PROC			; COMDAT

; 2638 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 856				; 00000358H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-856]
	mov	ecx, 214				; 000000d6H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2639 :    stbi__jpeg_reset(z);

	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	_stbi__jpeg_reset
	add	esp, 4

; 2640 :    if (!z->progressive) {

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18380], 0
	jne	$LN71@stbi__pars

; 2641 :       if (z->scan_n == 1) {

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18416], 1
	jne	$LN70@stbi__pars

; 2642 :          int i,j;
; 2643 :          STBI_SIMD_ALIGN(short, data[64]);
; 2644 :          int n = z->order[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR [edx+ecx+18420]
	mov	DWORD PTR _n$30[ebp], eax

; 2645 :          // non-interleaved data, we just need to process one block at a time,
; 2646 :          // in trivial scanline order
; 2647 :          // number of blocks to do just depends on how many actual "pixels" this
; 2648 :          // component has, independent of interleaved MCU blocking and such
; 2649 :          int w = (z->img_comp[n].x+7) >> 3;

	imul	eax, DWORD PTR _n$30[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18104]
	add	edx, 7
	sar	edx, 3
	mov	DWORD PTR _w$29[ebp], edx

; 2650 :          int h = (z->img_comp[n].y+7) >> 3;

	imul	eax, DWORD PTR _n$30[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18108]
	add	edx, 7
	sar	edx, 3
	mov	DWORD PTR _h$28[ebp], edx

; 2651 :          for (j=0; j < h; ++j) {

	mov	DWORD PTR _j$32[ebp], 0
	jmp	SHORT $LN69@stbi__pars
$LN68@stbi__pars:
	mov	eax, DWORD PTR _j$32[ebp]
	add	eax, 1
	mov	DWORD PTR _j$32[ebp], eax
$LN69@stbi__pars:
	mov	eax, DWORD PTR _j$32[ebp]
	cmp	eax, DWORD PTR _h$28[ebp]
	jge	$LN67@stbi__pars

; 2652 :             for (i=0; i < w; ++i) {

	mov	DWORD PTR _i$33[ebp], 0
	jmp	SHORT $LN66@stbi__pars
$LN65@stbi__pars:
	mov	eax, DWORD PTR _i$33[ebp]
	add	eax, 1
	mov	DWORD PTR _i$33[ebp], eax
$LN66@stbi__pars:
	mov	eax, DWORD PTR _i$33[ebp]
	cmp	eax, DWORD PTR _w$29[ebp]
	jge	$LN64@stbi__pars

; 2653 :                int ha = z->img_comp[n].ha;

	imul	eax, DWORD PTR _n$30[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18096]
	mov	DWORD PTR _ha$27[ebp], edx

; 2654 :                if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

	imul	eax, DWORD PTR _n$30[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18088]
	shl	edx, 7
	mov	eax, DWORD PTR _z$[ebx]
	lea	ecx, DWORD PTR [eax+edx+13444]
	push	ecx
	mov	edx, DWORD PTR _n$30[ebp]
	push	edx
	mov	eax, DWORD PTR _ha$27[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+13956]
	push	edx
	imul	eax, DWORD PTR _ha$27[ebp], 1680
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+6724]
	push	edx
	imul	eax, DWORD PTR _n$30[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	imul	edx, DWORD PTR [ecx+eax+18092], 1680
	mov	eax, DWORD PTR _z$[ebx]
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	lea	edx, DWORD PTR _data$31[ebp]
	push	edx
	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	_stbi__jpeg_decode_block
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN63@stbi__pars
	xor	eax, eax
	jmp	$LN72@stbi__pars
$LN63@stbi__pars:

; 2655 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);

	mov	esi, esp
	lea	eax, DWORD PTR _data$31[ebp]
	push	eax
	imul	ecx, DWORD PTR _n$30[ebp], 72
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR [edx+ecx+18112]
	push	eax
	imul	ecx, DWORD PTR _n$30[ebp], 72
	imul	edx, DWORD PTR _n$30[ebp], 72
	mov	eax, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [eax+edx+18112]
	imul	edx, DWORD PTR _j$32[ebp]
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR [eax+ecx+18120]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	eax, DWORD PTR _i$33[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	push	ecx
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR [edx+18444]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2656 :                // every data block is an MCU, so countdown the restart interval
; 2657 :                if (--z->todo <= 0) {

	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR [eax+18440]
	sub	ecx, 1
	mov	DWORD PTR tv176[ebp], ecx
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR tv176[ebp]
	mov	DWORD PTR [edx+18440], eax
	cmp	DWORD PTR tv176[ebp], 0
	jg	SHORT $LN62@stbi__pars

; 2658 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18368], 24		; 00000018H
	jge	SHORT $LN61@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	_stbi__grow_buffer_unsafe
	add	esp, 4
$LN61@stbi__pars:

; 2659 :                   // if it's NOT a restart, then just bail, so we get corrupt data
; 2660 :                   // rather than no data
; 2661 :                   if (!STBI__RESTART(z->marker)) return 1;

	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 208				; 000000d0H
	jl	SHORT $LN59@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 215				; 000000d7H
	jle	SHORT $LN60@stbi__pars
$LN59@stbi__pars:
	mov	eax, 1
	jmp	$LN72@stbi__pars
$LN60@stbi__pars:

; 2662 :                   stbi__jpeg_reset(z);

	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	_stbi__jpeg_reset
	add	esp, 4
$LN62@stbi__pars:

; 2663 :                }
; 2664 :             }

	jmp	$LN65@stbi__pars
$LN64@stbi__pars:

; 2665 :          }

	jmp	$LN68@stbi__pars
$LN67@stbi__pars:

; 2666 :          return 1;

	mov	eax, 1
	jmp	$LN72@stbi__pars

; 2667 :       } else { // interleaved

	jmp	$LN58@stbi__pars
$LN70@stbi__pars:

; 2668 :          int i,j,k,x,y;
; 2669 :          STBI_SIMD_ALIGN(short, data[64]);
; 2670 :          for (j=0; j < z->img_mcu_y; ++j) {

	mov	DWORD PTR _j$25[ebp], 0
	jmp	SHORT $LN57@stbi__pars
$LN56@stbi__pars:
	mov	eax, DWORD PTR _j$25[ebp]
	add	eax, 1
	mov	DWORD PTR _j$25[ebp], eax
$LN57@stbi__pars:
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR _j$25[ebp]
	cmp	ecx, DWORD PTR [eax+18064]
	jge	$LN55@stbi__pars

; 2671 :             for (i=0; i < z->img_mcu_x; ++i) {

	mov	DWORD PTR _i$26[ebp], 0
	jmp	SHORT $LN54@stbi__pars
$LN53@stbi__pars:
	mov	eax, DWORD PTR _i$26[ebp]
	add	eax, 1
	mov	DWORD PTR _i$26[ebp], eax
$LN54@stbi__pars:
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR _i$26[ebp]
	cmp	ecx, DWORD PTR [eax+18060]
	jge	$LN52@stbi__pars

; 2672 :                // scan an interleaved mcu... process scan_n components in order
; 2673 :                for (k=0; k < z->scan_n; ++k) {

	mov	DWORD PTR _k$24[ebp], 0
	jmp	SHORT $LN51@stbi__pars
$LN50@stbi__pars:
	mov	eax, DWORD PTR _k$24[ebp]
	add	eax, 1
	mov	DWORD PTR _k$24[ebp], eax
$LN51@stbi__pars:
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR _k$24[ebp]
	cmp	ecx, DWORD PTR [eax+18416]
	jge	$LN49@stbi__pars

; 2674 :                   int n = z->order[k];

	mov	eax, DWORD PTR _k$24[ebp]
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax*4+18420]
	mov	DWORD PTR _n$20[ebp], edx

; 2675 :                   // scan out an mcu's worth of this component; that's just determined
; 2676 :                   // by the basic H and V specified for the component
; 2677 :                   for (y=0; y < z->img_comp[n].v; ++y) {

	mov	DWORD PTR _y$22[ebp], 0
	jmp	SHORT $LN48@stbi__pars
$LN47@stbi__pars:
	mov	eax, DWORD PTR _y$22[ebp]
	add	eax, 1
	mov	DWORD PTR _y$22[ebp], eax
$LN48@stbi__pars:
	imul	eax, DWORD PTR _n$20[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _y$22[ebp]
	cmp	edx, DWORD PTR [ecx+eax+18084]
	jge	$LN46@stbi__pars

; 2678 :                      for (x=0; x < z->img_comp[n].h; ++x) {

	mov	DWORD PTR _x$23[ebp], 0
	jmp	SHORT $LN45@stbi__pars
$LN44@stbi__pars:
	mov	eax, DWORD PTR _x$23[ebp]
	add	eax, 1
	mov	DWORD PTR _x$23[ebp], eax
$LN45@stbi__pars:
	imul	eax, DWORD PTR _n$20[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _x$23[ebp]
	cmp	edx, DWORD PTR [ecx+eax+18080]
	jge	$LN43@stbi__pars

; 2679 :                         int x2 = (i*z->img_comp[n].h + x)*8;

	imul	eax, DWORD PTR _n$20[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _i$26[ebp]
	imul	edx, DWORD PTR [ecx+eax+18080]
	add	edx, DWORD PTR _x$23[ebp]
	shl	edx, 3
	mov	DWORD PTR _x2$19[ebp], edx

; 2680 :                         int y2 = (j*z->img_comp[n].v + y)*8;

	imul	eax, DWORD PTR _n$20[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _j$25[ebp]
	imul	edx, DWORD PTR [ecx+eax+18084]
	add	edx, DWORD PTR _y$22[ebp]
	shl	edx, 3
	mov	DWORD PTR _y2$18[ebp], edx

; 2681 :                         int ha = z->img_comp[n].ha;

	imul	eax, DWORD PTR _n$20[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18096]
	mov	DWORD PTR _ha$17[ebp], edx

; 2682 :                         if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

	imul	eax, DWORD PTR _n$20[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18088]
	shl	edx, 7
	mov	eax, DWORD PTR _z$[ebx]
	lea	ecx, DWORD PTR [eax+edx+13444]
	push	ecx
	mov	edx, DWORD PTR _n$20[ebp]
	push	edx
	mov	eax, DWORD PTR _ha$17[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+13956]
	push	edx
	imul	eax, DWORD PTR _ha$17[ebp], 1680
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+6724]
	push	edx
	imul	eax, DWORD PTR _n$20[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	imul	edx, DWORD PTR [ecx+eax+18092], 1680
	mov	eax, DWORD PTR _z$[ebx]
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	lea	edx, DWORD PTR _data$21[ebp]
	push	edx
	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	_stbi__jpeg_decode_block
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN42@stbi__pars
	xor	eax, eax
	jmp	$LN72@stbi__pars
$LN42@stbi__pars:

; 2683 :                         z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);

	mov	esi, esp
	lea	eax, DWORD PTR _data$21[ebp]
	push	eax
	imul	ecx, DWORD PTR _n$20[ebp], 72
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR [edx+ecx+18112]
	push	eax
	imul	ecx, DWORD PTR _n$20[ebp], 72
	imul	edx, DWORD PTR _n$20[ebp], 72
	mov	eax, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [eax+edx+18112]
	imul	edx, DWORD PTR _y2$18[ebp]
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR [eax+ecx+18120]
	add	ecx, edx
	add	ecx, DWORD PTR _x2$19[ebp]
	push	ecx
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR [edx+18444]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2684 :                      }

	jmp	$LN44@stbi__pars
$LN43@stbi__pars:

; 2685 :                   }

	jmp	$LN47@stbi__pars
$LN46@stbi__pars:

; 2686 :                }

	jmp	$LN50@stbi__pars
$LN49@stbi__pars:

; 2687 :                // after all interleaved components, that's an interleaved MCU,
; 2688 :                // so now count down the restart interval
; 2689 :                if (--z->todo <= 0) {

	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR [eax+18440]
	sub	ecx, 1
	mov	DWORD PTR tv280[ebp], ecx
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR tv280[ebp]
	mov	DWORD PTR [edx+18440], eax
	cmp	DWORD PTR tv280[ebp], 0
	jg	SHORT $LN41@stbi__pars

; 2690 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18368], 24		; 00000018H
	jge	SHORT $LN40@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	_stbi__grow_buffer_unsafe
	add	esp, 4
$LN40@stbi__pars:

; 2691 :                   if (!STBI__RESTART(z->marker)) return 1;

	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 208				; 000000d0H
	jl	SHORT $LN38@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 215				; 000000d7H
	jle	SHORT $LN39@stbi__pars
$LN38@stbi__pars:
	mov	eax, 1
	jmp	$LN72@stbi__pars
$LN39@stbi__pars:

; 2692 :                   stbi__jpeg_reset(z);

	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	_stbi__jpeg_reset
	add	esp, 4
$LN41@stbi__pars:

; 2693 :                }
; 2694 :             }

	jmp	$LN53@stbi__pars
$LN52@stbi__pars:

; 2695 :          }

	jmp	$LN56@stbi__pars
$LN55@stbi__pars:

; 2696 :          return 1;

	mov	eax, 1
	jmp	$LN72@stbi__pars
$LN58@stbi__pars:

; 2697 :       }
; 2698 :    } else {

	jmp	$LN72@stbi__pars
$LN71@stbi__pars:

; 2699 :       if (z->scan_n == 1) {

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18416], 1
	jne	$LN36@stbi__pars

; 2700 :          int i,j;
; 2701 :          int n = z->order[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR [edx+ecx+18420]
	mov	DWORD PTR _n$14[ebp], eax

; 2702 :          // non-interleaved data, we just need to process one block at a time,
; 2703 :          // in trivial scanline order
; 2704 :          // number of blocks to do just depends on how many actual "pixels" this
; 2705 :          // component has, independent of interleaved MCU blocking and such
; 2706 :          int w = (z->img_comp[n].x+7) >> 3;

	imul	eax, DWORD PTR _n$14[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18104]
	add	edx, 7
	sar	edx, 3
	mov	DWORD PTR _w$13[ebp], edx

; 2707 :          int h = (z->img_comp[n].y+7) >> 3;

	imul	eax, DWORD PTR _n$14[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18108]
	add	edx, 7
	sar	edx, 3
	mov	DWORD PTR _h$12[ebp], edx

; 2708 :          for (j=0; j < h; ++j) {

	mov	DWORD PTR _j$15[ebp], 0
	jmp	SHORT $LN35@stbi__pars
$LN34@stbi__pars:
	mov	eax, DWORD PTR _j$15[ebp]
	add	eax, 1
	mov	DWORD PTR _j$15[ebp], eax
$LN35@stbi__pars:
	mov	eax, DWORD PTR _j$15[ebp]
	cmp	eax, DWORD PTR _h$12[ebp]
	jge	$LN33@stbi__pars

; 2709 :             for (i=0; i < w; ++i) {

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN32@stbi__pars
$LN31@stbi__pars:
	mov	eax, DWORD PTR _i$16[ebp]
	add	eax, 1
	mov	DWORD PTR _i$16[ebp], eax
$LN32@stbi__pars:
	mov	eax, DWORD PTR _i$16[ebp]
	cmp	eax, DWORD PTR _w$13[ebp]
	jge	$LN30@stbi__pars

; 2710 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

	imul	eax, DWORD PTR _n$14[ebp], 72
	imul	ecx, DWORD PTR _n$14[ebp], 72
	mov	edx, DWORD PTR _z$[ebx]
	mov	esi, DWORD PTR _j$15[ebp]
	imul	esi, DWORD PTR [edx+ecx+18140]
	add	esi, DWORD PTR _i$16[ebp]
	shl	esi, 6
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18136]
	lea	eax, DWORD PTR [edx+esi*2]
	mov	DWORD PTR _data$11[ebp], eax

; 2711 :                if (z->spec_start == 0) {

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18384], 0
	jne	SHORT $LN29@stbi__pars

; 2712 :                   if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

	mov	eax, DWORD PTR _n$14[ebp]
	push	eax
	imul	ecx, DWORD PTR _n$14[ebp], 72
	mov	edx, DWORD PTR _z$[ebx]
	imul	eax, DWORD PTR [edx+ecx+18092], 1680
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+4]
	push	edx
	mov	eax, DWORD PTR _data$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebx]
	push	ecx
	call	_stbi__jpeg_decode_block_prog_dc
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN28@stbi__pars

; 2713 :                      return 0;

	xor	eax, eax
	jmp	$LN72@stbi__pars
$LN28@stbi__pars:

; 2714 :                } else {

	jmp	SHORT $LN27@stbi__pars
$LN29@stbi__pars:

; 2715 :                   int ha = z->img_comp[n].ha;

	imul	eax, DWORD PTR _n$14[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18096]
	mov	DWORD PTR _ha$10[ebp], edx

; 2716 :                   if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))

	mov	eax, DWORD PTR _ha$10[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+13956]
	push	edx
	imul	eax, DWORD PTR _ha$10[ebp], 1680
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+6724]
	push	edx
	mov	eax, DWORD PTR _data$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebx]
	push	ecx
	call	_stbi__jpeg_decode_block_prog_ac
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN27@stbi__pars

; 2717 :                      return 0;

	xor	eax, eax
	jmp	$LN72@stbi__pars
$LN27@stbi__pars:

; 2718 :                }
; 2719 :                // every data block is an MCU, so countdown the restart interval
; 2720 :                if (--z->todo <= 0) {

	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR [eax+18440]
	sub	ecx, 1
	mov	DWORD PTR tv359[ebp], ecx
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR tv359[ebp]
	mov	DWORD PTR [edx+18440], eax
	cmp	DWORD PTR tv359[ebp], 0
	jg	SHORT $LN25@stbi__pars

; 2721 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18368], 24		; 00000018H
	jge	SHORT $LN24@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	_stbi__grow_buffer_unsafe
	add	esp, 4
$LN24@stbi__pars:

; 2722 :                   if (!STBI__RESTART(z->marker)) return 1;

	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 208				; 000000d0H
	jl	SHORT $LN22@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 215				; 000000d7H
	jle	SHORT $LN23@stbi__pars
$LN22@stbi__pars:
	mov	eax, 1
	jmp	$LN72@stbi__pars
$LN23@stbi__pars:

; 2723 :                   stbi__jpeg_reset(z);

	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	_stbi__jpeg_reset
	add	esp, 4
$LN25@stbi__pars:

; 2724 :                }
; 2725 :             }

	jmp	$LN31@stbi__pars
$LN30@stbi__pars:

; 2726 :          }

	jmp	$LN34@stbi__pars
$LN33@stbi__pars:

; 2727 :          return 1;

	mov	eax, 1
	jmp	$LN72@stbi__pars

; 2728 :       } else { // interleaved

	jmp	$LN72@stbi__pars
$LN36@stbi__pars:

; 2729 :          int i,j,k,x,y;
; 2730 :          for (j=0; j < z->img_mcu_y; ++j) {

	mov	DWORD PTR _j$8[ebp], 0
	jmp	SHORT $LN20@stbi__pars
$LN19@stbi__pars:
	mov	eax, DWORD PTR _j$8[ebp]
	add	eax, 1
	mov	DWORD PTR _j$8[ebp], eax
$LN20@stbi__pars:
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR _j$8[ebp]
	cmp	ecx, DWORD PTR [eax+18064]
	jge	$LN18@stbi__pars

; 2731 :             for (i=0; i < z->img_mcu_x; ++i) {

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN17@stbi__pars
$LN16@stbi__pars:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN17@stbi__pars:
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR _i$9[ebp]
	cmp	ecx, DWORD PTR [eax+18060]
	jge	$LN15@stbi__pars

; 2732 :                // scan an interleaved mcu... process scan_n components in order
; 2733 :                for (k=0; k < z->scan_n; ++k) {

	mov	DWORD PTR _k$7[ebp], 0
	jmp	SHORT $LN14@stbi__pars
$LN13@stbi__pars:
	mov	eax, DWORD PTR _k$7[ebp]
	add	eax, 1
	mov	DWORD PTR _k$7[ebp], eax
$LN14@stbi__pars:
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR _k$7[ebp]
	cmp	ecx, DWORD PTR [eax+18416]
	jge	$LN12@stbi__pars

; 2734 :                   int n = z->order[k];

	mov	eax, DWORD PTR _k$7[ebp]
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax*4+18420]
	mov	DWORD PTR _n$4[ebp], edx

; 2735 :                   // scan out an mcu's worth of this component; that's just determined
; 2736 :                   // by the basic H and V specified for the component
; 2737 :                   for (y=0; y < z->img_comp[n].v; ++y) {

	mov	DWORD PTR _y$5[ebp], 0
	jmp	SHORT $LN11@stbi__pars
$LN10@stbi__pars:
	mov	eax, DWORD PTR _y$5[ebp]
	add	eax, 1
	mov	DWORD PTR _y$5[ebp], eax
$LN11@stbi__pars:
	imul	eax, DWORD PTR _n$4[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _y$5[ebp]
	cmp	edx, DWORD PTR [ecx+eax+18084]
	jge	$LN9@stbi__pars

; 2738 :                      for (x=0; x < z->img_comp[n].h; ++x) {

	mov	DWORD PTR _x$6[ebp], 0
	jmp	SHORT $LN8@stbi__pars
$LN7@stbi__pars:
	mov	eax, DWORD PTR _x$6[ebp]
	add	eax, 1
	mov	DWORD PTR _x$6[ebp], eax
$LN8@stbi__pars:
	imul	eax, DWORD PTR _n$4[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _x$6[ebp]
	cmp	edx, DWORD PTR [ecx+eax+18080]
	jge	$LN6@stbi__pars

; 2739 :                         int x2 = (i*z->img_comp[n].h + x);

	imul	eax, DWORD PTR _n$4[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _i$9[ebp]
	imul	edx, DWORD PTR [ecx+eax+18080]
	add	edx, DWORD PTR _x$6[ebp]
	mov	DWORD PTR _x2$3[ebp], edx

; 2740 :                         int y2 = (j*z->img_comp[n].v + y);

	imul	eax, DWORD PTR _n$4[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _j$8[ebp]
	imul	edx, DWORD PTR [ecx+eax+18084]
	add	edx, DWORD PTR _y$5[ebp]
	mov	DWORD PTR _y2$2[ebp], edx

; 2741 :                         short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);

	imul	eax, DWORD PTR _n$4[ebp], 72
	imul	ecx, DWORD PTR _n$4[ebp], 72
	mov	edx, DWORD PTR _z$[ebx]
	mov	esi, DWORD PTR _y2$2[ebp]
	imul	esi, DWORD PTR [edx+ecx+18140]
	add	esi, DWORD PTR _x2$3[ebp]
	shl	esi, 6
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18136]
	lea	eax, DWORD PTR [edx+esi*2]
	mov	DWORD PTR _data$1[ebp], eax

; 2742 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

	mov	eax, DWORD PTR _n$4[ebp]
	push	eax
	imul	ecx, DWORD PTR _n$4[ebp], 72
	mov	edx, DWORD PTR _z$[ebx]
	imul	eax, DWORD PTR [edx+ecx+18092], 1680
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+4]
	push	edx
	mov	eax, DWORD PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebx]
	push	ecx
	call	_stbi__jpeg_decode_block_prog_dc
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN5@stbi__pars

; 2743 :                            return 0;

	xor	eax, eax
	jmp	$LN72@stbi__pars
$LN5@stbi__pars:

; 2744 :                      }

	jmp	$LN7@stbi__pars
$LN6@stbi__pars:

; 2745 :                   }

	jmp	$LN10@stbi__pars
$LN9@stbi__pars:

; 2746 :                }

	jmp	$LN13@stbi__pars
$LN12@stbi__pars:

; 2747 :                // after all interleaved components, that's an interleaved MCU,
; 2748 :                // so now count down the restart interval
; 2749 :                if (--z->todo <= 0) {

	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR [eax+18440]
	sub	ecx, 1
	mov	DWORD PTR tv467[ebp], ecx
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR tv467[ebp]
	mov	DWORD PTR [edx+18440], eax
	cmp	DWORD PTR tv467[ebp], 0
	jg	SHORT $LN4@stbi__pars

; 2750 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18368], 24		; 00000018H
	jge	SHORT $LN3@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	_stbi__grow_buffer_unsafe
	add	esp, 4
$LN3@stbi__pars:

; 2751 :                   if (!STBI__RESTART(z->marker)) return 1;

	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 208				; 000000d0H
	jl	SHORT $LN1@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 215				; 000000d7H
	jle	SHORT $LN2@stbi__pars
$LN1@stbi__pars:
	mov	eax, 1
	jmp	SHORT $LN72@stbi__pars
$LN2@stbi__pars:

; 2752 :                   stbi__jpeg_reset(z);

	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	_stbi__jpeg_reset
	add	esp, 4
$LN4@stbi__pars:

; 2753 :                }
; 2754 :             }

	jmp	$LN16@stbi__pars
$LN15@stbi__pars:

; 2755 :          }

	jmp	$LN19@stbi__pars
$LN18@stbi__pars:

; 2756 :          return 1;

	mov	eax, 1
$LN72@stbi__pars:

; 2757 :       }
; 2758 :    }
; 2759 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN77@stbi__pars
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
	npad	1
$LN77@stbi__pars:
	DD	2
	DD	$LN76@stbi__pars
$LN76@stbi__pars:
	DD	-160					; ffffff60H
	DD	128					; 00000080H
	DD	$LN74@stbi__pars
	DD	-416					; fffffe60H
	DD	128					; 00000080H
	DD	$LN75@stbi__pars
$LN75@stbi__pars:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$LN74@stbi__pars:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
_stbi__parse_entropy_coded_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__jpeg_reset
_TEXT	SEGMENT
tv88 = -196						; size = 4
_j$ = 8							; size = 4
_stbi__jpeg_reset PROC					; COMDAT

; 2625 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2626 :    j->code_bits = 0;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18368], 0

; 2627 :    j->code_buffer = 0;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18364], 0

; 2628 :    j->nomore = 0;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18376], 0

; 2629 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;

	mov	eax, 72					; 00000048H
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+ecx+18100], 0
	mov	eax, 72					; 00000048H
	shl	eax, 1
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+eax+18100], 0
	mov	edx, 72					; 00000048H
	shl	edx, 0
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+edx+18100], 0
	mov	ecx, 72					; 00000048H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+edx+18100], 0

; 2630 :    j->marker = STBI__MARKER_none;

	mov	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax+18372], 255		; 000000ffH

; 2631 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18436], 0
	je	SHORT $LN3@stbi__jpeg
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [ecx+18436]
	mov	DWORD PTR tv88[ebp], edx
	jmp	SHORT $LN4@stbi__jpeg
$LN3@stbi__jpeg:
	mov	DWORD PTR tv88[ebp], 2147483647		; 7fffffffH
$LN4@stbi__jpeg:
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR tv88[ebp]
	mov	DWORD PTR [eax+18440], ecx

; 2632 :    j->eob_run = 0;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18400], 0

; 2633 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2634 :    // since we don't even allow 1<<30 pixels
; 2635 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__jpeg_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__get_marker
_TEXT	SEGMENT
_x$ = -5						; size = 1
_j$ = 8							; size = 4
_stbi__get_marker PROC					; COMDAT

; 2608 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2609 :    stbi_uc x;
; 2610 :    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }

	mov	eax, DWORD PTR _j$[ebp]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN4@stbi__get_
	mov	eax, DWORD PTR _j$[ebp]
	mov	cl, BYTE PTR [eax+18372]
	mov	BYTE PTR _x$[ebp], cl
	mov	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax+18372], 255		; 000000ffH
	mov	al, BYTE PTR _x$[ebp]
	jmp	SHORT $LN5@stbi__get_
$LN4@stbi__get_:

; 2611 :    x = stbi__get8(j->s);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	mov	BYTE PTR _x$[ebp], al

; 2612 :    if (x != 0xff) return STBI__MARKER_none;

	movzx	eax, BYTE PTR _x$[ebp]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN2@stbi__get_
	or	al, 255					; 000000ffH
	jmp	SHORT $LN5@stbi__get_
$LN2@stbi__get_:

; 2613 :    while (x == 0xff)

	movzx	eax, BYTE PTR _x$[ebp]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN1@stbi__get_

; 2614 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	mov	BYTE PTR _x$[ebp], al
	jmp	SHORT $LN2@stbi__get_
$LN1@stbi__get_:

; 2615 :    return x;

	mov	al, BYTE PTR _x$[ebp]
$LN5@stbi__get_:

; 2616 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__get_marker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__idct_simd
_TEXT	SEGMENT
_p3$1 = -5344						; size = 16
_p2$2 = -5312						; size = 16
_p1$3 = -5280						; size = 16
_p0$4 = -5248						; size = 16
_dif_h$5 = -5216					; size = 16
_dif_l$6 = -5184					; size = 16
_sum_h$7 = -5152					; size = 16
_sum_l$8 = -5120					; size = 16
_abiased_h$9 = -5088					; size = 16
_abiased_l$10 = -5056					; size = 16
_dif_h$11 = -5024					; size = 16
_dif_l$12 = -4992					; size = 16
_sum_h$13 = -4960					; size = 16
_sum_l$14 = -4928					; size = 16
_abiased_h$15 = -4896					; size = 16
_abiased_l$16 = -4864					; size = 16
_dif_h$17 = -4832					; size = 16
_dif_l$18 = -4800					; size = 16
_sum_h$19 = -4768					; size = 16
_sum_l$20 = -4736					; size = 16
_abiased_h$21 = -4704					; size = 16
_abiased_l$22 = -4672					; size = 16
_dif_h$23 = -4640					; size = 16
_dif_l$24 = -4608					; size = 16
_sum_h$25 = -4576					; size = 16
_sum_l$26 = -4544					; size = 16
_abiased_h$27 = -4512					; size = 16
_abiased_l$28 = -4480					; size = 16
_x7_h$29 = -4448					; size = 16
_x7_l$30 = -4416					; size = 16
_x6_h$31 = -4384					; size = 16
_x6_l$32 = -4352					; size = 16
_x5_h$33 = -4320					; size = 16
_x5_l$34 = -4288					; size = 16
_x4_h$35 = -4256					; size = 16
_x4_l$36 = -4224					; size = 16
_y5o_h$37 = -4192					; size = 16
_y5o_l$38 = -4160					; size = 16
_y4o_h$39 = -4128					; size = 16
_y4o_l$40 = -4096					; size = 16
_rot1_0hi$41 = -4064					; size = 16
_rot1_0lo$42 = -4032					; size = 16
_sum35$43 = -4000					; size = 16
_sum17$44 = -3968					; size = 16
_y3o_h$45 = -3936					; size = 16
_y3o_l$46 = -3904					; size = 16
_y1o_h$47 = -3872					; size = 16
_y1o_l$48 = -3840					; size = 16
_rot3_0hi$49 = -3808					; size = 16
_rot3_0lo$50 = -3776					; size = 16
_y2o_h$51 = -3744					; size = 16
_y2o_l$52 = -3712					; size = 16
_y0o_h$53 = -3680					; size = 16
_y0o_l$54 = -3648					; size = 16
_rot2_0hi$55 = -3616					; size = 16
_rot2_0lo$56 = -3584					; size = 16
_x2_h$57 = -3552					; size = 16
_x2_l$58 = -3520					; size = 16
_x1_h$59 = -3488					; size = 16
_x1_l$60 = -3456					; size = 16
_x3_h$61 = -3424					; size = 16
_x3_l$62 = -3392					; size = 16
_x0_h$63 = -3360					; size = 16
_x0_l$64 = -3328					; size = 16
_t1e_h$65 = -3296					; size = 16
_t1e_l$66 = -3264					; size = 16
_t0e_h$67 = -3232					; size = 16
_t0e_l$68 = -3200					; size = 16
_dif04$69 = -3168					; size = 16
_sum04$70 = -3136					; size = 16
_t3e_h$71 = -3104					; size = 16
_t3e_l$72 = -3072					; size = 16
_t2e_h$73 = -3040					; size = 16
_t2e_l$74 = -3008					; size = 16
_rot0_0hi$75 = -2976					; size = 16
_rot0_0lo$76 = -2944					; size = 16
_dif_h$77 = -2912					; size = 16
_dif_l$78 = -2880					; size = 16
_sum_h$79 = -2848					; size = 16
_sum_l$80 = -2816					; size = 16
_abiased_h$81 = -2784					; size = 16
_abiased_l$82 = -2752					; size = 16
_dif_h$83 = -2720					; size = 16
_dif_l$84 = -2688					; size = 16
_sum_h$85 = -2656					; size = 16
_sum_l$86 = -2624					; size = 16
_abiased_h$87 = -2592					; size = 16
_abiased_l$88 = -2560					; size = 16
_dif_h$89 = -2528					; size = 16
_dif_l$90 = -2496					; size = 16
_sum_h$91 = -2464					; size = 16
_sum_l$92 = -2432					; size = 16
_abiased_h$93 = -2400					; size = 16
_abiased_l$94 = -2368					; size = 16
_dif_h$95 = -2336					; size = 16
_dif_l$96 = -2304					; size = 16
_sum_h$97 = -2272					; size = 16
_sum_l$98 = -2240					; size = 16
_abiased_h$99 = -2208					; size = 16
_abiased_l$100 = -2176					; size = 16
_x7_h$101 = -2144					; size = 16
_x7_l$102 = -2112					; size = 16
_x6_h$103 = -2080					; size = 16
_x6_l$104 = -2048					; size = 16
_x5_h$105 = -2016					; size = 16
_x5_l$106 = -1984					; size = 16
_x4_h$107 = -1952					; size = 16
_x4_l$108 = -1920					; size = 16
_y5o_h$109 = -1888					; size = 16
_y5o_l$110 = -1856					; size = 16
_y4o_h$111 = -1824					; size = 16
_y4o_l$112 = -1792					; size = 16
_rot1_0hi$113 = -1760					; size = 16
_rot1_0lo$114 = -1728					; size = 16
_sum35$115 = -1696					; size = 16
_sum17$116 = -1664					; size = 16
_y3o_h$117 = -1632					; size = 16
_y3o_l$118 = -1600					; size = 16
_y1o_h$119 = -1568					; size = 16
_y1o_l$120 = -1536					; size = 16
_rot3_0hi$121 = -1504					; size = 16
_rot3_0lo$122 = -1472					; size = 16
_y2o_h$123 = -1440					; size = 16
_y2o_l$124 = -1408					; size = 16
_y0o_h$125 = -1376					; size = 16
_y0o_l$126 = -1344					; size = 16
_rot2_0hi$127 = -1312					; size = 16
_rot2_0lo$128 = -1280					; size = 16
_x2_h$129 = -1248					; size = 16
_x2_l$130 = -1216					; size = 16
_x1_h$131 = -1184					; size = 16
_x1_l$132 = -1152					; size = 16
_x3_h$133 = -1120					; size = 16
_x3_l$134 = -1088					; size = 16
_x0_h$135 = -1056					; size = 16
_x0_l$136 = -1024					; size = 16
_t1e_h$137 = -992					; size = 16
_t1e_l$138 = -960					; size = 16
_t0e_h$139 = -928					; size = 16
_t0e_l$140 = -896					; size = 16
_dif04$141 = -864					; size = 16
_sum04$142 = -832					; size = 16
_t3e_h$143 = -800					; size = 16
_t3e_l$144 = -768					; size = 16
_t2e_h$145 = -736					; size = 16
_t2e_l$146 = -704					; size = 16
_rot0_0hi$147 = -672					; size = 16
_rot0_0lo$148 = -640					; size = 16
_bias_1$ = -608						; size = 16
_bias_0$ = -576						; size = 16
_rot3_1$ = -544						; size = 16
_rot3_0$ = -512						; size = 16
_rot2_1$ = -480						; size = 16
_rot2_0$ = -448						; size = 16
_rot1_1$ = -416						; size = 16
_rot1_0$ = -384						; size = 16
_rot0_1$ = -352						; size = 16
_rot0_0$ = -320						; size = 16
_tmp$ = -288						; size = 16
_row7$ = -256						; size = 16
_row6$ = -224						; size = 16
_row5$ = -192						; size = 16
_row4$ = -160						; size = 16
_row3$ = -128						; size = 16
_row2$ = -96						; size = 16
_row1$ = -64						; size = 16
_row0$ = -32						; size = 16
_out$ = 8						; size = 4
_out_stride$ = 12					; size = 4
_data$ = 16						; size = 4
_stbi__idct_simd PROC					; COMDAT

; 2219 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	mov	eax, 5544				; 000015a8H
	call	__chkstk
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-5544]
	mov	ecx, 1386				; 0000056aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2220 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2221 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2222 :    __m128i tmp;
; 2223 : 
; 2224 :    // dot product constant: even elems=x, odd elems=y
; 2225 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2226 : 
; 2227 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2228 :    // out(1) = c1[even]*x + c1[odd]*y
; 2229 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2230 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2231 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2232 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2233 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2234 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2235 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2236 : 
; 2237 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2238 :    #define dct_widen(out, in) \
; 2239 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2240 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2241 : 
; 2242 :    // wide add
; 2243 :    #define dct_wadd(out, a, b) \
; 2244 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2245 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2246 : 
; 2247 :    // wide sub
; 2248 :    #define dct_wsub(out, a, b) \
; 2249 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2250 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2251 : 
; 2252 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2253 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2254 :       { \
; 2255 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2256 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2257 :          dct_wadd(sum, abiased, b); \
; 2258 :          dct_wsub(dif, abiased, b); \
; 2259 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2260 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2261 :       }
; 2262 : 
; 2263 :    // 8-bit interleave step (for transposes)
; 2264 :    #define dct_interleave8(a, b) \
; 2265 :       tmp = a; \
; 2266 :       a = _mm_unpacklo_epi8(a, b); \
; 2267 :       b = _mm_unpackhi_epi8(tmp, b)
; 2268 : 
; 2269 :    // 16-bit interleave step (for transposes)
; 2270 :    #define dct_interleave16(a, b) \
; 2271 :       tmp = a; \
; 2272 :       a = _mm_unpacklo_epi16(a, b); \
; 2273 :       b = _mm_unpackhi_epi16(tmp, b)
; 2274 : 
; 2275 :    #define dct_pass(bias,shift) \
; 2276 :       { \
; 2277 :          /* even part */ \
; 2278 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2279 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2280 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2281 :          dct_widen(t0e, sum04); \
; 2282 :          dct_widen(t1e, dif04); \
; 2283 :          dct_wadd(x0, t0e, t3e); \
; 2284 :          dct_wsub(x3, t0e, t3e); \
; 2285 :          dct_wadd(x1, t1e, t2e); \
; 2286 :          dct_wsub(x2, t1e, t2e); \
; 2287 :          /* odd part */ \
; 2288 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2289 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2290 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2291 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2292 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2293 :          dct_wadd(x4, y0o, y4o); \
; 2294 :          dct_wadd(x5, y1o, y5o); \
; 2295 :          dct_wadd(x6, y2o, y5o); \
; 2296 :          dct_wadd(x7, y3o, y4o); \
; 2297 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2298 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2299 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2300 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2301 :       }
; 2302 : 
; 2303 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));

	movdqa	xmm0, XMMWORD PTR __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
	movdqa	XMMWORD PTR _rot0_0$[ebp], xmm0

; 2304 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));

	movdqa	xmm0, XMMWORD PTR __xmm@08a914e808a914e808a914e808a914e8
	movdqa	XMMWORD PTR _rot0_1$[ebp], xmm0

; 2305 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));

	movdqa	xmm0, XMMWORD PTR __xmm@12d0046b12d0046b12d0046b12d0046b
	movdqa	XMMWORD PTR _rot1_0$[ebp], xmm0

; 2306 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));

	movdqa	xmm0, XMMWORD PTR __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
	movdqa	XMMWORD PTR _rot1_1$[ebp], xmm0

; 2307 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));

	movdqa	xmm0, XMMWORD PTR __xmm@e09ee565e09ee565e09ee565e09ee565
	movdqa	XMMWORD PTR _rot2_0$[ebp], xmm0

; 2308 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));

	movdqa	xmm0, XMMWORD PTR __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
	movdqa	XMMWORD PTR _rot2_1$[ebp], xmm0

; 2309 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));

	movdqa	xmm0, XMMWORD PTR __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
	movdqa	XMMWORD PTR _rot3_0$[ebp], xmm0

; 2310 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

	movdqa	xmm0, XMMWORD PTR __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
	movdqa	XMMWORD PTR _rot3_1$[ebp], xmm0

; 2311 : 
; 2312 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2313 :    __m128i bias_0 = _mm_set1_epi32(512);

	movdqa	xmm0, XMMWORD PTR __xmm@00000200000002000000020000000200
	movdqa	XMMWORD PTR _bias_0$[ebp], xmm0

; 2314 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

	movdqa	xmm0, XMMWORD PTR __xmm@01010000010100000101000001010000
	movdqa	XMMWORD PTR _bias_1$[ebp], xmm0

; 2315 : 
; 2316 :    // load
; 2317 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));

	mov	eax, DWORD PTR _data$[ebx]
	movdqa	xmm0, XMMWORD PTR [eax]
	movdqa	XMMWORD PTR _row0$[ebp], xmm0

; 2318 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));

	mov	eax, DWORD PTR _data$[ebx]
	movdqa	xmm0, XMMWORD PTR [eax+16]
	movdqa	XMMWORD PTR _row1$[ebp], xmm0

; 2319 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));

	mov	eax, DWORD PTR _data$[ebx]
	movdqa	xmm0, XMMWORD PTR [eax+32]
	movdqa	XMMWORD PTR _row2$[ebp], xmm0

; 2320 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));

	mov	eax, DWORD PTR _data$[ebx]
	movdqa	xmm0, XMMWORD PTR [eax+48]
	movdqa	XMMWORD PTR _row3$[ebp], xmm0

; 2321 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));

	mov	eax, DWORD PTR _data$[ebx]
	movdqa	xmm0, XMMWORD PTR [eax+64]
	movdqa	XMMWORD PTR _row4$[ebp], xmm0

; 2322 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));

	mov	eax, DWORD PTR _data$[ebx]
	movdqa	xmm0, XMMWORD PTR [eax+80]
	movdqa	XMMWORD PTR _row5$[ebp], xmm0

; 2323 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));

	mov	eax, DWORD PTR _data$[ebx]
	movdqa	xmm0, XMMWORD PTR [eax+96]
	movdqa	XMMWORD PTR _row6$[ebp], xmm0

; 2324 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));

	mov	eax, DWORD PTR _data$[ebx]
	movdqa	xmm0, XMMWORD PTR [eax+112]
	movdqa	XMMWORD PTR _row7$[ebp], xmm0

; 2325 : 
; 2326 :    // column pass
; 2327 :    dct_pass(bias_0, 10);

	movdqa	xmm0, XMMWORD PTR _row2$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row6$[ebp]
	movdqa	XMMWORD PTR _rot0_0lo$148[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row2$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row6$[ebp]
	movdqa	XMMWORD PTR _rot0_0hi$147[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot0_0lo$148[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_0$[ebp]
	movdqa	XMMWORD PTR _t2e_l$146[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot0_0hi$147[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_0$[ebp]
	movdqa	XMMWORD PTR _t2e_h$145[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot0_0lo$148[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_1$[ebp]
	movdqa	XMMWORD PTR _t3e_l$144[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot0_0hi$147[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_1$[ebp]
	movdqa	XMMWORD PTR _t3e_h$143[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row0$[ebp]
	paddw	xmm0, XMMWORD PTR _row4$[ebp]
	movdqa	XMMWORD PTR _sum04$142[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row0$[ebp]
	psubw	xmm0, XMMWORD PTR _row4$[ebp]
	movdqa	XMMWORD PTR _dif04$141[ebp], xmm0
	pxor	xmm0, xmm0
	punpcklwd xmm0, XMMWORD PTR _sum04$142[ebp]
	psrad	xmm0, 4
	movdqa	XMMWORD PTR _t0e_l$140[ebp], xmm0
	pxor	xmm0, xmm0
	punpckhwd xmm0, XMMWORD PTR _sum04$142[ebp]
	psrad	xmm0, 4
	movdqa	XMMWORD PTR _t0e_h$139[ebp], xmm0
	pxor	xmm0, xmm0
	punpcklwd xmm0, XMMWORD PTR _dif04$141[ebp]
	psrad	xmm0, 4
	movdqa	XMMWORD PTR _t1e_l$138[ebp], xmm0
	pxor	xmm0, xmm0
	punpckhwd xmm0, XMMWORD PTR _dif04$141[ebp]
	psrad	xmm0, 4
	movdqa	XMMWORD PTR _t1e_h$137[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t0e_l$140[ebp]
	paddd	xmm0, XMMWORD PTR _t3e_l$144[ebp]
	movdqa	XMMWORD PTR _x0_l$136[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t0e_h$139[ebp]
	paddd	xmm0, XMMWORD PTR _t3e_h$143[ebp]
	movdqa	XMMWORD PTR _x0_h$135[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t0e_l$140[ebp]
	psubd	xmm0, XMMWORD PTR _t3e_l$144[ebp]
	movdqa	XMMWORD PTR _x3_l$134[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t0e_h$139[ebp]
	psubd	xmm0, XMMWORD PTR _t3e_h$143[ebp]
	movdqa	XMMWORD PTR _x3_h$133[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t1e_l$138[ebp]
	paddd	xmm0, XMMWORD PTR _t2e_l$146[ebp]
	movdqa	XMMWORD PTR _x1_l$132[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t1e_h$137[ebp]
	paddd	xmm0, XMMWORD PTR _t2e_h$145[ebp]
	movdqa	XMMWORD PTR _x1_h$131[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t1e_l$138[ebp]
	psubd	xmm0, XMMWORD PTR _t2e_l$146[ebp]
	movdqa	XMMWORD PTR _x2_l$130[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t1e_h$137[ebp]
	psubd	xmm0, XMMWORD PTR _t2e_h$145[ebp]
	movdqa	XMMWORD PTR _x2_h$129[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row7$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row3$[ebp]
	movdqa	XMMWORD PTR _rot2_0lo$128[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row7$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row3$[ebp]
	movdqa	XMMWORD PTR _rot2_0hi$127[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot2_0lo$128[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_0$[ebp]
	movdqa	XMMWORD PTR _y0o_l$126[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot2_0hi$127[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_0$[ebp]
	movdqa	XMMWORD PTR _y0o_h$125[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot2_0lo$128[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_1$[ebp]
	movdqa	XMMWORD PTR _y2o_l$124[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot2_0hi$127[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_1$[ebp]
	movdqa	XMMWORD PTR _y2o_h$123[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row5$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row1$[ebp]
	movdqa	XMMWORD PTR _rot3_0lo$122[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row5$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row1$[ebp]
	movdqa	XMMWORD PTR _rot3_0hi$121[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot3_0lo$122[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_0$[ebp]
	movdqa	XMMWORD PTR _y1o_l$120[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot3_0hi$121[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_0$[ebp]
	movdqa	XMMWORD PTR _y1o_h$119[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot3_0lo$122[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_1$[ebp]
	movdqa	XMMWORD PTR _y3o_l$118[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot3_0hi$121[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_1$[ebp]
	movdqa	XMMWORD PTR _y3o_h$117[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row1$[ebp]
	paddw	xmm0, XMMWORD PTR _row7$[ebp]
	movdqa	XMMWORD PTR _sum17$116[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row3$[ebp]
	paddw	xmm0, XMMWORD PTR _row5$[ebp]
	movdqa	XMMWORD PTR _sum35$115[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _sum17$116[ebp]
	punpcklwd xmm0, XMMWORD PTR _sum35$115[ebp]
	movdqa	XMMWORD PTR _rot1_0lo$114[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _sum17$116[ebp]
	punpckhwd xmm0, XMMWORD PTR _sum35$115[ebp]
	movdqa	XMMWORD PTR _rot1_0hi$113[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot1_0lo$114[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_0$[ebp]
	movdqa	XMMWORD PTR _y4o_l$112[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot1_0hi$113[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_0$[ebp]
	movdqa	XMMWORD PTR _y4o_h$111[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot1_0lo$114[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_1$[ebp]
	movdqa	XMMWORD PTR _y5o_l$110[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot1_0hi$113[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_1$[ebp]
	movdqa	XMMWORD PTR _y5o_h$109[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y0o_l$126[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_l$112[ebp]
	movdqa	XMMWORD PTR _x4_l$108[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y0o_h$125[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_h$111[ebp]
	movdqa	XMMWORD PTR _x4_h$107[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y1o_l$120[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_l$110[ebp]
	movdqa	XMMWORD PTR _x5_l$106[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y1o_h$119[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_h$109[ebp]
	movdqa	XMMWORD PTR _x5_h$105[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y2o_l$124[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_l$110[ebp]
	movdqa	XMMWORD PTR _x6_l$104[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y2o_h$123[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_h$109[ebp]
	movdqa	XMMWORD PTR _x6_h$103[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y3o_l$118[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_l$112[ebp]
	movdqa	XMMWORD PTR _x7_l$102[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y3o_h$117[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_h$111[ebp]
	movdqa	XMMWORD PTR _x7_h$101[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _x0_l$136[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movdqa	XMMWORD PTR _abiased_l$100[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _x0_h$135[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movdqa	XMMWORD PTR _abiased_h$99[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$100[ebp]
	paddd	xmm0, XMMWORD PTR _x7_l$102[ebp]
	movdqa	XMMWORD PTR _sum_l$98[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$99[ebp]
	paddd	xmm0, XMMWORD PTR _x7_h$101[ebp]
	movdqa	XMMWORD PTR _sum_h$97[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$100[ebp]
	psubd	xmm0, XMMWORD PTR _x7_l$102[ebp]
	movdqa	XMMWORD PTR _dif_l$96[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$99[ebp]
	psubd	xmm0, XMMWORD PTR _x7_h$101[ebp]
	movdqa	XMMWORD PTR _dif_h$95[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _sum_h$97[ebp]
	psrad	xmm0, 10				; 0000000aH
	movdqa	xmm1, XMMWORD PTR _sum_l$98[ebp]
	psrad	xmm1, 10				; 0000000aH
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row0$[ebp], xmm1
	movdqa	xmm0, XMMWORD PTR _dif_h$95[ebp]
	psrad	xmm0, 10				; 0000000aH
	movdqa	xmm1, XMMWORD PTR _dif_l$96[ebp]
	psrad	xmm1, 10				; 0000000aH
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row7$[ebp], xmm1
	movdqa	xmm0, XMMWORD PTR _x1_l$132[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movdqa	XMMWORD PTR _abiased_l$94[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _x1_h$131[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movdqa	XMMWORD PTR _abiased_h$93[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$94[ebp]
	paddd	xmm0, XMMWORD PTR _x6_l$104[ebp]
	movdqa	XMMWORD PTR _sum_l$92[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$93[ebp]
	paddd	xmm0, XMMWORD PTR _x6_h$103[ebp]
	movdqa	XMMWORD PTR _sum_h$91[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$94[ebp]
	psubd	xmm0, XMMWORD PTR _x6_l$104[ebp]
	movdqa	XMMWORD PTR _dif_l$90[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$93[ebp]
	psubd	xmm0, XMMWORD PTR _x6_h$103[ebp]
	movdqa	XMMWORD PTR _dif_h$89[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _sum_h$91[ebp]
	psrad	xmm0, 10				; 0000000aH
	movdqa	xmm1, XMMWORD PTR _sum_l$92[ebp]
	psrad	xmm1, 10				; 0000000aH
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row1$[ebp], xmm1
	movdqa	xmm0, XMMWORD PTR _dif_h$89[ebp]
	psrad	xmm0, 10				; 0000000aH
	movdqa	xmm1, XMMWORD PTR _dif_l$90[ebp]
	psrad	xmm1, 10				; 0000000aH
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row6$[ebp], xmm1
	movdqa	xmm0, XMMWORD PTR _x2_l$130[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movdqa	XMMWORD PTR _abiased_l$88[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _x2_h$129[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movdqa	XMMWORD PTR _abiased_h$87[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$88[ebp]
	paddd	xmm0, XMMWORD PTR _x5_l$106[ebp]
	movdqa	XMMWORD PTR _sum_l$86[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$87[ebp]
	paddd	xmm0, XMMWORD PTR _x5_h$105[ebp]
	movdqa	XMMWORD PTR _sum_h$85[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$88[ebp]
	psubd	xmm0, XMMWORD PTR _x5_l$106[ebp]
	movdqa	XMMWORD PTR _dif_l$84[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$87[ebp]
	psubd	xmm0, XMMWORD PTR _x5_h$105[ebp]
	movdqa	XMMWORD PTR _dif_h$83[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _sum_h$85[ebp]
	psrad	xmm0, 10				; 0000000aH
	movdqa	xmm1, XMMWORD PTR _sum_l$86[ebp]
	psrad	xmm1, 10				; 0000000aH
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row2$[ebp], xmm1
	movdqa	xmm0, XMMWORD PTR _dif_h$83[ebp]
	psrad	xmm0, 10				; 0000000aH
	movdqa	xmm1, XMMWORD PTR _dif_l$84[ebp]
	psrad	xmm1, 10				; 0000000aH
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row5$[ebp], xmm1
	movdqa	xmm0, XMMWORD PTR _x3_l$134[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movdqa	XMMWORD PTR _abiased_l$82[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _x3_h$133[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movdqa	XMMWORD PTR _abiased_h$81[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$82[ebp]
	paddd	xmm0, XMMWORD PTR _x4_l$108[ebp]
	movdqa	XMMWORD PTR _sum_l$80[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$81[ebp]
	paddd	xmm0, XMMWORD PTR _x4_h$107[ebp]
	movdqa	XMMWORD PTR _sum_h$79[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$82[ebp]
	psubd	xmm0, XMMWORD PTR _x4_l$108[ebp]
	movdqa	XMMWORD PTR _dif_l$78[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$81[ebp]
	psubd	xmm0, XMMWORD PTR _x4_h$107[ebp]
	movdqa	XMMWORD PTR _dif_h$77[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _sum_h$79[ebp]
	psrad	xmm0, 10				; 0000000aH
	movdqa	xmm1, XMMWORD PTR _sum_l$80[ebp]
	psrad	xmm1, 10				; 0000000aH
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row3$[ebp], xmm1
	movdqa	xmm0, XMMWORD PTR _dif_h$77[ebp]
	psrad	xmm0, 10				; 0000000aH
	movdqa	xmm1, XMMWORD PTR _dif_l$78[ebp]
	psrad	xmm1, 10				; 0000000aH
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row4$[ebp], xmm1

; 2328 : 
; 2329 :    {
; 2330 :       // 16bit 8x8 transpose pass 1
; 2331 :       dct_interleave16(row0, row4);

	movdqa	xmm0, XMMWORD PTR _row0$[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row0$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row4$[ebp]
	movdqa	XMMWORD PTR _row0$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row4$[ebp]
	movdqa	XMMWORD PTR _row4$[ebp], xmm0

; 2332 :       dct_interleave16(row1, row5);

	movdqa	xmm0, XMMWORD PTR _row1$[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row1$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row5$[ebp]
	movdqa	XMMWORD PTR _row1$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row5$[ebp]
	movdqa	XMMWORD PTR _row5$[ebp], xmm0

; 2333 :       dct_interleave16(row2, row6);

	movdqa	xmm0, XMMWORD PTR _row2$[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row2$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row6$[ebp]
	movdqa	XMMWORD PTR _row2$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row6$[ebp]
	movdqa	XMMWORD PTR _row6$[ebp], xmm0

; 2334 :       dct_interleave16(row3, row7);

	movdqa	xmm0, XMMWORD PTR _row3$[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row3$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row7$[ebp]
	movdqa	XMMWORD PTR _row3$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row7$[ebp]
	movdqa	XMMWORD PTR _row7$[ebp], xmm0

; 2335 : 
; 2336 :       // transpose pass 2
; 2337 :       dct_interleave16(row0, row2);

	movdqa	xmm0, XMMWORD PTR _row0$[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row0$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row2$[ebp]
	movdqa	XMMWORD PTR _row0$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row2$[ebp]
	movdqa	XMMWORD PTR _row2$[ebp], xmm0

; 2338 :       dct_interleave16(row1, row3);

	movdqa	xmm0, XMMWORD PTR _row1$[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row1$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row3$[ebp]
	movdqa	XMMWORD PTR _row1$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row3$[ebp]
	movdqa	XMMWORD PTR _row3$[ebp], xmm0

; 2339 :       dct_interleave16(row4, row6);

	movdqa	xmm0, XMMWORD PTR _row4$[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row4$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row6$[ebp]
	movdqa	XMMWORD PTR _row4$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row6$[ebp]
	movdqa	XMMWORD PTR _row6$[ebp], xmm0

; 2340 :       dct_interleave16(row5, row7);

	movdqa	xmm0, XMMWORD PTR _row5$[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row5$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row7$[ebp]
	movdqa	XMMWORD PTR _row5$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row7$[ebp]
	movdqa	XMMWORD PTR _row7$[ebp], xmm0

; 2341 : 
; 2342 :       // transpose pass 3
; 2343 :       dct_interleave16(row0, row1);

	movdqa	xmm0, XMMWORD PTR _row0$[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row0$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row1$[ebp]
	movdqa	XMMWORD PTR _row0$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row1$[ebp]
	movdqa	XMMWORD PTR _row1$[ebp], xmm0

; 2344 :       dct_interleave16(row2, row3);

	movdqa	xmm0, XMMWORD PTR _row2$[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row2$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row3$[ebp]
	movdqa	XMMWORD PTR _row2$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row3$[ebp]
	movdqa	XMMWORD PTR _row3$[ebp], xmm0

; 2345 :       dct_interleave16(row4, row5);

	movdqa	xmm0, XMMWORD PTR _row4$[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row4$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row5$[ebp]
	movdqa	XMMWORD PTR _row4$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row5$[ebp]
	movdqa	XMMWORD PTR _row5$[ebp], xmm0

; 2346 :       dct_interleave16(row6, row7);

	movdqa	xmm0, XMMWORD PTR _row6$[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row6$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row7$[ebp]
	movdqa	XMMWORD PTR _row6$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row7$[ebp]
	movdqa	XMMWORD PTR _row7$[ebp], xmm0

; 2347 :    }
; 2348 : 
; 2349 :    // row pass
; 2350 :    dct_pass(bias_1, 17);

	movdqa	xmm0, XMMWORD PTR _row2$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row6$[ebp]
	movdqa	XMMWORD PTR _rot0_0lo$76[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row2$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row6$[ebp]
	movdqa	XMMWORD PTR _rot0_0hi$75[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot0_0lo$76[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_0$[ebp]
	movdqa	XMMWORD PTR _t2e_l$74[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot0_0hi$75[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_0$[ebp]
	movdqa	XMMWORD PTR _t2e_h$73[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot0_0lo$76[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_1$[ebp]
	movdqa	XMMWORD PTR _t3e_l$72[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot0_0hi$75[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_1$[ebp]
	movdqa	XMMWORD PTR _t3e_h$71[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row0$[ebp]
	paddw	xmm0, XMMWORD PTR _row4$[ebp]
	movdqa	XMMWORD PTR _sum04$70[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row0$[ebp]
	psubw	xmm0, XMMWORD PTR _row4$[ebp]
	movdqa	XMMWORD PTR _dif04$69[ebp], xmm0
	pxor	xmm0, xmm0
	punpcklwd xmm0, XMMWORD PTR _sum04$70[ebp]
	psrad	xmm0, 4
	movdqa	XMMWORD PTR _t0e_l$68[ebp], xmm0
	pxor	xmm0, xmm0
	punpckhwd xmm0, XMMWORD PTR _sum04$70[ebp]
	psrad	xmm0, 4
	movdqa	XMMWORD PTR _t0e_h$67[ebp], xmm0
	pxor	xmm0, xmm0
	punpcklwd xmm0, XMMWORD PTR _dif04$69[ebp]
	psrad	xmm0, 4
	movdqa	XMMWORD PTR _t1e_l$66[ebp], xmm0
	pxor	xmm0, xmm0
	punpckhwd xmm0, XMMWORD PTR _dif04$69[ebp]
	psrad	xmm0, 4
	movdqa	XMMWORD PTR _t1e_h$65[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t0e_l$68[ebp]
	paddd	xmm0, XMMWORD PTR _t3e_l$72[ebp]
	movdqa	XMMWORD PTR _x0_l$64[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t0e_h$67[ebp]
	paddd	xmm0, XMMWORD PTR _t3e_h$71[ebp]
	movdqa	XMMWORD PTR _x0_h$63[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t0e_l$68[ebp]
	psubd	xmm0, XMMWORD PTR _t3e_l$72[ebp]
	movdqa	XMMWORD PTR _x3_l$62[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t0e_h$67[ebp]
	psubd	xmm0, XMMWORD PTR _t3e_h$71[ebp]
	movdqa	XMMWORD PTR _x3_h$61[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t1e_l$66[ebp]
	paddd	xmm0, XMMWORD PTR _t2e_l$74[ebp]
	movdqa	XMMWORD PTR _x1_l$60[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t1e_h$65[ebp]
	paddd	xmm0, XMMWORD PTR _t2e_h$73[ebp]
	movdqa	XMMWORD PTR _x1_h$59[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t1e_l$66[ebp]
	psubd	xmm0, XMMWORD PTR _t2e_l$74[ebp]
	movdqa	XMMWORD PTR _x2_l$58[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _t1e_h$65[ebp]
	psubd	xmm0, XMMWORD PTR _t2e_h$73[ebp]
	movdqa	XMMWORD PTR _x2_h$57[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row7$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row3$[ebp]
	movdqa	XMMWORD PTR _rot2_0lo$56[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row7$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row3$[ebp]
	movdqa	XMMWORD PTR _rot2_0hi$55[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot2_0lo$56[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_0$[ebp]
	movdqa	XMMWORD PTR _y0o_l$54[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot2_0hi$55[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_0$[ebp]
	movdqa	XMMWORD PTR _y0o_h$53[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot2_0lo$56[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_1$[ebp]
	movdqa	XMMWORD PTR _y2o_l$52[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot2_0hi$55[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_1$[ebp]
	movdqa	XMMWORD PTR _y2o_h$51[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row5$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row1$[ebp]
	movdqa	XMMWORD PTR _rot3_0lo$50[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row5$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row1$[ebp]
	movdqa	XMMWORD PTR _rot3_0hi$49[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot3_0lo$50[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_0$[ebp]
	movdqa	XMMWORD PTR _y1o_l$48[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot3_0hi$49[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_0$[ebp]
	movdqa	XMMWORD PTR _y1o_h$47[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot3_0lo$50[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_1$[ebp]
	movdqa	XMMWORD PTR _y3o_l$46[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot3_0hi$49[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_1$[ebp]
	movdqa	XMMWORD PTR _y3o_h$45[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row1$[ebp]
	paddw	xmm0, XMMWORD PTR _row7$[ebp]
	movdqa	XMMWORD PTR _sum17$44[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _row3$[ebp]
	paddw	xmm0, XMMWORD PTR _row5$[ebp]
	movdqa	XMMWORD PTR _sum35$43[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _sum17$44[ebp]
	punpcklwd xmm0, XMMWORD PTR _sum35$43[ebp]
	movdqa	XMMWORD PTR _rot1_0lo$42[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _sum17$44[ebp]
	punpckhwd xmm0, XMMWORD PTR _sum35$43[ebp]
	movdqa	XMMWORD PTR _rot1_0hi$41[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot1_0lo$42[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_0$[ebp]
	movdqa	XMMWORD PTR _y4o_l$40[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot1_0hi$41[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_0$[ebp]
	movdqa	XMMWORD PTR _y4o_h$39[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot1_0lo$42[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_1$[ebp]
	movdqa	XMMWORD PTR _y5o_l$38[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _rot1_0hi$41[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_1$[ebp]
	movdqa	XMMWORD PTR _y5o_h$37[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y0o_l$54[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_l$40[ebp]
	movdqa	XMMWORD PTR _x4_l$36[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y0o_h$53[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_h$39[ebp]
	movdqa	XMMWORD PTR _x4_h$35[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y1o_l$48[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_l$38[ebp]
	movdqa	XMMWORD PTR _x5_l$34[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y1o_h$47[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_h$37[ebp]
	movdqa	XMMWORD PTR _x5_h$33[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y2o_l$52[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_l$38[ebp]
	movdqa	XMMWORD PTR _x6_l$32[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y2o_h$51[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_h$37[ebp]
	movdqa	XMMWORD PTR _x6_h$31[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y3o_l$46[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_l$40[ebp]
	movdqa	XMMWORD PTR _x7_l$30[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _y3o_h$45[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_h$39[ebp]
	movdqa	XMMWORD PTR _x7_h$29[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _x0_l$64[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movdqa	XMMWORD PTR _abiased_l$28[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _x0_h$63[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movdqa	XMMWORD PTR _abiased_h$27[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$28[ebp]
	paddd	xmm0, XMMWORD PTR _x7_l$30[ebp]
	movdqa	XMMWORD PTR _sum_l$26[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$27[ebp]
	paddd	xmm0, XMMWORD PTR _x7_h$29[ebp]
	movdqa	XMMWORD PTR _sum_h$25[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$28[ebp]
	psubd	xmm0, XMMWORD PTR _x7_l$30[ebp]
	movdqa	XMMWORD PTR _dif_l$24[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$27[ebp]
	psubd	xmm0, XMMWORD PTR _x7_h$29[ebp]
	movdqa	XMMWORD PTR _dif_h$23[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _sum_h$25[ebp]
	psrad	xmm0, 17				; 00000011H
	movdqa	xmm1, XMMWORD PTR _sum_l$26[ebp]
	psrad	xmm1, 17				; 00000011H
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row0$[ebp], xmm1
	movdqa	xmm0, XMMWORD PTR _dif_h$23[ebp]
	psrad	xmm0, 17				; 00000011H
	movdqa	xmm1, XMMWORD PTR _dif_l$24[ebp]
	psrad	xmm1, 17				; 00000011H
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row7$[ebp], xmm1
	movdqa	xmm0, XMMWORD PTR _x1_l$60[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movdqa	XMMWORD PTR _abiased_l$22[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _x1_h$59[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movdqa	XMMWORD PTR _abiased_h$21[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$22[ebp]
	paddd	xmm0, XMMWORD PTR _x6_l$32[ebp]
	movdqa	XMMWORD PTR _sum_l$20[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$21[ebp]
	paddd	xmm0, XMMWORD PTR _x6_h$31[ebp]
	movdqa	XMMWORD PTR _sum_h$19[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$22[ebp]
	psubd	xmm0, XMMWORD PTR _x6_l$32[ebp]
	movdqa	XMMWORD PTR _dif_l$18[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$21[ebp]
	psubd	xmm0, XMMWORD PTR _x6_h$31[ebp]
	movdqa	XMMWORD PTR _dif_h$17[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _sum_h$19[ebp]
	psrad	xmm0, 17				; 00000011H
	movdqa	xmm1, XMMWORD PTR _sum_l$20[ebp]
	psrad	xmm1, 17				; 00000011H
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row1$[ebp], xmm1
	movdqa	xmm0, XMMWORD PTR _dif_h$17[ebp]
	psrad	xmm0, 17				; 00000011H
	movdqa	xmm1, XMMWORD PTR _dif_l$18[ebp]
	psrad	xmm1, 17				; 00000011H
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row6$[ebp], xmm1
	movdqa	xmm0, XMMWORD PTR _x2_l$58[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movdqa	XMMWORD PTR _abiased_l$16[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _x2_h$57[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movdqa	XMMWORD PTR _abiased_h$15[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$16[ebp]
	paddd	xmm0, XMMWORD PTR _x5_l$34[ebp]
	movdqa	XMMWORD PTR _sum_l$14[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$15[ebp]
	paddd	xmm0, XMMWORD PTR _x5_h$33[ebp]
	movdqa	XMMWORD PTR _sum_h$13[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$16[ebp]
	psubd	xmm0, XMMWORD PTR _x5_l$34[ebp]
	movdqa	XMMWORD PTR _dif_l$12[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$15[ebp]
	psubd	xmm0, XMMWORD PTR _x5_h$33[ebp]
	movdqa	XMMWORD PTR _dif_h$11[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _sum_h$13[ebp]
	psrad	xmm0, 17				; 00000011H
	movdqa	xmm1, XMMWORD PTR _sum_l$14[ebp]
	psrad	xmm1, 17				; 00000011H
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row2$[ebp], xmm1
	movdqa	xmm0, XMMWORD PTR _dif_h$11[ebp]
	psrad	xmm0, 17				; 00000011H
	movdqa	xmm1, XMMWORD PTR _dif_l$12[ebp]
	psrad	xmm1, 17				; 00000011H
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row5$[ebp], xmm1
	movdqa	xmm0, XMMWORD PTR _x3_l$62[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movdqa	XMMWORD PTR _abiased_l$10[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _x3_h$61[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movdqa	XMMWORD PTR _abiased_h$9[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$10[ebp]
	paddd	xmm0, XMMWORD PTR _x4_l$36[ebp]
	movdqa	XMMWORD PTR _sum_l$8[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$9[ebp]
	paddd	xmm0, XMMWORD PTR _x4_h$35[ebp]
	movdqa	XMMWORD PTR _sum_h$7[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$10[ebp]
	psubd	xmm0, XMMWORD PTR _x4_l$36[ebp]
	movdqa	XMMWORD PTR _dif_l$6[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$9[ebp]
	psubd	xmm0, XMMWORD PTR _x4_h$35[ebp]
	movdqa	XMMWORD PTR _dif_h$5[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _sum_h$7[ebp]
	psrad	xmm0, 17				; 00000011H
	movdqa	xmm1, XMMWORD PTR _sum_l$8[ebp]
	psrad	xmm1, 17				; 00000011H
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row3$[ebp], xmm1
	movdqa	xmm0, XMMWORD PTR _dif_h$5[ebp]
	psrad	xmm0, 17				; 00000011H
	movdqa	xmm1, XMMWORD PTR _dif_l$6[ebp]
	psrad	xmm1, 17				; 00000011H
	packssdw xmm1, xmm0
	movdqa	XMMWORD PTR _row4$[ebp], xmm1

; 2351 : 
; 2352 :    {
; 2353 :       // pack
; 2354 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7

	movdqa	xmm0, XMMWORD PTR _row0$[ebp]
	packuswb xmm0, XMMWORD PTR _row1$[ebp]
	movdqa	XMMWORD PTR _p0$4[ebp], xmm0

; 2355 :       __m128i p1 = _mm_packus_epi16(row2, row3);

	movdqa	xmm0, XMMWORD PTR _row2$[ebp]
	packuswb xmm0, XMMWORD PTR _row3$[ebp]
	movdqa	XMMWORD PTR _p1$3[ebp], xmm0

; 2356 :       __m128i p2 = _mm_packus_epi16(row4, row5);

	movdqa	xmm0, XMMWORD PTR _row4$[ebp]
	packuswb xmm0, XMMWORD PTR _row5$[ebp]
	movdqa	XMMWORD PTR _p2$2[ebp], xmm0

; 2357 :       __m128i p3 = _mm_packus_epi16(row6, row7);

	movdqa	xmm0, XMMWORD PTR _row6$[ebp]
	packuswb xmm0, XMMWORD PTR _row7$[ebp]
	movdqa	XMMWORD PTR _p3$1[ebp], xmm0

; 2358 : 
; 2359 :       // 8bit 8x8 transpose pass 1
; 2360 :       dct_interleave8(p0, p2); // a0e0a1e1...

	movdqa	xmm0, XMMWORD PTR _p0$4[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _p0$4[ebp]
	punpcklbw xmm0, XMMWORD PTR _p2$2[ebp]
	movdqa	XMMWORD PTR _p0$4[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhbw xmm0, XMMWORD PTR _p2$2[ebp]
	movdqa	XMMWORD PTR _p2$2[ebp], xmm0

; 2361 :       dct_interleave8(p1, p3); // c0g0c1g1...

	movdqa	xmm0, XMMWORD PTR _p1$3[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _p1$3[ebp]
	punpcklbw xmm0, XMMWORD PTR _p3$1[ebp]
	movdqa	XMMWORD PTR _p1$3[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhbw xmm0, XMMWORD PTR _p3$1[ebp]
	movdqa	XMMWORD PTR _p3$1[ebp], xmm0

; 2362 : 
; 2363 :       // transpose pass 2
; 2364 :       dct_interleave8(p0, p1); // a0c0e0g0...

	movdqa	xmm0, XMMWORD PTR _p0$4[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _p0$4[ebp]
	punpcklbw xmm0, XMMWORD PTR _p1$3[ebp]
	movdqa	XMMWORD PTR _p0$4[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhbw xmm0, XMMWORD PTR _p1$3[ebp]
	movdqa	XMMWORD PTR _p1$3[ebp], xmm0

; 2365 :       dct_interleave8(p2, p3); // b0d0f0h0...

	movdqa	xmm0, XMMWORD PTR _p2$2[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _p2$2[ebp]
	punpcklbw xmm0, XMMWORD PTR _p3$1[ebp]
	movdqa	XMMWORD PTR _p2$2[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhbw xmm0, XMMWORD PTR _p3$1[ebp]
	movdqa	XMMWORD PTR _p3$1[ebp], xmm0

; 2366 : 
; 2367 :       // transpose pass 3
; 2368 :       dct_interleave8(p0, p2); // a0b0c0d0...

	movdqa	xmm0, XMMWORD PTR _p0$4[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _p0$4[ebp]
	punpcklbw xmm0, XMMWORD PTR _p2$2[ebp]
	movdqa	XMMWORD PTR _p0$4[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhbw xmm0, XMMWORD PTR _p2$2[ebp]
	movdqa	XMMWORD PTR _p2$2[ebp], xmm0

; 2369 :       dct_interleave8(p1, p3); // a4b4c4d4...

	movdqa	xmm0, XMMWORD PTR _p1$3[ebp]
	movdqa	XMMWORD PTR _tmp$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _p1$3[ebp]
	punpcklbw xmm0, XMMWORD PTR _p3$1[ebp]
	movdqa	XMMWORD PTR _p1$3[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhbw xmm0, XMMWORD PTR _p3$1[ebp]
	movdqa	XMMWORD PTR _p3$1[ebp], xmm0

; 2370 : 
; 2371 :       // store
; 2372 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;

	movdqa	xmm0, XMMWORD PTR _p0$4[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _out_stride$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 2373 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;

	pshufd	xmm0, XMMWORD PTR _p0$4[ebp], 78	; 0000004eH
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _out_stride$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 2374 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;

	movdqa	xmm0, XMMWORD PTR _p2$2[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _out_stride$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 2375 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;

	pshufd	xmm0, XMMWORD PTR _p2$2[ebp], 78	; 0000004eH
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _out_stride$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 2376 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;

	movdqa	xmm0, XMMWORD PTR _p1$3[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _out_stride$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 2377 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;

	pshufd	xmm0, XMMWORD PTR _p1$3[ebp], 78	; 0000004eH
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _out_stride$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 2378 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;

	movdqa	xmm0, XMMWORD PTR _p3$1[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _out_stride$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 2379 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));

	pshufd	xmm0, XMMWORD PTR _p3$1[ebp], 78	; 0000004eH
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0

; 2380 :    }
; 2381 : 
; 2382 : #undef dct_const
; 2383 : #undef dct_rot
; 2384 : #undef dct_widen
; 2385 : #undef dct_wadd
; 2386 : #undef dct_wsub
; 2387 : #undef dct_bfly32o
; 2388 : #undef dct_interleave8
; 2389 : #undef dct_interleave16
; 2390 : #undef dct_pass
; 2391 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
_stbi__idct_simd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__idct_block
_TEXT	SEGMENT
_x3$1 = -636						; size = 4
_x2$2 = -624						; size = 4
_x1$3 = -612						; size = 4
_x0$4 = -600						; size = 4
_p5$5 = -588						; size = 4
_p4$6 = -576						; size = 4
_p3$7 = -564						; size = 4
_p2$8 = -552						; size = 4
_p1$9 = -540						; size = 4
_t3$10 = -528						; size = 4
_t2$11 = -516						; size = 4
_t1$12 = -504						; size = 4
_t0$13 = -492						; size = 4
_x3$14 = -480						; size = 4
_x2$15 = -468						; size = 4
_x1$16 = -456						; size = 4
_x0$17 = -444						; size = 4
_p5$18 = -432						; size = 4
_p4$19 = -420						; size = 4
_p3$20 = -408						; size = 4
_p2$21 = -396						; size = 4
_p1$22 = -384						; size = 4
_t3$23 = -372						; size = 4
_t2$24 = -360						; size = 4
_t1$25 = -348						; size = 4
_t0$26 = -336						; size = 4
_dcterm$27 = -324					; size = 4
_d$ = -312						; size = 4
_o$ = -300						; size = 4
_v$ = -288						; size = 4
_val$ = -276						; size = 256
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_out_stride$ = 12					; size = 4
_data$ = 16						; size = 4
_stbi__idct_block PROC					; COMDAT

; 2156 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 832				; 00000340H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-832]
	mov	ecx, 208				; 000000d0H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2157 :    int i,val[64],*v=val;

	lea	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _v$[ebp], eax

; 2158 :    stbi_uc *o;
; 2159 :    short *d = data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 2160 : 
; 2161 :    // columns
; 2162 :    for (i=0; i < 8; ++i,++d, ++v) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@stbi__idct
$LN7@stbi__idct:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, 2
	mov	DWORD PTR _d$[ebp], ecx
	mov	edx, DWORD PTR _v$[ebp]
	add	edx, 4
	mov	DWORD PTR _v$[ebp], edx
$LN8@stbi__idct:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN6@stbi__idct

; 2163 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2164 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2165 :            && d[40]==0 && d[48]==0 && d[56]==0) {

	mov	eax, 2
	shl	eax, 3
	mov	ecx, DWORD PTR _d$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	test	edx, edx
	jne	$LN5@stbi__idct
	mov	eax, 2
	shl	eax, 4
	mov	ecx, DWORD PTR _d$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	test	edx, edx
	jne	$LN5@stbi__idct
	mov	eax, 2
	imul	ecx, eax, 24
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	test	eax, eax
	jne	$LN5@stbi__idct
	mov	eax, 2
	shl	eax, 5
	mov	ecx, DWORD PTR _d$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	test	edx, edx
	jne	$LN5@stbi__idct
	mov	eax, 2
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	test	eax, eax
	jne	$LN5@stbi__idct
	mov	eax, 2
	imul	ecx, eax, 48
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	test	eax, eax
	jne	$LN5@stbi__idct
	mov	eax, 2
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	test	eax, eax
	jne	$LN5@stbi__idct

; 2166 :          //    no shortcut                 0     seconds
; 2167 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2168 :          //    all separate               -0.047 seconds
; 2169 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2170 :          int dcterm = d[0] << 2;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	shl	eax, 2
	mov	DWORD PTR _dcterm$27[ebp], eax

; 2171 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;

	mov	eax, 4
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	imul	eax, edx, 40
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 5
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	imul	ecx, eax, 24
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 4
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [eax+edx], ecx

; 2172 :       } else {

	jmp	$LN4@stbi__idct
$LN5@stbi__idct:

; 2173 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])

	mov	eax, 2
	shl	eax, 4
	mov	ecx, DWORD PTR _d$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	mov	DWORD PTR _p2$21[ebp], edx
	mov	eax, 2
	imul	ecx, eax, 48
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _p3$20[ebp], eax
	mov	eax, DWORD PTR _p2$21[ebp]
	add	eax, DWORD PTR _p3$20[ebp]
	imul	ecx, eax, 2217
	mov	DWORD PTR _p1$22[ebp], ecx
	imul	eax, DWORD PTR _p3$20[ebp], -7567
	add	eax, DWORD PTR _p1$22[ebp]
	mov	DWORD PTR _t2$24[ebp], eax
	imul	eax, DWORD PTR _p2$21[ebp], 3135
	add	eax, DWORD PTR _p1$22[ebp]
	mov	DWORD PTR _t3$23[ebp], eax
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _p2$21[ebp], eax
	mov	eax, 2
	shl	eax, 5
	mov	ecx, DWORD PTR _d$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	mov	DWORD PTR _p3$20[ebp], edx
	mov	eax, DWORD PTR _p2$21[ebp]
	add	eax, DWORD PTR _p3$20[ebp]
	shl	eax, 12					; 0000000cH
	mov	DWORD PTR _t0$26[ebp], eax
	mov	eax, DWORD PTR _p2$21[ebp]
	sub	eax, DWORD PTR _p3$20[ebp]
	shl	eax, 12					; 0000000cH
	mov	DWORD PTR _t1$25[ebp], eax
	mov	eax, DWORD PTR _t0$26[ebp]
	add	eax, DWORD PTR _t3$23[ebp]
	mov	DWORD PTR _x0$17[ebp], eax
	mov	eax, DWORD PTR _t0$26[ebp]
	sub	eax, DWORD PTR _t3$23[ebp]
	mov	DWORD PTR _x3$14[ebp], eax
	mov	eax, DWORD PTR _t1$25[ebp]
	add	eax, DWORD PTR _t2$24[ebp]
	mov	DWORD PTR _x1$16[ebp], eax
	mov	eax, DWORD PTR _t1$25[ebp]
	sub	eax, DWORD PTR _t2$24[ebp]
	mov	DWORD PTR _x2$15[ebp], eax
	mov	eax, 2
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _t0$26[ebp], eax
	mov	eax, 2
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _t1$25[ebp], eax
	mov	eax, 2
	imul	ecx, eax, 24
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _t2$24[ebp], eax
	mov	eax, 2
	shl	eax, 3
	mov	ecx, DWORD PTR _d$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	mov	DWORD PTR _t3$23[ebp], edx
	mov	eax, DWORD PTR _t0$26[ebp]
	add	eax, DWORD PTR _t2$24[ebp]
	mov	DWORD PTR _p3$20[ebp], eax
	mov	eax, DWORD PTR _t1$25[ebp]
	add	eax, DWORD PTR _t3$23[ebp]
	mov	DWORD PTR _p4$19[ebp], eax
	mov	eax, DWORD PTR _t0$26[ebp]
	add	eax, DWORD PTR _t3$23[ebp]
	mov	DWORD PTR _p1$22[ebp], eax
	mov	eax, DWORD PTR _t1$25[ebp]
	add	eax, DWORD PTR _t2$24[ebp]
	mov	DWORD PTR _p2$21[ebp], eax
	mov	eax, DWORD PTR _p3$20[ebp]
	add	eax, DWORD PTR _p4$19[ebp]
	imul	ecx, eax, 4816
	mov	DWORD PTR _p5$18[ebp], ecx
	imul	eax, DWORD PTR _t0$26[ebp], 1223
	mov	DWORD PTR _t0$26[ebp], eax
	imul	eax, DWORD PTR _t1$25[ebp], 8410
	mov	DWORD PTR _t1$25[ebp], eax
	imul	eax, DWORD PTR _t2$24[ebp], 12586
	mov	DWORD PTR _t2$24[ebp], eax
	imul	eax, DWORD PTR _t3$23[ebp], 6149
	mov	DWORD PTR _t3$23[ebp], eax
	imul	eax, DWORD PTR _p1$22[ebp], -3685
	add	eax, DWORD PTR _p5$18[ebp]
	mov	DWORD PTR _p1$22[ebp], eax
	imul	eax, DWORD PTR _p2$21[ebp], -10497
	add	eax, DWORD PTR _p5$18[ebp]
	mov	DWORD PTR _p2$21[ebp], eax
	imul	eax, DWORD PTR _p3$20[ebp], -8034
	mov	DWORD PTR _p3$20[ebp], eax
	imul	eax, DWORD PTR _p4$19[ebp], -1597
	mov	DWORD PTR _p4$19[ebp], eax
	mov	eax, DWORD PTR _p1$22[ebp]
	add	eax, DWORD PTR _p4$19[ebp]
	add	eax, DWORD PTR _t3$23[ebp]
	mov	DWORD PTR _t3$23[ebp], eax
	mov	eax, DWORD PTR _p2$21[ebp]
	add	eax, DWORD PTR _p3$20[ebp]
	add	eax, DWORD PTR _t2$24[ebp]
	mov	DWORD PTR _t2$24[ebp], eax
	mov	eax, DWORD PTR _p2$21[ebp]
	add	eax, DWORD PTR _p4$19[ebp]
	add	eax, DWORD PTR _t1$25[ebp]
	mov	DWORD PTR _t1$25[ebp], eax
	mov	eax, DWORD PTR _p1$22[ebp]
	add	eax, DWORD PTR _p3$20[ebp]
	add	eax, DWORD PTR _t0$26[ebp]
	mov	DWORD PTR _t0$26[ebp], eax

; 2174 :          // constants scaled things up by 1<<12; let's bring them back
; 2175 :          // down, but keep 2 extra bits of precision
; 2176 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;

	mov	eax, DWORD PTR _x0$17[ebp]
	add	eax, 512				; 00000200H
	mov	DWORD PTR _x0$17[ebp], eax
	mov	eax, DWORD PTR _x1$16[ebp]
	add	eax, 512				; 00000200H
	mov	DWORD PTR _x1$16[ebp], eax
	mov	eax, DWORD PTR _x2$15[ebp]
	add	eax, 512				; 00000200H
	mov	DWORD PTR _x2$15[ebp], eax
	mov	eax, DWORD PTR _x3$14[ebp]
	add	eax, 512				; 00000200H
	mov	DWORD PTR _x3$14[ebp], eax

; 2177 :          v[ 0] = (x0+t3) >> 10;

	mov	eax, DWORD PTR _x0$17[ebp]
	add	eax, DWORD PTR _t3$23[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 2178 :          v[56] = (x0-t3) >> 10;

	mov	eax, DWORD PTR _x0$17[ebp]
	sub	eax, DWORD PTR _t3$23[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	imul	edx, ecx, 56
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 2179 :          v[ 8] = (x1+t2) >> 10;

	mov	eax, DWORD PTR _x1$16[ebp]
	add	eax, DWORD PTR _t2$24[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 2180 :          v[48] = (x1-t2) >> 10;

	mov	eax, DWORD PTR _x1$16[ebp]
	sub	eax, DWORD PTR _t2$24[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	imul	edx, ecx, 48
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 2181 :          v[16] = (x2+t1) >> 10;

	mov	eax, DWORD PTR _x2$15[ebp]
	add	eax, DWORD PTR _t1$25[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	shl	ecx, 4
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 2182 :          v[40] = (x2-t1) >> 10;

	mov	eax, DWORD PTR _x2$15[ebp]
	sub	eax, DWORD PTR _t1$25[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 2183 :          v[24] = (x3+t0) >> 10;

	mov	eax, DWORD PTR _x3$14[ebp]
	add	eax, DWORD PTR _t0$26[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	imul	edx, ecx, 24
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 2184 :          v[32] = (x3-t0) >> 10;

	mov	eax, DWORD PTR _x3$14[ebp]
	sub	eax, DWORD PTR _t0$26[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	shl	ecx, 5
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+ecx], eax
$LN4@stbi__idct:

; 2185 :       }
; 2186 :    }

	jmp	$LN7@stbi__idct
$LN6@stbi__idct:

; 2187 : 
; 2188 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {

	mov	DWORD PTR _i$[ebp], 0
	lea	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _v$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _o$[ebp], ecx
	jmp	SHORT $LN3@stbi__idct
$LN2@stbi__idct:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR _v$[ebp], ecx
	mov	edx, DWORD PTR _o$[ebp]
	add	edx, DWORD PTR _out_stride$[ebp]
	mov	DWORD PTR _o$[ebp], edx
$LN3@stbi__idct:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN9@stbi__idct

; 2189 :       // no fast case since the first 1D IDCT spread components out
; 2190 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _p2$8[ebp], edx
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _p3$7[ebp], eax
	mov	eax, DWORD PTR _p2$8[ebp]
	add	eax, DWORD PTR _p3$7[ebp]
	imul	ecx, eax, 2217
	mov	DWORD PTR _p1$9[ebp], ecx
	imul	eax, DWORD PTR _p3$7[ebp], -7567
	add	eax, DWORD PTR _p1$9[ebp]
	mov	DWORD PTR _t2$11[ebp], eax
	imul	eax, DWORD PTR _p2$8[ebp], 3135
	add	eax, DWORD PTR _p1$9[ebp]
	mov	DWORD PTR _t3$10[ebp], eax
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _p2$8[ebp], eax
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _p3$7[ebp], edx
	mov	eax, DWORD PTR _p2$8[ebp]
	add	eax, DWORD PTR _p3$7[ebp]
	shl	eax, 12					; 0000000cH
	mov	DWORD PTR _t0$13[ebp], eax
	mov	eax, DWORD PTR _p2$8[ebp]
	sub	eax, DWORD PTR _p3$7[ebp]
	shl	eax, 12					; 0000000cH
	mov	DWORD PTR _t1$12[ebp], eax
	mov	eax, DWORD PTR _t0$13[ebp]
	add	eax, DWORD PTR _t3$10[ebp]
	mov	DWORD PTR _x0$4[ebp], eax
	mov	eax, DWORD PTR _t0$13[ebp]
	sub	eax, DWORD PTR _t3$10[ebp]
	mov	DWORD PTR _x3$1[ebp], eax
	mov	eax, DWORD PTR _t1$12[ebp]
	add	eax, DWORD PTR _t2$11[ebp]
	mov	DWORD PTR _x1$3[ebp], eax
	mov	eax, DWORD PTR _t1$12[ebp]
	sub	eax, DWORD PTR _t2$11[ebp]
	mov	DWORD PTR _x2$2[ebp], eax
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _t0$13[ebp], eax
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _t1$12[ebp], eax
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _t2$11[ebp], eax
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _t3$10[ebp], edx
	mov	eax, DWORD PTR _t0$13[ebp]
	add	eax, DWORD PTR _t2$11[ebp]
	mov	DWORD PTR _p3$7[ebp], eax
	mov	eax, DWORD PTR _t1$12[ebp]
	add	eax, DWORD PTR _t3$10[ebp]
	mov	DWORD PTR _p4$6[ebp], eax
	mov	eax, DWORD PTR _t0$13[ebp]
	add	eax, DWORD PTR _t3$10[ebp]
	mov	DWORD PTR _p1$9[ebp], eax
	mov	eax, DWORD PTR _t1$12[ebp]
	add	eax, DWORD PTR _t2$11[ebp]
	mov	DWORD PTR _p2$8[ebp], eax
	mov	eax, DWORD PTR _p3$7[ebp]
	add	eax, DWORD PTR _p4$6[ebp]
	imul	ecx, eax, 4816
	mov	DWORD PTR _p5$5[ebp], ecx
	imul	eax, DWORD PTR _t0$13[ebp], 1223
	mov	DWORD PTR _t0$13[ebp], eax
	imul	eax, DWORD PTR _t1$12[ebp], 8410
	mov	DWORD PTR _t1$12[ebp], eax
	imul	eax, DWORD PTR _t2$11[ebp], 12586
	mov	DWORD PTR _t2$11[ebp], eax
	imul	eax, DWORD PTR _t3$10[ebp], 6149
	mov	DWORD PTR _t3$10[ebp], eax
	imul	eax, DWORD PTR _p1$9[ebp], -3685
	add	eax, DWORD PTR _p5$5[ebp]
	mov	DWORD PTR _p1$9[ebp], eax
	imul	eax, DWORD PTR _p2$8[ebp], -10497
	add	eax, DWORD PTR _p5$5[ebp]
	mov	DWORD PTR _p2$8[ebp], eax
	imul	eax, DWORD PTR _p3$7[ebp], -8034
	mov	DWORD PTR _p3$7[ebp], eax
	imul	eax, DWORD PTR _p4$6[ebp], -1597
	mov	DWORD PTR _p4$6[ebp], eax
	mov	eax, DWORD PTR _p1$9[ebp]
	add	eax, DWORD PTR _p4$6[ebp]
	add	eax, DWORD PTR _t3$10[ebp]
	mov	DWORD PTR _t3$10[ebp], eax
	mov	eax, DWORD PTR _p2$8[ebp]
	add	eax, DWORD PTR _p3$7[ebp]
	add	eax, DWORD PTR _t2$11[ebp]
	mov	DWORD PTR _t2$11[ebp], eax
	mov	eax, DWORD PTR _p2$8[ebp]
	add	eax, DWORD PTR _p4$6[ebp]
	add	eax, DWORD PTR _t1$12[ebp]
	mov	DWORD PTR _t1$12[ebp], eax
	mov	eax, DWORD PTR _p1$9[ebp]
	add	eax, DWORD PTR _p3$7[ebp]
	add	eax, DWORD PTR _t0$13[ebp]
	mov	DWORD PTR _t0$13[ebp], eax

; 2191 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2192 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2193 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2194 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2195 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2196 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2197 :       x0 += 65536 + (128<<17);

	mov	eax, DWORD PTR _x0$4[ebp]
	add	eax, 16842752				; 01010000H
	mov	DWORD PTR _x0$4[ebp], eax

; 2198 :       x1 += 65536 + (128<<17);

	mov	eax, DWORD PTR _x1$3[ebp]
	add	eax, 16842752				; 01010000H
	mov	DWORD PTR _x1$3[ebp], eax

; 2199 :       x2 += 65536 + (128<<17);

	mov	eax, DWORD PTR _x2$2[ebp]
	add	eax, 16842752				; 01010000H
	mov	DWORD PTR _x2$2[ebp], eax

; 2200 :       x3 += 65536 + (128<<17);

	mov	eax, DWORD PTR _x3$1[ebp]
	add	eax, 16842752				; 01010000H
	mov	DWORD PTR _x3$1[ebp], eax

; 2201 :       // tried computing the shifts into temps, or'ing the temps to see
; 2202 :       // if any were out of range, but that was slower
; 2203 :       o[0] = stbi__clamp((x0+t3) >> 17);

	mov	eax, DWORD PTR _x0$4[ebp]
	add	eax, DWORD PTR _t3$10[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	_stbi__clamp
	add	esp, 4
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 2204 :       o[7] = stbi__clamp((x0-t3) >> 17);

	mov	eax, DWORD PTR _x0$4[ebp]
	sub	eax, DWORD PTR _t3$10[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	_stbi__clamp
	add	esp, 4
	mov	ecx, 1
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 2205 :       o[1] = stbi__clamp((x1+t2) >> 17);

	mov	eax, DWORD PTR _x1$3[ebp]
	add	eax, DWORD PTR _t2$11[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	_stbi__clamp
	add	esp, 4
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 2206 :       o[6] = stbi__clamp((x1-t2) >> 17);

	mov	eax, DWORD PTR _x1$3[ebp]
	sub	eax, DWORD PTR _t2$11[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	_stbi__clamp
	add	esp, 4
	mov	ecx, 1
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 2207 :       o[2] = stbi__clamp((x2+t1) >> 17);

	mov	eax, DWORD PTR _x2$2[ebp]
	add	eax, DWORD PTR _t1$12[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	_stbi__clamp
	add	esp, 4
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 2208 :       o[5] = stbi__clamp((x2-t1) >> 17);

	mov	eax, DWORD PTR _x2$2[ebp]
	sub	eax, DWORD PTR _t1$12[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	_stbi__clamp
	add	esp, 4
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 2209 :       o[3] = stbi__clamp((x3+t0) >> 17);

	mov	eax, DWORD PTR _x3$1[ebp]
	add	eax, DWORD PTR _t0$13[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	_stbi__clamp
	add	esp, 4
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 2210 :       o[4] = stbi__clamp((x3-t0) >> 17);

	mov	eax, DWORD PTR _x3$1[ebp]
	sub	eax, DWORD PTR _t0$13[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	_stbi__clamp
	add	esp, 4
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 2211 :    }

	jmp	$LN2@stbi__idct
$LN9@stbi__idct:

; 2212 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@stbi__idct
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 832				; 00000340H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN13@stbi__idct:
	DD	1
	DD	$LN12@stbi__idct
$LN12@stbi__idct:
	DD	-276					; fffffeecH
	DD	256					; 00000100H
	DD	$LN11@stbi__idct
$LN11@stbi__idct:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
_stbi__idct_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__clamp
_TEXT	SEGMENT
_x$ = 8							; size = 4
_stbi__clamp PROC					; COMDAT

; 2105 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2106 :    // trick to use a single test to catch both cases
; 2107 :    if ((unsigned int) x > 255) {

	cmp	DWORD PTR _x$[ebp], 255			; 000000ffH
	jbe	SHORT $LN3@stbi__clam

; 2108 :       if (x < 0) return 0;

	cmp	DWORD PTR _x$[ebp], 0
	jge	SHORT $LN2@stbi__clam
	xor	al, al
	jmp	SHORT $LN4@stbi__clam
$LN2@stbi__clam:

; 2109 :       if (x > 255) return 255;

	cmp	DWORD PTR _x$[ebp], 255			; 000000ffH
	jle	SHORT $LN3@stbi__clam
	or	al, 255					; 000000ffH
	jmp	SHORT $LN4@stbi__clam
$LN3@stbi__clam:

; 2110 :    }
; 2111 :    return (stbi_uc) x;

	mov	al, BYTE PTR _x$[ebp]
$LN4@stbi__clam:

; 2112 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__clamp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__jpeg_decode_block_prog_ac
_TEXT	SEGMENT
_p$1 = -152						; size = 4
_rs$2 = -140						; size = 4
_s$3 = -128						; size = 4
_r$4 = -116						; size = 4
_p$5 = -104						; size = 4
_bit$6 = -92						; size = 2
_rs$7 = -80						; size = 4
_s$8 = -68						; size = 4
_r$9 = -56						; size = 4
_c$10 = -44						; size = 4
_zig$11 = -32						; size = 4
_shift$12 = -20						; size = 4
_k$ = -8						; size = 4
_j$ = 8							; size = 4
_data$ = 12						; size = 4
_hac$ = 16						; size = 4
_fac$ = 20						; size = 4
_stbi__jpeg_decode_block_prog_ac PROC			; COMDAT

; 1985 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-348]
	mov	ecx, 87					; 00000057H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1986 :    int k;
; 1987 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18384], 0
	jne	SHORT $LN46@stbi__jpeg
	push	OFFSET ??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN47@stbi__jpeg
$LN46@stbi__jpeg:

; 1988 : 
; 1989 :    if (j->succ_high == 0) {

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18392], 0
	jne	$LN45@stbi__jpeg

; 1990 :       int shift = j->succ_low;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18396]
	mov	DWORD PTR _shift$12[ebp], ecx

; 1991 : 
; 1992 :       if (j->eob_run) {

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18400], 0
	je	SHORT $LN44@stbi__jpeg

; 1993 :          --j->eob_run;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18400]
	sub	ecx, 1
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18400], ecx

; 1994 :          return 1;

	mov	eax, 1
	jmp	$LN47@stbi__jpeg
$LN44@stbi__jpeg:

; 1995 :       }
; 1996 : 
; 1997 :       k = j->spec_start;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18384]
	mov	DWORD PTR _k$[ebp], ecx
$LN43@stbi__jpeg:

; 1998 :       do {
; 1999 :          unsigned int zig;
; 2000 :          int c,r,s;
; 2001 :          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18368], 16		; 00000010H
	jge	SHORT $LN40@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__grow_buffer_unsafe
	add	esp, 4
$LN40@stbi__jpeg:

; 2002 :          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18364]
	shr	ecx, 23					; 00000017H
	and	ecx, 511				; 000001ffH
	mov	DWORD PTR _c$10[ebp], ecx

; 2003 :          r = fac[c];

	mov	eax, DWORD PTR _c$10[ebp]
	mov	ecx, DWORD PTR _fac$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	DWORD PTR _r$9[ebp], edx

; 2004 :          if (r) { // fast-AC path

	cmp	DWORD PTR _r$9[ebp], 0
	je	SHORT $LN39@stbi__jpeg

; 2005 :             k += (r >> 4) & 15; // run

	mov	eax, DWORD PTR _r$9[ebp]
	sar	eax, 4
	and	eax, 15					; 0000000fH
	add	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR _k$[ebp], eax

; 2006 :             s = r & 15; // combined length

	mov	eax, DWORD PTR _r$9[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _s$8[ebp], eax

; 2007 :             j->code_buffer <<= s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+18364]
	mov	ecx, DWORD PTR _s$8[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18364], edx

; 2008 :             j->code_bits -= s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, DWORD PTR _s$8[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 2009 :             zig = stbi__jpeg_dezigzag[k++];

	mov	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR _stbi__jpeg_dezigzag[eax]
	mov	DWORD PTR _zig$11[ebp], ecx
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx

; 2010 :             data[zig] = (short) ((r >> 8) << shift);

	mov	eax, DWORD PTR _r$9[ebp]
	sar	eax, 8
	mov	ecx, DWORD PTR _shift$12[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _zig$11[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 2011 :          } else {

	jmp	$LN42@stbi__jpeg
$LN39@stbi__jpeg:

; 2012 :             int rs = stbi__jpeg_huff_decode(j, hac);

	mov	eax, DWORD PTR _hac$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	_stbi__jpeg_huff_decode
	add	esp, 8
	mov	DWORD PTR _rs$7[ebp], eax

; 2013 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");

	cmp	DWORD PTR _rs$7[ebp], 0
	jge	SHORT $LN37@stbi__jpeg
	push	OFFSET ??_C@_0BB@IIMLINA@bad?5huffman?5code?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN47@stbi__jpeg
$LN37@stbi__jpeg:

; 2014 :             s = rs & 15;

	mov	eax, DWORD PTR _rs$7[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _s$8[ebp], eax

; 2015 :             r = rs >> 4;

	mov	eax, DWORD PTR _rs$7[ebp]
	sar	eax, 4
	mov	DWORD PTR _r$9[ebp], eax

; 2016 :             if (s == 0) {

	cmp	DWORD PTR _s$8[ebp], 0
	jne	SHORT $LN36@stbi__jpeg

; 2017 :                if (r < 15) {

	cmp	DWORD PTR _r$9[ebp], 15			; 0000000fH
	jge	SHORT $LN35@stbi__jpeg

; 2018 :                   j->eob_run = (1 << r);

	mov	eax, 1
	mov	ecx, DWORD PTR _r$9[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+18400], eax

; 2019 :                   if (r)

	cmp	DWORD PTR _r$9[ebp], 0
	je	SHORT $LN34@stbi__jpeg

; 2020 :                      j->eob_run += stbi__jpeg_get_bits(j, r);

	mov	eax, DWORD PTR _r$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	_stbi__jpeg_get_bits
	add	esp, 8
	mov	edx, DWORD PTR _j$[ebp]
	add	eax, DWORD PTR [edx+18400]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+18400], eax
$LN34@stbi__jpeg:

; 2021 :                   --j->eob_run;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18400]
	sub	ecx, 1
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18400], ecx

; 2022 :                   break;

	jmp	SHORT $LN41@stbi__jpeg
$LN35@stbi__jpeg:

; 2023 :                }
; 2024 :                k += 16;

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _k$[ebp], eax

; 2025 :             } else {

	jmp	SHORT $LN42@stbi__jpeg
$LN36@stbi__jpeg:

; 2026 :                k += r;

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, DWORD PTR _r$9[ebp]
	mov	DWORD PTR _k$[ebp], eax

; 2027 :                zig = stbi__jpeg_dezigzag[k++];

	mov	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR _stbi__jpeg_dezigzag[eax]
	mov	DWORD PTR _zig$11[ebp], ecx
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx

; 2028 :                data[zig] = (short) (stbi__extend_receive(j,s) << shift);

	mov	eax, DWORD PTR _s$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	_stbi__extend_receive
	add	esp, 8
	mov	ecx, DWORD PTR _shift$12[ebp]
	shl	eax, cl
	mov	edx, DWORD PTR _zig$11[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	WORD PTR [ecx+edx*2], ax
$LN42@stbi__jpeg:

; 2029 :             }
; 2030 :          }
; 2031 :       } while (k <= j->spec_end);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+18388]
	jle	$LN43@stbi__jpeg
$LN41@stbi__jpeg:

; 2032 :    } else {

	jmp	$LN32@stbi__jpeg
$LN45@stbi__jpeg:

; 2033 :       // refinement scan for these AC coefficients
; 2034 : 
; 2035 :       short bit = (short) (1 << j->succ_low);

	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+18396]
	shl	edx, cl
	mov	WORD PTR _bit$6[ebp], dx

; 2036 : 
; 2037 :       if (j->eob_run) {

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18400], 0
	je	$LN31@stbi__jpeg

; 2038 :          --j->eob_run;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18400]
	sub	ecx, 1
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18400], ecx

; 2039 :          for (k = j->spec_start; k <= j->spec_end; ++k) {

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18384]
	mov	DWORD PTR _k$[ebp], ecx
	jmp	SHORT $LN30@stbi__jpeg
$LN29@stbi__jpeg:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN30@stbi__jpeg:
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+18388]
	jg	SHORT $LN28@stbi__jpeg

; 2040 :             short *p = &data[stbi__jpeg_dezigzag[k]];

	mov	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR _stbi__jpeg_dezigzag[eax]
	mov	edx, DWORD PTR _data$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _p$5[ebp], eax

; 2041 :             if (*p != 0)

	mov	eax, DWORD PTR _p$5[ebp]
	movsx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN27@stbi__jpeg

; 2042 :                if (stbi__jpeg_get_bit(j))

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__jpeg_get_bit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN27@stbi__jpeg

; 2043 :                   if ((*p & bit)==0) {

	mov	eax, DWORD PTR _p$5[ebp]
	movsx	ecx, WORD PTR [eax]
	movsx	edx, WORD PTR _bit$6[ebp]
	and	ecx, edx
	jne	SHORT $LN27@stbi__jpeg

; 2044 :                      if (*p > 0)

	mov	eax, DWORD PTR _p$5[ebp]
	movsx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jle	SHORT $LN24@stbi__jpeg

; 2045 :                         *p += bit;

	movsx	eax, WORD PTR _bit$6[ebp]
	mov	ecx, DWORD PTR _p$5[ebp]
	movsx	edx, WORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR _p$5[ebp]
	mov	WORD PTR [eax], dx

; 2046 :                      else

	jmp	SHORT $LN27@stbi__jpeg
$LN24@stbi__jpeg:

; 2047 :                         *p -= bit;

	movsx	eax, WORD PTR _bit$6[ebp]
	mov	ecx, DWORD PTR _p$5[ebp]
	movsx	edx, WORD PTR [ecx]
	sub	edx, eax
	mov	eax, DWORD PTR _p$5[ebp]
	mov	WORD PTR [eax], dx
$LN27@stbi__jpeg:

; 2048 :                   }
; 2049 :          }

	jmp	$LN29@stbi__jpeg
$LN28@stbi__jpeg:

; 2050 :       } else {

	jmp	$LN32@stbi__jpeg
$LN31@stbi__jpeg:

; 2051 :          k = j->spec_start;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18384]
	mov	DWORD PTR _k$[ebp], ecx
$LN21@stbi__jpeg:

; 2052 :          do {
; 2053 :             int r,s;
; 2054 :             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh

	mov	eax, DWORD PTR _hac$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	_stbi__jpeg_huff_decode
	add	esp, 8
	mov	DWORD PTR _rs$2[ebp], eax

; 2055 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");

	cmp	DWORD PTR _rs$2[ebp], 0
	jge	SHORT $LN18@stbi__jpeg
	push	OFFSET ??_C@_0BB@IIMLINA@bad?5huffman?5code?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN47@stbi__jpeg
$LN18@stbi__jpeg:

; 2056 :             s = rs & 15;

	mov	eax, DWORD PTR _rs$2[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _s$3[ebp], eax

; 2057 :             r = rs >> 4;

	mov	eax, DWORD PTR _rs$2[ebp]
	sar	eax, 4
	mov	DWORD PTR _r$4[ebp], eax

; 2058 :             if (s == 0) {

	cmp	DWORD PTR _s$3[ebp], 0
	jne	SHORT $LN17@stbi__jpeg

; 2059 :                if (r < 15) {

	cmp	DWORD PTR _r$4[ebp], 15			; 0000000fH
	jge	SHORT $LN14@stbi__jpeg

; 2060 :                   j->eob_run = (1 << r) - 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _r$4[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+18400], eax

; 2061 :                   if (r)

	cmp	DWORD PTR _r$4[ebp], 0
	je	SHORT $LN15@stbi__jpeg

; 2062 :                      j->eob_run += stbi__jpeg_get_bits(j, r);

	mov	eax, DWORD PTR _r$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	_stbi__jpeg_get_bits
	add	esp, 8
	mov	edx, DWORD PTR _j$[ebp]
	add	eax, DWORD PTR [edx+18400]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+18400], eax
$LN15@stbi__jpeg:

; 2063 :                   r = 64; // force end of block

	mov	DWORD PTR _r$4[ebp], 64			; 00000040H
$LN14@stbi__jpeg:

; 2064 :                } else {
; 2065 :                   // r=15 s=0 should write 16 0s, so we just do
; 2066 :                   // a run of 15 0s and then write s (which is 0),
; 2067 :                   // so we don't have to do anything special here
; 2068 :                }
; 2069 :             } else {

	jmp	SHORT $LN9@stbi__jpeg
$LN17@stbi__jpeg:

; 2070 :                if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");

	cmp	DWORD PTR _s$3[ebp], 1
	je	SHORT $LN12@stbi__jpeg
	push	OFFSET ??_C@_0BB@IIMLINA@bad?5huffman?5code?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN47@stbi__jpeg
$LN12@stbi__jpeg:

; 2071 :                // sign bit
; 2072 :                if (stbi__jpeg_get_bit(j))

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__jpeg_get_bit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@stbi__jpeg

; 2073 :                   s = bit;

	movsx	eax, WORD PTR _bit$6[ebp]
	mov	DWORD PTR _s$3[ebp], eax

; 2074 :                else

	jmp	SHORT $LN9@stbi__jpeg
$LN11@stbi__jpeg:

; 2075 :                   s = -bit;

	movsx	eax, WORD PTR _bit$6[ebp]
	neg	eax
	mov	DWORD PTR _s$3[ebp], eax
$LN9@stbi__jpeg:

; 2076 :             }
; 2077 : 
; 2078 :             // advance by r
; 2079 :             while (k <= j->spec_end) {

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+18388]
	jg	$LN20@stbi__jpeg

; 2080 :                short *p = &data[stbi__jpeg_dezigzag[k++]];

	mov	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR _stbi__jpeg_dezigzag[eax]
	mov	edx, DWORD PTR _data$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _p$1[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx

; 2081 :                if (*p != 0) {

	mov	eax, DWORD PTR _p$1[ebp]
	movsx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN7@stbi__jpeg

; 2082 :                   if (stbi__jpeg_get_bit(j))

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__jpeg_get_bit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@stbi__jpeg

; 2083 :                      if ((*p & bit)==0) {

	mov	eax, DWORD PTR _p$1[ebp]
	movsx	ecx, WORD PTR [eax]
	movsx	edx, WORD PTR _bit$6[ebp]
	and	ecx, edx
	jne	SHORT $LN6@stbi__jpeg

; 2084 :                         if (*p > 0)

	mov	eax, DWORD PTR _p$1[ebp]
	movsx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jle	SHORT $LN4@stbi__jpeg

; 2085 :                            *p += bit;

	movsx	eax, WORD PTR _bit$6[ebp]
	mov	ecx, DWORD PTR _p$1[ebp]
	movsx	edx, WORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR _p$1[ebp]
	mov	WORD PTR [eax], dx

; 2086 :                         else

	jmp	SHORT $LN6@stbi__jpeg
$LN4@stbi__jpeg:

; 2087 :                            *p -= bit;

	movsx	eax, WORD PTR _bit$6[ebp]
	mov	ecx, DWORD PTR _p$1[ebp]
	movsx	edx, WORD PTR [ecx]
	sub	edx, eax
	mov	eax, DWORD PTR _p$1[ebp]
	mov	WORD PTR [eax], dx
$LN6@stbi__jpeg:

; 2088 :                      }
; 2089 :                } else {

	jmp	SHORT $LN2@stbi__jpeg
$LN7@stbi__jpeg:

; 2090 :                   if (r == 0) {

	cmp	DWORD PTR _r$4[ebp], 0
	jne	SHORT $LN1@stbi__jpeg

; 2091 :                      *p = (short) s;

	mov	eax, DWORD PTR _p$1[ebp]
	mov	cx, WORD PTR _s$3[ebp]
	mov	WORD PTR [eax], cx

; 2092 :                      break;

	jmp	SHORT $LN20@stbi__jpeg
$LN1@stbi__jpeg:

; 2093 :                   }
; 2094 :                   --r;

	mov	eax, DWORD PTR _r$4[ebp]
	sub	eax, 1
	mov	DWORD PTR _r$4[ebp], eax
$LN2@stbi__jpeg:

; 2095 :                }
; 2096 :             }

	jmp	$LN9@stbi__jpeg
$LN20@stbi__jpeg:

; 2097 :          } while (k <= j->spec_end);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+18388]
	jle	$LN21@stbi__jpeg
$LN32@stbi__jpeg:

; 2098 :       }
; 2099 :    }
; 2100 :    return 1;

	mov	eax, 1
$LN47@stbi__jpeg:

; 2101 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 348				; 0000015cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__jpeg_decode_block_prog_ac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__jpeg_decode_block_prog_dc
_TEXT	SEGMENT
tv83 = -232						; size = 4
_t$ = -32						; size = 4
_dc$ = -20						; size = 4
_diff$ = -8						; size = 4
_j$ = 8							; size = 4
_data$ = 12						; size = 4
_hdc$ = 16						; size = 4
_b$ = 20						; size = 4
_stbi__jpeg_decode_block_prog_dc PROC			; COMDAT

; 1958 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1959 :    int diff,dc;
; 1960 :    int t;
; 1961 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18388], 0
	je	SHORT $LN5@stbi__jpeg
	push	OFFSET ??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN6@stbi__jpeg
$LN5@stbi__jpeg:

; 1962 : 
; 1963 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18368], 16		; 00000010H
	jge	SHORT $LN4@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__grow_buffer_unsafe
	add	esp, 4
$LN4@stbi__jpeg:

; 1964 : 
; 1965 :    if (j->succ_high == 0) {

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18392], 0
	jne	$LN3@stbi__jpeg

; 1966 :       // first scan for DC coefficient, must be first
; 1967 :       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now

	push	128					; 00000080H
	push	0
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1968 :       t = stbi__jpeg_huff_decode(j, hdc);

	mov	eax, DWORD PTR _hdc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	_stbi__jpeg_huff_decode
	add	esp, 8
	mov	DWORD PTR _t$[ebp], eax

; 1969 :       diff = t ? stbi__extend_receive(j, t) : 0;

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN8@stbi__jpeg
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	_stbi__extend_receive
	add	esp, 8
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN9@stbi__jpeg
$LN8@stbi__jpeg:
	mov	DWORD PTR tv83[ebp], 0
$LN9@stbi__jpeg:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _diff$[ebp], edx

; 1970 : 
; 1971 :       dc = j->img_comp[b].dc_pred + diff;

	imul	eax, DWORD PTR _b$[ebp], 72
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18100]
	add	edx, DWORD PTR _diff$[ebp]
	mov	DWORD PTR _dc$[ebp], edx

; 1972 :       j->img_comp[b].dc_pred = dc;

	imul	eax, DWORD PTR _b$[ebp], 72
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _dc$[ebp]
	mov	DWORD PTR [ecx+eax+18100], edx

; 1973 :       data[0] = (short) (dc << j->succ_low);

	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _dc$[ebp]
	mov	ecx, DWORD PTR [eax+18396]
	shl	edx, cl
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _data$[ebp]
	mov	WORD PTR [eax+ecx], dx

; 1974 :    } else {

	jmp	SHORT $LN2@stbi__jpeg
$LN3@stbi__jpeg:

; 1975 :       // refinement scan for DC coefficient
; 1976 :       if (stbi__jpeg_get_bit(j))

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__jpeg_get_bit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@stbi__jpeg

; 1977 :          data[0] += (short) (1 << j->succ_low);

	mov	eax, 2
	imul	edx, eax, 0
	mov	eax, DWORD PTR _j$[ebp]
	mov	esi, 1
	mov	ecx, DWORD PTR [eax+18396]
	shl	esi, cl
	movsx	ecx, si
	mov	eax, DWORD PTR _data$[ebp]
	movsx	edx, WORD PTR [eax+edx]
	add	edx, ecx
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _data$[ebp]
	mov	WORD PTR [eax+ecx], dx
$LN2@stbi__jpeg:

; 1978 :    }
; 1979 :    return 1;

	mov	eax, 1
$LN6@stbi__jpeg:

; 1980 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__jpeg_decode_block_prog_dc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__jpeg_decode_block
_TEXT	SEGMENT
tv80 = -304						; size = 4
_rs$1 = -104						; size = 4
_s$2 = -92						; size = 4
_r$3 = -80						; size = 4
_c$4 = -68						; size = 4
_zig$5 = -56						; size = 4
_t$ = -44						; size = 4
_k$ = -32						; size = 4
_dc$ = -20						; size = 4
_diff$ = -8						; size = 4
_j$ = 8							; size = 4
_data$ = 12						; size = 4
_hdc$ = 16						; size = 4
_hac$ = 20						; size = 4
_fac$ = 24						; size = 4
_b$ = 28						; size = 4
_dequant$ = 32						; size = 4
_stbi__jpeg_decode_block PROC				; COMDAT

; 1906 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-304]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1907 :    int diff,dc,k;
; 1908 :    int t;
; 1909 : 
; 1910 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18368], 16		; 00000010H
	jge	SHORT $LN12@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__grow_buffer_unsafe
	add	esp, 4
$LN12@stbi__jpeg:

; 1911 :    t = stbi__jpeg_huff_decode(j, hdc);

	mov	eax, DWORD PTR _hdc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	_stbi__jpeg_huff_decode
	add	esp, 8
	mov	DWORD PTR _t$[ebp], eax

; 1912 :    if (t < 0) return stbi__err("bad huffman code","Corrupt JPEG");

	cmp	DWORD PTR _t$[ebp], 0
	jge	SHORT $LN11@stbi__jpeg
	push	OFFSET ??_C@_0BB@IIMLINA@bad?5huffman?5code?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN13@stbi__jpeg
$LN11@stbi__jpeg:

; 1913 : 
; 1914 :    // 0 all the ac values now so we can do it 32-bits at a time
; 1915 :    memset(data,0,64*sizeof(data[0]));

	push	128					; 00000080H
	push	0
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1916 : 
; 1917 :    diff = t ? stbi__extend_receive(j, t) : 0;

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN15@stbi__jpeg
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	_stbi__extend_receive
	add	esp, 8
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN16@stbi__jpeg
$LN15@stbi__jpeg:
	mov	DWORD PTR tv80[ebp], 0
$LN16@stbi__jpeg:
	mov	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _diff$[ebp], edx

; 1918 :    dc = j->img_comp[b].dc_pred + diff;

	imul	eax, DWORD PTR _b$[ebp], 72
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18100]
	add	edx, DWORD PTR _diff$[ebp]
	mov	DWORD PTR _dc$[ebp], edx

; 1919 :    j->img_comp[b].dc_pred = dc;

	imul	eax, DWORD PTR _b$[ebp], 72
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _dc$[ebp]
	mov	DWORD PTR [ecx+eax+18100], edx

; 1920 :    data[0] = (short) (dc * dequant[0]);

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dequant$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	imul	eax, DWORD PTR _dc$[ebp]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _data$[ebp]
	mov	WORD PTR [ecx+edx], ax

; 1921 : 
; 1922 :    // decode AC components, see JPEG spec
; 1923 :    k = 1;

	mov	DWORD PTR _k$[ebp], 1
$LN10@stbi__jpeg:

; 1924 :    do {
; 1925 :       unsigned int zig;
; 1926 :       int c,r,s;
; 1927 :       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18368], 16		; 00000010H
	jge	SHORT $LN7@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__grow_buffer_unsafe
	add	esp, 4
$LN7@stbi__jpeg:

; 1928 :       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18364]
	shr	ecx, 23					; 00000017H
	and	ecx, 511				; 000001ffH
	mov	DWORD PTR _c$4[ebp], ecx

; 1929 :       r = fac[c];

	mov	eax, DWORD PTR _c$4[ebp]
	mov	ecx, DWORD PTR _fac$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	DWORD PTR _r$3[ebp], edx

; 1930 :       if (r) { // fast-AC path

	cmp	DWORD PTR _r$3[ebp], 0
	je	SHORT $LN6@stbi__jpeg

; 1931 :          k += (r >> 4) & 15; // run

	mov	eax, DWORD PTR _r$3[ebp]
	sar	eax, 4
	and	eax, 15					; 0000000fH
	add	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR _k$[ebp], eax

; 1932 :          s = r & 15; // combined length

	mov	eax, DWORD PTR _r$3[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _s$2[ebp], eax

; 1933 :          j->code_buffer <<= s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+18364]
	mov	ecx, DWORD PTR _s$2[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18364], edx

; 1934 :          j->code_bits -= s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, DWORD PTR _s$2[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 1935 :          // decode into unzigzag'd location
; 1936 :          zig = stbi__jpeg_dezigzag[k++];

	mov	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR _stbi__jpeg_dezigzag[eax]
	mov	DWORD PTR _zig$5[ebp], ecx
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx

; 1937 :          data[zig] = (short) ((r >> 8) * dequant[zig]);

	mov	eax, DWORD PTR _r$3[ebp]
	sar	eax, 8
	mov	ecx, DWORD PTR _zig$5[ebp]
	mov	edx, DWORD PTR _dequant$[ebp]
	movzx	ecx, WORD PTR [edx+ecx*2]
	imul	eax, ecx
	mov	edx, DWORD PTR _zig$5[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	WORD PTR [ecx+edx*2], ax

; 1938 :       } else {

	jmp	$LN9@stbi__jpeg
$LN6@stbi__jpeg:

; 1939 :          int rs = stbi__jpeg_huff_decode(j, hac);

	mov	eax, DWORD PTR _hac$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	_stbi__jpeg_huff_decode
	add	esp, 8
	mov	DWORD PTR _rs$1[ebp], eax

; 1940 :          if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");

	cmp	DWORD PTR _rs$1[ebp], 0
	jge	SHORT $LN4@stbi__jpeg
	push	OFFSET ??_C@_0BB@IIMLINA@bad?5huffman?5code?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN13@stbi__jpeg
$LN4@stbi__jpeg:

; 1941 :          s = rs & 15;

	mov	eax, DWORD PTR _rs$1[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _s$2[ebp], eax

; 1942 :          r = rs >> 4;

	mov	eax, DWORD PTR _rs$1[ebp]
	sar	eax, 4
	mov	DWORD PTR _r$3[ebp], eax

; 1943 :          if (s == 0) {

	cmp	DWORD PTR _s$2[ebp], 0
	jne	SHORT $LN3@stbi__jpeg

; 1944 :             if (rs != 0xf0) break; // end block

	cmp	DWORD PTR _rs$1[ebp], 240		; 000000f0H
	je	SHORT $LN2@stbi__jpeg
	jmp	SHORT $LN8@stbi__jpeg
$LN2@stbi__jpeg:

; 1945 :             k += 16;

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _k$[ebp], eax

; 1946 :          } else {

	jmp	SHORT $LN9@stbi__jpeg
$LN3@stbi__jpeg:

; 1947 :             k += r;

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, DWORD PTR _r$3[ebp]
	mov	DWORD PTR _k$[ebp], eax

; 1948 :             // decode into unzigzag'd location
; 1949 :             zig = stbi__jpeg_dezigzag[k++];

	mov	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR _stbi__jpeg_dezigzag[eax]
	mov	DWORD PTR _zig$5[ebp], ecx
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx

; 1950 :             data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);

	mov	eax, DWORD PTR _s$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	_stbi__extend_receive
	add	esp, 8
	mov	edx, DWORD PTR _zig$5[ebp]
	mov	ecx, DWORD PTR _dequant$[ebp]
	movzx	edx, WORD PTR [ecx+edx*2]
	imul	eax, edx
	mov	ecx, DWORD PTR _zig$5[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
$LN9@stbi__jpeg:

; 1951 :          }
; 1952 :       }
; 1953 :    } while (k < 64);

	cmp	DWORD PTR _k$[ebp], 64			; 00000040H
	jl	$LN10@stbi__jpeg
$LN8@stbi__jpeg:

; 1954 :    return 1;

	mov	eax, 1
$LN13@stbi__jpeg:

; 1955 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__jpeg_decode_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__jpeg_get_bit
_TEXT	SEGMENT
_k$ = -8						; size = 4
_j$ = 8							; size = 4
_stbi__jpeg_get_bit PROC				; COMDAT

; 1878 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1879 :    unsigned int k;
; 1880 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18368], 1
	jge	SHORT $LN1@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__grow_buffer_unsafe
	add	esp, 4
$LN1@stbi__jpeg:

; 1881 :    k = j->code_buffer;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18364]
	mov	DWORD PTR _k$[ebp], ecx

; 1882 :    j->code_buffer <<= 1;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18364]
	shl	ecx, 1
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18364], ecx

; 1883 :    --j->code_bits;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, 1
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 1884 :    return k & 0x80000000;

	mov	eax, DWORD PTR _k$[ebp]
	and	eax, -2147483648			; 80000000H

; 1885 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__jpeg_get_bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__jpeg_get_bits
_TEXT	SEGMENT
_k$ = -8						; size = 4
_j$ = 8							; size = 4
_n$ = 12						; size = 4
_stbi__jpeg_get_bits PROC				; COMDAT

; 1867 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1868 :    unsigned int k;
; 1869 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	cmp	ecx, DWORD PTR _n$[ebp]
	jge	SHORT $LN1@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__grow_buffer_unsafe
	add	esp, 4
$LN1@stbi__jpeg:

; 1870 :    k = stbi_lrot(j->code_buffer, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [ecx+18364]
	push	edx
	call	__lrotl
	add	esp, 8
	mov	DWORD PTR _k$[ebp], eax

; 1871 :    j->code_buffer = k & ~stbi__bmask[n];

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _stbi__bmask[eax*4]
	not	ecx
	and	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18364], ecx

; 1872 :    k &= stbi__bmask[n];

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	and	ecx, DWORD PTR _stbi__bmask[eax*4]
	mov	DWORD PTR _k$[ebp], ecx

; 1873 :    j->code_bits -= n;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 1874 :    return k;

	mov	eax, DWORD PTR _k$[ebp]

; 1875 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__jpeg_get_bits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__extend_receive
_TEXT	SEGMENT
_sgn$ = -20						; size = 4
_k$ = -8						; size = 4
_j$ = 8							; size = 4
_n$ = 12						; size = 4
_stbi__extend_receive PROC				; COMDAT

; 1851 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1852 :    unsigned int k;
; 1853 :    int sgn;
; 1854 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	cmp	ecx, DWORD PTR _n$[ebp]
	jge	SHORT $LN1@stbi__exte
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__grow_buffer_unsafe
	add	esp, 4
$LN1@stbi__exte:

; 1855 : 
; 1856 :    sgn = (stbi__int32)j->code_buffer >> 31; // sign bit is always in MSB

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18364]
	sar	ecx, 31					; 0000001fH
	mov	DWORD PTR _sgn$[ebp], ecx

; 1857 :    k = stbi_lrot(j->code_buffer, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [ecx+18364]
	push	edx
	call	__lrotl
	add	esp, 8
	mov	DWORD PTR _k$[ebp], eax

; 1858 :    STBI_ASSERT(n >= 0 && n < (int) (sizeof(stbi__bmask)/sizeof(*stbi__bmask)));

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN4@stbi__exte
	cmp	DWORD PTR _n$[ebp], 17			; 00000011H
	jl	SHORT $LN5@stbi__exte
$LN4@stbi__exte:
	mov	eax, DWORD PTR ?__LINE__Var@?1??stbi__extend_receive@@9@9@e7b221e1
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1HO@LDGMAAKB@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs?$AAt?$AAb?$AAi@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@stbi__exte:

; 1859 :    j->code_buffer = k & ~stbi__bmask[n];

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _stbi__bmask[eax*4]
	not	ecx
	and	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18364], ecx

; 1860 :    k &= stbi__bmask[n];

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	and	ecx, DWORD PTR _stbi__bmask[eax*4]
	mov	DWORD PTR _k$[ebp], ecx

; 1861 :    j->code_bits -= n;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 1862 :    return k + (stbi__jbias[n] & ~sgn);

	mov	eax, DWORD PTR _sgn$[ebp]
	not	eax
	mov	ecx, DWORD PTR _n$[ebp]
	and	eax, DWORD PTR _stbi__jbias[ecx*4]
	add	eax, DWORD PTR _k$[ebp]

; 1863 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__extend_receive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__jpeg_huff_decode
_TEXT	SEGMENT
_s$1 = -44						; size = 4
_k$ = -32						; size = 4
_c$ = -20						; size = 4
_temp$ = -8						; size = 4
_j$ = 8							; size = 4
_h$ = 12						; size = 4
_stbi__jpeg_huff_decode PROC				; COMDAT

; 1797 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1798 :    unsigned int temp;
; 1799 :    int c,k;
; 1800 : 
; 1801 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18368], 16		; 00000010H
	jge	SHORT $LN9@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__grow_buffer_unsafe
	add	esp, 4
$LN9@stbi__jpeg:

; 1802 : 
; 1803 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 1804 :    // if the code is <= FAST_BITS
; 1805 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18364]
	shr	ecx, 23					; 00000017H
	and	ecx, 511				; 000001ffH
	mov	DWORD PTR _c$[ebp], ecx

; 1806 :    k = h->fast[c];

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _k$[ebp], ecx

; 1807 :    if (k < 255) {

	cmp	DWORD PTR _k$[ebp], 255			; 000000ffH
	jge	SHORT $LN8@stbi__jpeg

; 1808 :       int s = h->size[k];

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax+1280]
	mov	DWORD PTR _s$1[ebp], ecx

; 1809 :       if (s > j->code_bits)

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _s$1[ebp]
	cmp	ecx, DWORD PTR [eax+18368]
	jle	SHORT $LN7@stbi__jpeg

; 1810 :          return -1;

	or	eax, -1
	jmp	$LN10@stbi__jpeg
$LN7@stbi__jpeg:

; 1811 :       j->code_buffer <<= s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+18364]
	mov	ecx, DWORD PTR _s$1[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18364], edx

; 1812 :       j->code_bits -= s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, DWORD PTR _s$1[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 1813 :       return h->values[k];

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [eax+1024]
	jmp	$LN10@stbi__jpeg
$LN8@stbi__jpeg:

; 1814 :    }
; 1815 : 
; 1816 :    // naive test is to shift the code_buffer down so k bits are
; 1817 :    // valid, then test against maxcode. To speed this up, we've
; 1818 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 1819 :    // end; in other words, regardless of the number of bits, it
; 1820 :    // wants to be compared against something shifted to have 16;
; 1821 :    // that way we don't need to shift inside the loop.
; 1822 :    temp = j->code_buffer >> 16;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18364]
	shr	ecx, 16					; 00000010H
	mov	DWORD PTR _temp$[ebp], ecx

; 1823 :    for (k=FAST_BITS+1 ; ; ++k)

	mov	DWORD PTR _k$[ebp], 10			; 0000000aH
	jmp	SHORT $LN6@stbi__jpeg
$LN5@stbi__jpeg:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN6@stbi__jpeg:

; 1824 :       if (temp < h->maxcode[k])

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR _temp$[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4+1540]
	jae	SHORT $LN3@stbi__jpeg

; 1825 :          break;

	jmp	SHORT $LN4@stbi__jpeg
$LN3@stbi__jpeg:

; 1826 :    if (k == 17) {

	jmp	SHORT $LN5@stbi__jpeg
$LN4@stbi__jpeg:
	cmp	DWORD PTR _k$[ebp], 17			; 00000011H
	jne	SHORT $LN2@stbi__jpeg

; 1827 :       // error! code not found
; 1828 :       j->code_bits -= 16;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 1829 :       return -1;

	or	eax, -1
	jmp	$LN10@stbi__jpeg
$LN2@stbi__jpeg:

; 1830 :    }
; 1831 : 
; 1832 :    if (k > j->code_bits)

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+18368]
	jle	SHORT $LN1@stbi__jpeg

; 1833 :       return -1;

	or	eax, -1
	jmp	$LN10@stbi__jpeg
$LN1@stbi__jpeg:

; 1834 : 
; 1835 :    // convert the huffman code to the symbol id
; 1836 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+18364]
	shr	edx, cl
	mov	eax, DWORD PTR _k$[ebp]
	and	edx, DWORD PTR _stbi__bmask[eax*4]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _h$[ebp]
	add	edx, DWORD PTR [eax+ecx*4+1612]
	mov	DWORD PTR _c$[ebp], edx

; 1837 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	movzx	ecx, BYTE PTR [eax+1280]
	mov	edx, 32					; 00000020H
	sub	edx, ecx
	mov	eax, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+18364]
	mov	ecx, edx
	shr	eax, cl
	mov	ecx, DWORD PTR _h$[ebp]
	add	ecx, DWORD PTR _c$[ebp]
	movzx	edx, BYTE PTR [ecx+1280]
	and	eax, DWORD PTR _stbi__bmask[edx*4]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _h$[ebp]
	movzx	ecx, WORD PTR [edx+ecx*2+512]
	cmp	eax, ecx
	je	SHORT $LN12@stbi__jpeg
	mov	edx, DWORD PTR ?__LINE__Var@?1??stbi__jpeg_huff_decode@@9@9@e7b221e1
	add	edx, 40					; 00000028H
	push	edx
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AA?$CI?$AA3?$AA2?$AA?5?$AA?9?$AA?5?$AAh?$AA?9?$AA?$DO?$AAs@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN12@stbi__jpeg:

; 1838 : 
; 1839 :    // convert the id to a symbol
; 1840 :    j->code_bits -= k;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 1841 :    j->code_buffer <<= k;

	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+18364]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18364], edx

; 1842 :    return h->values[c];

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	movzx	eax, BYTE PTR [eax+1024]
$LN10@stbi__jpeg:

; 1843 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__jpeg_huff_decode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__grow_buffer_unsafe
_TEXT	SEGMENT
tv70 = -220						; size = 4
_c$1 = -20						; size = 4
_b$2 = -8						; size = 4
_j$ = 8							; size = 4
_stbi__grow_buffer_unsafe PROC				; COMDAT

; 1775 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN7@stbi__grow:

; 1776 :    do {
; 1777 :       int b = j->nomore ? 0 : stbi__get8(j->s);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18376], 0
	je	SHORT $LN10@stbi__grow
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN11@stbi__grow
$LN10@stbi__grow:
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_stbi__get8
	add	esp, 4
	movzx	eax, al
	mov	DWORD PTR tv70[ebp], eax
$LN11@stbi__grow:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _b$2[ebp], ecx

; 1778 :       if (b == 0xff) {

	cmp	DWORD PTR _b$2[ebp], 255		; 000000ffH
	jne	SHORT $LN4@stbi__grow

; 1779 :          int c = stbi__get8(j->s);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _c$1[ebp], edx
$LN3@stbi__grow:

; 1780 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes

	cmp	DWORD PTR _c$1[ebp], 255		; 000000ffH
	jne	SHORT $LN2@stbi__grow
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _c$1[ebp], edx
	jmp	SHORT $LN3@stbi__grow
$LN2@stbi__grow:

; 1781 :          if (c != 0) {

	cmp	DWORD PTR _c$1[ebp], 0
	je	SHORT $LN4@stbi__grow

; 1782 :             j->marker = (unsigned char) c;

	mov	eax, DWORD PTR _j$[ebp]
	mov	cl, BYTE PTR _c$1[ebp]
	mov	BYTE PTR [eax+18372], cl

; 1783 :             j->nomore = 1;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18376], 1

; 1784 :             return;

	jmp	SHORT $LN8@stbi__grow
$LN4@stbi__grow:

; 1785 :          }
; 1786 :       }
; 1787 :       j->code_buffer |= b << (24 - j->code_bits);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, 24					; 00000018H
	sub	ecx, DWORD PTR [eax+18368]
	mov	edx, DWORD PTR _b$2[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _j$[ebp]
	or	edx, DWORD PTR [eax+18364]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+18364], edx

; 1788 :       j->code_bits += 8;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	add	ecx, 8
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 1789 :    } while (j->code_bits <= 24);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18368], 24		; 00000018H
	jle	$LN7@stbi__grow
$LN8@stbi__grow:

; 1790 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__grow_buffer_unsafe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__build_fast_ac
_TEXT	SEGMENT
_m$1 = -92						; size = 4
_k$2 = -80						; size = 4
_len$3 = -68						; size = 4
_magbits$4 = -56					; size = 4
_run$5 = -44						; size = 4
_rs$6 = -32						; size = 4
_fast$7 = -17						; size = 1
_i$ = -8						; size = 4
_fast_ac$ = 8						; size = 4
_h$ = 12						; size = 4
_stbi__build_fast_ac PROC				; COMDAT

; 1750 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1751 :    int i;
; 1752 :    for (i=0; i < (1 << FAST_BITS); ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@stbi__buil
$LN6@stbi__buil:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@stbi__buil:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	$LN8@stbi__buil

; 1753 :       stbi_uc fast = h->fast[i];

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _fast$7[ebp], cl

; 1754 :       fast_ac[i] = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fast_ac$[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 1755 :       if (fast < 255) {

	movzx	eax, BYTE PTR _fast$7[ebp]
	cmp	eax, 255				; 000000ffH
	jge	$LN4@stbi__buil

; 1756 :          int rs = h->values[fast];

	movzx	eax, BYTE PTR _fast$7[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1024]
	mov	DWORD PTR _rs$6[ebp], edx

; 1757 :          int run = (rs >> 4) & 15;

	mov	eax, DWORD PTR _rs$6[ebp]
	sar	eax, 4
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _run$5[ebp], eax

; 1758 :          int magbits = rs & 15;

	mov	eax, DWORD PTR _rs$6[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _magbits$4[ebp], eax

; 1759 :          int len = h->size[fast];

	movzx	eax, BYTE PTR _fast$7[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1280]
	mov	DWORD PTR _len$3[ebp], edx

; 1760 : 
; 1761 :          if (magbits && len + magbits <= FAST_BITS) {

	cmp	DWORD PTR _magbits$4[ebp], 0
	je	SHORT $LN4@stbi__buil
	mov	eax, DWORD PTR _len$3[ebp]
	add	eax, DWORD PTR _magbits$4[ebp]
	cmp	eax, 9
	jg	SHORT $LN4@stbi__buil

; 1762 :             // magnitude code followed by receive_extend code
; 1763 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _len$3[ebp]
	shl	eax, cl
	and	eax, 511				; 000001ffH
	mov	ecx, 9
	sub	ecx, DWORD PTR _magbits$4[ebp]
	sar	eax, cl
	mov	DWORD PTR _k$2[ebp], eax

; 1764 :             int m = 1 << (magbits - 1);

	mov	ecx, DWORD PTR _magbits$4[ebp]
	sub	ecx, 1
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _m$1[ebp], eax

; 1765 :             if (k < m) k += (~0U << magbits) + 1;

	mov	eax, DWORD PTR _k$2[ebp]
	cmp	eax, DWORD PTR _m$1[ebp]
	jge	SHORT $LN2@stbi__buil
	or	eax, -1
	mov	ecx, DWORD PTR _magbits$4[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _k$2[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _k$2[ebp], edx
$LN2@stbi__buil:

; 1766 :             // if the result is small enough, we can fit it in fast_ac table
; 1767 :             if (k >= -128 && k <= 127)

	cmp	DWORD PTR _k$2[ebp], -128		; ffffff80H
	jl	SHORT $LN4@stbi__buil
	cmp	DWORD PTR _k$2[ebp], 127		; 0000007fH
	jg	SHORT $LN4@stbi__buil

; 1768 :                fast_ac[i] = (stbi__int16) ((k << 8) + (run << 4) + (len + magbits));

	mov	eax, DWORD PTR _k$2[ebp]
	shl	eax, 8
	mov	ecx, DWORD PTR _run$5[ebp]
	shl	ecx, 4
	add	eax, ecx
	mov	edx, DWORD PTR _len$3[ebp]
	add	edx, DWORD PTR _magbits$4[ebp]
	add	eax, edx
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fast_ac$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
$LN4@stbi__buil:

; 1769 :          }
; 1770 :       }
; 1771 :    }

	jmp	$LN6@stbi__buil
$LN8@stbi__buil:

; 1772 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__build_fast_ac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__build_huffman
_TEXT	SEGMENT
_m$1 = -80						; size = 4
_c$2 = -68						; size = 4
_s$3 = -56						; size = 4
_code$ = -44						; size = 4
_k$ = -32						; size = 4
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_h$ = 8							; size = 4
_count$ = 12						; size = 4
_stbi__build_huffman PROC				; COMDAT

; 1707 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1708 :    int i,j,k=0,code;

	mov	DWORD PTR _k$[ebp], 0

; 1709 :    // build size list for each symbol (from JPEG spec)
; 1710 :    for (i=0; i < 16; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN20@stbi__buil
$LN19@stbi__buil:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN20@stbi__buil:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN18@stbi__buil

; 1711 :       for (j=0; j < count[i]; ++j)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN17@stbi__buil
$LN16@stbi__buil:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN17@stbi__buil:
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4]
	jge	SHORT $LN15@stbi__buil

; 1712 :          h->size[k++] = (stbi_uc) (i+1);

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _h$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	BYTE PTR [ecx+1280], al
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
	jmp	SHORT $LN16@stbi__buil
$LN15@stbi__buil:
	jmp	SHORT $LN19@stbi__buil
$LN18@stbi__buil:

; 1713 :    h->size[k] = 0;

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax+1280], 0

; 1714 : 
; 1715 :    // compute actual symbols (from jpeg spec)
; 1716 :    code = 0;

	mov	DWORD PTR _code$[ebp], 0

; 1717 :    k = 0;

	mov	DWORD PTR _k$[ebp], 0

; 1718 :    for(j=1; j <= 16; ++j) {

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN14@stbi__buil
$LN13@stbi__buil:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN14@stbi__buil:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jg	$LN12@stbi__buil

; 1719 :       // compute delta to add to code to compute symbol id
; 1720 :       h->delta[j] = k - code;

	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, DWORD PTR _code$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [edx+ecx*4+1612], eax

; 1721 :       if (h->size[k] == j) {

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax+1280]
	cmp	ecx, DWORD PTR _j$[ebp]
	jne	SHORT $LN11@stbi__buil
$LN10@stbi__buil:

; 1722 :          while (h->size[k] == j)

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax+1280]
	cmp	ecx, DWORD PTR _j$[ebp]
	jne	SHORT $LN9@stbi__buil

; 1723 :             h->code[k++] = (stbi__uint16) (code++);

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	dx, WORD PTR _code$[ebp]
	mov	WORD PTR [ecx+eax*2+512], dx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	mov	ecx, DWORD PTR _code$[ebp]
	add	ecx, 1
	mov	DWORD PTR _code$[ebp], ecx
	jmp	SHORT $LN10@stbi__buil
$LN9@stbi__buil:

; 1724 :          if (code-1 >= (1 << j)) return stbi__err("bad code lengths","Corrupt JPEG");

	mov	eax, DWORD PTR _code$[ebp]
	sub	eax, 1
	mov	edx, 1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	edx, cl
	cmp	eax, edx
	jl	SHORT $LN11@stbi__buil
	push	OFFSET ??_C@_0BB@FOKGPEKG@bad?5code?5lengths?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	$LN21@stbi__buil
$LN11@stbi__buil:

; 1725 :       }
; 1726 :       // compute largest code + 1 for this size, preshifted as needed later
; 1727 :       h->maxcode[j] = code << (16-j);

	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _code$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [edx+ecx*4+1540], eax

; 1728 :       code <<= 1;

	mov	eax, DWORD PTR _code$[ebp]
	shl	eax, 1
	mov	DWORD PTR _code$[ebp], eax

; 1729 :    }

	jmp	$LN13@stbi__buil
$LN12@stbi__buil:

; 1730 :    h->maxcode[j] = 0xffffffff;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [ecx+eax*4+1540], -1

; 1731 : 
; 1732 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 1733 :    memset(h->fast, 255, 1 << FAST_BITS);

	push	512					; 00000200H
	push	255					; 000000ffH
	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1734 :    for (i=0; i < k; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@stbi__buil
$LN6@stbi__buil:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@stbi__buil:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN5@stbi__buil

; 1735 :       int s = h->size[i];

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax+1280]
	mov	DWORD PTR _s$3[ebp], ecx

; 1736 :       if (s <= FAST_BITS) {

	cmp	DWORD PTR _s$3[ebp], 9
	jg	SHORT $LN4@stbi__buil

; 1737 :          int c = h->code[i] << (FAST_BITS-s);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2+512]
	mov	ecx, 9
	sub	ecx, DWORD PTR _s$3[ebp]
	shl	edx, cl
	mov	DWORD PTR _c$2[ebp], edx

; 1738 :          int m = 1 << (FAST_BITS-s);

	mov	ecx, 9
	sub	ecx, DWORD PTR _s$3[ebp]
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _m$1[ebp], eax

; 1739 :          for (j=0; j < m; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN3@stbi__buil
$LN2@stbi__buil:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN3@stbi__buil:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _m$1[ebp]
	jge	SHORT $LN4@stbi__buil

; 1740 :             h->fast[c+j] = (stbi_uc) i;

	mov	eax, DWORD PTR _c$2[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	dl, BYTE PTR _i$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 1741 :          }

	jmp	SHORT $LN2@stbi__buil
$LN4@stbi__buil:

; 1742 :       }
; 1743 :    }

	jmp	$LN6@stbi__buil
$LN5@stbi__buil:

; 1744 :    return 1;

	mov	eax, 1
$LN21@stbi__buil:

; 1745 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__build_huffman ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__convert_format16
_TEXT	SEGMENT
tv95 = -256						; size = 4
tv82 = -256						; size = 4
_dest$1 = -56						; size = 4
_src$2 = -44						; size = 4
_good$ = -32						; size = 4
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_data$ = 8						; size = 4
_img_n$ = 12						; size = 4
_req_comp$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_stbi__convert_format16 PROC				; COMDAT

; 1521 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1522 :    int i,j;
; 1523 :    stbi__uint16 *good;
; 1524 : 
; 1525 :    if (req_comp == img_n) return data;

	mov	eax, DWORD PTR _req_comp$[ebp]
	cmp	eax, DWORD PTR _img_n$[ebp]
	jne	SHORT $LN56@stbi__conv
	mov	eax, DWORD PTR _data$[ebp]
	jmp	$LN57@stbi__conv
$LN56@stbi__conv:

; 1526 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

	cmp	DWORD PTR _req_comp$[ebp], 1
	jl	SHORT $LN59@stbi__conv
	cmp	DWORD PTR _req_comp$[ebp], 4
	jle	SHORT $LN60@stbi__conv
$LN59@stbi__conv:
	mov	eax, DWORD PTR ?__LINE__Var@?1??stbi__convert_format16@@9@9@e7b221e1
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA4?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN60@stbi__conv:

; 1527 : 
; 1528 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);

	mov	eax, DWORD PTR _req_comp$[ebp]
	imul	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _y$[ebp]
	shl	eax, 1
	push	eax
	call	_stbi__malloc
	add	esp, 4
	mov	DWORD PTR _good$[ebp], eax

; 1529 :    if (good == NULL) {

	cmp	DWORD PTR _good$[ebp], 0
	jne	SHORT $LN55@stbi__conv

; 1530 :       STBI_FREE(data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 1531 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN61@stbi__conv
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $LN62@stbi__conv
$LN61@stbi__conv:
	mov	DWORD PTR tv82[ebp], 0
$LN62@stbi__conv:
	mov	eax, DWORD PTR tv82[ebp]
	jmp	$LN57@stbi__conv
$LN55@stbi__conv:

; 1532 :    }
; 1533 : 
; 1534 :    for (j=0; j < (int) y; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN54@stbi__conv
$LN53@stbi__conv:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN54@stbi__conv:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _y$[ebp]
	jge	$LN52@stbi__conv

; 1535 :       stbi__uint16 *src  = data + j * x * img_n   ;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _img_n$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _src$2[ebp], edx

; 1536 :       stbi__uint16 *dest = good + j * x * req_comp;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _req_comp$[ebp]
	mov	ecx, DWORD PTR _good$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _dest$1[ebp], edx

; 1537 : 
; 1538 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1539 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1540 :       // convert source image with img_n components to one with req_comp components;
; 1541 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1542 :       switch (STBI__COMBO(img_n, req_comp)) {

	mov	eax, DWORD PTR _img_n$[ebp]
	mov	ecx, DWORD PTR _req_comp$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR tv95[ebp], edx
	mov	eax, DWORD PTR tv95[ebp]
	sub	eax, 10					; 0000000aH
	mov	DWORD PTR tv95[ebp], eax
	cmp	DWORD PTR tv95[ebp], 25			; 00000019H
	ja	$LN1@stbi__conv
	mov	ecx, DWORD PTR tv95[ebp]
	movzx	edx, BYTE PTR $LN64@stbi__conv[ecx]
	jmp	DWORD PTR $LN65@stbi__conv[edx*4]
$LN49@stbi__conv:

; 1543 :          STBI__CASE(1,2) { dest[0]=src[0], dest[1]=0xffff;                                     } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN48@stbi__conv
$LN47@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 2
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 4
	mov	DWORD PTR _dest$1[ebp], edx
$LN48@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN46@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [edx+eax], cx
	mov	edx, 2
	shl	edx, 0
	mov	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [ecx+edx], ax
	jmp	SHORT $LN47@stbi__conv
$LN46@stbi__conv:
	jmp	$LN50@stbi__conv
$LN45@stbi__conv:

; 1544 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN44@stbi__conv
$LN43@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 2
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 6
	mov	DWORD PTR _dest$1[ebp], edx
$LN44@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN42@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [eax+edx], cx
	mov	edx, 2
	shl	edx, 1
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dx, WORD PTR [esi+edx]
	mov	WORD PTR [ecx+eax], dx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [ecx+edx], ax
	jmp	SHORT $LN43@stbi__conv
$LN42@stbi__conv:
	jmp	$LN50@stbi__conv
$LN41@stbi__conv:

; 1545 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=0xffff;                     } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN40@stbi__conv
$LN39@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 2
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 8
	mov	DWORD PTR _dest$1[ebp], edx
$LN40@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN38@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [eax+edx], cx
	mov	edx, 2
	shl	edx, 1
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dx, WORD PTR [esi+edx]
	mov	WORD PTR [ecx+eax], dx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [ecx+edx], ax
	mov	ecx, 2
	imul	edx, ecx, 3
	mov	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [ecx+edx], ax
	jmp	$LN39@stbi__conv
$LN38@stbi__conv:
	jmp	$LN50@stbi__conv
$LN37@stbi__conv:

; 1546 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN36@stbi__conv
$LN35@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 4
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 2
	mov	DWORD PTR _dest$1[ebp], edx
$LN36@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN34@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [edx+eax], cx
	jmp	SHORT $LN35@stbi__conv
$LN34@stbi__conv:
	jmp	$LN50@stbi__conv
$LN33@stbi__conv:

; 1547 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN32@stbi__conv
$LN31@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 4
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 6
	mov	DWORD PTR _dest$1[ebp], edx
$LN32@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN30@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [eax+edx], cx
	mov	edx, 2
	shl	edx, 1
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dx, WORD PTR [esi+edx]
	mov	WORD PTR [ecx+eax], dx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [ecx+edx], ax
	jmp	SHORT $LN31@stbi__conv
$LN30@stbi__conv:
	jmp	$LN50@stbi__conv
$LN29@stbi__conv:

; 1548 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1];                     } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN28@stbi__conv
$LN27@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 4
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 8
	mov	DWORD PTR _dest$1[ebp], edx
$LN28@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN26@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [eax+edx], cx
	mov	edx, 2
	shl	edx, 1
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dx, WORD PTR [esi+edx]
	mov	WORD PTR [ecx+eax], dx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [ecx+edx], ax
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 2
	imul	eax, edx, 3
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [edx+eax], cx
	jmp	$LN27@stbi__conv
$LN26@stbi__conv:
	jmp	$LN50@stbi__conv
$LN25@stbi__conv:

; 1549 :          STBI__CASE(3,4) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=0xffff;        } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN24@stbi__conv
$LN23@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 6
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 8
	mov	DWORD PTR _dest$1[ebp], edx
$LN24@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN22@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [edx+eax], cx
	mov	edx, 2
	shl	edx, 0
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	dx, WORD PTR [esi+edx]
	mov	WORD PTR [ecx+eax], dx
	mov	eax, 2
	shl	eax, 1
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [edx+ecx], ax
	mov	ecx, 2
	imul	edx, ecx, 3
	mov	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [ecx+edx], ax
	jmp	$LN23@stbi__conv
$LN22@stbi__conv:
	jmp	$LN50@stbi__conv
$LN21@stbi__conv:

; 1550 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN20@stbi__conv
$LN19@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 6
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 2
	mov	DWORD PTR _dest$1[ebp], edx
$LN20@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN18@stbi__conv
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	push	eax
	call	_stbi__compute_y_16
	add	esp, 12					; 0000000cH
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [ecx+edx], ax
	jmp	SHORT $LN19@stbi__conv
$LN18@stbi__conv:
	jmp	$LN50@stbi__conv
$LN17@stbi__conv:

; 1551 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]), dest[1] = 0xffff; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN16@stbi__conv
$LN15@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 6
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 4
	mov	DWORD PTR _dest$1[ebp], edx
$LN16@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN14@stbi__conv
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	push	eax
	call	_stbi__compute_y_16
	add	esp, 12					; 0000000cH
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [ecx+edx], ax
	mov	edx, 2
	shl	edx, 0
	mov	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [ecx+edx], ax
	jmp	SHORT $LN15@stbi__conv
$LN14@stbi__conv:
	jmp	$LN50@stbi__conv
$LN13@stbi__conv:

; 1552 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN12@stbi__conv
$LN11@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 8
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 2
	mov	DWORD PTR _dest$1[ebp], edx
$LN12@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN10@stbi__conv
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	push	eax
	call	_stbi__compute_y_16
	add	esp, 12					; 0000000cH
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [ecx+edx], ax
	jmp	SHORT $LN11@stbi__conv
$LN10@stbi__conv:
	jmp	$LN50@stbi__conv
$LN9@stbi__conv:

; 1553 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]), dest[1] = src[3]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN8@stbi__conv
$LN7@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 8
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 4
	mov	DWORD PTR _dest$1[ebp], edx
$LN8@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN6@stbi__conv
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	push	eax
	call	_stbi__compute_y_16
	add	esp, 12					; 0000000cH
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [ecx+edx], ax
	mov	edx, 2
	imul	eax, edx, 3
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [edx+ecx], ax
	jmp	$LN7@stbi__conv
$LN6@stbi__conv:
	jmp	$LN50@stbi__conv
$LN5@stbi__conv:

; 1554 :          STBI__CASE(4,3) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2];                       } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@stbi__conv
$LN3@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 8
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 6
	mov	DWORD PTR _dest$1[ebp], edx
$LN4@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN2@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [edx+eax], cx
	mov	edx, 2
	shl	edx, 0
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	dx, WORD PTR [esi+edx]
	mov	WORD PTR [ecx+eax], dx
	mov	eax, 2
	shl	eax, 1
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [edx+ecx], ax
	jmp	SHORT $LN3@stbi__conv
$LN2@stbi__conv:
	jmp	SHORT $LN50@stbi__conv
$LN1@stbi__conv:

; 1555 :          default: STBI_ASSERT(0);

	xor	eax, eax
	jne	SHORT $LN50@stbi__conv
	mov	ecx, DWORD PTR ?__LINE__Var@?1??stbi__convert_format16@@9@9@e7b221e1
	add	ecx, 34					; 00000022H
	push	ecx
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN50@stbi__conv:

; 1556 :       }
; 1557 :       #undef STBI__CASE
; 1558 :    }

	jmp	$LN53@stbi__conv
$LN52@stbi__conv:

; 1559 : 
; 1560 :    STBI_FREE(data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 1561 :    return good;

	mov	eax, DWORD PTR _good$[ebp]
$LN57@stbi__conv:

; 1562 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@stbi__conv:
	DD	$LN49@stbi__conv
	DD	$LN45@stbi__conv
	DD	$LN41@stbi__conv
	DD	$LN37@stbi__conv
	DD	$LN33@stbi__conv
	DD	$LN29@stbi__conv
	DD	$LN21@stbi__conv
	DD	$LN17@stbi__conv
	DD	$LN25@stbi__conv
	DD	$LN13@stbi__conv
	DD	$LN9@stbi__conv
	DD	$LN5@stbi__conv
	DD	$LN1@stbi__conv
$LN64@stbi__conv:
	DB	0
	DB	1
	DB	2
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	3
	DB	12					; 0000000cH
	DB	4
	DB	5
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	6
	DB	7
	DB	12					; 0000000cH
	DB	8
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
_stbi__convert_format16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__compute_y_16
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_stbi__compute_y_16 PROC				; COMDAT

; 1516 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1517 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	eax, DWORD PTR _r$[ebp], 77
	imul	ecx, DWORD PTR _g$[ebp], 150
	add	eax, ecx
	imul	edx, DWORD PTR _b$[ebp], 29
	add	eax, edx
	sar	eax, 8

; 1518 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__compute_y_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__convert_format
_TEXT	SEGMENT
tv93 = -256						; size = 4
tv82 = -256						; size = 4
_dest$1 = -56						; size = 4
_src$2 = -44						; size = 4
_good$ = -32						; size = 4
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_data$ = 8						; size = 4
_img_n$ = 12						; size = 4
_req_comp$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_stbi__convert_format PROC				; COMDAT

; 1472 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1473 :    int i,j;
; 1474 :    unsigned char *good;
; 1475 : 
; 1476 :    if (req_comp == img_n) return data;

	mov	eax, DWORD PTR _req_comp$[ebp]
	cmp	eax, DWORD PTR _img_n$[ebp]
	jne	SHORT $LN56@stbi__conv
	mov	eax, DWORD PTR _data$[ebp]
	jmp	$LN57@stbi__conv
$LN56@stbi__conv:

; 1477 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

	cmp	DWORD PTR _req_comp$[ebp], 1
	jl	SHORT $LN59@stbi__conv
	cmp	DWORD PTR _req_comp$[ebp], 4
	jle	SHORT $LN60@stbi__conv
$LN59@stbi__conv:
	mov	eax, DWORD PTR ?__LINE__Var@?1??stbi__convert_format@@9@9@e7b221e1
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA4?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN60@stbi__conv:

; 1478 : 
; 1479 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);

	push	0
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _req_comp$[ebp]
	push	edx
	call	_stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	DWORD PTR _good$[ebp], eax

; 1480 :    if (good == NULL) {

	cmp	DWORD PTR _good$[ebp], 0
	jne	SHORT $LN55@stbi__conv

; 1481 :       STBI_FREE(data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 1482 :       return stbi__errpuc("outofmem", "Out of memory");

	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN61@stbi__conv
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $LN62@stbi__conv
$LN61@stbi__conv:
	mov	DWORD PTR tv82[ebp], 0
$LN62@stbi__conv:
	mov	eax, DWORD PTR tv82[ebp]
	jmp	$LN57@stbi__conv
$LN55@stbi__conv:

; 1483 :    }
; 1484 : 
; 1485 :    for (j=0; j < (int) y; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN54@stbi__conv
$LN53@stbi__conv:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN54@stbi__conv:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _y$[ebp]
	jge	$LN52@stbi__conv

; 1486 :       unsigned char *src  = data + j * x * img_n   ;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _img_n$[ebp]
	add	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _src$2[ebp], eax

; 1487 :       unsigned char *dest = good + j * x * req_comp;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _req_comp$[ebp]
	add	eax, DWORD PTR _good$[ebp]
	mov	DWORD PTR _dest$1[ebp], eax

; 1488 : 
; 1489 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1490 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1491 :       // convert source image with img_n components to one with req_comp components;
; 1492 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1493 :       switch (STBI__COMBO(img_n, req_comp)) {

	mov	eax, DWORD PTR _img_n$[ebp]
	mov	ecx, DWORD PTR _req_comp$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR tv93[ebp], edx
	mov	eax, DWORD PTR tv93[ebp]
	sub	eax, 10					; 0000000aH
	mov	DWORD PTR tv93[ebp], eax
	cmp	DWORD PTR tv93[ebp], 25			; 00000019H
	ja	$LN1@stbi__conv
	mov	ecx, DWORD PTR tv93[ebp]
	movzx	edx, BYTE PTR $LN64@stbi__conv[ecx]
	jmp	DWORD PTR $LN65@stbi__conv[edx*4]
$LN49@stbi__conv:

; 1494 :          STBI__CASE(1,2) { dest[0]=src[0], dest[1]=255;                                     } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN48@stbi__conv
$LN47@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 2
	mov	DWORD PTR _dest$1[ebp], edx
$LN48@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN46@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [eax+edx], 255			; 000000ffH
	jmp	SHORT $LN47@stbi__conv
$LN46@stbi__conv:
	jmp	$LN50@stbi__conv
$LN45@stbi__conv:

; 1495 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN44@stbi__conv
$LN43@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 3
	mov	DWORD PTR _dest$1[ebp], edx
$LN44@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN42@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, 1
	shl	edx, 1
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al
	jmp	SHORT $LN43@stbi__conv
$LN42@stbi__conv:
	jmp	$LN50@stbi__conv
$LN41@stbi__conv:

; 1496 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=255;                     } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN40@stbi__conv
$LN39@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 4
	mov	DWORD PTR _dest$1[ebp], edx
$LN40@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN38@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, 1
	shl	edx, 1
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [eax+edx], 255			; 000000ffH
	jmp	$LN39@stbi__conv
$LN38@stbi__conv:
	jmp	$LN50@stbi__conv
$LN37@stbi__conv:

; 1497 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN36@stbi__conv
$LN35@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 2
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 1
	mov	DWORD PTR _dest$1[ebp], edx
$LN36@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN34@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl
	jmp	SHORT $LN35@stbi__conv
$LN34@stbi__conv:
	jmp	$LN50@stbi__conv
$LN33@stbi__conv:

; 1498 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN32@stbi__conv
$LN31@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 2
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 3
	mov	DWORD PTR _dest$1[ebp], edx
$LN32@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN30@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, 1
	shl	edx, 1
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al
	jmp	SHORT $LN31@stbi__conv
$LN30@stbi__conv:
	jmp	$LN50@stbi__conv
$LN29@stbi__conv:

; 1499 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1];                  } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN28@stbi__conv
$LN27@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 2
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 4
	mov	DWORD PTR _dest$1[ebp], edx
$LN28@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN26@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, 1
	shl	edx, 1
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl
	jmp	$LN27@stbi__conv
$LN26@stbi__conv:
	jmp	$LN50@stbi__conv
$LN25@stbi__conv:

; 1500 :          STBI__CASE(3,4) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=255;        } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN24@stbi__conv
$LN23@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 3
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 4
	mov	DWORD PTR _dest$1[ebp], edx
$LN24@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN22@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl
	mov	edx, 1
	shl	edx, 0
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [eax+edx], 255			; 000000ffH
	jmp	$LN23@stbi__conv
$LN22@stbi__conv:
	jmp	$LN50@stbi__conv
$LN21@stbi__conv:

; 1501 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN20@stbi__conv
$LN19@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 3
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 1
	mov	DWORD PTR _dest$1[ebp], edx
$LN20@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN18@stbi__conv
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	_stbi__compute_y
	add	esp, 12					; 0000000cH
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [ecx+edx], al
	jmp	SHORT $LN19@stbi__conv
$LN18@stbi__conv:
	jmp	$LN50@stbi__conv
$LN17@stbi__conv:

; 1502 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = 255;    } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN16@stbi__conv
$LN15@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 3
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 2
	mov	DWORD PTR _dest$1[ebp], edx
$LN16@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN14@stbi__conv
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	_stbi__compute_y
	add	esp, 12					; 0000000cH
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [eax+edx], 255			; 000000ffH
	jmp	SHORT $LN15@stbi__conv
$LN14@stbi__conv:
	jmp	$LN50@stbi__conv
$LN13@stbi__conv:

; 1503 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN12@stbi__conv
$LN11@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 4
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 1
	mov	DWORD PTR _dest$1[ebp], edx
$LN12@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN10@stbi__conv
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	_stbi__compute_y
	add	esp, 12					; 0000000cH
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [ecx+edx], al
	jmp	SHORT $LN11@stbi__conv
$LN10@stbi__conv:
	jmp	$LN50@stbi__conv
$LN9@stbi__conv:

; 1504 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = src[3]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN8@stbi__conv
$LN7@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 4
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 2
	mov	DWORD PTR _dest$1[ebp], edx
$LN8@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN6@stbi__conv
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	_stbi__compute_y
	add	esp, 12					; 0000000cH
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al
	jmp	$LN7@stbi__conv
$LN6@stbi__conv:
	jmp	$LN50@stbi__conv
$LN5@stbi__conv:

; 1505 :          STBI__CASE(4,3) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2];                    } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@stbi__conv
$LN3@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 4
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 3
	mov	DWORD PTR _dest$1[ebp], edx
$LN4@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN2@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl
	mov	edx, 1
	shl	edx, 0
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al
	jmp	SHORT $LN3@stbi__conv
$LN2@stbi__conv:
	jmp	SHORT $LN50@stbi__conv
$LN1@stbi__conv:

; 1506 :          default: STBI_ASSERT(0);

	xor	eax, eax
	jne	SHORT $LN50@stbi__conv
	mov	ecx, DWORD PTR ?__LINE__Var@?1??stbi__convert_format@@9@9@e7b221e1
	add	ecx, 34					; 00000022H
	push	ecx
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN50@stbi__conv:

; 1507 :       }
; 1508 :       #undef STBI__CASE
; 1509 :    }

	jmp	$LN53@stbi__conv
$LN52@stbi__conv:

; 1510 : 
; 1511 :    STBI_FREE(data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 1512 :    return good;

	mov	eax, DWORD PTR _good$[ebp]
$LN57@stbi__conv:

; 1513 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN65@stbi__conv:
	DD	$LN49@stbi__conv
	DD	$LN45@stbi__conv
	DD	$LN41@stbi__conv
	DD	$LN37@stbi__conv
	DD	$LN33@stbi__conv
	DD	$LN29@stbi__conv
	DD	$LN21@stbi__conv
	DD	$LN17@stbi__conv
	DD	$LN25@stbi__conv
	DD	$LN13@stbi__conv
	DD	$LN9@stbi__conv
	DD	$LN5@stbi__conv
	DD	$LN1@stbi__conv
$LN64@stbi__conv:
	DB	0
	DB	1
	DB	2
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	3
	DB	12					; 0000000cH
	DB	4
	DB	5
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	6
	DB	7
	DB	12					; 0000000cH
	DB	8
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
_stbi__convert_format ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__compute_y
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_stbi__compute_y PROC					; COMDAT

; 1467 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1468 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	eax, DWORD PTR _r$[ebp], 77
	imul	ecx, DWORD PTR _g$[ebp], 150
	add	eax, ecx
	imul	edx, DWORD PTR _b$[ebp], 29
	add	eax, edx
	sar	eax, 8

; 1469 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__compute_y ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__get32le
_TEXT	SEGMENT
_z$ = -8						; size = 4
_s$ = 8							; size = 4
_stbi__get32le PROC					; COMDAT

; 1446 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1447 :    stbi__uint32 z = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	mov	DWORD PTR _z$[ebp], eax

; 1448 :    return z + (stbi__get16le(s) << 16);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	shl	eax, 16					; 00000010H
	add	eax, DWORD PTR _z$[ebp]

; 1449 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__get32le ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__get16le
_TEXT	SEGMENT
_z$ = -8						; size = 4
_s$ = 8							; size = 4
_stbi__get16le PROC					; COMDAT

; 1438 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1439 :    int z = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _z$[ebp], ecx

; 1440 :    return z + (stbi__get8(s) << 8);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	eax, al
	shl	eax, 8
	add	eax, DWORD PTR _z$[ebp]

; 1441 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__get16le ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__get32be
_TEXT	SEGMENT
_z$ = -8						; size = 4
_s$ = 8							; size = 4
_stbi__get32be PROC					; COMDAT

; 1429 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1430 :    stbi__uint32 z = stbi__get16be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16be
	add	esp, 4
	mov	DWORD PTR _z$[ebp], eax

; 1431 :    return (z << 16) + stbi__get16be(s);

	mov	esi, DWORD PTR _z$[ebp]
	shl	esi, 16					; 00000010H
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16be
	add	esp, 4
	add	eax, esi

; 1432 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__get32be ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__get16be
_TEXT	SEGMENT
_z$ = -8						; size = 4
_s$ = 8							; size = 4
_stbi__get16be PROC					; COMDAT

; 1423 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1424 :    int z = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _z$[ebp], ecx

; 1425 :    return (z << 8) + stbi__get8(s);

	mov	esi, DWORD PTR _z$[ebp]
	shl	esi, 8
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	add	esi, ecx
	mov	eax, esi

; 1426 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__get16be ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__getn
_TEXT	SEGMENT
tv84 = -232						; size = 4
_count$1 = -32						; size = 4
_res$2 = -20						; size = 4
_blen$3 = -8						; size = 4
_s$ = 8							; size = 4
_buffer$ = 12						; size = 4
_n$ = 16						; size = 4
_stbi__getn PROC					; COMDAT

; 1399 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1400 :    if (s->io.read) {

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	$LN4@stbi__getn

; 1401 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax+172]
	sub	edx, DWORD PTR [ecx+168]
	mov	DWORD PTR _blen$3[ebp], edx

; 1402 :       if (blen < n) {

	mov	eax, DWORD PTR _blen$3[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	$LN4@stbi__getn

; 1403 :          int res, count;
; 1404 : 
; 1405 :          memcpy(buffer, s->img_buffer, blen);

	mov	eax, DWORD PTR _blen$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+168]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1406 : 
; 1407 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, DWORD PTR _blen$3[ebp]
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _blen$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _count$1[ebp], eax

; 1408 :          res = (count == (n-blen));

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, DWORD PTR _blen$3[ebp]
	cmp	DWORD PTR _count$1[ebp], eax
	jne	SHORT $LN7@stbi__getn
	mov	DWORD PTR tv84[ebp], 1
	jmp	SHORT $LN8@stbi__getn
$LN7@stbi__getn:
	mov	DWORD PTR tv84[ebp], 0
$LN8@stbi__getn:
	mov	ecx, DWORD PTR tv84[ebp]
	mov	DWORD PTR _res$2[ebp], ecx

; 1409 :          s->img_buffer = s->img_buffer_end;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+172]
	mov	DWORD PTR [eax+168], edx

; 1410 :          return res;

	mov	eax, DWORD PTR _res$2[ebp]
	jmp	SHORT $LN5@stbi__getn
$LN4@stbi__getn:

; 1411 :       }
; 1412 :    }
; 1413 : 
; 1414 :    if (s->img_buffer+n <= s->img_buffer_end) {

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	add	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	cmp	ecx, DWORD PTR [edx+172]
	ja	SHORT $LN2@stbi__getn

; 1415 :       memcpy(buffer, s->img_buffer, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+168]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1416 :       s->img_buffer += n;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	add	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+168], ecx

; 1417 :       return 1;

	mov	eax, 1
	jmp	SHORT $LN5@stbi__getn

; 1418 :    } else

	jmp	SHORT $LN5@stbi__getn
$LN2@stbi__getn:

; 1419 :       return 0;

	xor	eax, eax
$LN5@stbi__getn:

; 1420 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__getn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__skip
_TEXT	SEGMENT
_blen$1 = -8						; size = 4
_s$ = 8							; size = 4
_n$ = 12						; size = 4
_stbi__skip PROC					; COMDAT

; 1382 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1383 :    if (n < 0) {

	cmp	DWORD PTR _n$[ebp], 0
	jge	SHORT $LN3@stbi__skip

; 1384 :       s->img_buffer = s->img_buffer_end;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+172]
	mov	DWORD PTR [eax+168], edx

; 1385 :       return;

	jmp	SHORT $LN4@stbi__skip
$LN3@stbi__skip:

; 1386 :    }
; 1387 :    if (s->io.read) {

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN2@stbi__skip

; 1388 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax+172]
	sub	edx, DWORD PTR [ecx+168]
	mov	DWORD PTR _blen$1[ebp], edx

; 1389 :       if (blen < n) {

	mov	eax, DWORD PTR _blen$1[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	SHORT $LN2@stbi__skip

; 1390 :          s->img_buffer = s->img_buffer_end;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+172]
	mov	DWORD PTR [eax+168], edx

; 1391 :          (s->io.skip)(s->io_user_data, n - blen);

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, DWORD PTR _blen$1[ebp]
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1392 :          return;

	jmp	SHORT $LN4@stbi__skip
$LN2@stbi__skip:

; 1393 :       }
; 1394 :    }
; 1395 :    s->img_buffer += n;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	add	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+168], ecx
$LN4@stbi__skip:

; 1396 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__skip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__at_eof
_TEXT	SEGMENT
tv76 = -196						; size = 4
_s$ = 8							; size = 4
_stbi__at_eof PROC					; COMDAT

; 1370 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1371 :    if (s->io.read) {

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN3@stbi__at_e

; 1372 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	esi, esp
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN2@stbi__at_e
	xor	eax, eax
	jmp	SHORT $LN4@stbi__at_e
$LN2@stbi__at_e:

; 1373 :       // if feof() is true, check if buffer = end
; 1374 :       // special case: we've only got the special 0 character at the end
; 1375 :       if (s->read_from_callbacks == 0) return 1;

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN3@stbi__at_e
	mov	eax, 1
	jmp	SHORT $LN4@stbi__at_e
$LN3@stbi__at_e:

; 1376 :    }
; 1377 : 
; 1378 :    return s->img_buffer >= s->img_buffer_end;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax+168]
	cmp	edx, DWORD PTR [ecx+172]
	jb	SHORT $LN6@stbi__at_e
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN7@stbi__at_e
$LN6@stbi__at_e:
	mov	DWORD PTR tv76[ebp], 0
$LN7@stbi__at_e:
	mov	eax, DWORD PTR tv76[ebp]
$LN4@stbi__at_e:

; 1379 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__at_eof ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__get8
_TEXT	SEGMENT
tv81 = -193						; size = 1
tv72 = -193						; size = 1
_s$ = 8							; size = 4
_stbi__get8 PROC					; COMDAT

; 1359 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1360 :    if (s->img_buffer < s->img_buffer_end)

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax+168]
	cmp	edx, DWORD PTR [ecx+172]
	jae	SHORT $LN2@stbi__get8

; 1361 :       return *s->img_buffer++;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv72[ebp], dl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+168], ecx
	mov	al, BYTE PTR tv72[ebp]
	jmp	SHORT $LN3@stbi__get8
$LN2@stbi__get8:

; 1362 :    if (s->read_from_callbacks) {

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN1@stbi__get8

; 1363 :       stbi__refill_buffer(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__refill_buffer
	add	esp, 4

; 1364 :       return *s->img_buffer++;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv81[ebp], dl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+168], ecx
	mov	al, BYTE PTR tv81[ebp]
	jmp	SHORT $LN3@stbi__get8
$LN1@stbi__get8:

; 1365 :    }
; 1366 :    return 0;

	xor	al, al
$LN3@stbi__get8:

; 1367 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__get8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_hdr_to_ldr_scale
_TEXT	SEGMENT
_scale$ = 8						; size = 4
_stbi_hdr_to_ldr_scale PROC				; COMDAT

; 1327 : STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR _stbi__h2l_scale_i, xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_hdr_to_ldr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_hdr_to_ldr_gamma
_TEXT	SEGMENT
_gamma$ = 8						; size = 4
_stbi_hdr_to_ldr_gamma PROC				; COMDAT

; 1326 : STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _gamma$[ebp]
	movss	DWORD PTR _stbi__h2l_gamma_i, xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_hdr_to_ldr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__loadf_main
_TEXT	SEGMENT
tv81 = -208						; size = 4
tv73 = -208						; size = 4
_data$ = -8						; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi__loadf_main PROC					; COMDAT

; 1210 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1211 :    unsigned char *data;
; 1212 :    #ifndef STBI_NO_HDR
; 1213 :    if (stbi__hdr_test(s)) {
; 1214 :       stbi__result_info ri;
; 1215 :       float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
; 1216 :       if (hdr_data)
; 1217 :          stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
; 1218 :       return hdr_data;
; 1219 :    }
; 1220 :    #endif
; 1221 :    data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__load_and_postprocess_8bit
	add	esp, 20					; 00000014H
	mov	DWORD PTR _data$[ebp], eax

; 1222 :    if (data)

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN1@stbi__load

; 1223 :       return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN4@stbi__load
	mov	eax, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN5@stbi__load
$LN4@stbi__load:
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv73[ebp], edx
$LN5@stbi__load:
	mov	eax, DWORD PTR tv73[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	call	_stbi__ldr_to_hdr
	add	esp, 16					; 00000010H
	jmp	SHORT $LN2@stbi__load
$LN1@stbi__load:

; 1224 :    return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");

	push	OFFSET ??_C@_0BD@CBEDEJPH@unknown?5image?5type?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@stbi__load
	mov	DWORD PTR tv81[ebp], 0
	jmp	SHORT $LN7@stbi__load
$LN6@stbi__load:
	mov	DWORD PTR tv81[ebp], 0
$LN7@stbi__load:
	mov	eax, DWORD PTR tv81[ebp]
$LN2@stbi__load:

; 1225 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__loadf_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__fopen
_TEXT	SEGMENT
_f$ = -8						; size = 4
_filename$ = 8						; size = 4
_mode$ = 12						; size = 4
_stbi__fopen PROC					; COMDAT

; 1119 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1120 :    FILE *f;
; 1121 : #if defined(_MSC_VER) && _MSC_VER >= 1400
; 1122 :    if (0 != fopen_s(&f, filename, mode))

	mov	eax, DWORD PTR _mode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_fopen_s
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@stbi__fope

; 1123 :       f=0;

	mov	DWORD PTR _f$[ebp], 0
$LN1@stbi__fope:

; 1124 : #else
; 1125 :    f = fopen(filename, mode);
; 1126 : #endif
; 1127 :    return f;

	mov	eax, DWORD PTR _f$[ebp]

; 1128 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@stbi__fope
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@stbi__fope:
	DD	1
	DD	$LN5@stbi__fope
$LN5@stbi__fope:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN4@stbi__fope
$LN4@stbi__fope:
	DB	102					; 00000066H
	DB	0
_stbi__fopen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__load_and_postprocess_16bit
_TEXT	SEGMENT
tv89 = -244						; size = 4
tv82 = -244						; size = 4
_channels$1 = -44					; size = 4
_result$ = -32						; size = 4
_ri$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi__load_and_postprocess_16bit PROC			; COMDAT

; 1082 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1083 :    stbi__result_info ri;
; 1084 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

	push	16					; 00000010H
	lea	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__load_main
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _result$[ebp], eax

; 1085 : 
; 1086 :    if (result == NULL)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN3@stbi__load

; 1087 :       return NULL;

	xor	eax, eax
	jmp	$LN4@stbi__load
$LN3@stbi__load:

; 1088 : 
; 1089 :    if (ri.bits_per_channel != 16) {

	cmp	DWORD PTR _ri$[ebp], 16			; 00000010H
	je	SHORT $LN2@stbi__load

; 1090 :       STBI_ASSERT(ri.bits_per_channel == 8);

	cmp	DWORD PTR _ri$[ebp], 8
	je	SHORT $LN6@stbi__load
	mov	eax, DWORD PTR ?__LINE__Var@?1??stbi__load_and_postprocess_16bit@@9@9@e7b221e1
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1DC@NDPEGMEG@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA8?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@stbi__load:

; 1091 :       result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);

	cmp	DWORD PTR _req_comp$[ebp], 0
	jne	SHORT $LN7@stbi__load
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv82[ebp], ecx
	jmp	SHORT $LN8@stbi__load
$LN7@stbi__load:
	mov	edx, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR tv82[ebp], edx
$LN8@stbi__load:
	mov	eax, DWORD PTR tv82[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _result$[ebp]
	push	edx
	call	_stbi__convert_8_to_16
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], eax

; 1092 :       ri.bits_per_channel = 16;

	mov	DWORD PTR _ri$[ebp], 16			; 00000010H
$LN2@stbi__load:

; 1093 :    }
; 1094 : 
; 1095 :    // @TODO: move stbi__convert_format16 to here
; 1096 :    // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
; 1097 : 
; 1098 :    if (stbi__vertically_flip_on_load) {

	cmp	DWORD PTR _stbi__vertically_flip_on_load, 0
	je	SHORT $LN1@stbi__load

; 1099 :       int channels = req_comp ? req_comp : *comp;

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN9@stbi__load
	mov	eax, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN10@stbi__load
$LN9@stbi__load:
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv89[ebp], edx
$LN10@stbi__load:
	mov	eax, DWORD PTR tv89[ebp]
	mov	DWORD PTR _channels$1[ebp], eax

; 1100 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));

	mov	eax, DWORD PTR _channels$1[ebp]
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _result$[ebp]
	push	edx
	call	_stbi__vertical_flip
	add	esp, 16					; 00000010H
$LN1@stbi__load:

; 1101 :    }
; 1102 : 
; 1103 :    return (stbi__uint16 *) result;

	mov	eax, DWORD PTR _result$[ebp]
$LN4@stbi__load:

; 1104 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@stbi__load
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@stbi__load:
	DD	1
	DD	$LN12@stbi__load
$LN12@stbi__load:
	DD	-20					; ffffffecH
	DD	12					; 0000000cH
	DD	$LN11@stbi__load
$LN11@stbi__load:
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	0
_stbi__load_and_postprocess_16bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__load_and_postprocess_8bit
_TEXT	SEGMENT
tv89 = -244						; size = 4
tv82 = -244						; size = 4
_channels$1 = -44					; size = 4
_result$ = -32						; size = 4
_ri$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi__load_and_postprocess_8bit PROC			; COMDAT

; 1058 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1059 :    stbi__result_info ri;
; 1060 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

	push	8
	lea	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__load_main
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _result$[ebp], eax

; 1061 : 
; 1062 :    if (result == NULL)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN3@stbi__load

; 1063 :       return NULL;

	xor	eax, eax
	jmp	$LN4@stbi__load
$LN3@stbi__load:

; 1064 : 
; 1065 :    if (ri.bits_per_channel != 8) {

	cmp	DWORD PTR _ri$[ebp], 8
	je	SHORT $LN2@stbi__load

; 1066 :       STBI_ASSERT(ri.bits_per_channel == 16);

	cmp	DWORD PTR _ri$[ebp], 16			; 00000010H
	je	SHORT $LN6@stbi__load
	mov	eax, DWORD PTR ?__LINE__Var@?1??stbi__load_and_postprocess_8bit@@9@9@e7b221e1
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1DE@BAGIOALB@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA6?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@stbi__load:

; 1067 :       result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);

	cmp	DWORD PTR _req_comp$[ebp], 0
	jne	SHORT $LN7@stbi__load
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv82[ebp], ecx
	jmp	SHORT $LN8@stbi__load
$LN7@stbi__load:
	mov	edx, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR tv82[ebp], edx
$LN8@stbi__load:
	mov	eax, DWORD PTR tv82[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _result$[ebp]
	push	edx
	call	_stbi__convert_16_to_8
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], eax

; 1068 :       ri.bits_per_channel = 8;

	mov	DWORD PTR _ri$[ebp], 8
$LN2@stbi__load:

; 1069 :    }
; 1070 : 
; 1071 :    // @TODO: move stbi__convert_format to here
; 1072 : 
; 1073 :    if (stbi__vertically_flip_on_load) {

	cmp	DWORD PTR _stbi__vertically_flip_on_load, 0
	je	SHORT $LN1@stbi__load

; 1074 :       int channels = req_comp ? req_comp : *comp;

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN9@stbi__load
	mov	eax, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN10@stbi__load
$LN9@stbi__load:
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv89[ebp], edx
$LN10@stbi__load:
	mov	eax, DWORD PTR tv89[ebp]
	mov	DWORD PTR _channels$1[ebp], eax

; 1075 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));

	mov	eax, DWORD PTR _channels$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _result$[ebp]
	push	edx
	call	_stbi__vertical_flip
	add	esp, 16					; 00000010H
$LN1@stbi__load:

; 1076 :    }
; 1077 : 
; 1078 :    return (unsigned char *) result;

	mov	eax, DWORD PTR _result$[ebp]
$LN4@stbi__load:

; 1079 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@stbi__load
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN13@stbi__load:
	DD	1
	DD	$LN12@stbi__load
$LN12@stbi__load:
	DD	-20					; ffffffecH
	DD	12					; 0000000cH
	DD	$LN11@stbi__load
$LN11@stbi__load:
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	0
_stbi__load_and_postprocess_8bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__vertical_flip
_TEXT	SEGMENT
tv76 = -2340						; size = 4
_bytes_copy$1 = -2140					; size = 4
_bytes_left$2 = -2128					; size = 4
_row1$3 = -2116						; size = 4
_row0$4 = -2104						; size = 4
_bytes$ = -2092						; size = 4
_temp$ = -2080						; size = 2048
_bytes_per_row$ = -24					; size = 4
_row$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_image$ = 8						; size = 4
_w$ = 12						; size = 4
_h$ = 16						; size = 4
_bytes_per_pixel$ = 20					; size = 4
_stbi__vertical_flip PROC				; COMDAT

; 1034 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2340				; 00000924H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2340]
	mov	ecx, 585				; 00000249H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1035 :    int row;
; 1036 :    size_t bytes_per_row = (size_t)w * bytes_per_pixel;

	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, DWORD PTR _bytes_per_pixel$[ebp]
	mov	DWORD PTR _bytes_per_row$[ebp], eax

; 1037 :    stbi_uc temp[2048];
; 1038 :    stbi_uc *bytes = (stbi_uc *)image;

	mov	eax, DWORD PTR _image$[ebp]
	mov	DWORD PTR _bytes$[ebp], eax

; 1039 : 
; 1040 :    for (row = 0; row < (h>>1); row++) {

	mov	DWORD PTR _row$[ebp], 0
	jmp	SHORT $LN5@stbi__vert
$LN4@stbi__vert:
	mov	eax, DWORD PTR _row$[ebp]
	add	eax, 1
	mov	DWORD PTR _row$[ebp], eax
$LN5@stbi__vert:
	mov	eax, DWORD PTR _h$[ebp]
	sar	eax, 1
	cmp	DWORD PTR _row$[ebp], eax
	jge	$LN6@stbi__vert

; 1041 :       stbi_uc *row0 = bytes + row*bytes_per_row;

	mov	eax, DWORD PTR _row$[ebp]
	imul	eax, DWORD PTR _bytes_per_row$[ebp]
	add	eax, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _row0$4[ebp], eax

; 1042 :       stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;

	mov	eax, DWORD PTR _h$[ebp]
	sub	eax, DWORD PTR _row$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _bytes_per_row$[ebp]
	add	eax, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _row1$3[ebp], eax

; 1043 :       // swap row0 with row1
; 1044 :       size_t bytes_left = bytes_per_row;

	mov	eax, DWORD PTR _bytes_per_row$[ebp]
	mov	DWORD PTR _bytes_left$2[ebp], eax
$LN2@stbi__vert:

; 1045 :       while (bytes_left) {

	cmp	DWORD PTR _bytes_left$2[ebp], 0
	je	$LN1@stbi__vert

; 1046 :          size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);

	cmp	DWORD PTR _bytes_left$2[ebp], 2048	; 00000800H
	jae	SHORT $LN8@stbi__vert
	mov	eax, DWORD PTR _bytes_left$2[ebp]
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN9@stbi__vert
$LN8@stbi__vert:
	mov	DWORD PTR tv76[ebp], 2048		; 00000800H
$LN9@stbi__vert:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR _bytes_copy$1[ebp], ecx

; 1047 :          memcpy(temp, row0, bytes_copy);

	mov	eax, DWORD PTR _bytes_copy$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _row0$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1048 :          memcpy(row0, row1, bytes_copy);

	mov	eax, DWORD PTR _bytes_copy$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _row1$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _row0$4[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1049 :          memcpy(row1, temp, bytes_copy);

	mov	eax, DWORD PTR _bytes_copy$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _row1$3[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1050 :          row0 += bytes_copy;

	mov	eax, DWORD PTR _row0$4[ebp]
	add	eax, DWORD PTR _bytes_copy$1[ebp]
	mov	DWORD PTR _row0$4[ebp], eax

; 1051 :          row1 += bytes_copy;

	mov	eax, DWORD PTR _row1$3[ebp]
	add	eax, DWORD PTR _bytes_copy$1[ebp]
	mov	DWORD PTR _row1$3[ebp], eax

; 1052 :          bytes_left -= bytes_copy;

	mov	eax, DWORD PTR _bytes_left$2[ebp]
	sub	eax, DWORD PTR _bytes_copy$1[ebp]
	mov	DWORD PTR _bytes_left$2[ebp], eax

; 1053 :       }

	jmp	$LN2@stbi__vert
$LN1@stbi__vert:

; 1054 :    }

	jmp	$LN4@stbi__vert
$LN6@stbi__vert:

; 1055 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@stbi__vert
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 2340				; 00000924H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN12@stbi__vert:
	DD	1
	DD	$LN11@stbi__vert
$LN11@stbi__vert:
	DD	-2080					; fffff7e0H
	DD	2048					; 00000800H
	DD	$LN10@stbi__vert
$LN10@stbi__vert:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_stbi__vertical_flip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__convert_8_to_16
_TEXT	SEGMENT
tv73 = -232						; size = 4
_enlarged$ = -32					; size = 4
_img_len$ = -20						; size = 4
_i$ = -8						; size = 4
_orig$ = 8						; size = 4
_w$ = 12						; size = 4
_h$ = 16						; size = 4
_channels$ = 20						; size = 4
_stbi__convert_8_to_16 PROC				; COMDAT

; 1018 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1019 :    int i;
; 1020 :    int img_len = w * h * channels;

	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, DWORD PTR _h$[ebp]
	imul	eax, DWORD PTR _channels$[ebp]
	mov	DWORD PTR _img_len$[ebp], eax

; 1021 :    stbi__uint16 *enlarged;
; 1022 : 
; 1023 :    enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);

	mov	eax, DWORD PTR _img_len$[ebp]
	shl	eax, 1
	push	eax
	call	_stbi__malloc
	add	esp, 4
	mov	DWORD PTR _enlarged$[ebp], eax

; 1024 :    if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

	cmp	DWORD PTR _enlarged$[ebp], 0
	jne	SHORT $LN4@stbi__conv
	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@stbi__conv
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN8@stbi__conv
$LN7@stbi__conv:
	mov	DWORD PTR tv73[ebp], 0
$LN8@stbi__conv:
	mov	eax, DWORD PTR tv73[ebp]
	jmp	SHORT $LN5@stbi__conv
$LN4@stbi__conv:

; 1025 : 
; 1026 :    for (i = 0; i < img_len; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@stbi__conv
$LN2@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _img_len$[ebp]
	jge	SHORT $LN1@stbi__conv

; 1027 :       enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

	mov	eax, DWORD PTR _orig$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 8
	mov	edx, DWORD PTR _orig$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	add	ecx, eax
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _enlarged$[ebp]
	mov	WORD PTR [eax+edx*2], cx
	jmp	SHORT $LN2@stbi__conv
$LN1@stbi__conv:

; 1028 : 
; 1029 :    STBI_FREE(orig);

	mov	eax, DWORD PTR _orig$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 1030 :    return enlarged;

	mov	eax, DWORD PTR _enlarged$[ebp]
$LN5@stbi__conv:

; 1031 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__convert_8_to_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__convert_16_to_8
_TEXT	SEGMENT
tv72 = -232						; size = 4
_reduced$ = -32						; size = 4
_img_len$ = -20						; size = 4
_i$ = -8						; size = 4
_orig$ = 8						; size = 4
_w$ = 12						; size = 4
_h$ = 16						; size = 4
_channels$ = 20						; size = 4
_stbi__convert_16_to_8 PROC				; COMDAT

; 1002 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1003 :    int i;
; 1004 :    int img_len = w * h * channels;

	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, DWORD PTR _h$[ebp]
	imul	eax, DWORD PTR _channels$[ebp]
	mov	DWORD PTR _img_len$[ebp], eax

; 1005 :    stbi_uc *reduced;
; 1006 : 
; 1007 :    reduced = (stbi_uc *) stbi__malloc(img_len);

	mov	eax, DWORD PTR _img_len$[ebp]
	push	eax
	call	_stbi__malloc
	add	esp, 4
	mov	DWORD PTR _reduced$[ebp], eax

; 1008 :    if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

	cmp	DWORD PTR _reduced$[ebp], 0
	jne	SHORT $LN4@stbi__conv
	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@stbi__conv
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN8@stbi__conv
$LN7@stbi__conv:
	mov	DWORD PTR tv72[ebp], 0
$LN8@stbi__conv:
	mov	eax, DWORD PTR tv72[ebp]
	jmp	SHORT $LN5@stbi__conv
$LN4@stbi__conv:

; 1009 : 
; 1010 :    for (i = 0; i < img_len; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@stbi__conv
$LN2@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _img_len$[ebp]
	jge	SHORT $LN1@stbi__conv

; 1011 :       reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _orig$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	sar	edx, 8
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _reduced$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN2@stbi__conv
$LN1@stbi__conv:

; 1012 : 
; 1013 :    STBI_FREE(orig);

	mov	eax, DWORD PTR _orig$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 1014 :    return reduced;

	mov	eax, DWORD PTR _reduced$[ebp]
$LN5@stbi__conv:

; 1015 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__convert_16_to_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__load_main
_TEXT	SEGMENT
tv145 = -196						; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
_bpc$ = 32						; size = 4
_stbi__load_main PROC					; COMDAT

; 957  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 958  :    memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields

	push	12					; 0000000cH
	push	0
	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 959  :    ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed

	mov	eax, DWORD PTR _ri$[ebp]
	mov	DWORD PTR [eax], 8

; 960  :    ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order

	mov	eax, DWORD PTR _ri$[ebp]
	mov	DWORD PTR [eax+8], 0

; 961  :    ri->num_channels = 0;

	mov	eax, DWORD PTR _ri$[ebp]
	mov	DWORD PTR [eax+4], 0

; 962  : 
; 963  :    #ifndef STBI_NO_JPEG
; 964  :    if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__jpeg_test
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@stbi__load
	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__jpeg_load
	add	esp, 24					; 00000018H
	jmp	$LN5@stbi__load
$LN4@stbi__load:

; 965  :    #endif
; 966  :    #ifndef STBI_NO_PNG
; 967  :    if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__png_test
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@stbi__load
	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__png_load
	add	esp, 24					; 00000018H
	jmp	$LN5@stbi__load
$LN3@stbi__load:

; 968  :    #endif
; 969  :    #ifndef STBI_NO_BMP
; 970  :    if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__bmp_test
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@stbi__load
	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__bmp_load
	add	esp, 24					; 00000018H
	jmp	SHORT $LN5@stbi__load
$LN2@stbi__load:

; 971  :    #endif
; 972  :    #ifndef STBI_NO_GIF
; 973  :    if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
; 974  :    #endif
; 975  :    #ifndef STBI_NO_PSD
; 976  :    if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
; 977  :    #endif
; 978  :    #ifndef STBI_NO_PIC
; 979  :    if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
; 980  :    #endif
; 981  :    #ifndef STBI_NO_PNM
; 982  :    if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
; 983  :    #endif
; 984  : 
; 985  :    #ifndef STBI_NO_HDR
; 986  :    if (stbi__hdr_test(s)) {
; 987  :       float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
; 988  :       return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
; 989  :    }
; 990  :    #endif
; 991  : 
; 992  :    #ifndef STBI_NO_TGA
; 993  :    // test tga last because it's a crappy test!
; 994  :    if (stbi__tga_test(s))

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__tga_test
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@stbi__load

; 995  :       return stbi__tga_load(s,x,y,comp,req_comp, ri);

	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__tga_load
	add	esp, 24					; 00000018H
	jmp	SHORT $LN5@stbi__load
$LN1@stbi__load:

; 996  :    #endif
; 997  : 
; 998  :    return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");

	push	OFFSET ??_C@_0BD@CBEDEJPH@unknown?5image?5type?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@stbi__load
	mov	DWORD PTR tv145[ebp], 0
	jmp	SHORT $LN8@stbi__load
$LN7@stbi__load:
	mov	DWORD PTR tv145[ebp], 0
$LN8@stbi__load:
	mov	eax, DWORD PTR tv145[ebp]
$LN5@stbi__load:

; 999  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__load_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__ldr_to_hdr
_TEXT	SEGMENT
tv172 = -248						; size = 8
tv76 = -244						; size = 4
_output$ = -44						; size = 4
_n$ = -32						; size = 4
_k$ = -20						; size = 4
_i$ = -8						; size = 4
_data$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_stbi__ldr_to_hdr PROC					; COMDAT

; 1566 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1567 :    int i,k,n;
; 1568 :    float *output;
; 1569 :    if (!data) return NULL;

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN11@stbi__ldr_
	xor	eax, eax
	jmp	$LN12@stbi__ldr_
$LN11@stbi__ldr_:

; 1570 :    output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);

	push	0
	push	4
	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_stbi__malloc_mad4
	add	esp, 20					; 00000014H
	mov	DWORD PTR _output$[ebp], eax

; 1571 :    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN10@stbi__ldr_
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_free
	add	esp, 4
	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN14@stbi__ldr_
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN15@stbi__ldr_
$LN14@stbi__ldr_:
	mov	DWORD PTR tv76[ebp], 0
$LN15@stbi__ldr_:
	mov	eax, DWORD PTR tv76[ebp]
	jmp	$LN12@stbi__ldr_
$LN10@stbi__ldr_:

; 1572 :    // compute number of non-alpha components
; 1573 :    if (comp & 1) n = comp; else n = comp-1;

	mov	eax, DWORD PTR _comp$[ebp]
	and	eax, 1
	je	SHORT $LN9@stbi__ldr_
	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR _n$[ebp], eax
	jmp	SHORT $LN8@stbi__ldr_
$LN9@stbi__ldr_:
	mov	eax, DWORD PTR _comp$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN8@stbi__ldr_:

; 1574 :    for (i=0; i < x*y; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@stbi__ldr_
$LN6@stbi__ldr_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@stbi__ldr_:
	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _y$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN5@stbi__ldr_

; 1575 :       for (k=0; k < n; ++k) {

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN4@stbi__ldr_
$LN3@stbi__ldr_:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN4@stbi__ldr_:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	SHORT $LN2@stbi__ldr_

; 1576 :          output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);

	cvtss2sd xmm0, DWORD PTR _stbi__l2h_gamma
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _comp$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv172[ebp]
	movsd	xmm0, QWORD PTR tv172[ebp]
	cvtss2sd xmm1, DWORD PTR _stbi__l2h_scale
	mulsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _comp$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _output$[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0

; 1577 :       }

	jmp	$LN3@stbi__ldr_
$LN2@stbi__ldr_:

; 1578 :       if (k < comp) output[i*comp + k] = data[i*comp+k]/255.0f;

	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _comp$[ebp]
	jge	SHORT $LN1@stbi__ldr_
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _comp$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _comp$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _output$[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0
$LN1@stbi__ldr_:

; 1579 :    }

	jmp	$LN6@stbi__ldr_
$LN5@stbi__ldr_:

; 1580 :    STBI_FREE(data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 1581 :    return output;

	mov	eax, DWORD PTR _output$[ebp]
$LN12@stbi__ldr_:

; 1582 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__ldr_to_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__malloc_mad4
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_d$ = 20						; size = 4
_add$ = 24						; size = 4
_stbi__malloc_mad4 PROC					; COMDAT

; 916  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 917  :    if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;

	mov	eax, DWORD PTR _add$[ebp]
	push	eax
	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_stbi__mad4sizes_valid
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN1@stbi__mall
	xor	eax, eax
	jmp	SHORT $LN2@stbi__mall
$LN1@stbi__mall:

; 918  :    return stbi__malloc(a*b*c*d + add);

	mov	eax, DWORD PTR _a$[ebp]
	imul	eax, DWORD PTR _b$[ebp]
	imul	eax, DWORD PTR _c$[ebp]
	imul	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _add$[ebp]
	push	eax
	call	_stbi__malloc
	add	esp, 4
$LN2@stbi__mall:

; 919  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__malloc_mad4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__malloc_mad3
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_add$ = 20						; size = 4
_stbi__malloc_mad3 PROC					; COMDAT

; 910  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 911  :    if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;

	mov	eax, DWORD PTR _add$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _b$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__mad3sizes_valid
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@stbi__mall
	xor	eax, eax
	jmp	SHORT $LN2@stbi__mall
$LN1@stbi__mall:

; 912  :    return stbi__malloc(a*b*c + add);

	mov	eax, DWORD PTR _a$[ebp]
	imul	eax, DWORD PTR _b$[ebp]
	imul	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _add$[ebp]
	push	eax
	call	_stbi__malloc
	add	esp, 4
$LN2@stbi__mall:

; 913  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__malloc_mad3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__malloc_mad2
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_add$ = 16						; size = 4
_stbi__malloc_mad2 PROC					; COMDAT

; 904  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 905  :    if (!stbi__mad2sizes_valid(a, b, add)) return NULL;

	mov	eax, DWORD PTR _add$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	call	_stbi__mad2sizes_valid
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@stbi__mall
	xor	eax, eax
	jmp	SHORT $LN2@stbi__mall
$LN1@stbi__mall:

; 906  :    return stbi__malloc(a*b + add);

	mov	eax, DWORD PTR _a$[ebp]
	imul	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _add$[ebp]
	push	eax
	call	_stbi__malloc
	add	esp, 4
$LN2@stbi__mall:

; 907  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__malloc_mad2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__mad4sizes_valid
_TEXT	SEGMENT
tv86 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_d$ = 20						; size = 4
_add$ = 24						; size = 4
_stbi__mad4sizes_valid PROC				; COMDAT

; 897  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 898  :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
; 899  :       stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);

	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_stbi__mul2sizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad4
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	imul	eax, DWORD PTR _b$[ebp]
	push	eax
	call	_stbi__mul2sizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad4
	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	imul	edx, DWORD PTR _b$[ebp]
	imul	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_stbi__mul2sizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad4
	mov	eax, DWORD PTR _add$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	imul	ecx, DWORD PTR _b$[ebp]
	imul	ecx, DWORD PTR _c$[ebp]
	imul	ecx, DWORD PTR _d$[ebp]
	push	ecx
	call	_stbi__addsizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad4
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN4@stbi__mad4
$LN3@stbi__mad4:
	mov	DWORD PTR tv86[ebp], 0
$LN4@stbi__mad4:
	mov	eax, DWORD PTR tv86[ebp]

; 900  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__mad4sizes_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__mad3sizes_valid
_TEXT	SEGMENT
tv79 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_add$ = 20						; size = 4
_stbi__mad3sizes_valid PROC				; COMDAT

; 890  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 891  :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
; 892  :       stbi__addsizes_valid(a*b*c, add);

	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_stbi__mul2sizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad3
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	imul	eax, DWORD PTR _b$[ebp]
	push	eax
	call	_stbi__mul2sizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad3
	mov	ecx, DWORD PTR _add$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	imul	edx, DWORD PTR _b$[ebp]
	imul	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_stbi__addsizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad3
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN4@stbi__mad3
$LN3@stbi__mad3:
	mov	DWORD PTR tv79[ebp], 0
$LN4@stbi__mad3:
	mov	eax, DWORD PTR tv79[ebp]

; 893  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__mad3sizes_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__mad2sizes_valid
_TEXT	SEGMENT
tv73 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_add$ = 16						; size = 4
_stbi__mad2sizes_valid PROC				; COMDAT

; 884  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 885  :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_stbi__mul2sizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad2
	mov	edx, DWORD PTR _add$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	imul	eax, DWORD PTR _b$[ebp]
	push	eax
	call	_stbi__addsizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad2
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN4@stbi__mad2
$LN3@stbi__mad2:
	mov	DWORD PTR tv73[ebp], 0
$LN4@stbi__mad2:
	mov	eax, DWORD PTR tv73[ebp]

; 886  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__mad2sizes_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__mul2sizes_valid
_TEXT	SEGMENT
tv69 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_stbi__mul2sizes_valid PROC				; COMDAT

; 875  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 876  :    if (a < 0 || b < 0) return 0;

	cmp	DWORD PTR _a$[ebp], 0
	jl	SHORT $LN2@stbi__mul2
	cmp	DWORD PTR _b$[ebp], 0
	jge	SHORT $LN3@stbi__mul2
$LN2@stbi__mul2:
	xor	eax, eax
	jmp	SHORT $LN4@stbi__mul2
$LN3@stbi__mul2:

; 877  :    if (b == 0) return 1; // mul-by-0 is always safe

	cmp	DWORD PTR _b$[ebp], 0
	jne	SHORT $LN1@stbi__mul2
	mov	eax, 1
	jmp	SHORT $LN4@stbi__mul2
$LN1@stbi__mul2:

; 878  :    // portable way to check for no overflows in a*b
; 879  :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	DWORD PTR _b$[ebp]
	cmp	DWORD PTR _a$[ebp], eax
	jg	SHORT $LN6@stbi__mul2
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN7@stbi__mul2
$LN6@stbi__mul2:
	mov	DWORD PTR tv69[ebp], 0
$LN7@stbi__mul2:
	mov	eax, DWORD PTR tv69[ebp]
$LN4@stbi__mul2:

; 880  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__mul2sizes_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__addsizes_valid
_TEXT	SEGMENT
tv67 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_stbi__addsizes_valid PROC				; COMDAT

; 863  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 864  :    if (b < 0) return 0;

	cmp	DWORD PTR _b$[ebp], 0
	jge	SHORT $LN1@stbi__adds
	xor	eax, eax
	jmp	SHORT $LN2@stbi__adds
$LN1@stbi__adds:

; 865  :    // now 0 <= b <= INT_MAX, hence also
; 866  :    // 0 <= INT_MAX - b <= INTMAX.
; 867  :    // And "a + b <= INT_MAX" (which might overflow) is the
; 868  :    // same as a <= INT_MAX - b (no overflow)
; 869  :    return a <= INT_MAX - b;

	mov	eax, 2147483647				; 7fffffffH
	sub	eax, DWORD PTR _b$[ebp]
	cmp	DWORD PTR _a$[ebp], eax
	jg	SHORT $LN4@stbi__adds
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN5@stbi__adds
$LN4@stbi__adds:
	mov	DWORD PTR tv67[ebp], 0
$LN5@stbi__adds:
	mov	eax, DWORD PTR tv67[ebp]
$LN2@stbi__adds:

; 870  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__addsizes_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__malloc
_TEXT	SEGMENT
_size$ = 8						; size = 4
_stbi__malloc PROC					; COMDAT

; 846  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 847  :     return STBI_MALLOC(size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	_malloc
	add	esp, 4

; 848  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__err
_TEXT	SEGMENT
_str$ = 8						; size = 4
_stbi__err PROC						; COMDAT

; 840  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 841  :    stbi__g_failure_reason = str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR _stbi__g_failure_reason, eax

; 842  :    return 0;

	xor	eax, eax

; 843  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__err ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__tga_info
_TEXT	SEGMENT
tv153 = -292						; size = 4
_tga_colormap_type$ = -92				; size = 4
_sz$ = -80						; size = 4
_tga_colormap_bpp$ = -68				; size = 4
_tga_bits_per_pixel$ = -56				; size = 4
_tga_image_type$ = -44					; size = 4
_tga_comp$ = -32					; size = 4
_tga_h$ = -20						; size = 4
_tga_w$ = -8						; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_stbi__tga_info PROC					; COMDAT

; 5253 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 73					; 00000049H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5254 :     int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
; 5255 :     int sz, tga_colormap_type;
; 5256 :     stbi__get8(s);                   // discard Offset

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4

; 5257 :     tga_colormap_type = stbi__get8(s); // colormap type

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_colormap_type$[ebp], ecx

; 5258 :     if( tga_colormap_type > 1 ) {

	cmp	DWORD PTR _tga_colormap_type$[ebp], 1
	jle	SHORT $LN15@stbi__tga_

; 5259 :         stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__rewind
	add	esp, 4

; 5260 :         return 0;      // only RGB or indexed allowed

	xor	eax, eax
	jmp	$LN16@stbi__tga_
$LN15@stbi__tga_:

; 5261 :     }
; 5262 :     tga_image_type = stbi__get8(s); // image type

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_image_type$[ebp], ecx

; 5263 :     if ( tga_colormap_type == 1 ) { // colormapped (paletted) image

	cmp	DWORD PTR _tga_colormap_type$[ebp], 1
	jne	$LN14@stbi__tga_

; 5264 :         if (tga_image_type != 1 && tga_image_type != 9) {

	cmp	DWORD PTR _tga_image_type$[ebp], 1
	je	SHORT $LN13@stbi__tga_
	cmp	DWORD PTR _tga_image_type$[ebp], 9
	je	SHORT $LN13@stbi__tga_

; 5265 :             stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__rewind
	add	esp, 4

; 5266 :             return 0;

	xor	eax, eax
	jmp	$LN16@stbi__tga_
$LN13@stbi__tga_:

; 5267 :         }
; 5268 :         stbi__skip(s,4);       // skip index of first colormap entry and number of entries

	push	4
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__skip
	add	esp, 8

; 5269 :         sz = stbi__get8(s);    //   check bits per palette color entry

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _sz$[ebp], ecx

; 5270 :         if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {

	cmp	DWORD PTR _sz$[ebp], 8
	je	SHORT $LN12@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 15			; 0000000fH
	je	SHORT $LN12@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 16			; 00000010H
	je	SHORT $LN12@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 24			; 00000018H
	je	SHORT $LN12@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 32			; 00000020H
	je	SHORT $LN12@stbi__tga_

; 5271 :             stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__rewind
	add	esp, 4

; 5272 :             return 0;

	xor	eax, eax
	jmp	$LN16@stbi__tga_
$LN12@stbi__tga_:

; 5273 :         }
; 5274 :         stbi__skip(s,4);       // skip image x and y origin

	push	4
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__skip
	add	esp, 8

; 5275 :         tga_colormap_bpp = sz;

	mov	eax, DWORD PTR _sz$[ebp]
	mov	DWORD PTR _tga_colormap_bpp$[ebp], eax

; 5276 :     } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE

	jmp	SHORT $LN11@stbi__tga_
$LN14@stbi__tga_:

; 5277 :         if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {

	cmp	DWORD PTR _tga_image_type$[ebp], 2
	je	SHORT $LN10@stbi__tga_
	cmp	DWORD PTR _tga_image_type$[ebp], 3
	je	SHORT $LN10@stbi__tga_
	cmp	DWORD PTR _tga_image_type$[ebp], 10	; 0000000aH
	je	SHORT $LN10@stbi__tga_
	cmp	DWORD PTR _tga_image_type$[ebp], 11	; 0000000bH
	je	SHORT $LN10@stbi__tga_

; 5278 :             stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__rewind
	add	esp, 4

; 5279 :             return 0; // only RGB or grey allowed, +/- RLE

	xor	eax, eax
	jmp	$LN16@stbi__tga_
$LN10@stbi__tga_:

; 5280 :         }
; 5281 :         stbi__skip(s,9); // skip colormap specification and image x/y origin

	push	9
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__skip
	add	esp, 8

; 5282 :         tga_colormap_bpp = 0;

	mov	DWORD PTR _tga_colormap_bpp$[ebp], 0
$LN11@stbi__tga_:

; 5283 :     }
; 5284 :     tga_w = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_w$[ebp], eax

; 5285 :     if( tga_w < 1 ) {

	cmp	DWORD PTR _tga_w$[ebp], 1
	jge	SHORT $LN9@stbi__tga_

; 5286 :         stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__rewind
	add	esp, 4

; 5287 :         return 0;   // test width

	xor	eax, eax
	jmp	$LN16@stbi__tga_
$LN9@stbi__tga_:

; 5288 :     }
; 5289 :     tga_h = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_h$[ebp], eax

; 5290 :     if( tga_h < 1 ) {

	cmp	DWORD PTR _tga_h$[ebp], 1
	jge	SHORT $LN8@stbi__tga_

; 5291 :         stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__rewind
	add	esp, 4

; 5292 :         return 0;   // test height

	xor	eax, eax
	jmp	$LN16@stbi__tga_
$LN8@stbi__tga_:

; 5293 :     }
; 5294 :     tga_bits_per_pixel = stbi__get8(s); // bits per pixel

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_bits_per_pixel$[ebp], ecx

; 5295 :     stbi__get8(s); // ignore alpha bits

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4

; 5296 :     if (tga_colormap_bpp != 0) {

	cmp	DWORD PTR _tga_colormap_bpp$[ebp], 0
	je	SHORT $LN7@stbi__tga_

; 5297 :         if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {

	cmp	DWORD PTR _tga_bits_per_pixel$[ebp], 8
	je	SHORT $LN6@stbi__tga_
	cmp	DWORD PTR _tga_bits_per_pixel$[ebp], 16	; 00000010H
	je	SHORT $LN6@stbi__tga_

; 5298 :             // when using a colormap, tga_bits_per_pixel is the size of the indexes
; 5299 :             // I don't think anything but 8 or 16bit indexes makes sense
; 5300 :             stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__rewind
	add	esp, 4

; 5301 :             return 0;

	xor	eax, eax
	jmp	$LN16@stbi__tga_
$LN6@stbi__tga_:

; 5302 :         }
; 5303 :         tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);

	push	0
	push	0
	mov	eax, DWORD PTR _tga_colormap_bpp$[ebp]
	push	eax
	call	_stbi__tga_get_comp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tga_comp$[ebp], eax

; 5304 :     } else {

	jmp	SHORT $LN5@stbi__tga_
$LN7@stbi__tga_:

; 5305 :         tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);

	cmp	DWORD PTR _tga_image_type$[ebp], 3
	je	SHORT $LN18@stbi__tga_
	cmp	DWORD PTR _tga_image_type$[ebp], 11	; 0000000bH
	je	SHORT $LN18@stbi__tga_
	mov	DWORD PTR tv153[ebp], 0
	jmp	SHORT $LN19@stbi__tga_
$LN18@stbi__tga_:
	mov	DWORD PTR tv153[ebp], 1
$LN19@stbi__tga_:
	push	0
	mov	eax, DWORD PTR tv153[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_bits_per_pixel$[ebp]
	push	ecx
	call	_stbi__tga_get_comp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tga_comp$[ebp], eax
$LN5@stbi__tga_:

; 5306 :     }
; 5307 :     if(!tga_comp) {

	cmp	DWORD PTR _tga_comp$[ebp], 0
	jne	SHORT $LN4@stbi__tga_

; 5308 :       stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__rewind
	add	esp, 4

; 5309 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN16@stbi__tga_
$LN4@stbi__tga_:

; 5310 :     }
; 5311 :     if (x) *x = tga_w;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@stbi__tga_
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _tga_w$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@stbi__tga_:

; 5312 :     if (y) *y = tga_h;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN2@stbi__tga_
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _tga_h$[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@stbi__tga_:

; 5313 :     if (comp) *comp = tga_comp;

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN1@stbi__tga_
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@stbi__tga_:

; 5314 :     return 1;                   // seems to have passed everything

	mov	eax, 1
$LN16@stbi__tga_:

; 5315 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__tga_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__tga_load
_TEXT	SEGMENT
tv278 = -592						; size = 4
tv257 = -592						; size = 4
tv233 = -592						; size = 4
tv181 = -592						; size = 4
tv170 = -592						; size = 4
tv160 = -592						; size = 4
tv149 = -592						; size = 4
tv142 = -592						; size = 4
_temp$1 = -389						; size = 1
_tga_pixel$2 = -380					; size = 4
_temp$3 = -365						; size = 1
_index2$4 = -356					; size = 4
_index1$5 = -344					; size = 4
_pal_idx$6 = -332					; size = 4
_RLE_cmd$7 = -320					; size = 4
_pal_entry$8 = -308					; size = 4
_tga_row$9 = -296					; size = 4
_row$10 = -284						; size = 4
_read_next_pixel$ = -272				; size = 4
_RLE_repeating$ = -260					; size = 4
_RLE_count$ = -248					; size = 4
_raw_data$ = -236					; size = 4
_j$ = -224						; size = 4
_i$ = -212						; size = 4
_tga_palette$ = -200					; size = 4
_tga_data$ = -188					; size = 4
_tga_inverted$ = -176					; size = 4
_tga_rgb16$ = -164					; size = 4
_tga_comp$ = -152					; size = 4
_tga_bits_per_pixel$ = -140				; size = 4
_tga_height$ = -128					; size = 4
_tga_width$ = -116					; size = 4
_tga_y_origin$ = -104					; size = 4
_tga_x_origin$ = -92					; size = 4
_tga_palette_bits$ = -80				; size = 4
_tga_palette_len$ = -68					; size = 4
_tga_palette_start$ = -56				; size = 4
_tga_is_RLE$ = -44					; size = 4
_tga_image_type$ = -32					; size = 4
_tga_indexed$ = -20					; size = 4
_tga_offset$ = -8					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
_stbi__tga_load PROC					; COMDAT

; 5369 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 592				; 00000250H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-592]
	mov	ecx, 148				; 00000094H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5370 :    //   read in the TGA header stuff
; 5371 :    int tga_offset = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_offset$[ebp], ecx

; 5372 :    int tga_indexed = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_indexed$[ebp], ecx

; 5373 :    int tga_image_type = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_image_type$[ebp], ecx

; 5374 :    int tga_is_RLE = 0;

	mov	DWORD PTR _tga_is_RLE$[ebp], 0

; 5375 :    int tga_palette_start = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_palette_start$[ebp], eax

; 5376 :    int tga_palette_len = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_palette_len$[ebp], eax

; 5377 :    int tga_palette_bits = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_palette_bits$[ebp], ecx

; 5378 :    int tga_x_origin = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_x_origin$[ebp], eax

; 5379 :    int tga_y_origin = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_y_origin$[ebp], eax

; 5380 :    int tga_width = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_width$[ebp], eax

; 5381 :    int tga_height = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_height$[ebp], eax

; 5382 :    int tga_bits_per_pixel = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_bits_per_pixel$[ebp], ecx

; 5383 :    int tga_comp, tga_rgb16=0;

	mov	DWORD PTR _tga_rgb16$[ebp], 0

; 5384 :    int tga_inverted = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_inverted$[ebp], ecx

; 5385 :    // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
; 5386 :    //   image data
; 5387 :    unsigned char *tga_data;
; 5388 :    unsigned char *tga_palette = NULL;

	mov	DWORD PTR _tga_palette$[ebp], 0

; 5389 :    int i, j;
; 5390 :    unsigned char raw_data[4] = {0};

	mov	BYTE PTR _raw_data$[ebp], 0
	xor	eax, eax
	mov	WORD PTR _raw_data$[ebp+1], ax
	mov	BYTE PTR _raw_data$[ebp+3], al

; 5391 :    int RLE_count = 0;

	mov	DWORD PTR _RLE_count$[ebp], 0

; 5392 :    int RLE_repeating = 0;

	mov	DWORD PTR _RLE_repeating$[ebp], 0

; 5393 :    int read_next_pixel = 1;

	mov	DWORD PTR _read_next_pixel$[ebp], 1

; 5394 :    STBI_NOTUSED(ri);
; 5395 : 
; 5396 :    //   do a tiny bit of precessing
; 5397 :    if ( tga_image_type >= 8 )

	cmp	DWORD PTR _tga_image_type$[ebp], 8
	jl	SHORT $LN56@stbi__tga_

; 5398 :    {
; 5399 :       tga_image_type -= 8;

	mov	eax, DWORD PTR _tga_image_type$[ebp]
	sub	eax, 8
	mov	DWORD PTR _tga_image_type$[ebp], eax

; 5400 :       tga_is_RLE = 1;

	mov	DWORD PTR _tga_is_RLE$[ebp], 1
$LN56@stbi__tga_:

; 5401 :    }
; 5402 :    tga_inverted = 1 - ((tga_inverted >> 5) & 1);

	mov	eax, DWORD PTR _tga_inverted$[ebp]
	sar	eax, 5
	and	eax, 1
	mov	ecx, 1
	sub	ecx, eax
	mov	DWORD PTR _tga_inverted$[ebp], ecx

; 5403 : 
; 5404 :    //   If I'm paletted, then I'll use the number of bits from the palette
; 5405 :    if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);

	cmp	DWORD PTR _tga_indexed$[ebp], 0
	je	SHORT $LN55@stbi__tga_
	lea	eax, DWORD PTR _tga_rgb16$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _tga_palette_bits$[ebp]
	push	ecx
	call	_stbi__tga_get_comp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tga_comp$[ebp], eax
	jmp	SHORT $LN54@stbi__tga_
$LN55@stbi__tga_:

; 5406 :    else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

	cmp	DWORD PTR _tga_image_type$[ebp], 3
	jne	SHORT $LN59@stbi__tga_
	mov	DWORD PTR tv142[ebp], 1
	jmp	SHORT $LN60@stbi__tga_
$LN59@stbi__tga_:
	mov	DWORD PTR tv142[ebp], 0
$LN60@stbi__tga_:
	lea	eax, DWORD PTR _tga_rgb16$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv142[ebp]
	push	ecx
	mov	edx, DWORD PTR _tga_bits_per_pixel$[ebp]
	push	edx
	call	_stbi__tga_get_comp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tga_comp$[ebp], eax
$LN54@stbi__tga_:

; 5407 : 
; 5408 :    if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency

	cmp	DWORD PTR _tga_comp$[ebp], 0
	jne	SHORT $LN53@stbi__tga_

; 5409 :       return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

	push	OFFSET ??_C@_0L@DMAPJJO@bad?5format?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN61@stbi__tga_
	mov	DWORD PTR tv149[ebp], 0
	jmp	SHORT $LN62@stbi__tga_
$LN61@stbi__tga_:
	mov	DWORD PTR tv149[ebp], 0
$LN62@stbi__tga_:
	mov	eax, DWORD PTR tv149[ebp]
	jmp	$LN57@stbi__tga_
$LN53@stbi__tga_:

; 5410 : 
; 5411 :    //   tga info
; 5412 :    *x = tga_width;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _tga_width$[ebp]
	mov	DWORD PTR [eax], ecx

; 5413 :    *y = tga_height;

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _tga_height$[ebp]
	mov	DWORD PTR [eax], ecx

; 5414 :    if (comp) *comp = tga_comp;

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN52@stbi__tga_
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR [eax], ecx
$LN52@stbi__tga_:

; 5415 : 
; 5416 :    if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))

	push	0
	mov	eax, DWORD PTR _tga_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tga_width$[ebp]
	push	edx
	call	_stbi__mad3sizes_valid
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN51@stbi__tga_

; 5417 :       return stbi__errpuc("too large", "Corrupt TGA");

	push	OFFSET ??_C@_09OJDLMMBJ@too?5large?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN63@stbi__tga_
	mov	DWORD PTR tv160[ebp], 0
	jmp	SHORT $LN64@stbi__tga_
$LN63@stbi__tga_:
	mov	DWORD PTR tv160[ebp], 0
$LN64@stbi__tga_:
	mov	eax, DWORD PTR tv160[ebp]
	jmp	$LN57@stbi__tga_
$LN51@stbi__tga_:

; 5418 : 
; 5419 :    tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);

	push	0
	mov	eax, DWORD PTR _tga_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tga_width$[ebp]
	push	edx
	call	_stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tga_data$[ebp], eax

; 5420 :    if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

	cmp	DWORD PTR _tga_data$[ebp], 0
	jne	SHORT $LN50@stbi__tga_
	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN65@stbi__tga_
	mov	DWORD PTR tv170[ebp], 0
	jmp	SHORT $LN66@stbi__tga_
$LN65@stbi__tga_:
	mov	DWORD PTR tv170[ebp], 0
$LN66@stbi__tga_:
	mov	eax, DWORD PTR tv170[ebp]
	jmp	$LN57@stbi__tga_
$LN50@stbi__tga_:

; 5421 : 
; 5422 :    // skip to the data's starting position (offset usually = 0)
; 5423 :    stbi__skip(s, tga_offset );

	mov	eax, DWORD PTR _tga_offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__skip
	add	esp, 8

; 5424 : 
; 5425 :    if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {

	cmp	DWORD PTR _tga_indexed$[ebp], 0
	jne	$LN49@stbi__tga_
	cmp	DWORD PTR _tga_is_RLE$[ebp], 0
	jne	$LN49@stbi__tga_
	cmp	DWORD PTR _tga_rgb16$[ebp], 0
	jne	$LN49@stbi__tga_

; 5426 :       for (i=0; i < tga_height; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN48@stbi__tga_
$LN47@stbi__tga_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN48@stbi__tga_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _tga_height$[ebp]
	jge	SHORT $LN46@stbi__tga_

; 5427 :          int row = tga_inverted ? tga_height -i - 1 : i;

	cmp	DWORD PTR _tga_inverted$[ebp], 0
	je	SHORT $LN67@stbi__tga_
	mov	eax, DWORD PTR _tga_height$[ebp]
	sub	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv181[ebp], eax
	jmp	SHORT $LN68@stbi__tga_
$LN67@stbi__tga_:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv181[ebp], ecx
$LN68@stbi__tga_:
	mov	edx, DWORD PTR tv181[ebp]
	mov	DWORD PTR _row$10[ebp], edx

; 5428 :          stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;

	mov	eax, DWORD PTR _row$10[ebp]
	imul	eax, DWORD PTR _tga_width$[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	add	eax, DWORD PTR _tga_data$[ebp]
	mov	DWORD PTR _tga_row$9[ebp], eax

; 5429 :          stbi__getn(s, tga_row, tga_width * tga_comp);

	mov	eax, DWORD PTR _tga_width$[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_row$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__getn
	add	esp, 12					; 0000000cH

; 5430 :       }

	jmp	$LN47@stbi__tga_
$LN46@stbi__tga_:

; 5431 :    } else  {

	jmp	$LN45@stbi__tga_
$LN49@stbi__tga_:

; 5432 :       //   do I need to load a palette?
; 5433 :       if ( tga_indexed)

	cmp	DWORD PTR _tga_indexed$[ebp], 0
	je	$LN44@stbi__tga_

; 5434 :       {
; 5435 :          //   any data to skip? (offset usually = 0)
; 5436 :          stbi__skip(s, tga_palette_start );

	mov	eax, DWORD PTR _tga_palette_start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__skip
	add	esp, 8

; 5437 :          //   load the palette
; 5438 :          tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);

	push	0
	mov	eax, DWORD PTR _tga_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_palette_len$[ebp]
	push	ecx
	call	_stbi__malloc_mad2
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tga_palette$[ebp], eax

; 5439 :          if (!tga_palette) {

	cmp	DWORD PTR _tga_palette$[ebp], 0
	jne	SHORT $LN43@stbi__tga_

; 5440 :             STBI_FREE(tga_data);

	mov	eax, DWORD PTR _tga_data$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 5441 :             return stbi__errpuc("outofmem", "Out of memory");

	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN69@stbi__tga_
	mov	DWORD PTR tv233[ebp], 0
	jmp	SHORT $LN70@stbi__tga_
$LN69@stbi__tga_:
	mov	DWORD PTR tv233[ebp], 0
$LN70@stbi__tga_:
	mov	eax, DWORD PTR tv233[ebp]
	jmp	$LN57@stbi__tga_
$LN43@stbi__tga_:

; 5442 :          }
; 5443 :          if (tga_rgb16) {

	cmp	DWORD PTR _tga_rgb16$[ebp], 0
	je	SHORT $LN42@stbi__tga_

; 5444 :             stbi_uc *pal_entry = tga_palette;

	mov	eax, DWORD PTR _tga_palette$[ebp]
	mov	DWORD PTR _pal_entry$8[ebp], eax

; 5445 :             STBI_ASSERT(tga_comp == STBI_rgb);

	cmp	DWORD PTR _tga_comp$[ebp], 3
	je	SHORT $LN71@stbi__tga_
	mov	eax, DWORD PTR ?__LINE__Var@?1??stbi__tga_load@@9@9@e7b221e1
	add	eax, 76					; 0000004cH
	push	eax
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB?$AAI?$AA_?$AAr?$AAg?$AAb?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN71@stbi__tga_:

; 5446 :             for (i=0; i < tga_palette_len; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN41@stbi__tga_
$LN40@stbi__tga_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN41@stbi__tga_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _tga_palette_len$[ebp]
	jge	SHORT $LN39@stbi__tga_

; 5447 :                stbi__tga_read_rgb16(s, pal_entry);

	mov	eax, DWORD PTR _pal_entry$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__tga_read_rgb16
	add	esp, 8

; 5448 :                pal_entry += tga_comp;

	mov	eax, DWORD PTR _pal_entry$8[ebp]
	add	eax, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR _pal_entry$8[ebp], eax

; 5449 :             }

	jmp	SHORT $LN40@stbi__tga_
$LN39@stbi__tga_:

; 5450 :          } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {

	jmp	SHORT $LN44@stbi__tga_
$LN42@stbi__tga_:
	mov	eax, DWORD PTR _tga_palette_len$[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_palette$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__getn
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN44@stbi__tga_

; 5451 :                STBI_FREE(tga_data);

	mov	eax, DWORD PTR _tga_data$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 5452 :                STBI_FREE(tga_palette);

	mov	eax, DWORD PTR _tga_palette$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 5453 :                return stbi__errpuc("bad palette", "Corrupt TGA");

	push	OFFSET ??_C@_0M@ILLOCNCO@bad?5palette?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN72@stbi__tga_
	mov	DWORD PTR tv257[ebp], 0
	jmp	SHORT $LN73@stbi__tga_
$LN72@stbi__tga_:
	mov	DWORD PTR tv257[ebp], 0
$LN73@stbi__tga_:
	mov	eax, DWORD PTR tv257[ebp]
	jmp	$LN57@stbi__tga_
$LN44@stbi__tga_:

; 5454 :          }
; 5455 :       }
; 5456 :       //   load the data
; 5457 :       for (i=0; i < tga_width * tga_height; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN36@stbi__tga_
$LN35@stbi__tga_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN36@stbi__tga_:
	mov	eax, DWORD PTR _tga_width$[ebp]
	imul	eax, DWORD PTR _tga_height$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN34@stbi__tga_

; 5458 :       {
; 5459 :          //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
; 5460 :          if ( tga_is_RLE )

	cmp	DWORD PTR _tga_is_RLE$[ebp], 0
	je	SHORT $LN33@stbi__tga_

; 5461 :          {
; 5462 :             if ( RLE_count == 0 )

	cmp	DWORD PTR _RLE_count$[ebp], 0
	jne	SHORT $LN32@stbi__tga_

; 5463 :             {
; 5464 :                //   yep, get the next byte as a RLE command
; 5465 :                int RLE_cmd = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _RLE_cmd$7[ebp], ecx

; 5466 :                RLE_count = 1 + (RLE_cmd & 127);

	mov	eax, DWORD PTR _RLE_cmd$7[ebp]
	and	eax, 127				; 0000007fH
	add	eax, 1
	mov	DWORD PTR _RLE_count$[ebp], eax

; 5467 :                RLE_repeating = RLE_cmd >> 7;

	mov	eax, DWORD PTR _RLE_cmd$7[ebp]
	sar	eax, 7
	mov	DWORD PTR _RLE_repeating$[ebp], eax

; 5468 :                read_next_pixel = 1;

	mov	DWORD PTR _read_next_pixel$[ebp], 1
	jmp	SHORT $LN31@stbi__tga_
$LN32@stbi__tga_:

; 5469 :             } else if ( !RLE_repeating )

	cmp	DWORD PTR _RLE_repeating$[ebp], 0
	jne	SHORT $LN31@stbi__tga_

; 5470 :             {
; 5471 :                read_next_pixel = 1;

	mov	DWORD PTR _read_next_pixel$[ebp], 1
$LN31@stbi__tga_:

; 5472 :             }
; 5473 :          } else

	jmp	SHORT $LN29@stbi__tga_
$LN33@stbi__tga_:

; 5474 :          {
; 5475 :             read_next_pixel = 1;

	mov	DWORD PTR _read_next_pixel$[ebp], 1
$LN29@stbi__tga_:

; 5476 :          }
; 5477 :          //   OK, if I need to read a pixel, do it now
; 5478 :          if ( read_next_pixel )

	cmp	DWORD PTR _read_next_pixel$[ebp], 0
	je	$LN28@stbi__tga_

; 5479 :          {
; 5480 :             //   load however much data we did have
; 5481 :             if ( tga_indexed )

	cmp	DWORD PTR _tga_indexed$[ebp], 0
	je	$LN27@stbi__tga_

; 5482 :             {
; 5483 :                // read in index, then perform the lookup
; 5484 :                int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);

	cmp	DWORD PTR _tga_bits_per_pixel$[ebp], 8
	jne	SHORT $LN74@stbi__tga_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR tv278[ebp], ecx
	jmp	SHORT $LN75@stbi__tga_
$LN74@stbi__tga_:
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__get16le
	add	esp, 4
	mov	DWORD PTR tv278[ebp], eax
$LN75@stbi__tga_:
	mov	eax, DWORD PTR tv278[ebp]
	mov	DWORD PTR _pal_idx$6[ebp], eax

; 5485 :                if ( pal_idx >= tga_palette_len ) {

	mov	eax, DWORD PTR _pal_idx$6[ebp]
	cmp	eax, DWORD PTR _tga_palette_len$[ebp]
	jl	SHORT $LN26@stbi__tga_

; 5486 :                   // invalid index
; 5487 :                   pal_idx = 0;

	mov	DWORD PTR _pal_idx$6[ebp], 0
$LN26@stbi__tga_:

; 5488 :                }
; 5489 :                pal_idx *= tga_comp;

	mov	eax, DWORD PTR _pal_idx$6[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR _pal_idx$6[ebp], eax

; 5490 :                for (j = 0; j < tga_comp; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN25@stbi__tga_
$LN24@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN25@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _tga_comp$[ebp]
	jge	SHORT $LN23@stbi__tga_

; 5491 :                   raw_data[j] = tga_palette[pal_idx+j];

	mov	eax, DWORD PTR _pal_idx$6[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _tga_palette$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR _raw_data$[ebp+ecx], al

; 5492 :                }

	jmp	SHORT $LN24@stbi__tga_
$LN23@stbi__tga_:

; 5493 :             } else if(tga_rgb16) {

	jmp	$LN22@stbi__tga_
$LN27@stbi__tga_:
	cmp	DWORD PTR _tga_rgb16$[ebp], 0
	je	SHORT $LN21@stbi__tga_

; 5494 :                STBI_ASSERT(tga_comp == STBI_rgb);

	cmp	DWORD PTR _tga_comp$[ebp], 3
	je	SHORT $LN76@stbi__tga_
	mov	eax, DWORD PTR ?__LINE__Var@?1??stbi__tga_load@@9@9@e7b221e1
	add	eax, 125				; 0000007dH
	push	eax
	push	OFFSET ??_C@_1HC@LCAFOEHA@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB?$AAI?$AA_?$AAr?$AAg?$AAb?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN76@stbi__tga_:

; 5495 :                stbi__tga_read_rgb16(s, raw_data);

	lea	eax, DWORD PTR _raw_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__tga_read_rgb16
	add	esp, 8

; 5496 :             } else {

	jmp	SHORT $LN22@stbi__tga_
$LN21@stbi__tga_:

; 5497 :                //   read in the data raw
; 5498 :                for (j = 0; j < tga_comp; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN19@stbi__tga_
$LN18@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN19@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _tga_comp$[ebp]
	jge	SHORT $LN22@stbi__tga_

; 5499 :                   raw_data[j] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _j$[ebp]
	mov	BYTE PTR _raw_data$[ebp+ecx], al

; 5500 :                }

	jmp	SHORT $LN18@stbi__tga_
$LN22@stbi__tga_:

; 5501 :             }
; 5502 :             //   clear the reading flag for the next pixel
; 5503 :             read_next_pixel = 0;

	mov	DWORD PTR _read_next_pixel$[ebp], 0
$LN28@stbi__tga_:

; 5504 :          } // end of reading a pixel
; 5505 : 
; 5506 :          // copy data
; 5507 :          for (j = 0; j < tga_comp; ++j)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN16@stbi__tga_
$LN15@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN16@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _tga_comp$[ebp]
	jge	SHORT $LN14@stbi__tga_

; 5508 :            tga_data[i*tga_comp+j] = raw_data[j];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _tga_data$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _raw_data$[ebp+edx]
	mov	BYTE PTR [ecx+eax], dl
	jmp	SHORT $LN15@stbi__tga_
$LN14@stbi__tga_:

; 5509 : 
; 5510 :          //   in case we're in RLE mode, keep counting down
; 5511 :          --RLE_count;

	mov	eax, DWORD PTR _RLE_count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _RLE_count$[ebp], eax

; 5512 :       }

	jmp	$LN35@stbi__tga_
$LN34@stbi__tga_:

; 5513 :       //   do I need to invert the image?
; 5514 :       if ( tga_inverted )

	cmp	DWORD PTR _tga_inverted$[ebp], 0
	je	$LN13@stbi__tga_

; 5515 :       {
; 5516 :          for (j = 0; j*2 < tga_height; ++j)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN12@stbi__tga_
$LN11@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN12@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 1
	cmp	eax, DWORD PTR _tga_height$[ebp]
	jge	$LN13@stbi__tga_

; 5517 :          {
; 5518 :             int index1 = j * tga_width * tga_comp;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, DWORD PTR _tga_width$[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR _index1$5[ebp], eax

; 5519 :             int index2 = (tga_height - 1 - j) * tga_width * tga_comp;

	mov	eax, DWORD PTR _tga_height$[ebp]
	sub	eax, 1
	sub	eax, DWORD PTR _j$[ebp]
	imul	eax, DWORD PTR _tga_width$[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR _index2$4[ebp], eax

; 5520 :             for (i = tga_width * tga_comp; i > 0; --i)

	mov	eax, DWORD PTR _tga_width$[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN9@stbi__tga_
$LN8@stbi__tga_:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@stbi__tga_:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN7@stbi__tga_

; 5521 :             {
; 5522 :                unsigned char temp = tga_data[index1];

	mov	eax, DWORD PTR _tga_data$[ebp]
	add	eax, DWORD PTR _index1$5[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _temp$3[ebp], cl

; 5523 :                tga_data[index1] = tga_data[index2];

	mov	eax, DWORD PTR _tga_data$[ebp]
	add	eax, DWORD PTR _index1$5[ebp]
	mov	ecx, DWORD PTR _tga_data$[ebp]
	add	ecx, DWORD PTR _index2$4[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 5524 :                tga_data[index2] = temp;

	mov	eax, DWORD PTR _tga_data$[ebp]
	add	eax, DWORD PTR _index2$4[ebp]
	mov	cl, BYTE PTR _temp$3[ebp]
	mov	BYTE PTR [eax], cl

; 5525 :                ++index1;

	mov	eax, DWORD PTR _index1$5[ebp]
	add	eax, 1
	mov	DWORD PTR _index1$5[ebp], eax

; 5526 :                ++index2;

	mov	eax, DWORD PTR _index2$4[ebp]
	add	eax, 1
	mov	DWORD PTR _index2$4[ebp], eax

; 5527 :             }

	jmp	SHORT $LN8@stbi__tga_
$LN7@stbi__tga_:

; 5528 :          }

	jmp	$LN11@stbi__tga_
$LN13@stbi__tga_:

; 5529 :       }
; 5530 :       //   clear my palette, if I had one
; 5531 :       if ( tga_palette != NULL )

	cmp	DWORD PTR _tga_palette$[ebp], 0
	je	SHORT $LN45@stbi__tga_

; 5532 :       {
; 5533 :          STBI_FREE( tga_palette );

	mov	eax, DWORD PTR _tga_palette$[ebp]
	push	eax
	call	_free
	add	esp, 4
$LN45@stbi__tga_:

; 5534 :       }
; 5535 :    }
; 5536 : 
; 5537 :    // swap RGB - if the source data was RGB16, it already is in the right order
; 5538 :    if (tga_comp >= 3 && !tga_rgb16)

	cmp	DWORD PTR _tga_comp$[ebp], 3
	jl	$LN5@stbi__tga_
	cmp	DWORD PTR _tga_rgb16$[ebp], 0
	jne	$LN5@stbi__tga_

; 5539 :    {
; 5540 :       unsigned char* tga_pixel = tga_data;

	mov	eax, DWORD PTR _tga_data$[ebp]
	mov	DWORD PTR _tga_pixel$2[ebp], eax

; 5541 :       for (i=0; i < tga_width * tga_height; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__tga_
$LN3@stbi__tga_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__tga_:
	mov	eax, DWORD PTR _tga_width$[ebp]
	imul	eax, DWORD PTR _tga_height$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN5@stbi__tga_

; 5542 :       {
; 5543 :          unsigned char temp = tga_pixel[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tga_pixel$2[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _temp$1[ebp], al

; 5544 :          tga_pixel[0] = tga_pixel[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _tga_pixel$2[ebp]
	mov	esi, DWORD PTR _tga_pixel$2[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al

; 5545 :          tga_pixel[2] = temp;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _tga_pixel$2[ebp]
	mov	dl, BYTE PTR _temp$1[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 5546 :          tga_pixel += tga_comp;

	mov	eax, DWORD PTR _tga_pixel$2[ebp]
	add	eax, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR _tga_pixel$2[ebp], eax

; 5547 :       }

	jmp	SHORT $LN3@stbi__tga_
$LN5@stbi__tga_:

; 5548 :    }
; 5549 : 
; 5550 :    // convert to target component count
; 5551 :    if (req_comp && req_comp != tga_comp)

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN1@stbi__tga_
	mov	eax, DWORD PTR _req_comp$[ebp]
	cmp	eax, DWORD PTR _tga_comp$[ebp]
	je	SHORT $LN1@stbi__tga_

; 5552 :       tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

	mov	eax, DWORD PTR _tga_height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _req_comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _tga_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_data$[ebp]
	push	ecx
	call	_stbi__convert_format
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tga_data$[ebp], eax
$LN1@stbi__tga_:

; 5553 : 
; 5554 :    //   the things I do to get rid of an error message, and yet keep
; 5555 :    //   Microsoft's C compilers happy... [8^(
; 5556 :    tga_palette_start = tga_palette_len = tga_palette_bits =
; 5557 :          tga_x_origin = tga_y_origin = 0;

	mov	DWORD PTR _tga_y_origin$[ebp], 0
	mov	eax, DWORD PTR _tga_y_origin$[ebp]
	mov	DWORD PTR _tga_x_origin$[ebp], eax
	mov	ecx, DWORD PTR _tga_x_origin$[ebp]
	mov	DWORD PTR _tga_palette_bits$[ebp], ecx
	mov	edx, DWORD PTR _tga_palette_bits$[ebp]
	mov	DWORD PTR _tga_palette_len$[ebp], edx
	mov	eax, DWORD PTR _tga_palette_len$[ebp]
	mov	DWORD PTR _tga_palette_start$[ebp], eax

; 5558 :    //   OK, done
; 5559 :    return tga_data;

	mov	eax, DWORD PTR _tga_data$[ebp]
$LN57@stbi__tga_:

; 5560 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN80@stbi__tga_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 592				; 00000250H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN80@stbi__tga_:
	DD	2
	DD	$LN79@stbi__tga_
$LN79@stbi__tga_:
	DD	-164					; ffffff5cH
	DD	4
	DD	$LN77@stbi__tga_
	DD	-236					; ffffff14H
	DD	4
	DD	$LN78@stbi__tga_
$LN78@stbi__tga_:
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$LN77@stbi__tga_:
	DB	116					; 00000074H
	DB	103					; 00000067H
	DB	97					; 00000061H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	98					; 00000062H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	0
_stbi__tga_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__tga_test
_TEXT	SEGMENT
_tga_color_type$ = -32					; size = 4
_sz$ = -20						; size = 4
_res$ = -8						; size = 4
_s$ = 8							; size = 4
_stbi__tga_test PROC					; COMDAT

; 5318 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5319 :    int res = 0;

	mov	DWORD PTR _res$[ebp], 0

; 5320 :    int sz, tga_color_type;
; 5321 :    stbi__get8(s);      //   discard Offset

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4

; 5322 :    tga_color_type = stbi__get8(s);   //   color type

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_color_type$[ebp], ecx

; 5323 :    if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed

	cmp	DWORD PTR _tga_color_type$[ebp], 1
	jle	SHORT $LN10@stbi__tga_
	jmp	$errorEnd$13
$LN10@stbi__tga_:

; 5324 :    sz = stbi__get8(s);   //   image type

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _sz$[ebp], ecx

; 5325 :    if ( tga_color_type == 1 ) { // colormapped (paletted) image

	cmp	DWORD PTR _tga_color_type$[ebp], 1
	jne	SHORT $LN9@stbi__tga_

; 5326 :       if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9

	cmp	DWORD PTR _sz$[ebp], 1
	je	SHORT $LN8@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 9
	je	SHORT $LN8@stbi__tga_
	jmp	$errorEnd$13
$LN8@stbi__tga_:

; 5327 :       stbi__skip(s,4);       // skip index of first colormap entry and number of entries

	push	4
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__skip
	add	esp, 8

; 5328 :       sz = stbi__get8(s);    //   check bits per palette color entry

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _sz$[ebp], ecx

; 5329 :       if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

	cmp	DWORD PTR _sz$[ebp], 8
	je	SHORT $LN7@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 15			; 0000000fH
	je	SHORT $LN7@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 16			; 00000010H
	je	SHORT $LN7@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 24			; 00000018H
	je	SHORT $LN7@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 32			; 00000020H
	je	SHORT $LN7@stbi__tga_
	jmp	$errorEnd$13
$LN7@stbi__tga_:

; 5330 :       stbi__skip(s,4);       // skip image x and y origin

	push	4
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__skip
	add	esp, 8

; 5331 :    } else { // "normal" image w/o colormap

	jmp	SHORT $LN6@stbi__tga_
$LN9@stbi__tga_:

; 5332 :       if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE

	cmp	DWORD PTR _sz$[ebp], 2
	je	SHORT $LN5@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 3
	je	SHORT $LN5@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 10			; 0000000aH
	je	SHORT $LN5@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 11			; 0000000bH
	je	SHORT $LN5@stbi__tga_
	jmp	$errorEnd$13
$LN5@stbi__tga_:

; 5333 :       stbi__skip(s,9); // skip colormap specification and image x/y origin

	push	9
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__skip
	add	esp, 8
$LN6@stbi__tga_:

; 5334 :    }
; 5335 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	cmp	eax, 1
	jge	SHORT $LN4@stbi__tga_
	jmp	SHORT $errorEnd$13
$LN4@stbi__tga_:

; 5336 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	cmp	eax, 1
	jge	SHORT $LN3@stbi__tga_
	jmp	SHORT $errorEnd$13
$LN3@stbi__tga_:

; 5337 :    sz = stbi__get8(s);   //   bits per pixel

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _sz$[ebp], ecx

; 5338 :    if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index

	cmp	DWORD PTR _tga_color_type$[ebp], 1
	jne	SHORT $LN2@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 8
	je	SHORT $LN2@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 16			; 00000010H
	je	SHORT $LN2@stbi__tga_
	jmp	SHORT $errorEnd$13
$LN2@stbi__tga_:

; 5339 :    if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

	cmp	DWORD PTR _sz$[ebp], 8
	je	SHORT $LN1@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 15			; 0000000fH
	je	SHORT $LN1@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 16			; 00000010H
	je	SHORT $LN1@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 24			; 00000018H
	je	SHORT $LN1@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 32			; 00000020H
	je	SHORT $LN1@stbi__tga_
	jmp	SHORT $errorEnd$13
$LN1@stbi__tga_:

; 5340 : 
; 5341 :    res = 1; // if we got this far, everything's good and we can return 1 instead of 0

	mov	DWORD PTR _res$[ebp], 1
$errorEnd$13:

; 5342 : 
; 5343 : errorEnd:
; 5344 :    stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__rewind
	add	esp, 4

; 5345 :    return res;

	mov	eax, DWORD PTR _res$[ebp]

; 5346 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__tga_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__bmp_info
_TEXT	SEGMENT
tv75 = -252						; size = 4
_info$ = -52						; size = 32
_p$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_stbi__bmp_info PROC					; COMDAT

; 6651 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6652 :    void *p;
; 6653 :    stbi__bmp_data info;
; 6654 : 
; 6655 :    info.all_a = 255;

	mov	DWORD PTR _info$[ebp+28], 255		; 000000ffH

; 6656 :    p = stbi__bmp_parse_header(s, &info);

	lea	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__bmp_parse_header
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 6657 :    stbi__rewind( s );

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__rewind
	add	esp, 4

; 6658 :    if (p == NULL)

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN4@stbi__bmp_

; 6659 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN5@stbi__bmp_
$LN4@stbi__bmp_:

; 6660 :    if (x) *x = s->img_x;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@stbi__bmp_
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@stbi__bmp_:

; 6661 :    if (y) *y = s->img_y;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN2@stbi__bmp_
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
$LN2@stbi__bmp_:

; 6662 :    if (comp) *comp = info.ma ? 4 : 3;

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN1@stbi__bmp_
	cmp	DWORD PTR _info$[ebp+24], 0
	je	SHORT $LN7@stbi__bmp_
	mov	DWORD PTR tv75[ebp], 4
	jmp	SHORT $LN8@stbi__bmp_
$LN7@stbi__bmp_:
	mov	DWORD PTR tv75[ebp], 3
$LN8@stbi__bmp_:
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@stbi__bmp_:

; 6663 :    return 1;

	mov	eax, 1
$LN5@stbi__bmp_:

; 6664 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@stbi__bmp_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN11@stbi__bmp_:
	DD	1
	DD	$LN10@stbi__bmp_
$LN10@stbi__bmp_:
	DD	-52					; ffffffccH
	DD	32					; 00000020H
	DD	$LN9@stbi__bmp_
$LN9@stbi__bmp_:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
_stbi__bmp_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__bmp_load
_TEXT	SEGMENT
tv432 = -1668						; size = 4
tv395 = -1668						; size = 4
tv379 = -1668						; size = 4
tv331 = -1668						; size = 4
tv277 = -1668						; size = 4
tv230 = -1668						; size = 4
tv215 = -1668						; size = 4
tv153 = -1668						; size = 4
tv145 = -1668						; size = 4
tv133 = -1668						; size = 4
tv86 = -1668						; size = 4
tv70 = -1668						; size = 4
_p2$1 = -1468						; size = 4
_p1$2 = -1456						; size = 4
_t$3 = -1441						; size = 1
_a$4 = -1432						; size = 4
_v$5 = -1420						; size = 4
_bpp$6 = -1408						; size = 4
_a$7 = -1393						; size = 1
_easy$8 = -1384						; size = 4
_z$9 = -1372						; size = 4
_acount$10 = -1360					; size = 4
_bcount$11 = -1348					; size = 4
_gcount$12 = -1336					; size = 4
_rcount$13 = -1324					; size = 4
_ashift$14 = -1312					; size = 4
_bshift$15 = -1300					; size = 4
_gshift$16 = -1288					; size = 4
_rshift$17 = -1276					; size = 4
_v2$18 = -1264						; size = 4
_v$19 = -1252						; size = 4
_z$20 = -1240						; size = 4
_info$ = -1228						; size = 32
_target$ = -1188					; size = 4
_pad$ = -1176						; size = 4
_flip_vertically$ = -1164				; size = 4
_width$ = -1152						; size = 4
_j$ = -1140						; size = 4
_i$ = -1128						; size = 4
_psize$ = -1116						; size = 4
_pal$ = -1104						; size = 1024
_all_a$ = -72						; size = 4
_ma$ = -60						; size = 4
_mb$ = -48						; size = 4
_mg$ = -36						; size = 4
_mr$ = -24						; size = 4
_out$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
_stbi__bmp_load PROC					; COMDAT

; 5075 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1668				; 00000684H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1668]
	mov	ecx, 417				; 000001a1H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5076 :    stbi_uc *out;
; 5077 :    unsigned int mr=0,mg=0,mb=0,ma=0, all_a;

	mov	DWORD PTR _mr$[ebp], 0
	mov	DWORD PTR _mg$[ebp], 0
	mov	DWORD PTR _mb$[ebp], 0
	mov	DWORD PTR _ma$[ebp], 0

; 5078 :    stbi_uc pal[256][4];
; 5079 :    int psize=0,i,j,width;

	mov	DWORD PTR _psize$[ebp], 0

; 5080 :    int flip_vertically, pad, target;
; 5081 :    stbi__bmp_data info;
; 5082 :    STBI_NOTUSED(ri);
; 5083 : 
; 5084 :    info.all_a = 255;

	mov	DWORD PTR _info$[ebp+28], 255		; 000000ffH

; 5085 :    if (stbi__bmp_parse_header(s, &info) == NULL)

	lea	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__bmp_parse_header
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN69@stbi__bmp_

; 5086 :       return NULL; // error code already set

	xor	eax, eax
	jmp	$LN70@stbi__bmp_
$LN69@stbi__bmp_:

; 5087 : 
; 5088 :    flip_vertically = ((int) s->img_y) > 0;

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jle	SHORT $LN72@stbi__bmp_
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN73@stbi__bmp_
$LN72@stbi__bmp_:
	mov	DWORD PTR tv70[ebp], 0
$LN73@stbi__bmp_:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _flip_vertically$[ebp], ecx

; 5089 :    s->img_y = abs((int) s->img_y);

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_abs
	add	esp, 4
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+4], eax

; 5090 : 
; 5091 :    mr = info.mr;

	mov	eax, DWORD PTR _info$[ebp+12]
	mov	DWORD PTR _mr$[ebp], eax

; 5092 :    mg = info.mg;

	mov	eax, DWORD PTR _info$[ebp+16]
	mov	DWORD PTR _mg$[ebp], eax

; 5093 :    mb = info.mb;

	mov	eax, DWORD PTR _info$[ebp+20]
	mov	DWORD PTR _mb$[ebp], eax

; 5094 :    ma = info.ma;

	mov	eax, DWORD PTR _info$[ebp+24]
	mov	DWORD PTR _ma$[ebp], eax

; 5095 :    all_a = info.all_a;

	mov	eax, DWORD PTR _info$[ebp+28]
	mov	DWORD PTR _all_a$[ebp], eax

; 5096 : 
; 5097 :    if (info.hsz == 12) {

	cmp	DWORD PTR _info$[ebp+8], 12		; 0000000cH
	jne	SHORT $LN68@stbi__bmp_

; 5098 :       if (info.bpp < 24)

	cmp	DWORD PTR _info$[ebp], 24		; 00000018H
	jge	SHORT $LN67@stbi__bmp_

; 5099 :          psize = (info.offset - 14 - 24) / 3;

	mov	eax, DWORD PTR _info$[ebp+4]
	sub	eax, 38					; 00000026H
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _psize$[ebp], eax
$LN67@stbi__bmp_:

; 5100 :    } else {

	jmp	SHORT $LN66@stbi__bmp_
$LN68@stbi__bmp_:

; 5101 :       if (info.bpp < 16)

	cmp	DWORD PTR _info$[ebp], 16		; 00000010H
	jge	SHORT $LN66@stbi__bmp_

; 5102 :          psize = (info.offset - 14 - info.hsz) >> 2;

	mov	eax, DWORD PTR _info$[ebp+4]
	sub	eax, 14					; 0000000eH
	sub	eax, DWORD PTR _info$[ebp+8]
	sar	eax, 2
	mov	DWORD PTR _psize$[ebp], eax
$LN66@stbi__bmp_:

; 5103 :    }
; 5104 : 
; 5105 :    s->img_n = ma ? 4 : 3;

	cmp	DWORD PTR _ma$[ebp], 0
	je	SHORT $LN74@stbi__bmp_
	mov	DWORD PTR tv86[ebp], 4
	jmp	SHORT $LN75@stbi__bmp_
$LN74@stbi__bmp_:
	mov	DWORD PTR tv86[ebp], 3
$LN75@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR [eax+8], ecx

; 5106 :    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN64@stbi__bmp_
	cmp	DWORD PTR _req_comp$[ebp], 3
	jl	SHORT $LN64@stbi__bmp_

; 5107 :       target = req_comp;

	mov	eax, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR _target$[ebp], eax

; 5108 :    else

	jmp	SHORT $LN63@stbi__bmp_
$LN64@stbi__bmp_:

; 5109 :       target = s->img_n; // if they want monochrome, we'll post-convert

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _target$[ebp], ecx
$LN63@stbi__bmp_:

; 5110 : 
; 5111 :    // sanity-check size
; 5112 :    if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))

	push	0
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	push	ecx
	call	_stbi__mad3sizes_valid
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN62@stbi__bmp_

; 5113 :       return stbi__errpuc("too large", "Corrupt BMP");

	push	OFFSET ??_C@_09OJDLMMBJ@too?5large?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN76@stbi__bmp_
	mov	DWORD PTR tv133[ebp], 0
	jmp	SHORT $LN77@stbi__bmp_
$LN76@stbi__bmp_:
	mov	DWORD PTR tv133[ebp], 0
$LN77@stbi__bmp_:
	mov	eax, DWORD PTR tv133[ebp]
	jmp	$LN70@stbi__bmp_
$LN62@stbi__bmp_:

; 5114 : 
; 5115 :    out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);

	push	0
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	push	ecx
	call	_stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	DWORD PTR _out$[ebp], eax

; 5116 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN61@stbi__bmp_
	push	OFFSET ??_C@_08NOGIMCHF@outofmem?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN78@stbi__bmp_
	mov	DWORD PTR tv145[ebp], 0
	jmp	SHORT $LN79@stbi__bmp_
$LN78@stbi__bmp_:
	mov	DWORD PTR tv145[ebp], 0
$LN79@stbi__bmp_:
	mov	eax, DWORD PTR tv145[ebp]
	jmp	$LN70@stbi__bmp_
$LN61@stbi__bmp_:

; 5117 :    if (info.bpp < 16) {

	cmp	DWORD PTR _info$[ebp], 16		; 00000010H
	jge	$LN60@stbi__bmp_

; 5118 :       int z=0;

	mov	DWORD PTR _z$20[ebp], 0

; 5119 :       if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }

	cmp	DWORD PTR _psize$[ebp], 0
	je	SHORT $LN58@stbi__bmp_
	cmp	DWORD PTR _psize$[ebp], 256		; 00000100H
	jle	SHORT $LN59@stbi__bmp_
$LN58@stbi__bmp_:
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_free
	add	esp, 4
	push	OFFSET ??_C@_07MALOAKCI@invalid?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN80@stbi__bmp_
	mov	DWORD PTR tv153[ebp], 0
	jmp	SHORT $LN81@stbi__bmp_
$LN80@stbi__bmp_:
	mov	DWORD PTR tv153[ebp], 0
$LN81@stbi__bmp_:
	mov	eax, DWORD PTR tv153[ebp]
	jmp	$LN70@stbi__bmp_
$LN59@stbi__bmp_:

; 5120 :       for (i=0; i < psize; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN57@stbi__bmp_
$LN56@stbi__bmp_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN57@stbi__bmp_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _psize$[ebp]
	jge	$LN55@stbi__bmp_

; 5121 :          pal[i][2] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR _pal$[ebp+ecx*4]
	mov	ecx, 1
	shl	ecx, 1
	mov	BYTE PTR [edx+ecx], al

; 5122 :          pal[i][1] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR _pal$[ebp+ecx*4]
	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR [edx+ecx], al

; 5123 :          pal[i][0] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR _pal$[ebp+ecx*4]
	mov	ecx, 1
	imul	ecx, ecx, 0
	mov	BYTE PTR [edx+ecx], al

; 5124 :          if (info.hsz != 12) stbi__get8(s);

	cmp	DWORD PTR _info$[ebp+8], 12		; 0000000cH
	je	SHORT $LN54@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
$LN54@stbi__bmp_:

; 5125 :          pal[i][3] = 255;

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 3
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 5126 :       }

	jmp	$LN56@stbi__bmp_
$LN55@stbi__bmp_:

; 5127 :       stbi__skip(s, info.offset - 14 - info.hsz - psize * (info.hsz == 12 ? 3 : 4));

	cmp	DWORD PTR _info$[ebp+8], 12		; 0000000cH
	jne	SHORT $LN82@stbi__bmp_
	mov	DWORD PTR tv215[ebp], 3
	jmp	SHORT $LN83@stbi__bmp_
$LN82@stbi__bmp_:
	mov	DWORD PTR tv215[ebp], 4
$LN83@stbi__bmp_:
	mov	eax, DWORD PTR _info$[ebp+4]
	sub	eax, 14					; 0000000eH
	sub	eax, DWORD PTR _info$[ebp+8]
	mov	ecx, DWORD PTR _psize$[ebp]
	imul	ecx, DWORD PTR tv215[ebp]
	sub	eax, ecx
	push	eax
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__skip
	add	esp, 8

; 5128 :       if (info.bpp == 4) width = (s->img_x + 1) >> 1;

	cmp	DWORD PTR _info$[ebp], 4
	jne	SHORT $LN53@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	shr	ecx, 1
	mov	DWORD PTR _width$[ebp], ecx
	jmp	SHORT $LN52@stbi__bmp_
$LN53@stbi__bmp_:

; 5129 :       else if (info.bpp == 8) width = s->img_x;

	cmp	DWORD PTR _info$[ebp], 8
	jne	SHORT $LN51@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _width$[ebp], ecx
	jmp	SHORT $LN52@stbi__bmp_
$LN51@stbi__bmp_:

; 5130 :       else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_free
	add	esp, 4
	push	OFFSET ??_C@_07JNJHIMGH@bad?5bpp?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN84@stbi__bmp_
	mov	DWORD PTR tv230[ebp], 0
	jmp	SHORT $LN85@stbi__bmp_
$LN84@stbi__bmp_:
	mov	DWORD PTR tv230[ebp], 0
$LN85@stbi__bmp_:
	mov	eax, DWORD PTR tv230[ebp]
	jmp	$LN70@stbi__bmp_
$LN52@stbi__bmp_:

; 5131 :       pad = (-width)&3;

	mov	eax, DWORD PTR _width$[ebp]
	neg	eax
	and	eax, 3
	mov	DWORD PTR _pad$[ebp], eax

; 5132 :       for (j=0; j < (int) s->img_y; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN49@stbi__bmp_
$LN48@stbi__bmp_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN49@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	$LN47@stbi__bmp_

; 5133 :          for (i=0; i < (int) s->img_x; i += 2) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN46@stbi__bmp_
$LN45@stbi__bmp_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	mov	DWORD PTR _i$[ebp], eax
$LN46@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$LN44@stbi__bmp_

; 5134 :             int v=stbi__get8(s),v2=0;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _v$19[ebp], ecx
	mov	DWORD PTR _v2$18[ebp], 0

; 5135 :             if (info.bpp == 4) {

	cmp	DWORD PTR _info$[ebp], 4
	jne	SHORT $LN43@stbi__bmp_

; 5136 :                v2 = v & 15;

	mov	eax, DWORD PTR _v$19[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _v2$18[ebp], eax

; 5137 :                v >>= 4;

	mov	eax, DWORD PTR _v$19[ebp]
	sar	eax, 4
	mov	DWORD PTR _v$19[ebp], eax
$LN43@stbi__bmp_:

; 5138 :             }
; 5139 :             out[z++] = pal[v][0];

	mov	eax, DWORD PTR _v$19[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, DWORD PTR _z$20[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _z$20[ebp]
	add	ecx, 1
	mov	DWORD PTR _z$20[ebp], ecx

; 5140 :             out[z++] = pal[v][1];

	mov	eax, DWORD PTR _v$19[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$20[ebp]
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _z$20[ebp]
	add	edx, 1
	mov	DWORD PTR _z$20[ebp], edx

; 5141 :             out[z++] = pal[v][2];

	mov	eax, DWORD PTR _v$19[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$20[ebp]
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _z$20[ebp]
	add	edx, 1
	mov	DWORD PTR _z$20[ebp], edx

; 5142 :             if (target == 4) out[z++] = 255;

	cmp	DWORD PTR _target$[ebp], 4
	jne	SHORT $LN42@stbi__bmp_
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$20[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	ecx, DWORD PTR _z$20[ebp]
	add	ecx, 1
	mov	DWORD PTR _z$20[ebp], ecx
$LN42@stbi__bmp_:

; 5143 :             if (i+1 == (int) s->img_x) break;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN41@stbi__bmp_
	jmp	$LN44@stbi__bmp_
$LN41@stbi__bmp_:

; 5144 :             v = (info.bpp == 8) ? stbi__get8(s) : v2;

	cmp	DWORD PTR _info$[ebp], 8
	jne	SHORT $LN86@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR tv277[ebp], ecx
	jmp	SHORT $LN87@stbi__bmp_
$LN86@stbi__bmp_:
	mov	edx, DWORD PTR _v2$18[ebp]
	mov	DWORD PTR tv277[ebp], edx
$LN87@stbi__bmp_:
	mov	eax, DWORD PTR tv277[ebp]
	mov	DWORD PTR _v$19[ebp], eax

; 5145 :             out[z++] = pal[v][0];

	mov	eax, DWORD PTR _v$19[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, DWORD PTR _z$20[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _z$20[ebp]
	add	ecx, 1
	mov	DWORD PTR _z$20[ebp], ecx

; 5146 :             out[z++] = pal[v][1];

	mov	eax, DWORD PTR _v$19[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$20[ebp]
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _z$20[ebp]
	add	edx, 1
	mov	DWORD PTR _z$20[ebp], edx

; 5147 :             out[z++] = pal[v][2];

	mov	eax, DWORD PTR _v$19[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$20[ebp]
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _z$20[ebp]
	add	edx, 1
	mov	DWORD PTR _z$20[ebp], edx

; 5148 :             if (target == 4) out[z++] = 255;

	cmp	DWORD PTR _target$[ebp], 4
	jne	SHORT $LN40@stbi__bmp_
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$20[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	ecx, DWORD PTR _z$20[ebp]
	add	ecx, 1
	mov	DWORD PTR _z$20[ebp], ecx
$LN40@stbi__bmp_:

; 5149 :          }

	jmp	$LN45@stbi__bmp_
$LN44@stbi__bmp_:

; 5150 :          stbi__skip(s, pad);

	mov	eax, DWORD PTR _pad$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__skip
	add	esp, 8

; 5151 :       }

	jmp	$LN48@stbi__bmp_
$LN47@stbi__bmp_:

; 5152 :    } else {

	jmp	$LN39@stbi__bmp_
$LN60@stbi__bmp_:

; 5153 :       int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;

	mov	DWORD PTR _rshift$17[ebp], 0
	mov	DWORD PTR _gshift$16[ebp], 0
	mov	DWORD PTR _bshift$15[ebp], 0
	mov	DWORD PTR _ashift$14[ebp], 0
	mov	DWORD PTR _rcount$13[ebp], 0
	mov	DWORD PTR _gcount$12[ebp], 0
	mov	DWORD PTR _bcount$11[ebp], 0
	mov	DWORD PTR _acount$10[ebp], 0

; 5154 :       int z = 0;

	mov	DWORD PTR _z$9[ebp], 0

; 5155 :       int easy=0;

	mov	DWORD PTR _easy$8[ebp], 0

; 5156 :       stbi__skip(s, info.offset - 14 - info.hsz);

	mov	eax, DWORD PTR _info$[ebp+4]
	sub	eax, 14					; 0000000eH
	sub	eax, DWORD PTR _info$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__skip
	add	esp, 8

; 5157 :       if (info.bpp == 24) width = 3 * s->img_x;

	cmp	DWORD PTR _info$[ebp], 24		; 00000018H
	jne	SHORT $LN38@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	imul	ecx, DWORD PTR [eax], 3
	mov	DWORD PTR _width$[ebp], ecx
	jmp	SHORT $LN37@stbi__bmp_
$LN38@stbi__bmp_:

; 5158 :       else if (info.bpp == 16) width = 2*s->img_x;

	cmp	DWORD PTR _info$[ebp], 16		; 00000010H
	jne	SHORT $LN36@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 1
	mov	DWORD PTR _width$[ebp], ecx
	jmp	SHORT $LN37@stbi__bmp_
$LN36@stbi__bmp_:

; 5159 :       else /* bpp = 32 and pad = 0 */ width=0;

	mov	DWORD PTR _width$[ebp], 0
$LN37@stbi__bmp_:

; 5160 :       pad = (-width) & 3;

	mov	eax, DWORD PTR _width$[ebp]
	neg	eax
	and	eax, 3
	mov	DWORD PTR _pad$[ebp], eax

; 5161 :       if (info.bpp == 24) {

	cmp	DWORD PTR _info$[ebp], 24		; 00000018H
	jne	SHORT $LN34@stbi__bmp_

; 5162 :          easy = 1;

	mov	DWORD PTR _easy$8[ebp], 1
	jmp	SHORT $LN33@stbi__bmp_
$LN34@stbi__bmp_:

; 5163 :       } else if (info.bpp == 32) {

	cmp	DWORD PTR _info$[ebp], 32		; 00000020H
	jne	SHORT $LN33@stbi__bmp_

; 5164 :          if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)

	cmp	DWORD PTR _mb$[ebp], 255		; 000000ffH
	jne	SHORT $LN33@stbi__bmp_
	cmp	DWORD PTR _mg$[ebp], 65280		; 0000ff00H
	jne	SHORT $LN33@stbi__bmp_
	cmp	DWORD PTR _mr$[ebp], 16711680		; 00ff0000H
	jne	SHORT $LN33@stbi__bmp_
	cmp	DWORD PTR _ma$[ebp], -16777216		; ff000000H
	jne	SHORT $LN33@stbi__bmp_

; 5165 :             easy = 2;

	mov	DWORD PTR _easy$8[ebp], 2
$LN33@stbi__bmp_:

; 5166 :       }
; 5167 :       if (!easy) {

	cmp	DWORD PTR _easy$8[ebp], 0
	jne	$LN30@stbi__bmp_

; 5168 :          if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

	cmp	DWORD PTR _mr$[ebp], 0
	je	SHORT $LN28@stbi__bmp_
	cmp	DWORD PTR _mg$[ebp], 0
	je	SHORT $LN28@stbi__bmp_
	cmp	DWORD PTR _mb$[ebp], 0
	jne	SHORT $LN29@stbi__bmp_
$LN28@stbi__bmp_:
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_free
	add	esp, 4
	push	OFFSET ??_C@_09DAEBACAB@bad?5masks?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN88@stbi__bmp_
	mov	DWORD PTR tv331[ebp], 0
	jmp	SHORT $LN89@stbi__bmp_
$LN88@stbi__bmp_:
	mov	DWORD PTR tv331[ebp], 0
$LN89@stbi__bmp_:
	mov	eax, DWORD PTR tv331[ebp]
	jmp	$LN70@stbi__bmp_
$LN29@stbi__bmp_:

; 5169 :          // right shift amt to put high bit in position #7
; 5170 :          rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);

	mov	eax, DWORD PTR _mr$[ebp]
	push	eax
	call	_stbi__high_bit
	add	esp, 4
	sub	eax, 7
	mov	DWORD PTR _rshift$17[ebp], eax
	mov	eax, DWORD PTR _mr$[ebp]
	push	eax
	call	_stbi__bitcount
	add	esp, 4
	mov	DWORD PTR _rcount$13[ebp], eax

; 5171 :          gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);

	mov	eax, DWORD PTR _mg$[ebp]
	push	eax
	call	_stbi__high_bit
	add	esp, 4
	sub	eax, 7
	mov	DWORD PTR _gshift$16[ebp], eax
	mov	eax, DWORD PTR _mg$[ebp]
	push	eax
	call	_stbi__bitcount
	add	esp, 4
	mov	DWORD PTR _gcount$12[ebp], eax

; 5172 :          bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);

	mov	eax, DWORD PTR _mb$[ebp]
	push	eax
	call	_stbi__high_bit
	add	esp, 4
	sub	eax, 7
	mov	DWORD PTR _bshift$15[ebp], eax
	mov	eax, DWORD PTR _mb$[ebp]
	push	eax
	call	_stbi__bitcount
	add	esp, 4
	mov	DWORD PTR _bcount$11[ebp], eax

; 5173 :          ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);

	mov	eax, DWORD PTR _ma$[ebp]
	push	eax
	call	_stbi__high_bit
	add	esp, 4
	sub	eax, 7
	mov	DWORD PTR _ashift$14[ebp], eax
	mov	eax, DWORD PTR _ma$[ebp]
	push	eax
	call	_stbi__bitcount
	add	esp, 4
	mov	DWORD PTR _acount$10[ebp], eax
$LN30@stbi__bmp_:

; 5174 :       }
; 5175 :       for (j=0; j < (int) s->img_y; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN27@stbi__bmp_
$LN26@stbi__bmp_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN27@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	$LN39@stbi__bmp_

; 5176 :          if (easy) {

	cmp	DWORD PTR _easy$8[ebp], 0
	je	$LN24@stbi__bmp_

; 5177 :             for (i=0; i < (int) s->img_x; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN23@stbi__bmp_
$LN22@stbi__bmp_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN23@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$LN21@stbi__bmp_

; 5178 :                unsigned char a;
; 5179 :                out[z+2] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _z$9[ebp]
	mov	BYTE PTR [ecx+2], al

; 5180 :                out[z+1] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _z$9[ebp]
	mov	BYTE PTR [ecx+1], al

; 5181 :                out[z+0] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _z$9[ebp]
	mov	BYTE PTR [ecx], al

; 5182 :                z += 3;

	mov	eax, DWORD PTR _z$9[ebp]
	add	eax, 3
	mov	DWORD PTR _z$9[ebp], eax

; 5183 :                a = (easy == 2 ? stbi__get8(s) : 255);

	cmp	DWORD PTR _easy$8[ebp], 2
	jne	SHORT $LN90@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR tv379[ebp], ecx
	jmp	SHORT $LN91@stbi__bmp_
$LN90@stbi__bmp_:
	mov	DWORD PTR tv379[ebp], 255		; 000000ffH
$LN91@stbi__bmp_:
	mov	dl, BYTE PTR tv379[ebp]
	mov	BYTE PTR _a$7[ebp], dl

; 5184 :                all_a |= a;

	movzx	eax, BYTE PTR _a$7[ebp]
	or	eax, DWORD PTR _all_a$[ebp]
	mov	DWORD PTR _all_a$[ebp], eax

; 5185 :                if (target == 4) out[z++] = a;

	cmp	DWORD PTR _target$[ebp], 4
	jne	SHORT $LN20@stbi__bmp_
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$9[ebp]
	mov	cl, BYTE PTR _a$7[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _z$9[ebp]
	add	edx, 1
	mov	DWORD PTR _z$9[ebp], edx
$LN20@stbi__bmp_:

; 5186 :             }

	jmp	$LN22@stbi__bmp_
$LN21@stbi__bmp_:

; 5187 :          } else {

	jmp	$LN19@stbi__bmp_
$LN24@stbi__bmp_:

; 5188 :             int bpp = info.bpp;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR _bpp$6[ebp], eax

; 5189 :             for (i=0; i < (int) s->img_x; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN18@stbi__bmp_
$LN17@stbi__bmp_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN18@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$LN19@stbi__bmp_

; 5190 :                stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));

	cmp	DWORD PTR _bpp$6[ebp], 16		; 00000010H
	jne	SHORT $LN92@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__get16le
	add	esp, 4
	mov	DWORD PTR tv395[ebp], eax
	jmp	SHORT $LN93@stbi__bmp_
$LN92@stbi__bmp_:
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__get32le
	add	esp, 4
	mov	DWORD PTR tv395[ebp], eax
$LN93@stbi__bmp_:
	mov	edx, DWORD PTR tv395[ebp]
	mov	DWORD PTR _v$5[ebp], edx

; 5191 :                int a;
; 5192 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));

	mov	eax, DWORD PTR _rcount$13[ebp]
	push	eax
	mov	ecx, DWORD PTR _rshift$17[ebp]
	push	ecx
	mov	edx, DWORD PTR _v$5[ebp]
	and	edx, DWORD PTR _mr$[ebp]
	push	edx
	call	_stbi__shiftsigned
	add	esp, 12					; 0000000cH
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _z$9[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _z$9[ebp]
	add	edx, 1
	mov	DWORD PTR _z$9[ebp], edx

; 5193 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));

	mov	eax, DWORD PTR _gcount$12[ebp]
	push	eax
	mov	ecx, DWORD PTR _gshift$16[ebp]
	push	ecx
	mov	edx, DWORD PTR _v$5[ebp]
	and	edx, DWORD PTR _mg$[ebp]
	push	edx
	call	_stbi__shiftsigned
	add	esp, 12					; 0000000cH
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _z$9[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _z$9[ebp]
	add	edx, 1
	mov	DWORD PTR _z$9[ebp], edx

; 5194 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));

	mov	eax, DWORD PTR _bcount$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _bshift$15[ebp]
	push	ecx
	mov	edx, DWORD PTR _v$5[ebp]
	and	edx, DWORD PTR _mb$[ebp]
	push	edx
	call	_stbi__shiftsigned
	add	esp, 12					; 0000000cH
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _z$9[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _z$9[ebp]
	add	edx, 1
	mov	DWORD PTR _z$9[ebp], edx

; 5195 :                a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);

	cmp	DWORD PTR _ma$[ebp], 0
	je	SHORT $LN94@stbi__bmp_
	mov	eax, DWORD PTR _acount$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _ashift$14[ebp]
	push	ecx
	mov	edx, DWORD PTR _v$5[ebp]
	and	edx, DWORD PTR _ma$[ebp]
	push	edx
	call	_stbi__shiftsigned
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv432[ebp], eax
	jmp	SHORT $LN95@stbi__bmp_
$LN94@stbi__bmp_:
	mov	DWORD PTR tv432[ebp], 255		; 000000ffH
$LN95@stbi__bmp_:
	mov	eax, DWORD PTR tv432[ebp]
	mov	DWORD PTR _a$4[ebp], eax

; 5196 :                all_a |= a;

	mov	eax, DWORD PTR _all_a$[ebp]
	or	eax, DWORD PTR _a$4[ebp]
	mov	DWORD PTR _all_a$[ebp], eax

; 5197 :                if (target == 4) out[z++] = STBI__BYTECAST(a);

	cmp	DWORD PTR _target$[ebp], 4
	jne	SHORT $LN15@stbi__bmp_
	mov	eax, DWORD PTR _a$4[ebp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _z$9[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _z$9[ebp]
	add	edx, 1
	mov	DWORD PTR _z$9[ebp], edx
$LN15@stbi__bmp_:

; 5198 :             }

	jmp	$LN17@stbi__bmp_
$LN19@stbi__bmp_:

; 5199 :          }
; 5200 :          stbi__skip(s, pad);

	mov	eax, DWORD PTR _pad$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__skip
	add	esp, 8

; 5201 :       }

	jmp	$LN26@stbi__bmp_
$LN39@stbi__bmp_:

; 5202 :    }
; 5203 : 
; 5204 :    // if alpha channel is all 0s, replace with all 255s
; 5205 :    if (target == 4 && all_a == 0)

	cmp	DWORD PTR _target$[ebp], 4
	jne	SHORT $LN14@stbi__bmp_
	cmp	DWORD PTR _all_a$[ebp], 0
	jne	SHORT $LN14@stbi__bmp_

; 5206 :       for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 2
	mov	edx, DWORD PTR _s$[ebp]
	imul	ecx, DWORD PTR [edx+4]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN13@stbi__bmp_
$LN12@stbi__bmp_:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 4
	mov	DWORD PTR _i$[ebp], eax
$LN13@stbi__bmp_:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN14@stbi__bmp_

; 5207 :          out[i] = 255;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	jmp	SHORT $LN12@stbi__bmp_
$LN14@stbi__bmp_:

; 5208 : 
; 5209 :    if (flip_vertically) {

	cmp	DWORD PTR _flip_vertically$[ebp], 0
	je	$LN10@stbi__bmp_

; 5210 :       stbi_uc t;
; 5211 :       for (j=0; j < (int) s->img_y>>1; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN9@stbi__bmp_
$LN8@stbi__bmp_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN9@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sar	ecx, 1
	cmp	DWORD PTR _j$[ebp], ecx
	jge	$LN10@stbi__bmp_

; 5212 :          stbi_uc *p1 = out +      j     *s->img_x*target;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, DWORD PTR [eax]
	imul	ecx, DWORD PTR _target$[ebp]
	add	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _p1$2[ebp], ecx

; 5213 :          stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	sub	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	imul	ecx, DWORD PTR [edx]
	imul	ecx, DWORD PTR _target$[ebp]
	add	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _p2$1[ebp], ecx

; 5214 :          for (i=0; i < (int) s->img_x*target; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@stbi__bmp_
$LN5@stbi__bmp_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, DWORD PTR _target$[ebp]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN4@stbi__bmp_

; 5215 :             t = p1[i], p1[i] = p2[i], p2[i] = t;

	mov	eax, DWORD PTR _p1$2[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _t$3[ebp], cl
	mov	edx, DWORD PTR _p1$2[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _p2$1[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _p2$1[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	al, BYTE PTR _t$3[ebp]
	mov	BYTE PTR [edx], al

; 5216 :          }

	jmp	SHORT $LN5@stbi__bmp_
$LN4@stbi__bmp_:

; 5217 :       }

	jmp	$LN8@stbi__bmp_
$LN10@stbi__bmp_:

; 5218 :    }
; 5219 : 
; 5220 :    if (req_comp && req_comp != target) {

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN3@stbi__bmp_
	mov	eax, DWORD PTR _req_comp$[ebp]
	cmp	eax, DWORD PTR _target$[ebp]
	je	SHORT $LN3@stbi__bmp_

; 5221 :       out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _target$[ebp]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_stbi__convert_format
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax

; 5222 :       if (out == NULL) return out; // stbi__convert_format frees input on failure

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN3@stbi__bmp_
	mov	eax, DWORD PTR _out$[ebp]
	jmp	SHORT $LN70@stbi__bmp_
$LN3@stbi__bmp_:

; 5223 :    }
; 5224 : 
; 5225 :    *x = s->img_x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 5226 :    *y = s->img_y;

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 5227 :    if (comp) *comp = s->img_n;

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN1@stbi__bmp_
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
$LN1@stbi__bmp_:

; 5228 :    return out;

	mov	eax, DWORD PTR _out$[ebp]
$LN70@stbi__bmp_:

; 5229 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN99@stbi__bmp_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1668				; 00000684H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN99@stbi__bmp_:
	DD	2
	DD	$LN98@stbi__bmp_
$LN98@stbi__bmp_:
	DD	-1104					; fffffbb0H
	DD	1024					; 00000400H
	DD	$LN96@stbi__bmp_
	DD	-1228					; fffffb34H
	DD	32					; 00000020H
	DD	$LN97@stbi__bmp_
$LN97@stbi__bmp_:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
$LN96@stbi__bmp_:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
_stbi__bmp_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__bmp_test
_TEXT	SEGMENT
_r$ = -8						; size = 4
_s$ = 8							; size = 4
_stbi__bmp_test PROC					; COMDAT

; 4936 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4937 :    int r = stbi__bmp_test_raw(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__bmp_test_raw
	add	esp, 4
	mov	DWORD PTR _r$[ebp], eax

; 4938 :    stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__rewind
	add	esp, 4

; 4939 :    return r;

	mov	eax, DWORD PTR _r$[ebp]

; 4940 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__bmp_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__png_info
_TEXT	SEGMENT
_p$ = -24						; size = 20
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_stbi__png_info PROC					; COMDAT

; 4910 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4911 :    stbi__png p;
; 4912 :    p.s = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 4913 :    return stbi__png_info_raw(&p, x, y, comp);

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	lea	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_stbi__png_info_raw
	add	esp, 16					; 00000010H

; 4914 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi__png_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@stbi__png_:
	DD	1
	DD	$LN4@stbi__png_
$LN4@stbi__png_:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@stbi__png_
$LN3@stbi__png_:
	DB	112					; 00000070H
	DB	0
_stbi__png_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__png_load
_TEXT	SEGMENT
_p$ = -24						; size = 20
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
_stbi__png_load PROC					; COMDAT

; 4883 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4884 :    stbi__png p;
; 4885 :    p.s = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 4886 :    return stbi__do_png(&p, x,y,comp,req_comp, ri);

	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	lea	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_stbi__do_png
	add	esp, 24					; 00000018H

; 4887 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi__png_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@stbi__png_:
	DD	1
	DD	$LN4@stbi__png_
$LN4@stbi__png_:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@stbi__png_
$LN3@stbi__png_:
	DB	112					; 00000070H
	DB	0
_stbi__png_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__png_test
_TEXT	SEGMENT
_r$ = -8						; size = 4
_s$ = 8							; size = 4
_stbi__png_test PROC					; COMDAT

; 4890 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4891 :    int r;
; 4892 :    r = stbi__check_png_header(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__check_png_header
	add	esp, 4
	mov	DWORD PTR _r$[ebp], eax

; 4893 :    stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__rewind
	add	esp, 4

; 4894 :    return r;

	mov	eax, DWORD PTR _r$[ebp]

; 4895 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__png_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__jpeg_info
_TEXT	SEGMENT
_j$ = -20						; size = 4
_result$ = -8						; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_stbi__jpeg_info PROC					; COMDAT

; 3720 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3721 :    int result;
; 3722 :    stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));

	push	18456					; 00004818H
	call	_stbi__malloc
	add	esp, 4
	mov	DWORD PTR _j$[ebp], eax

; 3723 :    j->s = s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], ecx

; 3724 :    result = stbi__jpeg_info_raw(j, x, y, comp);

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__jpeg_info_raw
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], eax

; 3725 :    STBI_FREE(j);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3726 :    return result;

	mov	eax, DWORD PTR _result$[ebp]

; 3727 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__jpeg_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__jpeg_load
_TEXT	SEGMENT
_j$ = -20						; size = 4
_result$ = -8						; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
_stbi__jpeg_load PROC					; COMDAT

; 3684 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3685 :    unsigned char* result;
; 3686 :    stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));

	push	18456					; 00004818H
	call	_stbi__malloc
	add	esp, 4
	mov	DWORD PTR _j$[ebp], eax

; 3687 :    STBI_NOTUSED(ri);
; 3688 :    j->s = s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], ecx

; 3689 :    stbi__setup_jpeg(j);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__setup_jpeg
	add	esp, 4

; 3690 :    result = load_jpeg_image(j, x,y,comp,req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	_load_jpeg_image
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax

; 3691 :    STBI_FREE(j);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3692 :    return result;

	mov	eax, DWORD PTR _result$[ebp]

; 3693 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__jpeg_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__jpeg_test
_TEXT	SEGMENT
_j$ = -20						; size = 4
_r$ = -8						; size = 4
_s$ = 8							; size = 4
_stbi__jpeg_test PROC					; COMDAT

; 3696 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3697 :    int r;
; 3698 :    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));

	push	18456					; 00004818H
	call	_stbi__malloc
	add	esp, 4
	mov	DWORD PTR _j$[ebp], eax

; 3699 :    j->s = s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], ecx

; 3700 :    stbi__setup_jpeg(j);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__setup_jpeg
	add	esp, 4

; 3701 :    r = stbi__decode_jpeg_header(j, STBI__SCAN_type);

	push	1
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_stbi__decode_jpeg_header
	add	esp, 8
	mov	DWORD PTR _r$[ebp], eax

; 3702 :    stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__rewind
	add	esp, 4

; 3703 :    STBI_FREE(j);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3704 :    return r;

	mov	eax, DWORD PTR _r$[ebp]

; 3705 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__jpeg_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__rewind
_TEXT	SEGMENT
_s$ = 8							; size = 4
_stbi__rewind PROC					; COMDAT

; 756  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 757  :    // conceptually rewind SHOULD rewind to the beginning of the stream,
; 758  :    // but we just rewind to the beginning of the initial buffer, because
; 759  :    // we only use it after doing 'test', which only ever looks at at most 92 bytes
; 760  :    s->img_buffer = s->img_buffer_original;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	mov	DWORD PTR [eax+168], edx

; 761  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR [eax+172], edx

; 762  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__rewind ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__start_file
_TEXT	SEGMENT
_s$ = 8							; size = 4
_f$ = 12						; size = 4
_stbi__start_file PROC					; COMDAT

; 747  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 748  :    stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	push	OFFSET _stbi__stdio_callbacks
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__start_callbacks
	add	esp, 12					; 0000000cH

; 749  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__start_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__stdio_eof
_TEXT	SEGMENT
_user$ = 8						; size = 4
_stbi__stdio_eof PROC					; COMDAT

; 735  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 736  :    return feof((FILE*) user);

	mov	eax, DWORD PTR _user$[ebp]
	push	eax
	call	_feof
	add	esp, 4

; 737  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__stdio_eof ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__stdio_skip
_TEXT	SEGMENT
_user$ = 8						; size = 4
_n$ = 12						; size = 4
_stbi__stdio_skip PROC					; COMDAT

; 730  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 731  :    fseek((FILE*) user, n, SEEK_CUR);

	push	1
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _user$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 732  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__stdio_skip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__stdio_read
_TEXT	SEGMENT
_user$ = 8						; size = 4
_data$ = 12						; size = 4
_size$ = 16						; size = 4
_stbi__stdio_read PROC					; COMDAT

; 725  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 726  :    return (int) fread(data,1,size,(FILE*) user);

	mov	eax, DWORD PTR _user$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 727  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__stdio_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__start_callbacks
_TEXT	SEGMENT
_s$ = 8							; size = 4
_c$ = 12						; size = 4
_user$ = 16						; size = 4
_stbi__start_callbacks PROC				; COMDAT

; 712  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 713  :    s->io = *c;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 714  :    s->io_user_data = user;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _user$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 715  :    s->buflen = sizeof(s->buffer_start);

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+36], 128			; 00000080H

; 716  :    s->read_from_callbacks = 1;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+32], 1

; 717  :    s->img_buffer_original = s->buffer_start;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 718  :    stbi__refill_buffer(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__refill_buffer
	add	esp, 4

; 719  :    s->img_buffer_original_end = s->img_buffer_end;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+172]
	mov	DWORD PTR [eax+180], edx

; 720  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__start_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__start_mem
_TEXT	SEGMENT
tv70 = -196						; size = 4
_s$ = 8							; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
_stbi__start_mem PROC					; COMDAT

; 703  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 704  :    s->io.read = NULL;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+16], 0

; 705  :    s->read_from_callbacks = 0;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+32], 0

; 706  :    s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [eax+176], ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [edx+168], eax

; 707  :    s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR tv70[ebp]
	mov	DWORD PTR [ecx+180], edx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR [eax+172], ecx

; 708  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__start_mem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__refill_buffer
_TEXT	SEGMENT
_n$ = -8						; size = 4
_s$ = 8							; size = 4
_stbi__refill_buffer PROC				; COMDAT

; 1343 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1344 :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);

	mov	esi, esp
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _n$[ebp], eax

; 1345 :    if (n == 0) {

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN2@stbi__refi

; 1346 :       // at end of file, treat same as if from memory, but need to handle case
; 1347 :       // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
; 1348 :       s->read_from_callbacks = 0;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+32], 0

; 1349 :       s->img_buffer = s->buffer_start;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+168], eax

; 1350 :       s->img_buffer_end = s->buffer_start+1;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 41					; 00000029H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 1351 :       *s->img_buffer = 0;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	BYTE PTR [ecx], 0

; 1352 :    } else {

	jmp	SHORT $LN3@stbi__refi
$LN2@stbi__refi:

; 1353 :       s->img_buffer = s->buffer_start;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+168], eax

; 1354 :       s->img_buffer_end = s->buffer_start + n;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+172], edx
$LN3@stbi__refi:

; 1355 :    }
; 1356 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__refill_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__sse2_available
_TEXT	SEGMENT
tv68 = -208						; size = 4
_info3$ = -8						; size = 4
_stbi__sse2_available PROC				; COMDAT

; 644  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 645  :    int info3 = stbi__cpuid3();

	call	_stbi__cpuid3
	mov	DWORD PTR _info3$[ebp], eax

; 646  :    return ((info3 >> 26) & 1) != 0;

	mov	eax, DWORD PTR _info3$[ebp]
	sar	eax, 26					; 0000001aH
	and	eax, 1
	je	SHORT $LN3@stbi__sse2
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@stbi__sse2
$LN3@stbi__sse2:
	mov	DWORD PTR tv68[ebp], 0
$LN4@stbi__sse2:
	mov	eax, DWORD PTR tv68[ebp]

; 647  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__sse2_available ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__cpuid3
_TEXT	SEGMENT
_info$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_stbi__cpuid3 PROC					; COMDAT

; 623  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 624  :    int info[4];
; 625  :    __cpuid(info,1);

	lea	esi, DWORD PTR _info$[ebp]
	mov	eax, 1
	xor	ecx, ecx
	cpuid
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], edx

; 626  :    return info[3];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _info$[ebp+ecx]

; 627  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi__cpui
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@stbi__cpui:
	DD	1
	DD	$LN4@stbi__cpui
$LN4@stbi__cpui:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN3@stbi__cpui
$LN3@stbi__cpui:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
_stbi__cpuid3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_zlib_decode_noheader_buffer
_TEXT	SEGMENT
_a$ = -4080						; size = 4072
__$ArrayPad$ = -4					; size = 4
_obuffer$ = 8						; size = 4
_olen$ = 12						; size = 4
_ibuffer$ = 16						; size = 4
_ilen$ = 20						; size = 4
_stbi_zlib_decode_noheader_buffer PROC			; COMDAT

; 4194 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4276				; 000010b4H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-4276]
	mov	ecx, 1069				; 0000042dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4195 :    stbi__zbuf a;
; 4196 :    a.zbuffer = (stbi_uc *) ibuffer;

	mov	eax, DWORD PTR _ibuffer$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 4197 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;

	mov	eax, DWORD PTR _ibuffer$[ebp]
	add	eax, DWORD PTR _ilen$[ebp]
	mov	DWORD PTR _a$[ebp+4], eax

; 4198 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 0))

	push	0
	push	0
	mov	eax, DWORD PTR _olen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obuffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	call	_stbi__do_zlib
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN2@stbi_zlib_

; 4199 :       return (int) (a.zout - a.zout_start);

	mov	eax, DWORD PTR _a$[ebp+16]
	sub	eax, DWORD PTR _a$[ebp+20]
	jmp	SHORT $LN3@stbi_zlib_

; 4200 :    else

	jmp	SHORT $LN3@stbi_zlib_
$LN2@stbi_zlib_:

; 4201 :       return -1;

	or	eax, -1
$LN3@stbi_zlib_:

; 4202 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@stbi_zlib_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 4276				; 000010b4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@stbi_zlib_:
	DD	1
	DD	$LN6@stbi_zlib_
$LN6@stbi_zlib_:
	DD	-4080					; fffff010H
	DD	4072					; 00000fe8H
	DD	$LN5@stbi_zlib_
$LN5@stbi_zlib_:
	DB	97					; 00000061H
	DB	0
_stbi_zlib_decode_noheader_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_zlib_decode_noheader_malloc
_TEXT	SEGMENT
_p$ = -4092						; size = 4
_a$ = -4080						; size = 4072
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_outlen$ = 16						; size = 4
_stbi_zlib_decode_noheader_malloc PROC			; COMDAT

; 4178 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4288				; 000010c0H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-4288]
	mov	ecx, 1072				; 00000430H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4179 :    stbi__zbuf a;
; 4180 :    char *p = (char *) stbi__malloc(16384);

	push	16384					; 00004000H
	call	_stbi__malloc
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 4181 :    if (p == NULL) return NULL;

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN4@stbi_zlib_
	xor	eax, eax
	jmp	SHORT $LN5@stbi_zlib_
$LN4@stbi_zlib_:

; 4182 :    a.zbuffer = (stbi_uc *) buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 4183 :    a.zbuffer_end = (stbi_uc *) buffer+len;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _a$[ebp+4], eax

; 4184 :    if (stbi__do_zlib(&a, p, 16384, 1, 0)) {

	push	0
	push	1
	push	16384					; 00004000H
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_stbi__do_zlib
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN3@stbi_zlib_

; 4185 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);

	cmp	DWORD PTR _outlen$[ebp], 0
	je	SHORT $LN2@stbi_zlib_
	mov	eax, DWORD PTR _a$[ebp+16]
	sub	eax, DWORD PTR _a$[ebp+20]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@stbi_zlib_:

; 4186 :       return a.zout_start;

	mov	eax, DWORD PTR _a$[ebp+20]
	jmp	SHORT $LN5@stbi_zlib_

; 4187 :    } else {

	jmp	SHORT $LN5@stbi_zlib_
$LN3@stbi_zlib_:

; 4188 :       STBI_FREE(a.zout_start);

	mov	eax, DWORD PTR _a$[ebp+20]
	push	eax
	call	_free
	add	esp, 4

; 4189 :       return NULL;

	xor	eax, eax
$LN5@stbi_zlib_:

; 4190 :    }
; 4191 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@stbi_zlib_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 4288				; 000010c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@stbi_zlib_:
	DD	1
	DD	$LN8@stbi_zlib_
$LN8@stbi_zlib_:
	DD	-4080					; fffff010H
	DD	4072					; 00000fe8H
	DD	$LN7@stbi_zlib_
$LN7@stbi_zlib_:
	DB	97					; 00000061H
	DB	0
_stbi_zlib_decode_noheader_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_zlib_decode_buffer
_TEXT	SEGMENT
_a$ = -4080						; size = 4072
__$ArrayPad$ = -4					; size = 4
_obuffer$ = 8						; size = 4
_olen$ = 12						; size = 4
_ibuffer$ = 16						; size = 4
_ilen$ = 20						; size = 4
_stbi_zlib_decode_buffer PROC				; COMDAT

; 4167 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4276				; 000010b4H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-4276]
	mov	ecx, 1069				; 0000042dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4168 :    stbi__zbuf a;
; 4169 :    a.zbuffer = (stbi_uc *) ibuffer;

	mov	eax, DWORD PTR _ibuffer$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 4170 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;

	mov	eax, DWORD PTR _ibuffer$[ebp]
	add	eax, DWORD PTR _ilen$[ebp]
	mov	DWORD PTR _a$[ebp+4], eax

; 4171 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 1))

	push	1
	push	0
	mov	eax, DWORD PTR _olen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obuffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	call	_stbi__do_zlib
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN2@stbi_zlib_

; 4172 :       return (int) (a.zout - a.zout_start);

	mov	eax, DWORD PTR _a$[ebp+16]
	sub	eax, DWORD PTR _a$[ebp+20]
	jmp	SHORT $LN3@stbi_zlib_

; 4173 :    else

	jmp	SHORT $LN3@stbi_zlib_
$LN2@stbi_zlib_:

; 4174 :       return -1;

	or	eax, -1
$LN3@stbi_zlib_:

; 4175 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@stbi_zlib_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 4276				; 000010b4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@stbi_zlib_:
	DD	1
	DD	$LN6@stbi_zlib_
$LN6@stbi_zlib_:
	DD	-4080					; fffff010H
	DD	4072					; 00000fe8H
	DD	$LN5@stbi_zlib_
$LN5@stbi_zlib_:
	DB	97					; 00000061H
	DB	0
_stbi_zlib_decode_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_zlib_decode_malloc
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_outlen$ = 16						; size = 4
_stbi_zlib_decode_malloc PROC				; COMDAT

; 4146 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4147 :    return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);

	mov	eax, DWORD PTR _outlen$[ebp]
	push	eax
	push	16384					; 00004000H
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_stbi_zlib_decode_malloc_guesssize
	add	esp, 16					; 00000010H

; 4148 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_zlib_decode_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_zlib_decode_malloc_guesssize_headerflag
_TEXT	SEGMENT
_p$ = -4092						; size = 4
_a$ = -4080						; size = 4072
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_initial_size$ = 16					; size = 4
_outlen$ = 20						; size = 4
_parse_header$ = 24					; size = 4
_stbi_zlib_decode_malloc_guesssize_headerflag PROC	; COMDAT

; 4151 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4288				; 000010c0H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-4288]
	mov	ecx, 1072				; 00000430H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4152 :    stbi__zbuf a;
; 4153 :    char *p = (char *) stbi__malloc(initial_size);

	mov	eax, DWORD PTR _initial_size$[ebp]
	push	eax
	call	_stbi__malloc
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 4154 :    if (p == NULL) return NULL;

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN4@stbi_zlib_
	xor	eax, eax
	jmp	SHORT $LN5@stbi_zlib_
$LN4@stbi_zlib_:

; 4155 :    a.zbuffer = (stbi_uc *) buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 4156 :    a.zbuffer_end = (stbi_uc *) buffer + len;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _a$[ebp+4], eax

; 4157 :    if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {

	mov	eax, DWORD PTR _parse_header$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _initial_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_stbi__do_zlib
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN3@stbi_zlib_

; 4158 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);

	cmp	DWORD PTR _outlen$[ebp], 0
	je	SHORT $LN2@stbi_zlib_
	mov	eax, DWORD PTR _a$[ebp+16]
	sub	eax, DWORD PTR _a$[ebp+20]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@stbi_zlib_:

; 4159 :       return a.zout_start;

	mov	eax, DWORD PTR _a$[ebp+20]
	jmp	SHORT $LN5@stbi_zlib_

; 4160 :    } else {

	jmp	SHORT $LN5@stbi_zlib_
$LN3@stbi_zlib_:

; 4161 :       STBI_FREE(a.zout_start);

	mov	eax, DWORD PTR _a$[ebp+20]
	push	eax
	call	_free
	add	esp, 4

; 4162 :       return NULL;

	xor	eax, eax
$LN5@stbi_zlib_:

; 4163 :    }
; 4164 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@stbi_zlib_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 4288				; 000010c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@stbi_zlib_:
	DD	1
	DD	$LN8@stbi_zlib_
$LN8@stbi_zlib_:
	DD	-4080					; fffff010H
	DD	4072					; 00000fe8H
	DD	$LN7@stbi_zlib_
$LN7@stbi_zlib_:
	DB	97					; 00000061H
	DB	0
_stbi_zlib_decode_malloc_guesssize_headerflag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_zlib_decode_malloc_guesssize
_TEXT	SEGMENT
_p$ = -4092						; size = 4
_a$ = -4080						; size = 4072
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_initial_size$ = 16					; size = 4
_outlen$ = 20						; size = 4
_stbi_zlib_decode_malloc_guesssize PROC			; COMDAT

; 4130 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4288				; 000010c0H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-4288]
	mov	ecx, 1072				; 00000430H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4131 :    stbi__zbuf a;
; 4132 :    char *p = (char *) stbi__malloc(initial_size);

	mov	eax, DWORD PTR _initial_size$[ebp]
	push	eax
	call	_stbi__malloc
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 4133 :    if (p == NULL) return NULL;

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN4@stbi_zlib_
	xor	eax, eax
	jmp	SHORT $LN5@stbi_zlib_
$LN4@stbi_zlib_:

; 4134 :    a.zbuffer = (stbi_uc *) buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 4135 :    a.zbuffer_end = (stbi_uc *) buffer + len;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _a$[ebp+4], eax

; 4136 :    if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {

	push	1
	push	1
	mov	eax, DWORD PTR _initial_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	call	_stbi__do_zlib
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN3@stbi_zlib_

; 4137 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);

	cmp	DWORD PTR _outlen$[ebp], 0
	je	SHORT $LN2@stbi_zlib_
	mov	eax, DWORD PTR _a$[ebp+16]
	sub	eax, DWORD PTR _a$[ebp+20]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@stbi_zlib_:

; 4138 :       return a.zout_start;

	mov	eax, DWORD PTR _a$[ebp+20]
	jmp	SHORT $LN5@stbi_zlib_

; 4139 :    } else {

	jmp	SHORT $LN5@stbi_zlib_
$LN3@stbi_zlib_:

; 4140 :       STBI_FREE(a.zout_start);

	mov	eax, DWORD PTR _a$[ebp+20]
	push	eax
	call	_free
	add	esp, 4

; 4141 :       return NULL;

	xor	eax, eax
$LN5@stbi_zlib_:

; 4142 :    }
; 4143 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@stbi_zlib_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 4288				; 000010c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN9@stbi_zlib_:
	DD	1
	DD	$LN8@stbi_zlib_
$LN8@stbi_zlib_:
	DD	-4080					; fffff010H
	DD	4072					; 00000fe8H
	DD	$LN7@stbi_zlib_
$LN7@stbi_zlib_:
	DB	97					; 00000061H
	DB	0
_stbi_zlib_decode_malloc_guesssize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_set_flip_vertically_on_load
_TEXT	SEGMENT
_flag_true_if_should_flip$ = 8				; size = 4
_stbi_set_flip_vertically_on_load PROC			; COMDAT

; 952  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 953  :     stbi__vertically_flip_on_load = flag_true_if_should_flip;

	mov	eax, DWORD PTR _flag_true_if_should_flip$[ebp]
	mov	DWORD PTR _stbi__vertically_flip_on_load, eax

; 954  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_set_flip_vertically_on_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_convert_iphone_png_to_rgb
_TEXT	SEGMENT
_flag_true_if_should_convert$ = 8			; size = 4
_stbi_convert_iphone_png_to_rgb PROC			; COMDAT

; 4631 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4632 :    stbi__de_iphone_flag = flag_true_if_should_convert;

	mov	eax, DWORD PTR _flag_true_if_should_convert$[ebp]
	mov	DWORD PTR _stbi__de_iphone_flag, eax

; 4633 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_convert_iphone_png_to_rgb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_set_unpremultiply_on_load
_TEXT	SEGMENT
_flag_true_if_should_unpremultiply$ = 8			; size = 4
_stbi_set_unpremultiply_on_load PROC			; COMDAT

; 4626 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4627 :    stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;

	mov	eax, DWORD PTR _flag_true_if_should_unpremultiply$[ebp]
	mov	DWORD PTR _stbi__unpremultiply_on_load, eax

; 4628 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_set_unpremultiply_on_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_info_from_file
_TEXT	SEGMENT
_pos$ = -216						; size = 4
_s$ = -204						; size = 184
_r$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_stbi_info_from_file PROC				; COMDAT

; 6943 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 412				; 0000019cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-412]
	mov	ecx, 103				; 00000067H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6944 :    int r;
; 6945 :    stbi__context s;
; 6946 :    long pos = ftell(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _pos$[ebp], eax

; 6947 :    stbi__start_file(&s, f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__start_file
	add	esp, 8

; 6948 :    r = stbi__info_main(&s,x,y,comp);

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__info_main
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r$[ebp], eax

; 6949 :    fseek(f,pos,SEEK_SET);

	push	0
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 6950 :    return r;

	mov	eax, DWORD PTR _r$[ebp]

; 6951 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_info_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 412				; 0000019cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@stbi_info_:
	DD	1
	DD	$LN4@stbi_info_
$LN4@stbi_info_:
	DD	-204					; ffffff34H
	DD	184					; 000000b8H
	DD	$LN3@stbi_info_
$LN3@stbi_info_:
	DB	115					; 00000073H
	DB	0
_stbi_info_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_info
_TEXT	SEGMENT
_result$ = -20						; size = 4
_f$ = -8						; size = 4
_filename$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_stbi_info PROC						; COMDAT

; 6933 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 6934 :     FILE *f = stbi__fopen(filename, "rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_stbi__fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax

; 6935 :     int result;
; 6936 :     if (!f) return stbi__err("can't fopen", "Unable to open file");

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN1@stbi_info
	push	OFFSET ??_C@_0M@JPDHFAGK@can?8t?5fopen?$AA@
	call	_stbi__err
	add	esp, 4
	jmp	SHORT $LN2@stbi_info
$LN1@stbi_info:

; 6937 :     result = stbi_info_from_file(f, x, y, comp);

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_stbi_info_from_file
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], eax

; 6938 :     fclose(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 6939 :     return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN2@stbi_info:

; 6940 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_info_from_callbacks
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_c$ = 8							; size = 4
_user$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_stbi_info_from_callbacks PROC				; COMDAT

; 6962 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6963 :    stbi__context s;
; 6964 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);

	mov	eax, DWORD PTR _user$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__start_callbacks
	add	esp, 12					; 0000000cH

; 6965 :    return stbi__info_main(&s,x,y,comp);

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__info_main
	add	esp, 16					; 00000010H

; 6966 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_info_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@stbi_info_:
	DD	1
	DD	$LN4@stbi_info_
$LN4@stbi_info_:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_info_
$LN3@stbi_info_:
	DB	115					; 00000073H
	DB	0
_stbi_info_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_info_from_memory
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_stbi_info_from_memory PROC				; COMDAT

; 6955 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6956 :    stbi__context s;
; 6957 :    stbi__start_mem(&s,buffer,len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__start_mem
	add	esp, 12					; 0000000cH

; 6958 :    return stbi__info_main(&s,x,y,comp);

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_stbi__info_main
	add	esp, 16					; 00000010H

; 6959 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_info_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@stbi_info_:
	DD	1
	DD	$LN4@stbi_info_
$LN4@stbi_info_:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_info_
$LN3@stbi_info_:
	DB	115					; 00000073H
	DB	0
_stbi_info_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_image_free
_TEXT	SEGMENT
_retval_from_stbi_load$ = 8				; size = 4
_stbi_image_free PROC					; COMDAT

; 937  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 938  :    STBI_FREE(retval_from_stbi_load);

	mov	eax, DWORD PTR _retval_from_stbi_load$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 939  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_image_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_failure_reason
_TEXT	SEGMENT
_stbi_failure_reason PROC				; COMDAT

; 835  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 836  :    return stbi__g_failure_reason;

	mov	eax, DWORD PTR _stbi__g_failure_reason

; 837  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_failure_reason ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_is_hdr_from_file
_TEXT	SEGMENT
_f$ = 8							; size = 4
_stbi_is_hdr_from_file PROC				; COMDAT

; 1292 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1293 :    #ifndef STBI_NO_HDR
; 1294 :    stbi__context s;
; 1295 :    stbi__start_file(&s,f);
; 1296 :    return stbi__hdr_test(&s);
; 1297 :    #else
; 1298 :    STBI_NOTUSED(f);
; 1299 :    return 0;

	xor	eax, eax

; 1300 :    #endif
; 1301 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_is_hdr_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_is_hdr
_TEXT	SEGMENT
_result$ = -20						; size = 4
_f$ = -8						; size = 4
_filename$ = 8						; size = 4
_stbi_is_hdr PROC					; COMDAT

; 1281 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1282 :    FILE *f = stbi__fopen(filename, "rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_stbi__fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax

; 1283 :    int result=0;

	mov	DWORD PTR _result$[ebp], 0

; 1284 :    if (f) {

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN1@stbi_is_hd

; 1285 :       result = stbi_is_hdr_from_file(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_stbi_is_hdr_from_file
	add	esp, 4
	mov	DWORD PTR _result$[ebp], eax

; 1286 :       fclose(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$LN1@stbi_is_hd:

; 1287 :    }
; 1288 :    return result;

	mov	eax, DWORD PTR _result$[ebp]

; 1289 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_is_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_is_hdr_from_memory
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_stbi_is_hdr_from_memory PROC				; COMDAT

; 1267 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1268 :    #ifndef STBI_NO_HDR
; 1269 :    stbi__context s;
; 1270 :    stbi__start_mem(&s,buffer,len);
; 1271 :    return stbi__hdr_test(&s);
; 1272 :    #else
; 1273 :    STBI_NOTUSED(buffer);
; 1274 :    STBI_NOTUSED(len);
; 1275 :    return 0;

	xor	eax, eax

; 1276 :    #endif
; 1277 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_is_hdr_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_is_hdr_from_callbacks
_TEXT	SEGMENT
_clbk$ = 8						; size = 4
_user$ = 12						; size = 4
_stbi_is_hdr_from_callbacks PROC			; COMDAT

; 1305 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1306 :    #ifndef STBI_NO_HDR
; 1307 :    stbi__context s;
; 1308 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1309 :    return stbi__hdr_test(&s);
; 1310 :    #else
; 1311 :    STBI_NOTUSED(clbk);
; 1312 :    STBI_NOTUSED(user);
; 1313 :    return 0;

	xor	eax, eax

; 1314 :    #endif
; 1315 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_is_hdr_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_ldr_to_hdr_scale
_TEXT	SEGMENT
_scale$ = 8						; size = 4
_stbi_ldr_to_hdr_scale PROC				; COMDAT

; 1321 : STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR _stbi__l2h_scale, xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_ldr_to_hdr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_ldr_to_hdr_gamma
_TEXT	SEGMENT
_gamma$ = 8						; size = 4
_stbi_ldr_to_hdr_gamma PROC				; COMDAT

; 1320 : STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR _gamma$[ebp]
	movss	DWORD PTR _stbi__l2h_gamma, xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_ldr_to_hdr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_loadf_from_file
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_loadf_from_file PROC				; COMDAT

; 1253 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1254 :    stbi__context s;
; 1255 :    stbi__start_file(&s,f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__start_file
	add	esp, 8

; 1256 :    return stbi__loadf_main(&s,x,y,comp,req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__loadf_main
	add	esp, 20					; 00000014H

; 1257 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_loadf
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@stbi_loadf:
	DD	1
	DD	$LN4@stbi_loadf
$LN4@stbi_loadf:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_loadf
$LN3@stbi_loadf:
	DB	115					; 00000073H
	DB	0
_stbi_loadf_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_loadf
_TEXT	SEGMENT
tv71 = -220						; size = 4
_f$ = -20						; size = 4
_result$ = -8						; size = 4
_filename$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_loadf PROC					; COMDAT

; 1243 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1244 :    float *result;
; 1245 :    FILE *f = stbi__fopen(filename, "rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_stbi__fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax

; 1246 :    if (!f) return stbi__errpf("can't fopen", "Unable to open file");

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN1@stbi_loadf
	push	OFFSET ??_C@_0M@JPDHFAGK@can?8t?5fopen?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@stbi_loadf
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN5@stbi_loadf
$LN4@stbi_loadf:
	mov	DWORD PTR tv71[ebp], 0
$LN5@stbi_loadf:
	mov	eax, DWORD PTR tv71[ebp]
	jmp	SHORT $LN2@stbi_loadf
$LN1@stbi_loadf:

; 1247 :    result = stbi_loadf_from_file(f,x,y,comp,req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_stbi_loadf_from_file
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax

; 1248 :    fclose(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 1249 :    return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN2@stbi_loadf:

; 1250 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_loadf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_loadf_from_callbacks
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_clbk$ = 8						; size = 4
_user$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_req_comp$ = 28						; size = 4
_stbi_loadf_from_callbacks PROC				; COMDAT

; 1235 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1236 :    stbi__context s;
; 1237 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);

	mov	eax, DWORD PTR _user$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clbk$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__start_callbacks
	add	esp, 12					; 0000000cH

; 1238 :    return stbi__loadf_main(&s,x,y,comp,req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__loadf_main
	add	esp, 20					; 00000014H

; 1239 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_loadf
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@stbi_loadf:
	DD	1
	DD	$LN4@stbi_loadf
$LN4@stbi_loadf:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_loadf
$LN3@stbi_loadf:
	DB	115					; 00000073H
	DB	0
_stbi_loadf_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_loadf_from_memory
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_req_comp$ = 28						; size = 4
_stbi_loadf_from_memory PROC				; COMDAT

; 1228 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1229 :    stbi__context s;
; 1230 :    stbi__start_mem(&s,buffer,len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__start_mem
	add	esp, 12					; 0000000cH

; 1231 :    return stbi__loadf_main(&s,x,y,comp,req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__loadf_main
	add	esp, 20					; 00000014H

; 1232 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_loadf
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@stbi_loadf:
	DD	1
	DD	$LN4@stbi_loadf
$LN4@stbi_loadf:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_loadf
$LN3@stbi_loadf:
	DB	115					; 00000073H
	DB	0
_stbi_loadf_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_load_from_file_16
_TEXT	SEGMENT
_s$ = -204						; size = 184
_result$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_load_from_file_16 PROC				; COMDAT

; 1155 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-400]
	mov	ecx, 100				; 00000064H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1156 :    stbi__uint16 *result;
; 1157 :    stbi__context s;
; 1158 :    stbi__start_file(&s,f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__start_file
	add	esp, 8

; 1159 :    result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__load_and_postprocess_16bit
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax

; 1160 :    if (result) {

	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN1@stbi_load_

; 1161 :       // need to 'unget' all the characters in the IO buffer
; 1162 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);

	push	1
	mov	eax, DWORD PTR _s$[ebp+172]
	sub	eax, DWORD PTR _s$[ebp+168]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH
$LN1@stbi_load_:

; 1163 :    }
; 1164 :    return result;

	mov	eax, DWORD PTR _result$[ebp]

; 1165 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@stbi_load_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 400				; 00000190H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@stbi_load_:
	DD	1
	DD	$LN5@stbi_load_
$LN5@stbi_load_:
	DD	-204					; ffffff34H
	DD	184					; 000000b8H
	DD	$LN4@stbi_load_
$LN4@stbi_load_:
	DB	115					; 00000073H
	DB	0
_stbi_load_from_file_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_load_16
_TEXT	SEGMENT
tv71 = -220						; size = 4
_result$ = -20						; size = 4
_f$ = -8						; size = 4
_filename$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_load_16 PROC					; COMDAT

; 1168 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1169 :    FILE *f = stbi__fopen(filename, "rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_stbi__fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax

; 1170 :    stbi__uint16 *result;
; 1171 :    if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN1@stbi_load_
	push	OFFSET ??_C@_0M@JPDHFAGK@can?8t?5fopen?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@stbi_load_
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN5@stbi_load_
$LN4@stbi_load_:
	mov	DWORD PTR tv71[ebp], 0
$LN5@stbi_load_:
	mov	eax, DWORD PTR tv71[ebp]
	jmp	SHORT $LN2@stbi_load_
$LN1@stbi_load_:

; 1172 :    result = stbi_load_from_file_16(f,x,y,comp,req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_stbi_load_from_file_16
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax

; 1173 :    fclose(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 1174 :    return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN2@stbi_load_:

; 1175 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_load_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_load_16_from_callbacks
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_clbk$ = 8						; size = 4
_user$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_channels_in_file$ = 24					; size = 4
_desired_channels$ = 28					; size = 4
_stbi_load_16_from_callbacks PROC			; COMDAT

; 1188 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1189 :    stbi__context s;
; 1190 :    stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);

	mov	eax, DWORD PTR _user$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clbk$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__start_callbacks
	add	esp, 12					; 0000000cH

; 1191 :    return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);

	mov	eax, DWORD PTR _desired_channels$[ebp]
	push	eax
	mov	ecx, DWORD PTR _channels_in_file$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__load_and_postprocess_16bit
	add	esp, 20					; 00000014H

; 1192 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_load_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@stbi_load_:
	DD	1
	DD	$LN4@stbi_load_
$LN4@stbi_load_:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_load_
$LN3@stbi_load_:
	DB	115					; 00000073H
	DB	0
_stbi_load_16_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_load_16_from_memory
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_channels_in_file$ = 24					; size = 4
_desired_channels$ = 28					; size = 4
_stbi_load_16_from_memory PROC				; COMDAT

; 1181 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1182 :    stbi__context s;
; 1183 :    stbi__start_mem(&s,buffer,len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__start_mem
	add	esp, 12					; 0000000cH

; 1184 :    return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);

	mov	eax, DWORD PTR _desired_channels$[ebp]
	push	eax
	mov	ecx, DWORD PTR _channels_in_file$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__load_and_postprocess_16bit
	add	esp, 20					; 00000014H

; 1185 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_load_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@stbi_load_:
	DD	1
	DD	$LN4@stbi_load_
$LN4@stbi_load_:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_load_
$LN3@stbi_load_:
	DB	115					; 00000073H
	DB	0
_stbi_load_16_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_load_from_file
_TEXT	SEGMENT
_s$ = -204						; size = 184
_result$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_load_from_file PROC				; COMDAT

; 1142 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-400]
	mov	ecx, 100				; 00000064H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1143 :    unsigned char *result;
; 1144 :    stbi__context s;
; 1145 :    stbi__start_file(&s,f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__start_file
	add	esp, 8

; 1146 :    result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__load_and_postprocess_8bit
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax

; 1147 :    if (result) {

	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN1@stbi_load_

; 1148 :       // need to 'unget' all the characters in the IO buffer
; 1149 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);

	push	1
	mov	eax, DWORD PTR _s$[ebp+172]
	sub	eax, DWORD PTR _s$[ebp+168]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH
$LN1@stbi_load_:

; 1150 :    }
; 1151 :    return result;

	mov	eax, DWORD PTR _result$[ebp]

; 1152 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@stbi_load_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 400				; 00000190H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@stbi_load_:
	DD	1
	DD	$LN5@stbi_load_
$LN5@stbi_load_:
	DD	-204					; ffffff34H
	DD	184					; 000000b8H
	DD	$LN4@stbi_load_
$LN4@stbi_load_:
	DB	115					; 00000073H
	DB	0
_stbi_load_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_load
_TEXT	SEGMENT
tv71 = -220						; size = 4
_result$ = -20						; size = 4
_f$ = -8						; size = 4
_filename$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_load PROC						; COMDAT

; 1132 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1133 :    FILE *f = stbi__fopen(filename, "rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_stbi__fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax

; 1134 :    unsigned char *result;
; 1135 :    if (!f) return stbi__errpuc("can't fopen", "Unable to open file");

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN1@stbi_load
	push	OFFSET ??_C@_0M@JPDHFAGK@can?8t?5fopen?$AA@
	call	_stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@stbi_load
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN5@stbi_load
$LN4@stbi_load:
	mov	DWORD PTR tv71[ebp], 0
$LN5@stbi_load:
	mov	eax, DWORD PTR tv71[ebp]
	jmp	SHORT $LN2@stbi_load
$LN1@stbi_load:

; 1136 :    result = stbi_load_from_file(f,x,y,comp,req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_stbi_load_from_file
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax

; 1137 :    fclose(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 1138 :    return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN2@stbi_load:

; 1139 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_load_from_callbacks
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_clbk$ = 8						; size = 4
_user$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_req_comp$ = 28						; size = 4
_stbi_load_from_callbacks PROC				; COMDAT

; 1202 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1203 :    stbi__context s;
; 1204 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);

	mov	eax, DWORD PTR _user$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clbk$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__start_callbacks
	add	esp, 12					; 0000000cH

; 1205 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__load_and_postprocess_8bit
	add	esp, 20					; 00000014H

; 1206 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_load_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@stbi_load_:
	DD	1
	DD	$LN4@stbi_load_
$LN4@stbi_load_:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_load_
$LN3@stbi_load_:
	DB	115					; 00000073H
	DB	0
_stbi_load_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi_load_from_memory
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_req_comp$ = 28						; size = 4
_stbi_load_from_memory PROC				; COMDAT

; 1195 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1196 :    stbi__context s;
; 1197 :    stbi__start_mem(&s,buffer,len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_stbi__start_mem
	add	esp, 12					; 0000000cH

; 1198 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_stbi__load_and_postprocess_8bit
	add	esp, 20					; 00000014H

; 1199 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_load_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@stbi_load_:
	DD	1
	DD	$LN4@stbi_load_
$LN4@stbi_load_:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_load_
$LN3@stbi_load_:
	DB	115					; 00000073H
	DB	0
_stbi_load_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawSys
_TEXT	SEGMENT
tv73 = -208						; size = 4
_i$ = -8						; size = 2
_DrawSys PROC						; COMDAT

; 8615 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 8616 : 	register uint16 i=0;

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax

; 8617 : 
; 8618 : 	for(i=0;i<st.num_calls;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN11@DrawSys
$LN10@DrawSys:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN11@DrawSys:
	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _st+262
	cmp	eax, ecx
	jge	$LN12@DrawSys

; 8619 : 	{
; 8620 : 		switch(st.renderer.ppline[i].type)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336876]
	mov	DWORD PTR tv73[ebp], edx
	cmp	DWORD PTR tv73[ebp], 8
	ja	$LN7@DrawSys
	mov	eax, DWORD PTR tv73[ebp]
	jmp	DWORD PTR $LN14@DrawSys[eax*4]
$LN6@DrawSys:

; 8621 : 		{	
; 8622 : #ifndef MGEAR_CLEAN_VERSION
; 8623 : 			case GRAPHICS_CALL: DrawGraphic(st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,st.renderer.ppline[i].color.r,
; 8624 : 									st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].data,st.renderer.ppline[i].color.a,st.renderer.ppline[i].tex_panx,st.renderer.ppline[i].tex_pany,
; 8625 : 									st.renderer.ppline[i].tex_sizex,st.renderer.ppline[i].tex_sizey,st.renderer.ppline[i].pos.z,0); break;
; 8626 : 
; 8627 : 			case HUD_CALL: DrawHud(st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,st.renderer.ppline[i].color.r,
; 8628 : 							  st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].tex_panx,st.renderer.ppline[i].tex_pany,st.renderer.ppline[i].tex_sizex,
; 8629 : 							  st.renderer.ppline[i].tex_sizey,st.renderer.ppline[i].data,st.renderer.ppline[i].color.a,st.renderer.ppline[i].pos.z); break;
; 8630 : #endif
; 8631 : 			case UI_CALL: DrawUI(st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,st.renderer.ppline[i].color.r,
; 8632 : 							  st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].tex_panx,st.renderer.ppline[i].tex_pany,st.renderer.ppline[i].tex_sizex,
; 8633 : 							  st.renderer.ppline[i].tex_sizey,st.renderer.ppline[i].data,st.renderer.ppline[i].color.a,st.renderer.ppline[i].pos.z); break;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336888]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336931]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	esi, eax, 372
	add	esi, OFFSET _st+2337208
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	mov	eax, DWORD PTR _st[edx+2337200]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	mov	eax, DWORD PTR _st[edx+2337196]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	mov	eax, DWORD PTR _st[edx+2337192]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	mov	eax, DWORD PTR _st[edx+2337188]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	movzx	eax, BYTE PTR _st[edx+2336930]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	movzx	eax, BYTE PTR _st[edx+2336929]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	movzx	eax, BYTE PTR _st[edx+2336928]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	movzx	eax, WORD PTR _st[edx+2337204]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	mov	eax, DWORD PTR _st[edx+2336908]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	mov	eax, DWORD PTR _st[edx+2336904]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	mov	eax, DWORD PTR _st[edx+2336884]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	mov	eax, DWORD PTR _st[edx+2336880]
	push	eax
	call	_DrawUI
	add	esp, 96					; 00000060H
	jmp	$LN7@DrawSys
$LN5@DrawSys:

; 8634 : #ifndef MGEAR_CLEAN_VERSION
; 8635 : 			case STRING_CALL: DrawString(st.renderer.ppline[i].text,st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,
; 8636 : 								  st.renderer.ppline[i].color.r,st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].color.a,st.renderer.ppline[i].font,st.renderer.ppline[i].size2.x,
; 8637 : 								  st.renderer.ppline[i].size2.y,st.renderer.ppline[i].pos.z); break;
; 8638 : #endif
; 8639 : 			case STRING2_CALL: DrawString2(st.renderer.ppline[i].text,st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,
; 8640 : 								  st.renderer.ppline[i].color.r,st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].color.a,st.renderer.ppline[i].font,st.renderer.ppline[i].size2.x,
; 8641 : 								  st.renderer.ppline[i].size2.y,st.renderer.ppline[i].pos.z); break;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336888]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336920]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336916]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2337206]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336931]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336930]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336929]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336928]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, WORD PTR _st[ecx+2337204]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336908]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336904]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336884]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336880]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	add	ecx, OFFSET _st+2336932
	push	ecx
	call	_DrawString2
	add	esp, 56					; 00000038H
	jmp	$LN7@DrawSys
$LN4@DrawSys:

; 8642 : 
; 8643 : 			case STRINGUI_CALL: DrawStringUI(st.renderer.ppline[i].text,st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,
; 8644 : 								  st.renderer.ppline[i].color.r,st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].color.a,st.renderer.ppline[i].font,st.renderer.ppline[i].size2.x,
; 8645 : 								  st.renderer.ppline[i].size2.y,st.renderer.ppline[i].pos.z); break;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336888]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336920]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336916]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2337206]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336931]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336930]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336929]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336928]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, WORD PTR _st[ecx+2337204]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336908]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336904]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336884]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336880]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	add	ecx, OFFSET _st+2336932
	push	ecx
	call	_DrawStringUI
	add	esp, 56					; 00000038H
	jmp	$LN7@DrawSys
$LN3@DrawSys:

; 8646 : 
; 8647 : 			case STRINGUI2_CALL: DrawString2UI(st.renderer.ppline[i].text,st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,
; 8648 : 								  st.renderer.ppline[i].color.r,st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].color.a,st.renderer.ppline[i].font,st.renderer.ppline[i].size2.x,
; 8649 : 								  st.renderer.ppline[i].size2.y,st.renderer.ppline[i].pos.z); break;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336888]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336920]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336916]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2337206]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336931]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336930]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336929]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336928]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, WORD PTR _st[ecx+2337204]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336908]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336904]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336884]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336880]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	add	ecx, OFFSET _st+2336932
	push	ecx
	call	_DrawString2UI
	add	esp, 56					; 00000038H
	jmp	$LN7@DrawSys
$LN2@DrawSys:

; 8650 : 
; 8651 : 			case LINE_CALL: DrawLine(st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].pos2.x,st.renderer.ppline[i].pos2.y,st.renderer.ppline[i].color.r,st.renderer.ppline[i].color.g,
; 8652 : 								st.renderer.ppline[i].color.b,st.renderer.ppline[i].color.a,st.renderer.ppline[i].size.x,st.renderer.ppline[i].pos.z); break;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336888]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, WORD PTR _st[ecx+2336904]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336931]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336930]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336929]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336928]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336896]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336892]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336884]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336880]
	push	edx
	call	_DrawLine
	add	esp, 40					; 00000028H
	jmp	$LN7@DrawSys
$LN1@DrawSys:

; 8653 : 
; 8654 : 			case STRINGUIV_CALL: DrawStringUIv(st.renderer.ppline[i].text,st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,
; 8655 : 								  st.renderer.ppline[i].color.r,st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].color.a,st.renderer.ppline[i].font,st.renderer.ppline[i].size2.x,
; 8656 : 								  st.renderer.ppline[i].size2.y,st.renderer.ppline[i].pos.z); break;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336888]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336920]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336916]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2337206]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336931]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336930]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336929]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, BYTE PTR _st[ecx+2336928]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movzx	edx, WORD PTR _st[ecx+2337204]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336908]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336904]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336884]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _st[ecx+2336880]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	add	ecx, OFFSET _st+2336932
	push	ecx
	call	_DrawStringUIv
	add	esp, 56					; 00000038H
$LN7@DrawSys:

; 8657 : 		}
; 8658 : 	}

	jmp	$LN10@DrawSys
$LN12@DrawSys:

; 8659 : 
; 8660 : 	//Finish();
; 8661 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN14@DrawSys:
	DD	$LN6@DrawSys
	DD	$LN7@DrawSys
	DD	$LN2@DrawSys
	DD	$LN7@DrawSys
	DD	$LN7@DrawSys
	DD	$LN5@DrawSys
	DD	$LN4@DrawSys
	DD	$LN3@DrawSys
	DD	$LN1@DrawSys
_DrawSys ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _Finish
_TEXT	SEGMENT
_i$ = -8						; size = 2
_Finish	PROC						; COMDAT

; 9477 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9478 : 	register uint16 i=0;

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax

; 9479 : 
; 9480 : 	//for(i=0;i<st.num_calls;i++)
; 9481 : 		//if(st.renderer.ppline[i].type>3)
; 9482 : 			//free(st.renderer.ppline[i].text);
; 9483 : 
; 9484 : 	st.num_calls=0;

	xor	eax, eax
	mov	WORD PTR _st+262, ax

; 9485 : 
; 9486 : 	memset(st.renderer.ppline,MAX_DRAWCALLS,sizeof(PIPELINE));

	push	372					; 00000174H
	push	1024					; 00000400H
	push	OFFSET _st+2336876
	call	_memset
	add	esp, 12					; 0000000cH

; 9487 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_Finish	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _StringData
_TEXT	SEGMENT
_i$ = -8						; size = 2
_text$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_sizex$ = 20						; size = 4
_sizey$ = 24						; size = 4
_ang$ = 28						; size = 2
_r$ = 32						; size = 1
_g$ = 36						; size = 1
_b$ = 40						; size = 1
_a$ = 44						; size = 1
_font$ = 48						; size = 1
_override_sizex$ = 52					; size = 4
_override_sizey$ = 56					; size = 4
_z$ = 60						; size = 1
_StringData PROC					; COMDAT

; 5720 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5721 : 	uint16 i=st.num_calls;

	mov	ax, WORD PTR _st+262
	mov	WORD PTR _i$[ebp], ax

; 5722 : 
; 5723 : 	st.renderer.ppline[i].pos.x=x;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _st[ecx+2336880], edx

; 5724 : 	st.renderer.ppline[i].pos.y=y;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _st[ecx+2336884], edx

; 5725 : 	st.renderer.ppline[i].pos.z=z;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movsx	edx, BYTE PTR _z$[ebp]
	mov	DWORD PTR _st[ecx+2336888], edx

; 5726 : 	st.renderer.ppline[i].size.x=sizex;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _sizex$[ebp]
	mov	DWORD PTR _st[ecx+2336904], edx

; 5727 : 	st.renderer.ppline[i].size.y=sizey;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _sizey$[ebp]
	mov	DWORD PTR _st[ecx+2336908], edx

; 5728 : 	st.renderer.ppline[i].size2.x=override_sizex;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _override_sizex$[ebp]
	mov	DWORD PTR _st[ecx+2336916], edx

; 5729 : 	st.renderer.ppline[i].size2.y=override_sizey;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _override_sizey$[ebp]
	mov	DWORD PTR _st[ecx+2336920], edx

; 5730 : 	st.renderer.ppline[i].ang=ang;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dx, WORD PTR _ang$[ebp]
	mov	WORD PTR _st[ecx+2337204], dx

; 5731 : 	st.renderer.ppline[i].color.r=r;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _st[ecx+2336928], dl

; 5732 : 	st.renderer.ppline[i].color.g=g;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _st[ecx+2336929], dl

; 5733 : 	st.renderer.ppline[i].color.b=b;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _st[ecx+2336930], dl

; 5734 : 	st.renderer.ppline[i].color.a=a;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR _st[ecx+2336931], dl

; 5735 : 	//st.renderer.ppline[i].text=malloc(strlen(text));
; 5736 : 	strcpy(st.renderer.ppline[i].text,text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	add	edx, OFFSET _st+2336932
	push	edx
	call	_strcpy
	add	esp, 8

; 5737 : 	st.renderer.ppline[i].font=font;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _font$[ebp]
	mov	BYTE PTR _st[ecx+2337206], dl

; 5738 : 
; 5739 : 	st.renderer.ppline[i].type=STRING_CALL;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	BYTE PTR _st[ecx+2336876], 4

; 5740 : 
; 5741 : 	st.num_calls++;

	mov	ax, WORD PTR _st+262
	add	ax, 1
	mov	WORD PTR _st+262, ax

; 5742 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_StringData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _String2Data
_TEXT	SEGMENT
_i$ = -8						; size = 2
_text$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_sizex$ = 20						; size = 4
_sizey$ = 24						; size = 4
_ang$ = 28						; size = 2
_r$ = 32						; size = 1
_g$ = 36						; size = 1
_b$ = 40						; size = 1
_a$ = 44						; size = 1
_font$ = 48						; size = 1
_override_sizex$ = 52					; size = 4
_override_sizey$ = 56					; size = 4
_z$ = 60						; size = 1
_String2Data PROC					; COMDAT

; 5695 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5696 : 	uint16 i=st.num_calls;

	mov	ax, WORD PTR _st+262
	mov	WORD PTR _i$[ebp], ax

; 5697 : 
; 5698 : 	st.renderer.ppline[i].pos.x=x;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _st[ecx+2336880], edx

; 5699 : 	st.renderer.ppline[i].pos.y=y;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _st[ecx+2336884], edx

; 5700 : 	st.renderer.ppline[i].pos.z=z;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movsx	edx, BYTE PTR _z$[ebp]
	mov	DWORD PTR _st[ecx+2336888], edx

; 5701 : 	st.renderer.ppline[i].size.x=sizex;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _sizex$[ebp]
	mov	DWORD PTR _st[ecx+2336904], edx

; 5702 : 	st.renderer.ppline[i].size.y=sizey;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _sizey$[ebp]
	mov	DWORD PTR _st[ecx+2336908], edx

; 5703 : 	st.renderer.ppline[i].size2.x=override_sizex;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _override_sizex$[ebp]
	mov	DWORD PTR _st[ecx+2336916], edx

; 5704 : 	st.renderer.ppline[i].size2.y=override_sizey;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _override_sizey$[ebp]
	mov	DWORD PTR _st[ecx+2336920], edx

; 5705 : 	st.renderer.ppline[i].ang=ang;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dx, WORD PTR _ang$[ebp]
	mov	WORD PTR _st[ecx+2337204], dx

; 5706 : 	st.renderer.ppline[i].color.r=r;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _st[ecx+2336928], dl

; 5707 : 	st.renderer.ppline[i].color.g=g;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _st[ecx+2336929], dl

; 5708 : 	st.renderer.ppline[i].color.b=b;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _st[ecx+2336930], dl

; 5709 : 	st.renderer.ppline[i].color.a=a;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR _st[ecx+2336931], dl

; 5710 : 	//st.renderer.ppline[i].text=malloc(strlen(text));
; 5711 : 	strcpy(st.renderer.ppline[i].text,text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	add	edx, OFFSET _st+2336932
	push	edx
	call	_strcpy
	add	esp, 8

; 5712 : 	st.renderer.ppline[i].font=font;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _font$[ebp]
	mov	BYTE PTR _st[ecx+2337206], dl

; 5713 : 
; 5714 : 	st.renderer.ppline[i].type=STRING2_CALL;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	BYTE PTR _st[ecx+2336876], 5

; 5715 : 
; 5716 : 	st.num_calls++;

	mov	ax, WORD PTR _st+262
	add	ax, 1
	mov	WORD PTR _st+262, ax

; 5717 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_String2Data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _StringUIvData
_TEXT	SEGMENT
_i$ = -8						; size = 2
_text$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_sizex$ = 20						; size = 4
_sizey$ = 24						; size = 4
_ang$ = 28						; size = 2
_r$ = 32						; size = 1
_g$ = 36						; size = 1
_b$ = 40						; size = 1
_a$ = 44						; size = 1
_font$ = 48						; size = 1
_override_sizex$ = 52					; size = 4
_override_sizey$ = 56					; size = 4
_z$ = 60						; size = 1
_StringUIvData PROC					; COMDAT

; 5745 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5746 : 	uint16 i=st.num_calls;

	mov	ax, WORD PTR _st+262
	mov	WORD PTR _i$[ebp], ax

; 5747 : 
; 5748 : 	st.renderer.ppline[i].pos.x=x;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _st[ecx+2336880], edx

; 5749 : 	st.renderer.ppline[i].pos.y=y;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _st[ecx+2336884], edx

; 5750 : 	st.renderer.ppline[i].pos.z=z;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movsx	edx, BYTE PTR _z$[ebp]
	mov	DWORD PTR _st[ecx+2336888], edx

; 5751 : 	st.renderer.ppline[i].size.x=sizex;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _sizex$[ebp]
	mov	DWORD PTR _st[ecx+2336904], edx

; 5752 : 	st.renderer.ppline[i].size.y=sizey;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _sizey$[ebp]
	mov	DWORD PTR _st[ecx+2336908], edx

; 5753 : 	st.renderer.ppline[i].size2.x=override_sizex;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _override_sizex$[ebp]
	mov	DWORD PTR _st[ecx+2336916], edx

; 5754 : 	st.renderer.ppline[i].size2.y=override_sizey;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _override_sizey$[ebp]
	mov	DWORD PTR _st[ecx+2336920], edx

; 5755 : 	st.renderer.ppline[i].ang=ang;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dx, WORD PTR _ang$[ebp]
	mov	WORD PTR _st[ecx+2337204], dx

; 5756 : 	st.renderer.ppline[i].color.r=r;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _st[ecx+2336928], dl

; 5757 : 	st.renderer.ppline[i].color.g=g;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _st[ecx+2336929], dl

; 5758 : 	st.renderer.ppline[i].color.b=b;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _st[ecx+2336930], dl

; 5759 : 	st.renderer.ppline[i].color.a=a;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR _st[ecx+2336931], dl

; 5760 : 	//st.renderer.ppline[i].text=malloc(strlen(text));
; 5761 : 	strcpy(st.renderer.ppline[i].text,text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	add	edx, OFFSET _st+2336932
	push	edx
	call	_strcpy
	add	esp, 8

; 5762 : 	st.renderer.ppline[i].font=font;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _font$[ebp]
	mov	BYTE PTR _st[ecx+2337206], dl

; 5763 : 
; 5764 : 	st.renderer.ppline[i].type=STRINGUIV_CALL;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	BYTE PTR _st[ecx+2336876], 8

; 5765 : 
; 5766 : 	st.num_calls++;

	mov	ax, WORD PTR _st+262
	add	ax, 1
	mov	WORD PTR _st+262, ax

; 5767 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_StringUIvData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _StringUIData
_TEXT	SEGMENT
_i$ = -8						; size = 2
_text$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_sizex$ = 20						; size = 4
_sizey$ = 24						; size = 4
_ang$ = 28						; size = 2
_r$ = 32						; size = 1
_g$ = 36						; size = 1
_b$ = 40						; size = 1
_a$ = 44						; size = 1
_font$ = 48						; size = 1
_override_sizex$ = 52					; size = 4
_override_sizey$ = 56					; size = 4
_z$ = 60						; size = 1
_StringUIData PROC					; COMDAT

; 5770 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5771 : 	uint16 i=st.num_calls;

	mov	ax, WORD PTR _st+262
	mov	WORD PTR _i$[ebp], ax

; 5772 : 
; 5773 : 	st.renderer.ppline[i].pos.x=x;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _st[ecx+2336880], edx

; 5774 : 	st.renderer.ppline[i].pos.y=y;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _st[ecx+2336884], edx

; 5775 : 	st.renderer.ppline[i].pos.z=z;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movsx	edx, BYTE PTR _z$[ebp]
	mov	DWORD PTR _st[ecx+2336888], edx

; 5776 : 	st.renderer.ppline[i].size.x=sizex;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _sizex$[ebp]
	mov	DWORD PTR _st[ecx+2336904], edx

; 5777 : 	st.renderer.ppline[i].size.y=sizey;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _sizey$[ebp]
	mov	DWORD PTR _st[ecx+2336908], edx

; 5778 : 	st.renderer.ppline[i].size2.x=override_sizex;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _override_sizex$[ebp]
	mov	DWORD PTR _st[ecx+2336916], edx

; 5779 : 	st.renderer.ppline[i].size2.y=override_sizey;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _override_sizey$[ebp]
	mov	DWORD PTR _st[ecx+2336920], edx

; 5780 : 	st.renderer.ppline[i].ang=ang;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dx, WORD PTR _ang$[ebp]
	mov	WORD PTR _st[ecx+2337204], dx

; 5781 : 	st.renderer.ppline[i].color.r=r;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _st[ecx+2336928], dl

; 5782 : 	st.renderer.ppline[i].color.g=g;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _st[ecx+2336929], dl

; 5783 : 	st.renderer.ppline[i].color.b=b;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _st[ecx+2336930], dl

; 5784 : 	st.renderer.ppline[i].color.a=a;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR _st[ecx+2336931], dl

; 5785 : 	//st.renderer.ppline[i].text=malloc(strlen(text));
; 5786 : 	strcpy(st.renderer.ppline[i].text,text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	add	edx, OFFSET _st+2336932
	push	edx
	call	_strcpy
	add	esp, 8

; 5787 : 	st.renderer.ppline[i].font=font;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _font$[ebp]
	mov	BYTE PTR _st[ecx+2337206], dl

; 5788 : 
; 5789 : 	st.renderer.ppline[i].type=STRINGUI_CALL;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	BYTE PTR _st[ecx+2336876], 6

; 5790 : 
; 5791 : 	st.num_calls++;

	mov	ax, WORD PTR _st+262
	add	ax, 1
	mov	WORD PTR _st+262, ax

; 5792 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_StringUIData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _StringUI2Data
_TEXT	SEGMENT
_i$ = -8						; size = 2
_text$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_sizex$ = 20						; size = 4
_sizey$ = 24						; size = 4
_ang$ = 28						; size = 2
_r$ = 32						; size = 1
_g$ = 36						; size = 1
_b$ = 40						; size = 1
_a$ = 44						; size = 1
_font$ = 48						; size = 1
_override_sizex$ = 52					; size = 4
_override_sizey$ = 56					; size = 4
_z$ = 60						; size = 1
_StringUI2Data PROC					; COMDAT

; 5795 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5796 : 	uint16 i=st.num_calls;

	mov	ax, WORD PTR _st+262
	mov	WORD PTR _i$[ebp], ax

; 5797 : 
; 5798 : 	st.renderer.ppline[i].pos.x=x;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _st[ecx+2336880], edx

; 5799 : 	st.renderer.ppline[i].pos.y=y;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _st[ecx+2336884], edx

; 5800 : 	st.renderer.ppline[i].pos.z=z;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movsx	edx, BYTE PTR _z$[ebp]
	mov	DWORD PTR _st[ecx+2336888], edx

; 5801 : 	st.renderer.ppline[i].size.x=sizex;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _sizex$[ebp]
	mov	DWORD PTR _st[ecx+2336904], edx

; 5802 : 	st.renderer.ppline[i].size.y=sizey;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _sizey$[ebp]
	mov	DWORD PTR _st[ecx+2336908], edx

; 5803 : 	st.renderer.ppline[i].size2.x=override_sizex;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _override_sizex$[ebp]
	mov	DWORD PTR _st[ecx+2336916], edx

; 5804 : 	st.renderer.ppline[i].size2.y=override_sizey;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _override_sizey$[ebp]
	mov	DWORD PTR _st[ecx+2336920], edx

; 5805 : 	st.renderer.ppline[i].ang=ang;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dx, WORD PTR _ang$[ebp]
	mov	WORD PTR _st[ecx+2337204], dx

; 5806 : 	st.renderer.ppline[i].color.r=r;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _st[ecx+2336928], dl

; 5807 : 	st.renderer.ppline[i].color.g=g;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _st[ecx+2336929], dl

; 5808 : 	st.renderer.ppline[i].color.b=b;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _st[ecx+2336930], dl

; 5809 : 	st.renderer.ppline[i].color.a=a;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR _st[ecx+2336931], dl

; 5810 : 	//st.renderer.ppline[i].text=malloc(strlen(text));
; 5811 : 	strcpy(st.renderer.ppline[i].text,text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 372
	add	edx, OFFSET _st+2336932
	push	edx
	call	_strcpy
	add	esp, 8

; 5812 : 	st.renderer.ppline[i].font=font;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _font$[ebp]
	mov	BYTE PTR _st[ecx+2337206], dl

; 5813 : 
; 5814 : 	st.renderer.ppline[i].type=STRINGUI2_CALL;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	BYTE PTR _st[ecx+2336876], 7

; 5815 : 
; 5816 : 	st.num_calls++;

	mov	ax, WORD PTR _st+262
	add	ax, 1
	mov	WORD PTR _st+262, ax

; 5817 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_StringUI2Data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _UIData
_TEXT	SEGMENT
_i$ = -8						; size = 2
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_sizex$ = 16						; size = 4
_sizey$ = 20						; size = 4
_ang$ = 24						; size = 2
_r$ = 28						; size = 1
_g$ = 32						; size = 1
_b$ = 36						; size = 1
_x1$ = 40						; size = 4
_y1$ = 44						; size = 4
_x2$ = 48						; size = 4
_y2$ = 52						; size = 4
_data$ = 56						; size = 40
_a$ = 96						; size = 1
_layer$ = 100						; size = 1
_UIData	PROC						; COMDAT

; 5641 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5642 : 	uint16 i=st.num_calls;

	mov	ax, WORD PTR _st+262
	mov	WORD PTR _i$[ebp], ax

; 5643 : 
; 5644 : 	st.renderer.ppline[i].pos.x=x;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _st[ecx+2336880], edx

; 5645 : 	st.renderer.ppline[i].pos.y=y;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _st[ecx+2336884], edx

; 5646 : 	st.renderer.ppline[i].pos.z=layer;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	movsx	edx, BYTE PTR _layer$[ebp]
	mov	DWORD PTR _st[ecx+2336888], edx

; 5647 : 	st.renderer.ppline[i].size.x=sizex;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _sizex$[ebp]
	mov	DWORD PTR _st[ecx+2336904], edx

; 5648 : 	st.renderer.ppline[i].size.y=sizey;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _sizey$[ebp]
	mov	DWORD PTR _st[ecx+2336908], edx

; 5649 : 	st.renderer.ppline[i].ang=ang;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dx, WORD PTR _ang$[ebp]
	mov	WORD PTR _st[ecx+2337204], dx

; 5650 : 	st.renderer.ppline[i].color.r=r;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _st[ecx+2336928], dl

; 5651 : 	st.renderer.ppline[i].color.g=g;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _st[ecx+2336929], dl

; 5652 : 	st.renderer.ppline[i].color.b=b;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _st[ecx+2336930], dl

; 5653 : 	st.renderer.ppline[i].color.a=a;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR _st[ecx+2336931], dl

; 5654 : 	st.renderer.ppline[i].tex_panx=x1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _x1$[ebp]
	mov	DWORD PTR _st[ecx+2337188], edx

; 5655 : 	st.renderer.ppline[i].tex_pany=y1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _y1$[ebp]
	mov	DWORD PTR _st[ecx+2337192], edx

; 5656 : 	st.renderer.ppline[i].tex_sizex=x2;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _x2$[ebp]
	mov	DWORD PTR _st[ecx+2337196], edx

; 5657 : 	st.renderer.ppline[i].tex_sizey=y2;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	edx, DWORD PTR _y2$[ebp]
	mov	DWORD PTR _st[ecx+2337200], edx

; 5658 : 	st.renderer.ppline[i].data=data;

	movzx	eax, WORD PTR _i$[ebp]
	imul	edi, eax, 372
	add	edi, OFFSET _st+2337208
	mov	ecx, 10					; 0000000aH
	lea	esi, DWORD PTR _data$[ebp]
	rep movsd

; 5659 : 
; 5660 : 	st.renderer.ppline[i].type=UI_CALL;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 372
	mov	BYTE PTR _st[ecx+2336876], 0

; 5661 : 
; 5662 : 	st.num_calls++;

	mov	ax, WORD PTR _st+262
	add	ax, 1
	mov	WORD PTR _st+262, ax

; 5663 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UIData	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CheckCollisionMouseWorld
_TEXT	SEGMENT
tv664 = -444						; size = 8
tv643 = -444						; size = 8
tv614 = -444						; size = 8
tv594 = -444						; size = 8
tv566 = -444						; size = 8
tv545 = -444						; size = 8
tv520 = -444						; size = 8
tv498 = -444						; size = 8
tv748 = -436						; size = 8
tv740 = -436						; size = 8
tv732 = -436						; size = 8
tv724 = -436						; size = 8
tv716 = -436						; size = 8
tv708 = -436						; size = 8
tv700 = -436						; size = 8
tv692 = -436						; size = 8
tv746 = -428						; size = 8
tv738 = -428						; size = 8
tv730 = -428						; size = 8
tv722 = -428						; size = 8
tv714 = -428						; size = 8
tv706 = -428						; size = 8
tv698 = -428						; size = 8
tv690 = -428						; size = 8
tv654 = -420						; size = 8
tv633 = -420						; size = 8
tv604 = -420						; size = 8
tv584 = -420						; size = 8
tv555 = -420						; size = 8
tv534 = -420						; size = 8
tv509 = -420						; size = 8
tv487 = -420						; size = 8
tv744 = -412						; size = 8
tv736 = -412						; size = 8
tv728 = -412						; size = 8
tv720 = -412						; size = 8
tv712 = -412						; size = 8
tv704 = -412						; size = 8
tv696 = -412						; size = 8
tv688 = -412						; size = 8
tv742 = -404						; size = 8
tv734 = -404						; size = 8
tv726 = -404						; size = 8
tv718 = -404						; size = 8
tv710 = -404						; size = 8
tv702 = -404						; size = 8
tv694 = -404						; size = 8
tv686 = -404						; size = 8
$T1 = -389						; size = 1
$T2 = -377						; size = 1
$T3 = -365						; size = 1
$T4 = -353						; size = 1
_my$ = -152						; size = 4
_mx$ = -140						; size = 4
_tmpy$ = -128						; size = 4
_tmpx$ = -116						; size = 4
_yl$ = -56						; size = 4
_yb$ = -44						; size = 4
_xl$ = -32						; size = 4
_xb$ = -20						; size = 4
_i$ = -5						; size = 1
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xsize$ = 16						; size = 4
_ysize$ = 20						; size = 4
_ang$ = 24						; size = 4
_z$ = 28						; size = 1
_CheckCollisionMouseWorld PROC				; COMDAT

; 3938 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 444				; 000001bcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-444]
	mov	ecx, 111				; 0000006fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T3[ebp], 0
	mov	BYTE PTR $T4[ebp], 0
	mov	BYTE PTR $T1[ebp], 0
	mov	BYTE PTR $T2[ebp], 0

; 3939 : 	register uint8 i;
; 3940 : 
; 3941 : 	int32 xb, xl, yb, yl, xtb, xtl, ytb, ytl, tmpx, tmpy;
; 3942 : 
; 3943 : 	int32 mx, my;
; 3944 : 
; 3945 : 	/*
; 3946 : 	x=((x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;
; 3947 : 	y=((y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;
; 3948 : 
; 3949 : 	xsize=((xsize*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;
; 3950 : 	ysize=((ysize*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;
; 3951 : 	*/
; 3952 : 
; 3953 : 	//x*=st.Camera.dimension.x;
; 3954 : 	//y*=st.Camera.dimension.y;
; 3955 : 
; 3956 : 	//xsize*=st.Camera.dimension.x;
; 3957 : 	//ysize*=st.Camera.dimension.y;
; 3958 : 
; 3959 : 	for(i=0;i<4;i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $LN38@CheckColli
$LN37@CheckColli:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$LN38@CheckColli:
	movzx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 4
	jge	$LN36@CheckColli

; 3960 : 	{
; 3961 : 			if(i==0)

	movzx	eax, BYTE PTR _i$[ebp]
	test	eax, eax
	jne	$LN35@CheckColli

; 3962 : 			{
; 3963 : 				tmpx = (float)x + (((x - (xsize / 2)) - x)*cos((ang*pi) / 180) - ((y - (ysize / 2)) - y)*sin((ang*pi) / 180));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2sd xmm1, ecx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv686[ebp], xmm0
	movsd	QWORD PTR tv688[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv487[ebp]
	movsd	xmm0, QWORD PTR tv688[ebp]
	mulsd	xmm0, QWORD PTR tv487[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _y$[ebp]
	sub	edx, eax
	sub	edx, DWORD PTR _y$[ebp]
	cvtsi2sd xmm1, edx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv690[ebp], xmm0
	movsd	QWORD PTR tv692[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv498[ebp]
	movsd	xmm0, QWORD PTR tv692[ebp]
	mulsd	xmm0, QWORD PTR tv498[ebp]
	movsd	xmm1, QWORD PTR tv690[ebp]
	subsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv686[ebp]
	addsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	mov	DWORD PTR _tmpx$[ebp], eax

; 3964 : 				tmpy = (float)y + (((x - (xsize / 2)) - x)*sin((ang*pi) / 180) + ((y - (ysize / 2)) - y)*cos((ang*pi) / 180));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2sd xmm1, ecx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv694[ebp], xmm0
	movsd	QWORD PTR tv696[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv509[ebp]
	movsd	xmm0, QWORD PTR tv696[ebp]
	mulsd	xmm0, QWORD PTR tv509[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _y$[ebp]
	sub	edx, eax
	sub	edx, DWORD PTR _y$[ebp]
	cvtsi2sd xmm1, edx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv698[ebp], xmm0
	movsd	QWORD PTR tv700[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv520[ebp]
	movsd	xmm0, QWORD PTR tv700[ebp]
	mulsd	xmm0, QWORD PTR tv520[ebp]
	movsd	xmm1, QWORD PTR tv698[ebp]
	addsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv694[ebp]
	addsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	mov	DWORD PTR _tmpy$[ebp], eax

; 3965 : 				xb=xl=tmpx;

	mov	BYTE PTR $T1[ebp], 1
	mov	eax, DWORD PTR _tmpx$[ebp]
	mov	DWORD PTR _xl$[ebp], eax
	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN41@CheckColli
	push	OFFSET $LN42@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN41@CheckColli:
	mov	BYTE PTR $T4[ebp], 1
	mov	ecx, DWORD PTR _xl$[ebp]
	mov	DWORD PTR _xb$[ebp], ecx

; 3966 : 				yb=yl=tmpy;

	mov	BYTE PTR $T3[ebp], 1
	mov	eax, DWORD PTR _tmpy$[ebp]
	mov	DWORD PTR _yl$[ebp], eax
	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN43@CheckColli
	push	OFFSET $LN44@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN43@CheckColli:
	mov	BYTE PTR $T2[ebp], 1
	mov	ecx, DWORD PTR _yl$[ebp]
	mov	DWORD PTR _yb$[ebp], ecx

; 3967 : 			}
; 3968 : 			else

	jmp	$LN11@CheckColli
$LN35@CheckColli:

; 3969 : 			if(i==1)

	movzx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 1
	jne	$LN33@CheckColli

; 3970 : 			{
; 3971 : 				tmpx = (float)x + (((x + (xsize / 2)) - x)*cos((ang*pi) / 180) - ((y - (ysize / 2)) - y)*sin((ang*pi) / 180));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv702[ebp], xmm0
	movsd	QWORD PTR tv704[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv534[ebp]
	movsd	xmm0, QWORD PTR tv704[ebp]
	mulsd	xmm0, QWORD PTR tv534[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2sd xmm1, ecx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv706[ebp], xmm0
	movsd	QWORD PTR tv708[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv545[ebp]
	movsd	xmm0, QWORD PTR tv708[ebp]
	mulsd	xmm0, QWORD PTR tv545[ebp]
	movsd	xmm1, QWORD PTR tv706[ebp]
	subsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv702[ebp]
	addsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	DWORD PTR _tmpx$[ebp], edx

; 3972 : 				tmpy = (float)y + (((x + (xsize / 2)) - x)*sin((ang*pi) / 180) + ((y - (ysize / 2)) - y)*cos((ang*pi) / 180));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv710[ebp], xmm0
	movsd	QWORD PTR tv712[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv555[ebp]
	movsd	xmm0, QWORD PTR tv712[ebp]
	mulsd	xmm0, QWORD PTR tv555[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2sd xmm1, ecx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv714[ebp], xmm0
	movsd	QWORD PTR tv716[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv566[ebp]
	movsd	xmm0, QWORD PTR tv716[ebp]
	mulsd	xmm0, QWORD PTR tv566[ebp]
	movsd	xmm1, QWORD PTR tv714[ebp]
	addsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv710[ebp]
	addsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	DWORD PTR _tmpy$[ebp], edx

; 3973 : 				if(tmpx>xb) xb=tmpx;

	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN45@CheckColli
	push	OFFSET $LN46@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN45@CheckColli:
	mov	eax, DWORD PTR _tmpx$[ebp]
	cmp	eax, DWORD PTR _xb$[ebp]
	jle	SHORT $LN32@CheckColli
	mov	BYTE PTR $T4[ebp], 1
	mov	eax, DWORD PTR _tmpx$[ebp]
	mov	DWORD PTR _xb$[ebp], eax
	jmp	SHORT $LN30@CheckColli
$LN32@CheckColli:

; 3974 : 				else if(tmpx<xl) xl=tmpx;

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN47@CheckColli
	push	OFFSET $LN42@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN47@CheckColli:
	mov	eax, DWORD PTR _tmpx$[ebp]
	cmp	eax, DWORD PTR _xl$[ebp]
	jge	SHORT $LN30@CheckColli
	mov	BYTE PTR $T1[ebp], 1
	mov	eax, DWORD PTR _tmpx$[ebp]
	mov	DWORD PTR _xl$[ebp], eax
$LN30@CheckColli:

; 3975 : 
; 3976 : 				if(tmpy>yb) yb=tmpy;

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN48@CheckColli
	push	OFFSET $LN49@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN48@CheckColli:
	mov	eax, DWORD PTR _tmpy$[ebp]
	cmp	eax, DWORD PTR _yb$[ebp]
	jle	SHORT $LN29@CheckColli
	mov	BYTE PTR $T2[ebp], 1
	mov	eax, DWORD PTR _tmpy$[ebp]
	mov	DWORD PTR _yb$[ebp], eax
	jmp	SHORT $LN27@CheckColli
$LN29@CheckColli:

; 3977 : 				else if(tmpy<yl) yl=tmpy;

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN50@CheckColli
	push	OFFSET $LN44@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN50@CheckColli:
	mov	eax, DWORD PTR _tmpy$[ebp]
	cmp	eax, DWORD PTR _yl$[ebp]
	jge	SHORT $LN27@CheckColli
	mov	BYTE PTR $T3[ebp], 1
	mov	eax, DWORD PTR _tmpy$[ebp]
	mov	DWORD PTR _yl$[ebp], eax
$LN27@CheckColli:

; 3978 : 			}
; 3979 : 			else

	jmp	$LN11@CheckColli
$LN33@CheckColli:

; 3980 : 			if(i==2)

	movzx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 2
	jne	$LN25@CheckColli

; 3981 : 			{
; 3982 : 				tmpx = (float)x + (((x + (xsize / 2)) - x)*cos((ang*pi) / 180) - ((y + (ysize / 2)) - y)*sin((ang*pi) / 180));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv718[ebp], xmm0
	movsd	QWORD PTR tv720[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv584[ebp]
	movsd	xmm0, QWORD PTR tv720[ebp]
	mulsd	xmm0, QWORD PTR tv584[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv722[ebp], xmm0
	movsd	QWORD PTR tv724[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv594[ebp]
	movsd	xmm0, QWORD PTR tv724[ebp]
	mulsd	xmm0, QWORD PTR tv594[ebp]
	movsd	xmm1, QWORD PTR tv722[ebp]
	subsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv718[ebp]
	addsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	mov	DWORD PTR _tmpx$[ebp], eax

; 3983 : 				tmpy = (float)y + (((x + (xsize / 2)) - x)*sin((ang*pi) / 180) + ((y + (ysize / 2)) - y)*cos((ang*pi) / 180));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv726[ebp], xmm0
	movsd	QWORD PTR tv728[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv604[ebp]
	movsd	xmm0, QWORD PTR tv728[ebp]
	mulsd	xmm0, QWORD PTR tv604[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv730[ebp], xmm0
	movsd	QWORD PTR tv732[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv614[ebp]
	movsd	xmm0, QWORD PTR tv732[ebp]
	mulsd	xmm0, QWORD PTR tv614[ebp]
	movsd	xmm1, QWORD PTR tv730[ebp]
	addsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv726[ebp]
	addsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	mov	DWORD PTR _tmpy$[ebp], eax

; 3984 : 				if(tmpx>xb) xb=tmpx;

	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN51@CheckColli
	push	OFFSET $LN46@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN51@CheckColli:
	mov	eax, DWORD PTR _tmpx$[ebp]
	cmp	eax, DWORD PTR _xb$[ebp]
	jle	SHORT $LN24@CheckColli
	mov	BYTE PTR $T4[ebp], 1
	mov	eax, DWORD PTR _tmpx$[ebp]
	mov	DWORD PTR _xb$[ebp], eax
	jmp	SHORT $LN22@CheckColli
$LN24@CheckColli:

; 3985 : 				else if(tmpx<xl) xl=tmpx;

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN52@CheckColli
	push	OFFSET $LN42@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN52@CheckColli:
	mov	eax, DWORD PTR _tmpx$[ebp]
	cmp	eax, DWORD PTR _xl$[ebp]
	jge	SHORT $LN22@CheckColli
	mov	BYTE PTR $T1[ebp], 1
	mov	eax, DWORD PTR _tmpx$[ebp]
	mov	DWORD PTR _xl$[ebp], eax
$LN22@CheckColli:

; 3986 : 
; 3987 : 				if(tmpy>yb) yb=tmpy;

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN53@CheckColli
	push	OFFSET $LN49@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN53@CheckColli:
	mov	eax, DWORD PTR _tmpy$[ebp]
	cmp	eax, DWORD PTR _yb$[ebp]
	jle	SHORT $LN21@CheckColli
	mov	BYTE PTR $T2[ebp], 1
	mov	eax, DWORD PTR _tmpy$[ebp]
	mov	DWORD PTR _yb$[ebp], eax
	jmp	SHORT $LN19@CheckColli
$LN21@CheckColli:

; 3988 : 				else if(tmpy<yl) yl=tmpy;

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN54@CheckColli
	push	OFFSET $LN44@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN54@CheckColli:
	mov	eax, DWORD PTR _tmpy$[ebp]
	cmp	eax, DWORD PTR _yl$[ebp]
	jge	SHORT $LN19@CheckColli
	mov	BYTE PTR $T3[ebp], 1
	mov	eax, DWORD PTR _tmpy$[ebp]
	mov	DWORD PTR _yl$[ebp], eax
$LN19@CheckColli:

; 3989 : 			}
; 3990 : 			else

	jmp	$LN11@CheckColli
$LN25@CheckColli:

; 3991 : 			if(i==3)

	movzx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 3
	jne	$LN11@CheckColli

; 3992 : 			{
; 3993 : 				tmpx = (float)x + (((x - (xsize / 2)) - x)*cos((ang*pi) / 180) - ((y + (ysize / 2)) - y)*sin((ang*pi) / 180));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2sd xmm1, ecx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv734[ebp], xmm0
	movsd	QWORD PTR tv736[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv633[ebp]
	movsd	xmm0, QWORD PTR tv736[ebp]
	mulsd	xmm0, QWORD PTR tv633[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv738[ebp], xmm0
	movsd	QWORD PTR tv740[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv643[ebp]
	movsd	xmm0, QWORD PTR tv740[ebp]
	mulsd	xmm0, QWORD PTR tv643[ebp]
	movsd	xmm1, QWORD PTR tv738[ebp]
	subsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv734[ebp]
	addsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	DWORD PTR _tmpx$[ebp], edx

; 3994 : 				tmpy = (float)y + (((x - (xsize / 2)) - x)*sin((ang*pi) / 180) + ((y + (ysize / 2)) - y)*cos((ang*pi) / 180));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2sd xmm1, ecx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv742[ebp], xmm0
	movsd	QWORD PTR tv744[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv654[ebp]
	movsd	xmm0, QWORD PTR tv744[ebp]
	mulsd	xmm0, QWORD PTR tv654[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv746[ebp], xmm0
	movsd	QWORD PTR tv748[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv664[ebp]
	movsd	xmm0, QWORD PTR tv748[ebp]
	mulsd	xmm0, QWORD PTR tv664[ebp]
	movsd	xmm1, QWORD PTR tv746[ebp]
	addsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv742[ebp]
	addsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	DWORD PTR _tmpy$[ebp], edx

; 3995 : 				if(tmpx>xb) xb=tmpx;

	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN55@CheckColli
	push	OFFSET $LN46@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN55@CheckColli:
	mov	eax, DWORD PTR _tmpx$[ebp]
	cmp	eax, DWORD PTR _xb$[ebp]
	jle	SHORT $LN16@CheckColli
	mov	BYTE PTR $T4[ebp], 1
	mov	eax, DWORD PTR _tmpx$[ebp]
	mov	DWORD PTR _xb$[ebp], eax
	jmp	SHORT $LN14@CheckColli
$LN16@CheckColli:

; 3996 : 				else if(tmpx<xl) xl=tmpx;

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN56@CheckColli
	push	OFFSET $LN42@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN56@CheckColli:
	mov	eax, DWORD PTR _tmpx$[ebp]
	cmp	eax, DWORD PTR _xl$[ebp]
	jge	SHORT $LN14@CheckColli
	mov	BYTE PTR $T1[ebp], 1
	mov	eax, DWORD PTR _tmpx$[ebp]
	mov	DWORD PTR _xl$[ebp], eax
$LN14@CheckColli:

; 3997 : 
; 3998 : 				if(tmpy>yb) yb=tmpy;

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN57@CheckColli
	push	OFFSET $LN49@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN57@CheckColli:
	mov	eax, DWORD PTR _tmpy$[ebp]
	cmp	eax, DWORD PTR _yb$[ebp]
	jle	SHORT $LN13@CheckColli
	mov	BYTE PTR $T2[ebp], 1
	mov	eax, DWORD PTR _tmpy$[ebp]
	mov	DWORD PTR _yb$[ebp], eax
	jmp	SHORT $LN11@CheckColli
$LN13@CheckColli:

; 3999 : 				else if(tmpy<yl) yl=tmpy;

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN58@CheckColli
	push	OFFSET $LN44@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN58@CheckColli:
	mov	eax, DWORD PTR _tmpy$[ebp]
	cmp	eax, DWORD PTR _yl$[ebp]
	jge	SHORT $LN11@CheckColli
	mov	BYTE PTR $T3[ebp], 1
	mov	eax, DWORD PTR _tmpy$[ebp]
	mov	DWORD PTR _yl$[ebp], eax
$LN11@CheckColli:

; 4000 : 			}
; 4001 : 	}

	jmp	$LN37@CheckColli
$LN36@CheckColli:

; 4002 : 
; 4003 : 	mx=st.mouse.x;

	mov	eax, DWORD PTR _st+65624
	mov	DWORD PTR _mx$[ebp], eax

; 4004 : 	my=st.mouse.y;

	mov	eax, DWORD PTR _st+65628
	mov	DWORD PTR _my$[ebp], eax

; 4005 : 
; 4006 : 	STWci(&mx, &my);

	lea	eax, DWORD PTR _my$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mx$[ebp]
	push	ecx
	call	_STWci
	add	esp, 8

; 4007 : 
; 4008 : 			if(z>39 && z<48)

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 39					; 00000027H
	jle	$LN10@CheckColli
	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 48					; 00000030H
	jge	$LN10@CheckColli

; 4009 : 			{
; 4010 : 				mx/=(float) st.Camera.dimension.x;

	cvtsi2ss xmm0, DWORD PTR _mx$[ebp]
	divss	xmm0, DWORD PTR _st+2335396
	cvttss2si eax, xmm0
	mov	DWORD PTR _mx$[ebp], eax

; 4011 : 				my/=(float) st.Camera.dimension.y;

	cvtsi2ss xmm0, DWORD PTR _my$[ebp]
	divss	xmm0, DWORD PTR _st+2335400
	cvttss2si eax, xmm0
	mov	DWORD PTR _my$[ebp], eax

; 4012 : 
; 4013 : 				mx+=(float) st.Camera.position.x*st.Current_Map.bck2_v;

	cvtsi2ss xmm0, DWORD PTR _st+2335380
	mulss	xmm0, DWORD PTR _st+66852
	cvtsi2ss xmm1, DWORD PTR _mx$[ebp]
	addss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _mx$[ebp], eax

; 4014 : 				my+=(float) st.Camera.position.y*st.Current_Map.bck2_v;

	cvtsi2ss xmm0, DWORD PTR _st+2335384
	mulss	xmm0, DWORD PTR _st+66852
	cvtsi2ss xmm1, DWORD PTR _my$[ebp]
	addss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _my$[ebp], eax

; 4015 : 
; 4016 : 				//mx*=st.Camera.dimension.x;
; 4017 : 				//my*=st.Camera.dimension.y;
; 4018 : 			}
; 4019 : 			else

	jmp	$LN6@CheckColli
$LN10@CheckColli:

; 4020 : 			if(z>31 && z<40)

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 31					; 0000001fH
	jle	$LN8@CheckColli
	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 40					; 00000028H
	jge	$LN8@CheckColli

; 4021 : 			{
; 4022 : 				
; 4023 : 				mx/=(float) st.Camera.dimension.x;

	cvtsi2ss xmm0, DWORD PTR _mx$[ebp]
	divss	xmm0, DWORD PTR _st+2335396
	cvttss2si eax, xmm0
	mov	DWORD PTR _mx$[ebp], eax

; 4024 : 				my/=(float) st.Camera.dimension.y;

	cvtsi2ss xmm0, DWORD PTR _my$[ebp]
	divss	xmm0, DWORD PTR _st+2335400
	cvttss2si eax, xmm0
	mov	DWORD PTR _my$[ebp], eax

; 4025 : 
; 4026 : 				mx+=(float) st.Camera.position.x*st.Current_Map.bck1_v;

	cvtsi2ss xmm0, DWORD PTR _st+2335380
	mulss	xmm0, DWORD PTR _st+66856
	cvtsi2ss xmm1, DWORD PTR _mx$[ebp]
	addss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _mx$[ebp], eax

; 4027 : 				my+=(float) st.Camera.position.y*st.Current_Map.bck1_v;

	cvtsi2ss xmm0, DWORD PTR _st+2335384
	mulss	xmm0, DWORD PTR _st+66856
	cvtsi2ss xmm1, DWORD PTR _my$[ebp]
	addss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _my$[ebp], eax

; 4028 : 
; 4029 : 			}
; 4030 : 			else

	jmp	SHORT $LN6@CheckColli
$LN8@CheckColli:

; 4031 : 			if((z>23 && z<32) || z>=0 && z<16)

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 23					; 00000017H
	jle	SHORT $LN4@CheckColli
	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 32					; 00000020H
	jl	SHORT $LN5@CheckColli
$LN4@CheckColli:
	movsx	eax, BYTE PTR _z$[ebp]
	test	eax, eax
	jl	SHORT $LN6@CheckColli
	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN6@CheckColli
$LN5@CheckColli:

; 4032 : 			{
; 4033 : 
; 4034 : 				mx/=(float) st.Camera.dimension.x;

	cvtsi2ss xmm0, DWORD PTR _mx$[ebp]
	divss	xmm0, DWORD PTR _st+2335396
	cvttss2si eax, xmm0
	mov	DWORD PTR _mx$[ebp], eax

; 4035 : 				my/=(float) st.Camera.dimension.y;

	cvtsi2ss xmm0, DWORD PTR _my$[ebp]
	divss	xmm0, DWORD PTR _st+2335400
	cvttss2si eax, xmm0
	mov	DWORD PTR _my$[ebp], eax

; 4036 : 
; 4037 : 				mx+=st.Camera.position.x;

	mov	eax, DWORD PTR _mx$[ebp]
	add	eax, DWORD PTR _st+2335380
	mov	DWORD PTR _mx$[ebp], eax

; 4038 : 				my+=st.Camera.position.y;

	mov	eax, DWORD PTR _my$[ebp]
	add	eax, DWORD PTR _st+2335384
	mov	DWORD PTR _my$[ebp], eax
$LN6@CheckColli:

; 4039 : 			}
; 4040 : 			if(z>15 && z<24)

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 15					; 0000000fH
	jle	$LN3@CheckColli
	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 24					; 00000018H
	jge	$LN3@CheckColli

; 4041 : 			{
; 4042 : 				mx/=(float) st.Camera.dimension.x;

	cvtsi2ss xmm0, DWORD PTR _mx$[ebp]
	divss	xmm0, DWORD PTR _st+2335396
	cvttss2si eax, xmm0
	mov	DWORD PTR _mx$[ebp], eax

; 4043 : 				my/=(float) st.Camera.dimension.y;

	cvtsi2ss xmm0, DWORD PTR _my$[ebp]
	divss	xmm0, DWORD PTR _st+2335400
	cvttss2si eax, xmm0
	mov	DWORD PTR _my$[ebp], eax

; 4044 : 
; 4045 : 				mx+=(float) st.Camera.position.x*st.Current_Map.fr_v;

	cvtsi2ss xmm0, DWORD PTR _st+2335380
	mulss	xmm0, DWORD PTR _st+66860
	cvtsi2ss xmm1, DWORD PTR _mx$[ebp]
	addss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _mx$[ebp], eax

; 4046 : 				my+=(float) st.Camera.position.y*st.Current_Map.fr_v;

	cvtsi2ss xmm0, DWORD PTR _st+2335384
	mulss	xmm0, DWORD PTR _st+66860
	cvtsi2ss xmm1, DWORD PTR _my$[ebp]
	addss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _my$[ebp], eax
$LN3@CheckColli:

; 4047 : 
; 4048 : 				//mx*=st.Camera.dimension.x;
; 4049 : 				//my*=st.Camera.dimension.y;
; 4050 : 			}
; 4051 : 
; 4052 : 	if(mx>xl && mx<xb && my>yl && my<yb)

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN59@CheckColli
	push	OFFSET $LN42@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN59@CheckColli:
	mov	eax, DWORD PTR _mx$[ebp]
	cmp	eax, DWORD PTR _xl$[ebp]
	jle	SHORT $LN2@CheckColli
	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN60@CheckColli
	push	OFFSET $LN46@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN60@CheckColli:
	mov	eax, DWORD PTR _mx$[ebp]
	cmp	eax, DWORD PTR _xb$[ebp]
	jge	SHORT $LN2@CheckColli
	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN61@CheckColli
	push	OFFSET $LN44@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN61@CheckColli:
	mov	eax, DWORD PTR _my$[ebp]
	cmp	eax, DWORD PTR _yl$[ebp]
	jle	SHORT $LN2@CheckColli
	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN62@CheckColli
	push	OFFSET $LN49@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN62@CheckColli:
	mov	eax, DWORD PTR _my$[ebp]
	cmp	eax, DWORD PTR _yb$[ebp]
	jge	SHORT $LN2@CheckColli

; 4053 : 		return 1; //Collided

	mov	al, 1
	jmp	SHORT $LN1@CheckColli

; 4054 : 	else

	jmp	SHORT $LN1@CheckColli
$LN2@CheckColli:

; 4055 : 		return 0; //No collision

	xor	al, al
$LN1@CheckColli:

; 4056 : 	
; 4057 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN66@CheckColli
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 444				; 000001bcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN66@CheckColli:
	DD	2
	DD	$LN65@CheckColli
$LN65@CheckColli:
	DD	-140					; ffffff74H
	DD	4
	DD	$LN63@CheckColli
	DD	-152					; ffffff68H
	DD	4
	DD	$LN64@CheckColli
$LN64@CheckColli:
	DB	109					; 0000006dH
	DB	121					; 00000079H
	DB	0
$LN63@CheckColli:
	DB	109					; 0000006dH
	DB	120					; 00000078H
	DB	0
$LN49@CheckColli:
	DB	121					; 00000079H
	DB	98					; 00000062H
	DB	0
$LN46@CheckColli:
	DB	120					; 00000078H
	DB	98					; 00000062H
	DB	0
$LN44@CheckColli:
	DB	121					; 00000079H
	DB	108					; 0000006cH
	DB	0
$LN42@CheckColli:
	DB	120					; 00000078H
	DB	108					; 0000006cH
	DB	0
_CheckCollisionMouseWorld ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CheckCollisionMouse
_TEXT	SEGMENT
tv592 = -444						; size = 8
tv571 = -444						; size = 8
tv542 = -444						; size = 8
tv522 = -444						; size = 8
tv494 = -444						; size = 8
tv473 = -444						; size = 8
tv448 = -444						; size = 8
tv426 = -444						; size = 8
tv681 = -436						; size = 8
tv673 = -436						; size = 8
tv665 = -436						; size = 8
tv657 = -436						; size = 8
tv649 = -436						; size = 8
tv641 = -436						; size = 8
tv633 = -436						; size = 8
tv625 = -436						; size = 8
tv679 = -428						; size = 8
tv671 = -428						; size = 8
tv663 = -428						; size = 8
tv655 = -428						; size = 8
tv647 = -428						; size = 8
tv639 = -428						; size = 8
tv631 = -428						; size = 8
tv623 = -428						; size = 8
tv582 = -420						; size = 8
tv561 = -420						; size = 8
tv532 = -420						; size = 8
tv512 = -420						; size = 8
tv483 = -420						; size = 8
tv462 = -420						; size = 8
tv437 = -420						; size = 8
tv415 = -420						; size = 8
tv677 = -412						; size = 8
tv669 = -412						; size = 8
tv661 = -412						; size = 8
tv653 = -412						; size = 8
tv645 = -412						; size = 8
tv637 = -412						; size = 8
tv629 = -412						; size = 8
tv621 = -412						; size = 8
tv675 = -404						; size = 8
tv667 = -404						; size = 8
tv659 = -404						; size = 8
tv651 = -404						; size = 8
tv643 = -404						; size = 8
tv635 = -404						; size = 8
tv627 = -404						; size = 8
tv619 = -404						; size = 8
$T1 = -389						; size = 1
$T2 = -377						; size = 1
$T3 = -365						; size = 1
$T4 = -353						; size = 1
_my$ = -152						; size = 4
_mx$ = -140						; size = 4
_tmpy$ = -128						; size = 4
_tmpx$ = -116						; size = 4
_yl$ = -56						; size = 4
_yb$ = -44						; size = 4
_xl$ = -32						; size = 4
_xb$ = -20						; size = 4
_i$ = -5						; size = 1
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xsize$ = 16						; size = 4
_ysize$ = 20						; size = 4
_ang$ = 24						; size = 4
_CheckCollisionMouse PROC				; COMDAT

; 3871 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 444				; 000001bcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-444]
	mov	ecx, 111				; 0000006fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T4[ebp], 0
	mov	BYTE PTR $T1[ebp], 0
	mov	BYTE PTR $T2[ebp], 0
	mov	BYTE PTR $T3[ebp], 0

; 3872 : 	register uint8 i;
; 3873 : 
; 3874 : 	int32 xb, xl, yb, yl, xtb, xtl, ytb, ytl, tmpx, tmpy;
; 3875 : 
; 3876 : 	int32 mx, my;
; 3877 : 
; 3878 : 	for(i=0;i<4;i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $LN30@CheckColli
$LN29@CheckColli:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$LN30@CheckColli:
	movzx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 4
	jge	$LN28@CheckColli

; 3879 : 	{
; 3880 : 			if(i==0)

	movzx	eax, BYTE PTR _i$[ebp]
	test	eax, eax
	jne	$LN27@CheckColli

; 3881 : 			{
; 3882 : 				tmpx=(float)x+(((x-(xsize/2))-x)*cos((ang*pi)/180) - ((y-(ysize/2))-y)*sin((ang*pi)/180));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2sd xmm1, ecx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv619[ebp], xmm0
	movsd	QWORD PTR tv621[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv415[ebp]
	movsd	xmm0, QWORD PTR tv621[ebp]
	mulsd	xmm0, QWORD PTR tv415[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _y$[ebp]
	sub	edx, eax
	sub	edx, DWORD PTR _y$[ebp]
	cvtsi2sd xmm1, edx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv623[ebp], xmm0
	movsd	QWORD PTR tv625[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv426[ebp]
	movsd	xmm0, QWORD PTR tv625[ebp]
	mulsd	xmm0, QWORD PTR tv426[ebp]
	movsd	xmm1, QWORD PTR tv623[ebp]
	subsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv619[ebp]
	addsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	mov	DWORD PTR _tmpx$[ebp], eax

; 3883 : 				tmpy=(float)y+(((x-(xsize/2))-x)*sin((ang*pi)/180) + ((y-(ysize/2))-y)*cos((ang*pi)/180));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2sd xmm1, ecx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv627[ebp], xmm0
	movsd	QWORD PTR tv629[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv437[ebp]
	movsd	xmm0, QWORD PTR tv629[ebp]
	mulsd	xmm0, QWORD PTR tv437[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _y$[ebp]
	sub	edx, eax
	sub	edx, DWORD PTR _y$[ebp]
	cvtsi2sd xmm1, edx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv631[ebp], xmm0
	movsd	QWORD PTR tv633[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv448[ebp]
	movsd	xmm0, QWORD PTR tv633[ebp]
	mulsd	xmm0, QWORD PTR tv448[ebp]
	movsd	xmm1, QWORD PTR tv631[ebp]
	addsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv627[ebp]
	addsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	mov	DWORD PTR _tmpy$[ebp], eax

; 3884 : 				xb=xl=tmpx;

	mov	BYTE PTR $T2[ebp], 1
	mov	eax, DWORD PTR _tmpx$[ebp]
	mov	DWORD PTR _xl$[ebp], eax
	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN33@CheckColli
	push	OFFSET $LN34@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN33@CheckColli:
	mov	BYTE PTR $T1[ebp], 1
	mov	ecx, DWORD PTR _xl$[ebp]
	mov	DWORD PTR _xb$[ebp], ecx

; 3885 : 				yb=yl=tmpy;

	mov	BYTE PTR $T4[ebp], 1
	mov	eax, DWORD PTR _tmpy$[ebp]
	mov	DWORD PTR _yl$[ebp], eax
	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN35@CheckColli
	push	OFFSET $LN36@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN35@CheckColli:
	mov	BYTE PTR $T3[ebp], 1
	mov	ecx, DWORD PTR _yl$[ebp]
	mov	DWORD PTR _yb$[ebp], ecx

; 3886 : 			}
; 3887 : 			else

	jmp	$LN3@CheckColli
$LN27@CheckColli:

; 3888 : 			if(i==1)

	movzx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 1
	jne	$LN25@CheckColli

; 3889 : 			{
; 3890 : 				tmpx=(float)x+(((x+(xsize/2))-x)*cos((ang*pi)/180) - ((y-(ysize/2))-y)*sin((ang*pi)/180));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv635[ebp], xmm0
	movsd	QWORD PTR tv637[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv462[ebp]
	movsd	xmm0, QWORD PTR tv637[ebp]
	mulsd	xmm0, QWORD PTR tv462[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2sd xmm1, ecx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv639[ebp], xmm0
	movsd	QWORD PTR tv641[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv473[ebp]
	movsd	xmm0, QWORD PTR tv641[ebp]
	mulsd	xmm0, QWORD PTR tv473[ebp]
	movsd	xmm1, QWORD PTR tv639[ebp]
	subsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv635[ebp]
	addsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	DWORD PTR _tmpx$[ebp], edx

; 3891 : 				tmpy=(float)y+(((x+(xsize/2))-x)*sin((ang*pi)/180) + ((y-(ysize/2))-y)*cos((ang*pi)/180));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv643[ebp], xmm0
	movsd	QWORD PTR tv645[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv483[ebp]
	movsd	xmm0, QWORD PTR tv645[ebp]
	mulsd	xmm0, QWORD PTR tv483[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2sd xmm1, ecx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv647[ebp], xmm0
	movsd	QWORD PTR tv649[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv494[ebp]
	movsd	xmm0, QWORD PTR tv649[ebp]
	mulsd	xmm0, QWORD PTR tv494[ebp]
	movsd	xmm1, QWORD PTR tv647[ebp]
	addsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv643[ebp]
	addsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	DWORD PTR _tmpy$[ebp], edx

; 3892 : 				if(tmpx>xb) xb=tmpx;

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN37@CheckColli
	push	OFFSET $LN38@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN37@CheckColli:
	mov	eax, DWORD PTR _tmpx$[ebp]
	cmp	eax, DWORD PTR _xb$[ebp]
	jle	SHORT $LN24@CheckColli
	mov	BYTE PTR $T1[ebp], 1
	mov	eax, DWORD PTR _tmpx$[ebp]
	mov	DWORD PTR _xb$[ebp], eax
	jmp	SHORT $LN22@CheckColli
$LN24@CheckColli:

; 3893 : 				else if(tmpx<xl) xl=tmpx;

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN39@CheckColli
	push	OFFSET $LN34@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN39@CheckColli:
	mov	eax, DWORD PTR _tmpx$[ebp]
	cmp	eax, DWORD PTR _xl$[ebp]
	jge	SHORT $LN22@CheckColli
	mov	BYTE PTR $T2[ebp], 1
	mov	eax, DWORD PTR _tmpx$[ebp]
	mov	DWORD PTR _xl$[ebp], eax
$LN22@CheckColli:

; 3894 : 
; 3895 : 				if(tmpy>yb) yb=tmpy;

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN40@CheckColli
	push	OFFSET $LN41@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN40@CheckColli:
	mov	eax, DWORD PTR _tmpy$[ebp]
	cmp	eax, DWORD PTR _yb$[ebp]
	jle	SHORT $LN21@CheckColli
	mov	BYTE PTR $T3[ebp], 1
	mov	eax, DWORD PTR _tmpy$[ebp]
	mov	DWORD PTR _yb$[ebp], eax
	jmp	SHORT $LN19@CheckColli
$LN21@CheckColli:

; 3896 : 				else if(tmpy<yl) yl=tmpy;

	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN42@CheckColli
	push	OFFSET $LN36@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN42@CheckColli:
	mov	eax, DWORD PTR _tmpy$[ebp]
	cmp	eax, DWORD PTR _yl$[ebp]
	jge	SHORT $LN19@CheckColli
	mov	BYTE PTR $T4[ebp], 1
	mov	eax, DWORD PTR _tmpy$[ebp]
	mov	DWORD PTR _yl$[ebp], eax
$LN19@CheckColli:

; 3897 : 			}
; 3898 : 			else

	jmp	$LN3@CheckColli
$LN25@CheckColli:

; 3899 : 			if(i==2)

	movzx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 2
	jne	$LN17@CheckColli

; 3900 : 			{
; 3901 : 				tmpx=(float)x+(((x+(xsize/2))-x)*cos((ang*pi)/180) - ((y+(ysize/2))-y)*sin((ang*pi)/180));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv651[ebp], xmm0
	movsd	QWORD PTR tv653[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv512[ebp]
	movsd	xmm0, QWORD PTR tv653[ebp]
	mulsd	xmm0, QWORD PTR tv512[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv655[ebp], xmm0
	movsd	QWORD PTR tv657[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv522[ebp]
	movsd	xmm0, QWORD PTR tv657[ebp]
	mulsd	xmm0, QWORD PTR tv522[ebp]
	movsd	xmm1, QWORD PTR tv655[ebp]
	subsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv651[ebp]
	addsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	mov	DWORD PTR _tmpx$[ebp], eax

; 3902 : 				tmpy=(float)y+(((x+(xsize/2))-x)*sin((ang*pi)/180) + ((y+(ysize/2))-y)*cos((ang*pi)/180));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv659[ebp], xmm0
	movsd	QWORD PTR tv661[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv532[ebp]
	movsd	xmm0, QWORD PTR tv661[ebp]
	mulsd	xmm0, QWORD PTR tv532[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv663[ebp], xmm0
	movsd	QWORD PTR tv665[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv542[ebp]
	movsd	xmm0, QWORD PTR tv665[ebp]
	mulsd	xmm0, QWORD PTR tv542[ebp]
	movsd	xmm1, QWORD PTR tv663[ebp]
	addsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv659[ebp]
	addsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	mov	DWORD PTR _tmpy$[ebp], eax

; 3903 : 				if(tmpx>xb) xb=tmpx;

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN43@CheckColli
	push	OFFSET $LN38@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN43@CheckColli:
	mov	eax, DWORD PTR _tmpx$[ebp]
	cmp	eax, DWORD PTR _xb$[ebp]
	jle	SHORT $LN16@CheckColli
	mov	BYTE PTR $T1[ebp], 1
	mov	eax, DWORD PTR _tmpx$[ebp]
	mov	DWORD PTR _xb$[ebp], eax
	jmp	SHORT $LN14@CheckColli
$LN16@CheckColli:

; 3904 : 				else if(tmpx<xl) xl=tmpx;

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN44@CheckColli
	push	OFFSET $LN34@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN44@CheckColli:
	mov	eax, DWORD PTR _tmpx$[ebp]
	cmp	eax, DWORD PTR _xl$[ebp]
	jge	SHORT $LN14@CheckColli
	mov	BYTE PTR $T2[ebp], 1
	mov	eax, DWORD PTR _tmpx$[ebp]
	mov	DWORD PTR _xl$[ebp], eax
$LN14@CheckColli:

; 3905 : 
; 3906 : 				if(tmpy>yb) yb=tmpy;

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN45@CheckColli
	push	OFFSET $LN41@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN45@CheckColli:
	mov	eax, DWORD PTR _tmpy$[ebp]
	cmp	eax, DWORD PTR _yb$[ebp]
	jle	SHORT $LN13@CheckColli
	mov	BYTE PTR $T3[ebp], 1
	mov	eax, DWORD PTR _tmpy$[ebp]
	mov	DWORD PTR _yb$[ebp], eax
	jmp	SHORT $LN11@CheckColli
$LN13@CheckColli:

; 3907 : 				else if(tmpy<yl) yl=tmpy;

	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN46@CheckColli
	push	OFFSET $LN36@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN46@CheckColli:
	mov	eax, DWORD PTR _tmpy$[ebp]
	cmp	eax, DWORD PTR _yl$[ebp]
	jge	SHORT $LN11@CheckColli
	mov	BYTE PTR $T4[ebp], 1
	mov	eax, DWORD PTR _tmpy$[ebp]
	mov	DWORD PTR _yl$[ebp], eax
$LN11@CheckColli:

; 3908 : 			}
; 3909 : 			else

	jmp	$LN3@CheckColli
$LN17@CheckColli:

; 3910 : 			if(i==3)

	movzx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 3
	jne	$LN3@CheckColli

; 3911 : 			{
; 3912 : 				tmpx=(float)x+(((x-(xsize/2))-x)*cos((ang*pi)/180) - ((y+(ysize/2))-y)*sin((ang*pi)/180));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2sd xmm1, ecx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv667[ebp], xmm0
	movsd	QWORD PTR tv669[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv561[ebp]
	movsd	xmm0, QWORD PTR tv669[ebp]
	mulsd	xmm0, QWORD PTR tv561[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv671[ebp], xmm0
	movsd	QWORD PTR tv673[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv571[ebp]
	movsd	xmm0, QWORD PTR tv673[ebp]
	mulsd	xmm0, QWORD PTR tv571[ebp]
	movsd	xmm1, QWORD PTR tv671[ebp]
	subsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv667[ebp]
	addsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	DWORD PTR _tmpx$[ebp], edx

; 3913 : 				tmpy=(float)y+(((x-(xsize/2))-x)*sin((ang*pi)/180) + ((y+(ysize/2))-y)*cos((ang*pi)/180));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _xsize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2sd xmm1, ecx
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv675[ebp], xmm0
	movsd	QWORD PTR tv677[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv582[ebp]
	movsd	xmm0, QWORD PTR tv677[ebp]
	mulsd	xmm0, QWORD PTR tv582[ebp]
	mov	eax, DWORD PTR _ysize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2sd xmm1, eax
	cvtsi2sd xmm2, DWORD PTR _ang$[ebp]
	mulsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm2, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv679[ebp], xmm0
	movsd	QWORD PTR tv681[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv592[ebp]
	movsd	xmm0, QWORD PTR tv681[ebp]
	mulsd	xmm0, QWORD PTR tv592[ebp]
	movsd	xmm1, QWORD PTR tv679[ebp]
	addsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv675[ebp]
	addsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	DWORD PTR _tmpy$[ebp], edx

; 3914 : 				if(tmpx>xb) xb=tmpx;

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN47@CheckColli
	push	OFFSET $LN38@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN47@CheckColli:
	mov	eax, DWORD PTR _tmpx$[ebp]
	cmp	eax, DWORD PTR _xb$[ebp]
	jle	SHORT $LN8@CheckColli
	mov	BYTE PTR $T1[ebp], 1
	mov	eax, DWORD PTR _tmpx$[ebp]
	mov	DWORD PTR _xb$[ebp], eax
	jmp	SHORT $LN6@CheckColli
$LN8@CheckColli:

; 3915 : 				else if(tmpx<xl) xl=tmpx;

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN48@CheckColli
	push	OFFSET $LN34@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN48@CheckColli:
	mov	eax, DWORD PTR _tmpx$[ebp]
	cmp	eax, DWORD PTR _xl$[ebp]
	jge	SHORT $LN6@CheckColli
	mov	BYTE PTR $T2[ebp], 1
	mov	eax, DWORD PTR _tmpx$[ebp]
	mov	DWORD PTR _xl$[ebp], eax
$LN6@CheckColli:

; 3916 : 
; 3917 : 				if(tmpy>yb) yb=tmpy;

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN49@CheckColli
	push	OFFSET $LN41@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN49@CheckColli:
	mov	eax, DWORD PTR _tmpy$[ebp]
	cmp	eax, DWORD PTR _yb$[ebp]
	jle	SHORT $LN5@CheckColli
	mov	BYTE PTR $T3[ebp], 1
	mov	eax, DWORD PTR _tmpy$[ebp]
	mov	DWORD PTR _yb$[ebp], eax
	jmp	SHORT $LN3@CheckColli
$LN5@CheckColli:

; 3918 : 				else if(tmpy<yl) yl=tmpy;

	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN50@CheckColli
	push	OFFSET $LN36@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN50@CheckColli:
	mov	eax, DWORD PTR _tmpy$[ebp]
	cmp	eax, DWORD PTR _yl$[ebp]
	jge	SHORT $LN3@CheckColli
	mov	BYTE PTR $T4[ebp], 1
	mov	eax, DWORD PTR _tmpy$[ebp]
	mov	DWORD PTR _yl$[ebp], eax
$LN3@CheckColli:

; 3919 : 			}
; 3920 : 	}

	jmp	$LN29@CheckColli
$LN28@CheckColli:

; 3921 : 
; 3922 : 	mx=st.mouse.x;

	mov	eax, DWORD PTR _st+65624
	mov	DWORD PTR _mx$[ebp], eax

; 3923 : 	my=st.mouse.y;

	mov	eax, DWORD PTR _st+65628
	mov	DWORD PTR _my$[ebp], eax

; 3924 : 
; 3925 : 	//STW(&mx, &my);
; 3926 : 
; 3927 : 	mx=((((mx*GAME_WIDTH)/st.screenx)));

	mov	eax, DWORD PTR _mx$[ebp]
	shl	eax, 14					; 0000000eH
	movzx	ecx, WORD PTR _st+228
	cdq
	idiv	ecx
	mov	DWORD PTR _mx$[ebp], eax

; 3928 : 	my=((((my*GAME_HEIGHT)/st.screeny)));

	imul	eax, DWORD PTR _my$[ebp], 9216
	movzx	ecx, WORD PTR _st+230
	cdq
	idiv	ecx
	mov	DWORD PTR _my$[ebp], eax

; 3929 : 
; 3930 : 	if(mx>xl && mx<xb && my>yl && my<yb)

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN51@CheckColli
	push	OFFSET $LN34@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN51@CheckColli:
	mov	eax, DWORD PTR _mx$[ebp]
	cmp	eax, DWORD PTR _xl$[ebp]
	jle	SHORT $LN2@CheckColli
	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN52@CheckColli
	push	OFFSET $LN38@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN52@CheckColli:
	mov	eax, DWORD PTR _mx$[ebp]
	cmp	eax, DWORD PTR _xb$[ebp]
	jge	SHORT $LN2@CheckColli
	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN53@CheckColli
	push	OFFSET $LN36@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN53@CheckColli:
	mov	eax, DWORD PTR _my$[ebp]
	cmp	eax, DWORD PTR _yl$[ebp]
	jle	SHORT $LN2@CheckColli
	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN54@CheckColli
	push	OFFSET $LN41@CheckColli
	call	__RTC_UninitUse
	add	esp, 4
$LN54@CheckColli:
	mov	eax, DWORD PTR _my$[ebp]
	cmp	eax, DWORD PTR _yb$[ebp]
	jge	SHORT $LN2@CheckColli

; 3931 : 		return 1; //Collided

	mov	al, 1
	jmp	SHORT $LN1@CheckColli

; 3932 : 	else

	jmp	SHORT $LN1@CheckColli
$LN2@CheckColli:

; 3933 : 		return 0; //No collision

	xor	al, al
$LN1@CheckColli:

; 3934 : 	
; 3935 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 444				; 000001bcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN55@CheckColli:
$LN41@CheckColli:
	DB	121					; 00000079H
	DB	98					; 00000062H
	DB	0
$LN38@CheckColli:
	DB	120					; 00000078H
	DB	98					; 00000062H
	DB	0
$LN36@CheckColli:
	DB	121					; 00000079H
	DB	108					; 0000006cH
	DB	0
$LN34@CheckColli:
	DB	120					; 00000078H
	DB	108					; 0000006cH
	DB	0
_CheckCollisionMouse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _Renderer
_TEXT	SEGMENT
_cat$ = -416						; size = 4
_txo$ = -392						; size = 4
_texcoord$ = -340					; size = 32
_vertex$ = -300						; size = 48
_mrt$ = -217						; size = 1
_l$ = -208						; size = 2
_k$ = -196						; size = 4
_n$ = -184						; size = 4
_m$ = -148						; size = 4
_j$ = -136						; size = 4
_i$ = -124						; size = 4
_num_targets$ = -112					; size = 4
_tex_bound$ = -88					; size = 8
_texc$ = -72						; size = 4
_col$ = -60						; size = 4
_pos$ = -48						; size = 4
_unif$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_type$ = 8						; size = 1
_Renderer PROC						; COMDAT

; 8664 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 612				; 00000264H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-612]
	mov	ecx, 153				; 00000099H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8665 : 
; 8666 : 	GLint unif, texcat, vertat, pos, col, texc, tex_bound[2]= { -1, -1 };

	mov	DWORD PTR _tex_bound$[ebp], -1
	mov	DWORD PTR _tex_bound$[ebp+4], -1

; 8667 : 	GLenum error;
; 8668 : 
; 8669 : 	uint32 num_targets=0;

	mov	DWORD PTR _num_targets$[ebp], 0

; 8670 : 	 int32 i=0, j=0, m=0, timej, timel, n=0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _m$[ebp], 0
	mov	DWORD PTR _n$[ebp], 0

; 8671 : 	uint16 *k, l=0;

	xor	eax, eax
	mov	WORD PTR _l$[ebp], ax

; 8672 : 
; 8673 : 	static uint32 tesg=0;
; 8674 : 
; 8675 : 	int8 mrt=0;

	mov	BYTE PTR _mrt$[ebp], 0

; 8676 : 
; 8677 : 	float m1, m2;
; 8678 : 
; 8679 : 	float vertex[12]={
; 8680 : 		-1,-1,0, 1,-1,0,
; 8681 : 		1,1,0, -1,1,0 };

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _vertex$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _vertex$[ebp+4], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vertex$[ebp+8], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _vertex$[ebp+12], xmm0
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _vertex$[ebp+16], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vertex$[ebp+20], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _vertex$[ebp+24], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _vertex$[ebp+28], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vertex$[ebp+32], xmm0
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _vertex$[ebp+36], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _vertex$[ebp+40], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vertex$[ebp+44], xmm0

; 8682 : 
; 8683 : 	float texcoord[8]={
; 8684 : 		0,0, 1,0,
; 8685 : 		1,1, 0,1 };

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _texcoord$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _texcoord$[ebp+4], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _texcoord$[ebp+8], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _texcoord$[ebp+12], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _texcoord$[ebp+16], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _texcoord$[ebp+20], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _texcoord$[ebp+24], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _texcoord$[ebp+28], xmm0

; 8686 : 
; 8687 : 	float tile[2];
; 8688 : 
; 8689 : 	GLuint fbo, fbr, txo=0, txr, cat[1]={ GL_COLOR_ATTACHMENT0 };

	mov	DWORD PTR _txo$[ebp], 0
	mov	DWORD PTR _cat$[ebp], 36064		; 00008ce0H

; 8690 : 
; 8691 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 8692 : 
; 8693 : //if(tesg==0)
; 8694 : //{
; 8695 : 	for(i=0;i<vbdt_num;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN165@Renderer
$LN164@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN165@Renderer:
	movzx	eax, WORD PTR _vbdt_num
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN163@Renderer

; 8696 : 	{
; 8697 : 		if(vbdt[i].num_elements>0)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	test	edx, edx
	jle	$LN162@Renderer

; 8698 : 		{
; 8699 : 			vbdt[i].vertex=(float*) calloc(vbdt[i].num_elements*12,sizeof(float));

	push	4
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	imul	eax, edx, 12
	push	eax
	call	_calloc
	add	esp, 8
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _vbdt
	mov	DWORD PTR [edx+ecx+12], eax

; 8700 : 			vbdt[i].texcoord=(float*) calloc(vbdt[i].num_elements*8,sizeof(float));

	push	4
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	shl	edx, 3
	push	edx
	call	_calloc
	add	esp, 8
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _vbdt
	mov	DWORD PTR [edx+ecx+16], eax

; 8701 : 			vbdt[i].index=(GLushort*) calloc(vbdt[i].num_elements*6,sizeof(GLushort));

	push	2
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	imul	eax, edx, 6
	push	eax
	call	_calloc
	add	esp, 8
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _vbdt
	mov	DWORD PTR [edx+ecx+32], eax

; 8702 : 			vbdt[i].color=(GLubyte*) calloc(vbdt[i].num_elements*16,sizeof(GLubyte));

	push	1
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	shl	edx, 4
	push	edx
	call	_calloc
	add	esp, 8
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _vbdt
	mov	DWORD PTR [edx+ecx+28], eax

; 8703 : 			vbdt[i].texcoordlight=(float*) calloc(vbdt[i].num_elements*8,sizeof(float));

	push	4
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	shl	edx, 3
	push	edx
	call	_calloc
	add	esp, 8
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _vbdt
	mov	DWORD PTR [edx+ecx+20], eax
$LN162@Renderer:

; 8704 : 			//vbdt[i].texrepeat=(float*) calloc(vbdt[i].num_elements*4,sizeof(float));
; 8705 : 		}
; 8706 : 	}

	jmp	$LN164@Renderer
$LN163@Renderer:

; 8707 : 
; 8708 : 	k=(uint16*) calloc(vbdt_num,sizeof(uint16));

	push	2
	movzx	eax, WORD PTR _vbdt_num
	push	eax
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _k$[ebp], eax

; 8709 : 
; 8710 : 	for(m=z_used;m>-1;m--)

	movsx	eax, BYTE PTR _z_used
	mov	DWORD PTR _m$[ebp], eax
	jmp	SHORT $LN161@Renderer
$LN160@Renderer:
	mov	eax, DWORD PTR _m$[ebp]
	sub	eax, 1
	mov	DWORD PTR _m$[ebp], eax
$LN161@Renderer:
	cmp	DWORD PTR _m$[ebp], -1
	jle	$LN159@Renderer

; 8711 : 	{
; 8712 : 		if(!z_slot[m]) continue;

	mov	eax, DWORD PTR _m$[ebp]
	movsx	ecx, WORD PTR _z_slot[eax*2]
	test	ecx, ecx
	jne	SHORT $LN158@Renderer
	jmp	SHORT $LN160@Renderer

; 8713 : 		else

	jmp	$LN154@Renderer
$LN158@Renderer:

; 8714 : 		for(n=0;n<z_slot[m];n++)

	mov	DWORD PTR _n$[ebp], 0
	jmp	SHORT $LN156@Renderer
$LN155@Renderer:
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN156@Renderer:
	mov	eax, DWORD PTR _m$[ebp]
	movsx	ecx, WORD PTR _z_slot[eax*2]
	cmp	DWORD PTR _n$[ebp], ecx
	jge	$LN154@Renderer

; 8715 : 		{
; 8716 : 			i=z_buffer[m][n];

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _n$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	mov	DWORD PTR _i$[ebp], edx

; 8717 : 			if(ent[i].data.vb_id!=-1)

	imul	eax, DWORD PTR _i$[ebp], 264
	movsx	ecx, WORD PTR _ent[eax+54]
	cmp	ecx, -1
	je	$LN153@Renderer

; 8718 : 			{
; 8719 : 				for(j=0;j<16;j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN152@Renderer
$LN151@Renderer:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN152@Renderer:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jge	$LN150@Renderer

; 8720 : 				{
; 8721 : 					//if(j<4)
; 8722 : 						//vbdt[ent[i].data.vb_id].texrepeat[(k[ent[i].data.vb_id])+j]=ent[i].texrepeat[j];
; 8723 : 
; 8724 : 					vbdt[ent[i].data.vb_id].color[(k[ent[i].data.vb_id]*16)+j]=ent[i].color[j];

	imul	eax, DWORD PTR _i$[ebp], 264
	imul	ecx, DWORD PTR _i$[ebp], 264
	movsx	edx, WORD PTR _ent[ecx+54]
	shl	edx, 6
	imul	ecx, DWORD PTR _i$[ebp], 264
	movsx	ecx, WORD PTR _ent[ecx+54]
	mov	esi, DWORD PTR _k$[ebp]
	movzx	ecx, WORD PTR [esi+ecx*2]
	shl	ecx, 4
	add	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _vbdt
	mov	edx, DWORD PTR [esi+edx+28]
	mov	esi, DWORD PTR _j$[ebp]
	mov	al, BYTE PTR _ent[eax+esi+228]
	mov	BYTE PTR [edx+ecx], al

; 8725 : 
; 8726 : 					if(j<12)

	cmp	DWORD PTR _j$[ebp], 12			; 0000000cH
	jge	SHORT $LN149@Renderer

; 8727 : 						vbdt[ent[i].data.vb_id].vertex[(k[ent[i].data.vb_id]*12)+j]=ent[i].vertex[j];

	imul	eax, DWORD PTR _i$[ebp], 264
	imul	ecx, DWORD PTR _i$[ebp], 264
	movsx	edx, WORD PTR _ent[ecx+54]
	shl	edx, 6
	imul	ecx, DWORD PTR _i$[ebp], 264
	movsx	ecx, WORD PTR _ent[ecx+54]
	mov	esi, DWORD PTR _k$[ebp]
	movzx	ecx, WORD PTR [esi+ecx*2]
	imul	ecx, ecx, 12
	add	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _vbdt
	mov	edx, DWORD PTR [esi+edx+12]
	mov	esi, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _ent[eax+esi*4+100]
	mov	DWORD PTR [edx+ecx*4], eax
$LN149@Renderer:

; 8728 : 
; 8729 : 					if(j<8)

	cmp	DWORD PTR _j$[ebp], 8
	jge	$LN148@Renderer

; 8730 : 					{
; 8731 : 						vbdt[ent[i].data.vb_id].texcoord[(k[ent[i].data.vb_id]*8)+j]=ent[i].texcor[j];

	imul	eax, DWORD PTR _i$[ebp], 264
	imul	ecx, DWORD PTR _i$[ebp], 264
	movsx	edx, WORD PTR _ent[ecx+54]
	shl	edx, 6
	imul	ecx, DWORD PTR _i$[ebp], 264
	movsx	ecx, WORD PTR _ent[ecx+54]
	mov	esi, DWORD PTR _k$[ebp]
	movzx	ecx, WORD PTR [esi+ecx*2]
	mov	esi, DWORD PTR _j$[ebp]
	lea	ecx, DWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR _vbdt
	mov	edx, DWORD PTR [esi+edx+16]
	mov	esi, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _ent[eax+esi*4+148]
	mov	DWORD PTR [edx+ecx*4], eax

; 8732 : 
; 8733 : 						vbdt[ent[i].data.vb_id].texcoordlight[(k[ent[i].data.vb_id]*8)+j]=ent[i].texcorlight[j];

	imul	eax, DWORD PTR _i$[ebp], 264
	imul	ecx, DWORD PTR _i$[ebp], 264
	movsx	edx, WORD PTR _ent[ecx+54]
	shl	edx, 6
	imul	ecx, DWORD PTR _i$[ebp], 264
	movsx	ecx, WORD PTR _ent[ecx+54]
	mov	esi, DWORD PTR _k$[ebp]
	movzx	ecx, WORD PTR [esi+ecx*2]
	mov	esi, DWORD PTR _j$[ebp]
	lea	ecx, DWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR _vbdt
	mov	edx, DWORD PTR [esi+edx+20]
	mov	esi, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _ent[eax+esi*4+180]
	mov	DWORD PTR [edx+ecx*4], eax
$LN148@Renderer:

; 8734 : 					}
; 8735 : 					
; 8736 : 					if(j<=2)

	cmp	DWORD PTR _j$[ebp], 2
	jg	SHORT $LN147@Renderer

; 8737 : 						vbdt[ent[i].data.vb_id].index[(k[ent[i].data.vb_id]*6)+j]=((k[ent[i].data.vb_id]*6)-(k[ent[i].data.vb_id]*2))+j;

	imul	eax, DWORD PTR _i$[ebp], 264
	movsx	ecx, WORD PTR _ent[eax+54]
	mov	edx, DWORD PTR _k$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2]
	imul	ecx, eax, 6
	imul	edx, DWORD PTR _i$[ebp], 264
	movsx	eax, WORD PTR _ent[edx+54]
	mov	edx, DWORD PTR _k$[ebp]
	movzx	eax, WORD PTR [edx+eax*2]
	shl	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _j$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	movsx	eax, WORD PTR _ent[edx+54]
	shl	eax, 6
	imul	edx, DWORD PTR _i$[ebp], 264
	movsx	edx, WORD PTR _ent[edx+54]
	mov	esi, DWORD PTR _k$[ebp]
	movzx	edx, WORD PTR [esi+edx*2]
	imul	edx, edx, 6
	add	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _vbdt
	mov	eax, DWORD PTR [esi+eax+32]
	mov	WORD PTR [eax+edx*2], cx
$LN147@Renderer:

; 8738 : 
; 8739 : 					if(j==3 || j==4)

	cmp	DWORD PTR _j$[ebp], 3
	je	SHORT $LN145@Renderer
	cmp	DWORD PTR _j$[ebp], 4
	jne	$LN146@Renderer
$LN145@Renderer:

; 8740 : 						vbdt[ent[i].data.vb_id].index[(k[ent[i].data.vb_id]*6)+j]=((k[ent[i].data.vb_id]*6)-(k[ent[i].data.vb_id]*2))+(j-1);

	imul	eax, DWORD PTR _i$[ebp], 264
	movsx	ecx, WORD PTR _ent[eax+54]
	mov	edx, DWORD PTR _k$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2]
	imul	ecx, eax, 6
	imul	edx, DWORD PTR _i$[ebp], 264
	movsx	eax, WORD PTR _ent[edx+54]
	mov	edx, DWORD PTR _k$[ebp]
	movzx	eax, WORD PTR [edx+eax*2]
	shl	eax, 1
	sub	ecx, eax
	mov	edx, DWORD PTR _j$[ebp]
	lea	eax, DWORD PTR [ecx+edx-1]
	imul	ecx, DWORD PTR _i$[ebp], 264
	movsx	edx, WORD PTR _ent[ecx+54]
	shl	edx, 6
	imul	ecx, DWORD PTR _i$[ebp], 264
	movsx	ecx, WORD PTR _ent[ecx+54]
	mov	esi, DWORD PTR _k$[ebp]
	movzx	ecx, WORD PTR [esi+ecx*2]
	imul	ecx, ecx, 6
	add	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _vbdt
	mov	edx, DWORD PTR [esi+edx+32]
	mov	WORD PTR [edx+ecx*2], ax
$LN146@Renderer:

; 8741 : 
; 8742 : 					if(j==5)

	cmp	DWORD PTR _j$[ebp], 5
	jne	SHORT $LN144@Renderer

; 8743 : 						vbdt[ent[i].data.vb_id].index[(k[ent[i].data.vb_id]*6)+j]=((k[ent[i].data.vb_id]*6)-(k[ent[i].data.vb_id]*2));

	imul	eax, DWORD PTR _i$[ebp], 264
	movsx	ecx, WORD PTR _ent[eax+54]
	mov	edx, DWORD PTR _k$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2]
	imul	ecx, eax, 6
	imul	edx, DWORD PTR _i$[ebp], 264
	movsx	eax, WORD PTR _ent[edx+54]
	mov	edx, DWORD PTR _k$[ebp]
	movzx	eax, WORD PTR [edx+eax*2]
	shl	eax, 1
	sub	ecx, eax
	imul	edx, DWORD PTR _i$[ebp], 264
	movsx	eax, WORD PTR _ent[edx+54]
	shl	eax, 6
	imul	edx, DWORD PTR _i$[ebp], 264
	movsx	edx, WORD PTR _ent[edx+54]
	mov	esi, DWORD PTR _k$[ebp]
	movzx	edx, WORD PTR [esi+edx*2]
	imul	edx, edx, 6
	add	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _vbdt
	mov	eax, DWORD PTR [esi+eax+32]
	mov	WORD PTR [eax+edx*2], cx
$LN144@Renderer:

; 8744 : 				}

	jmp	$LN151@Renderer
$LN150@Renderer:

; 8745 : 
; 8746 : 				ent[i].data.loc=k[ent[i].data.vb_id];

	imul	eax, DWORD PTR _i$[ebp], 264
	movsx	ecx, WORD PTR _ent[eax+54]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _k$[ebp]
	mov	cx, WORD PTR [eax+ecx*2]
	mov	WORD PTR _ent[edx+56], cx

; 8747 : 
; 8748 : 				k[ent[i].data.vb_id]++;

	imul	eax, DWORD PTR _i$[ebp], 264
	movsx	ecx, WORD PTR _ent[eax+54]
	mov	edx, DWORD PTR _k$[ebp]
	mov	ax, WORD PTR [edx+ecx*2]
	add	ax, 1
	imul	ecx, DWORD PTR _i$[ebp], 264
	movsx	edx, WORD PTR _ent[ecx+54]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	WORD PTR [ecx+edx*2], ax

; 8749 : 			}
; 8750 : 			else

	jmp	SHORT $LN143@Renderer
$LN153@Renderer:

; 8751 : 				ent[i].data.loc=-1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 65535				; 0000ffffH
	mov	WORD PTR _ent[eax+56], cx
$LN143@Renderer:

; 8752 : 		}

	jmp	$LN155@Renderer
$LN154@Renderer:

; 8753 : 	}

	jmp	$LN160@Renderer
$LN159@Renderer:

; 8754 : 
; 8755 : 	free(k);

	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 8756 : 
; 8757 : #ifdef _VAO_RENDER
; 8758 : 
; 8759 : 	if(st.renderer.VAO_ON)

	movzx	eax, BYTE PTR _st+2336440
	test	eax, eax
	je	$LN139@Renderer

; 8760 : 	{
; 8761 : 		for(i=0;i<vbdt_num;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN141@Renderer
$LN140@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN141@Renderer:
	movzx	eax, WORD PTR _vbdt_num
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN139@Renderer

; 8762 : 		{
; 8763 : 			if(vbdt[i].num_elements>0)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	test	edx, edx
	jle	$LN131@Renderer

; 8764 : 			{
; 8765 : 				if(vbdt[i].num_elements<vbdt[i].buffer_elements)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	eax, WORD PTR [ecx+eax+48]
	cmp	edx, eax
	jge	$LN137@Renderer

; 8766 : 				{
; 8767 : 					if(vbdt[i].num_elements!=vbdt[i].num_elements2)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	eax, WORD PTR [ecx+eax+50]
	cmp	edx, eax
	je	SHORT $LN136@Renderer

; 8768 : 					{
; 8769 : 						UpdateVAO(&vbdt[i],0,1,3);

	push	3
	push	1
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _vbdt
	push	eax
	call	_UpdateVAO
	add	esp, 16					; 00000010H

; 8770 : 						vbdt[i].num_elements2=vbdt[i].num_elements;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _vbdt
	mov	esi, DWORD PTR _vbdt
	mov	ax, WORD PTR [esi+eax+46]
	mov	WORD PTR [edx+ecx+50], ax

; 8771 : 					}
; 8772 : 					else

	jmp	SHORT $LN135@Renderer
$LN136@Renderer:

; 8773 : 						UpdateVAO(&vbdt[i],0,0,3);

	push	3
	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _vbdt
	push	eax
	call	_UpdateVAO
	add	esp, 16					; 00000010H
$LN135@Renderer:

; 8774 : 				}
; 8775 : 				else

	jmp	$LN131@Renderer
$LN137@Renderer:

; 8776 : 				if(vbdt[i].num_elements<vbdt[i].buffer_elements-8)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	eax, WORD PTR [ecx+eax+48]
	sub	eax, 8
	cmp	edx, eax
	jge	SHORT $LN133@Renderer

; 8777 : 				{
; 8778 : 					vbdt[i].buffer_elements=vbdt[i].num_elements+8;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	add	edx, 8
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	WORD PTR [ecx+eax+48], dx

; 8779 : 					UpdateVAO(&vbdt[i],1,1,3);

	push	3
	push	1
	push	1
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _vbdt
	push	eax
	call	_UpdateVAO
	add	esp, 16					; 00000010H

; 8780 : 				}
; 8781 : 				else

	jmp	SHORT $LN131@Renderer
$LN133@Renderer:

; 8782 : 				if(vbdt[i].num_elements>=vbdt[i].buffer_elements)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	eax, WORD PTR [ecx+eax+48]
	cmp	edx, eax
	jl	SHORT $LN131@Renderer

; 8783 : 				{
; 8784 : 					vbdt[i].buffer_elements=vbdt[i].num_elements+8;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	add	edx, 8
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	WORD PTR [ecx+eax+48], dx

; 8785 : 					UpdateVAO(&vbdt[i],1,1,3);

	push	3
	push	1
	push	1
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _vbdt
	push	eax
	call	_UpdateVAO
	add	esp, 16					; 00000010H
$LN131@Renderer:

; 8786 : 				}
; 8787 : 			}
; 8788 : 		}

	jmp	$LN140@Renderer
$LN139@Renderer:

; 8789 : 	}
; 8790 : 
; 8791 : #endif
; 8792 : 		/*
; 8793 : 		else
; 8794 : 		if(vbdt[i].num_elements==0 && vbdt[i].buffer_elements>8)
; 8795 : 		{
; 8796 : 			vbdt[i].buffer_elements=8;
; 8797 : 			UpdateVAO(&vbdt[i],2,0,2);
; 8798 : 		}
; 8799 : 		*/
; 8800 : 
; 8801 : #endif
; 8802 : 
; 8803 : 	if(type)

	movzx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN130@Renderer

; 8804 : 		st.num_lightmap=1; //Make sure BASICBKD() is being used

	mov	BYTE PTR _st+261, 1
$LN130@Renderer:

; 8805 : 
; 8806 : 	num_targets=st.num_entities;

	mov	eax, DWORD PTR _st+244
	mov	DWORD PTR _num_targets$[ebp], eax

; 8807 : 
; 8808 : #ifdef _VAO_RENDER
; 8809 : 	if(st.renderer.VAO_ON)

	movzx	eax, BYTE PTR _st+2336440
	test	eax, eax
	je	$LN83@Renderer

; 8810 : 	{
; 8811 : 		glUseProgram(st.renderer.Program[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glUseProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8812 : 
; 8813 : 		glUniform1i(st.renderer.unifs[1],0);

	mov	esi, esp
	push	0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _st[eax+2336712]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glUniform1i
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8814 : 
; 8815 : 		glUniform1i(st.renderer.unifs[2],2);

	mov	esi, esp
	push	2
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _st[eax+2336712]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glUniform1i
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8816 : 
; 8817 : 		glUniform1i(st.renderer.unifs[3],1);

	mov	esi, esp
	push	1
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336712]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glUniform1i
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8818 : 
; 8819 : 		glUniform1f(st.renderer.unifs[4],0);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _st[eax+2336712]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glUniform1f
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8820 : 
; 8821 : 		glBindFramebuffer(GL_FRAMEBUFFER,st.renderer.FBO[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336776]
	push	edx
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glBindFramebuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8822 : 
; 8823 : 		glDrawBuffers(1,&st.renderer.Buffers[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	add	ecx, OFFSET _st+2336856
	mov	esi, esp
	push	ecx
	push	1
	call	DWORD PTR _GLeeFuncPtr_glDrawBuffers
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8824 : 
; 8825 : 		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	mov	esi, esp
	push	16640					; 00004100H
	call	DWORD PTR __imp__glClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8826 : 
; 8827 : 		glActiveTexture(GL_TEXTURE0);

	mov	esi, esp
	push	33984					; 000084c0H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8828 : 
; 8829 : 		glBindVertexArray(vbd.vao_id);

	mov	esi, esp
	mov	eax, DWORD PTR _vbd
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8830 : 
; 8831 : 		glBindBuffer(GL_ARRAY_BUFFER,vbd.vbo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _vbd+8
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8832 : 
; 8833 : 		if(z_used>15)

	movsx	eax, BYTE PTR _z_used
	cmp	eax, 15					; 0000000fH
	jle	$LN125@Renderer

; 8834 : 		{
; 8835 : 			for(i=0;i<st.num_lightmap;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN127@Renderer
$LN126@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN127@Renderer:
	movzx	eax, BYTE PTR _st+261
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN125@Renderer

; 8836 : 			{
; 8837 : 				glBindTexture(GL_TEXTURE_2D,lmp[i].data.data);

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	esi, esp
	mov	ecx, DWORD PTR _lmp[eax+44]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8838 : 
; 8839 : 				glBufferSubData(GL_ARRAY_BUFFER,0,12*sizeof(float),lmp[i].vertex);

	imul	eax, DWORD PTR _i$[ebp], 264
	add	eax, OFFSET _lmp+100
	mov	esi, esp
	push	eax
	push	48					; 00000030H
	push	0
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8840 : 				glBufferSubData(GL_ARRAY_BUFFER,12*sizeof(float),8*sizeof(float),vbd.texcoord);

	mov	esi, esp
	mov	eax, DWORD PTR _vbd+16
	push	eax
	push	32					; 00000020H
	push	48					; 00000030H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8841 : 				glBufferSubData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float)),16*sizeof(GLubyte),lmp[i].color);

	imul	eax, DWORD PTR _i$[ebp], 264
	add	eax, OFFSET _lmp+228
	mov	esi, esp
	push	eax
	push	16					; 00000010H
	push	80					; 00000050H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8842 : 
; 8843 : 				glDrawRangeElements(GL_TRIANGLES,0,6,6,GL_UNSIGNED_SHORT,0);

	mov	esi, esp
	push	0
	push	5123					; 00001403H
	push	6
	push	6
	push	0
	push	4
	call	DWORD PTR _GLeeFuncPtr_glDrawRangeElements
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8844 : 			}

	jmp	$LN126@Renderer
$LN125@Renderer:

; 8845 : 		}
; 8846 : 
; 8847 : 		glActiveTexture(GL_TEXTURE2);

	mov	esi, esp
	push	33986					; 000084c2H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8848 : 
; 8849 : 		glBindTexture(GL_TEXTURE_2D,st.renderer.FBTex[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336792]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8850 : 
; 8851 : 		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@46180000
	movss	DWORD PTR [esp], xmm0
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameterf@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8852 : 		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@46180000
	movss	DWORD PTR [esp], xmm0
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameterf@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8853 : 
; 8854 : 		glBindFramebuffer(GL_FRAMEBUFFER,0);

	mov	esi, esp
	push	0
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glBindFramebuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8855 : 
; 8856 : 		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	mov	esi, esp
	push	16640					; 00004100H
	call	DWORD PTR __imp__glClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8857 : 
; 8858 : 		for(i=z_used;i>-1;i--)

	movsx	eax, BYTE PTR _z_used
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN124@Renderer
$LN123@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN124@Renderer:
	cmp	DWORD PTR _i$[ebp], -1
	jle	$LN122@Renderer

; 8859 : 		{
; 8860 : 			for(j=0;j<z_slot[i];j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN121@Renderer
$LN120@Renderer:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN121@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _z_slot[eax*2]
	cmp	DWORD PTR _j$[ebp], ecx
	jge	$LN119@Renderer

; 8861 : 			{
; 8862 : 				if(ent[z_buffer[i][j]].data.vb_id!=-1)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movsx	ecx, WORD PTR _ent[eax+54]
	cmp	ecx, -1
	je	$LN118@Renderer

; 8863 : 				{
; 8864 : 					m=ent[z_buffer[i][j]].data.vb_id;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movsx	ecx, WORD PTR _ent[eax+54]
	mov	DWORD PTR _m$[ebp], ecx

; 8865 : 
; 8866 : 					glActiveTexture(GL_TEXTURE0);

	mov	esi, esp
	push	33984					; 000084c0H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8867 : 
; 8868 : 					if(tex_bound[0]!=vbdt[m].texture)

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _m$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _vbdt
	mov	ecx, DWORD PTR _tex_bound$[ebp+ecx]
	cmp	ecx, DWORD PTR [eax+edx+36]
	je	SHORT $LN117@Renderer

; 8869 : 					{
; 8870 : 						glBindTexture(GL_TEXTURE_2D,vbdt[m].texture);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+36]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8871 : 						tex_bound[0]=vbdt[m].texture;

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _vbdt
	mov	eax, DWORD PTR [ecx+eax+36]
	mov	DWORD PTR _tex_bound$[ebp+edx], eax
$LN117@Renderer:

; 8872 : 					}
; 8873 : 
; 8874 : 					//glUniform2f(st.renderer.unifs[6],(float) ent[z_buffer[i][j]].data.sizex/32768,(float) ent[z_buffer[i][j]].data.sizey/32768);
; 8875 : 					//glUniform2f(st.renderer.unifs[7],(float) ent[z_buffer[i][j]].data.posx/32768,(float) ent[z_buffer[i][j]].data.posy/32768);
; 8876 : 
; 8877 : 					if(i<16  || ent[z_buffer[i][j]].lightmapid==-2)

	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jl	SHORT $LN115@Renderer
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movsx	ecx, WORD PTR _ent[eax+260]
	cmp	ecx, -2					; fffffffeH
	jne	SHORT $LN116@Renderer
$LN115@Renderer:

; 8878 : 						glUniform1f(st.renderer.unifs[4],3);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _st[eax+2336712]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glUniform1f
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8879 : 					else

	jmp	$LN111@Renderer
$LN116@Renderer:

; 8880 : 					{
; 8881 : 						glActiveTexture(GL_TEXTURE1);

	mov	esi, esp
	push	33985					; 000084c1H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8882 : 
; 8883 : 						if(vbdt[m].normal)

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, BYTE PTR [ecx+eax+44]
	test	edx, edx
	je	$LN113@Renderer

; 8884 : 						{
; 8885 : 							if(tex_bound[1]!=vbdt[m].Ntexture)

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _m$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _vbdt
	mov	eax, DWORD PTR _tex_bound$[ebp+eax]
	cmp	eax, DWORD PTR [edx+ecx+40]
	je	SHORT $LN112@Renderer

; 8886 : 							{
; 8887 : 								glBindTexture(GL_TEXTURE_2D,vbdt[m].Ntexture);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+40]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8888 : 								tex_bound[1]=vbdt[m].Ntexture;

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _vbdt
	mov	eax, DWORD PTR [edx+eax+40]
	mov	DWORD PTR _tex_bound$[ebp+ecx], eax
$LN112@Renderer:

; 8889 : 							}
; 8890 : 							glUniform1f(st.renderer.unifs[4],1);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _st[eax+2336712]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glUniform1f
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8891 : 						}
; 8892 : 						else

	jmp	SHORT $LN111@Renderer
$LN113@Renderer:

; 8893 : 						{
; 8894 : 							//if(tex_bound[1]!=vbdt[m].texture)
; 8895 : 							//{
; 8896 : 							//	glBindTexture(GL_TEXTURE_2D,vbdt[m].texture);
; 8897 : 								//tex_bound[1]=vbdt[m].texture;
; 8898 : 							//}
; 8899 : 
; 8900 : 							glUniform1f(st.renderer.unifs[4],2);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _st[eax+2336712]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glUniform1f
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN111@Renderer:

; 8901 : 						}
; 8902 : 
; 8903 : 					}
; 8904 : 
; 8905 : 					glBindVertexArray(vbdt[m].vao_id);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8906 : 
; 8907 : 					l=0;

	xor	eax, eax
	mov	WORD PTR _l$[ebp], ax

; 8908 : 					if(j<z_slot[i]-2)

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _z_slot[eax*2]
	sub	ecx, 2
	cmp	DWORD PTR _j$[ebp], ecx
	jge	$LN107@Renderer

; 8909 : 					{
; 8910 : 						for(m=j+1;m<z_slot[i];m++)

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _m$[ebp], eax
	jmp	SHORT $LN109@Renderer
$LN108@Renderer:
	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 1
	mov	DWORD PTR _m$[ebp], eax
$LN109@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _z_slot[eax*2]
	cmp	DWORD PTR _m$[ebp], ecx
	jge	$LN107@Renderer

; 8911 : 						{
; 8912 : 							if(ent[z_buffer[i][m]].data.vb_id==ent[z_buffer[i][j]].data.vb_id && ent[z_buffer[i][m]].lightmapid==ent[z_buffer[i][j]].lightmapid)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _m$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movsx	ecx, WORD PTR _ent[eax+54]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[edx+eax*2]
	imul	eax, edx, 264
	movsx	edx, WORD PTR _ent[eax+54]
	cmp	ecx, edx
	jne	SHORT $LN106@Renderer
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _m$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movsx	ecx, WORD PTR _ent[eax+260]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[edx+eax*2]
	imul	eax, edx, 264
	movsx	edx, WORD PTR _ent[eax+260]
	cmp	ecx, edx
	jne	SHORT $LN106@Renderer

; 8913 : 								l++;

	mov	ax, WORD PTR _l$[ebp]
	add	ax, 1
	mov	WORD PTR _l$[ebp], ax

; 8914 : 							else

	jmp	SHORT $LN105@Renderer
$LN106@Renderer:

; 8915 : 								break;

	jmp	SHORT $LN107@Renderer
$LN105@Renderer:

; 8916 : 						}

	jmp	$LN108@Renderer
$LN107@Renderer:

; 8917 : 					}
; 8918 : 
; 8919 : 					if(!l)

	movzx	eax, WORD PTR _l$[ebp]
	test	eax, eax
	jne	SHORT $LN104@Renderer

; 8920 : 						glDrawRangeElements(GL_TRIANGLES,0,(ent[z_buffer[i][j]].data.loc*6)+6,6,GL_UNSIGNED_SHORT,(void*) ((ent[z_buffer[i][j]].data.loc*6)*2));

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movzx	ecx, WORD PTR _ent[eax+56]
	imul	edx, ecx, 6
	shl	edx, 1
	mov	esi, esp
	push	edx
	push	5123					; 00001403H
	push	6
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movzx	ecx, WORD PTR _ent[eax+56]
	imul	edx, ecx, 6
	add	edx, 6
	push	edx
	push	0
	push	4
	call	DWORD PTR _GLeeFuncPtr_glDrawRangeElements
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8921 : 					else

	jmp	SHORT $LN103@Renderer
$LN104@Renderer:

; 8922 : 						glDrawRangeElements(GL_TRIANGLES,0,((ent[z_buffer[i][j]].data.loc+l)*6)+6,(l*6)+6,GL_UNSIGNED_SHORT,(void*) ((ent[z_buffer[i][j]].data.loc*6)*2));

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movzx	ecx, WORD PTR _ent[eax+56]
	imul	edx, ecx, 6
	shl	edx, 1
	mov	esi, esp
	push	edx
	push	5123					; 00001403H
	movzx	eax, WORD PTR _l$[ebp]
	imul	ecx, eax, 6
	add	ecx, 6
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _z_buffer[edx+eax*2]
	imul	edx, ecx, 264
	movzx	eax, WORD PTR _ent[edx+56]
	movzx	ecx, WORD PTR _l$[ebp]
	add	eax, ecx
	imul	edx, eax, 6
	add	edx, 6
	push	edx
	push	0
	push	4
	call	DWORD PTR _GLeeFuncPtr_glDrawRangeElements
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN103@Renderer:

; 8923 : 
; 8924 : 					glBindVertexArray(0);

	mov	esi, esp
	push	0
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8925 : 
; 8926 : 					if(l)

	movzx	eax, WORD PTR _l$[ebp]
	test	eax, eax
	je	SHORT $LN102@Renderer

; 8927 : 						j+=l;

	movzx	eax, WORD PTR _l$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _j$[ebp], eax
$LN102@Renderer:

; 8928 : 				}
; 8929 : 				else

	jmp	$LN101@Renderer
$LN118@Renderer:

; 8930 : 				{
; 8931 : 					glActiveTexture(GL_TEXTURE0);

	mov	esi, esp
	push	33984					; 000084c0H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8932 : 
; 8933 : 					if(tex_bound[0]!=ent[z_buffer[i][j]].data.data)

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[edx+eax*2]
	imul	eax, edx, 264
	mov	ecx, DWORD PTR _tex_bound$[ebp+ecx]
	cmp	ecx, DWORD PTR _ent[eax+44]
	je	SHORT $LN100@Renderer

; 8934 : 					{
; 8935 : 						glBindTexture(GL_TEXTURE_2D,ent[z_buffer[i][j]].data.data);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	mov	esi, esp
	mov	ecx, DWORD PTR _ent[eax+44]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8936 : 						tex_bound[0]=ent[z_buffer[i][j]].data.data;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent[eax+44]
	mov	DWORD PTR _tex_bound$[ebp+edx], eax
$LN100@Renderer:

; 8937 : 					}
; 8938 : 
; 8939 : 					//glUniform2f(st.renderer.unifs[6],(float) ent[z_buffer[i][j]].data.sizex/32768,(float) ent[z_buffer[i][j]].data.sizey/32768);
; 8940 : 					//glUniform2f(st.renderer.unifs[7],(float) ent[z_buffer[i][j]].data.posx/32768,(float) ent[z_buffer[i][j]].data.posy/32768);
; 8941 : 
; 8942 : 					if(i<16 || ent[z_buffer[i][j]].lightmapid==-2)

	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jl	SHORT $LN98@Renderer
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movsx	ecx, WORD PTR _ent[eax+260]
	cmp	ecx, -2					; fffffffeH
	jne	SHORT $LN99@Renderer
$LN98@Renderer:

; 8943 : 						glUniform1f(st.renderer.unifs[4],3);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _st[eax+2336712]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glUniform1f
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8944 : 					else

	jmp	$LN94@Renderer
$LN99@Renderer:

; 8945 : 					{
; 8946 : 						glActiveTexture(GL_TEXTURE1);

	mov	esi, esp
	push	33985					; 000084c1H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8947 : 
; 8948 : 						if(ent[z_buffer[i][j]].data.normal)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movzx	ecx, BYTE PTR _ent[eax+52]
	test	ecx, ecx
	je	$LN96@Renderer

; 8949 : 						{
; 8950 : 							glUniform1f(st.renderer.unifs[4],1);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _st[eax+2336712]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glUniform1f
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8951 : 
; 8952 : 							if(tex_bound[1]!=ent[z_buffer[i][j]].data.Ndata)

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _z_buffer[ecx+edx*2]
	imul	edx, ecx, 264
	mov	eax, DWORD PTR _tex_bound$[ebp+eax]
	cmp	eax, DWORD PTR _ent[edx+48]
	je	SHORT $LN95@Renderer

; 8953 : 							{
; 8954 : 								glBindTexture(GL_TEXTURE_2D,ent[z_buffer[i][j]].data.Ndata);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	mov	esi, esp
	mov	ecx, DWORD PTR _ent[eax+48]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8955 : 								tex_bound[1]=ent[z_buffer[i][j]].data.Ndata;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent[eax+48]
	mov	DWORD PTR _tex_bound$[ebp+ecx], edx
$LN95@Renderer:

; 8956 : 							}
; 8957 : 						}
; 8958 : 						else

	jmp	$LN94@Renderer
$LN96@Renderer:

; 8959 : 						{
; 8960 : 							if(tex_bound[1]!=ent[z_buffer[i][j]].data.data)

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _z_buffer[ecx+edx*2]
	imul	edx, ecx, 264
	mov	eax, DWORD PTR _tex_bound$[ebp+eax]
	cmp	eax, DWORD PTR _ent[edx+44]
	je	SHORT $LN93@Renderer

; 8961 : 							{
; 8962 : 								glBindTexture(GL_TEXTURE_2D,ent[z_buffer[i][j]].data.data);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	mov	esi, esp
	mov	ecx, DWORD PTR _ent[eax+44]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8963 : 								tex_bound[1]=ent[z_buffer[i][j]].data.data;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent[eax+44]
	mov	DWORD PTR _tex_bound$[ebp+ecx], edx
$LN93@Renderer:

; 8964 : 							}
; 8965 : 
; 8966 : 							glUniform1f(st.renderer.unifs[4],2);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _st[eax+2336712]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glUniform1f
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN94@Renderer:

; 8967 : 						}
; 8968 : 					}
; 8969 : 
; 8970 : 					glBindVertexArray(vbd.vao_id);

	mov	esi, esp
	mov	eax, DWORD PTR _vbd
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8971 : 
; 8972 : 					glBindBuffer(GL_ARRAY_BUFFER,vbd.vbo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _vbd+8
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8973 : 
; 8974 : 					glBufferSubData(GL_ARRAY_BUFFER,0,12*sizeof(float),ent[z_buffer[i][j]].vertex);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	add	eax, OFFSET _ent+100
	mov	esi, esp
	push	eax
	push	48					; 00000030H
	push	0
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8975 : 					glBufferSubData(GL_ARRAY_BUFFER,12*sizeof(float),8*sizeof(float),ent[z_buffer[i][j]].texcor);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	add	eax, OFFSET _ent+148
	mov	esi, esp
	push	eax
	push	32					; 00000020H
	push	48					; 00000030H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8976 : 					glBufferSubData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float)),16*sizeof(GLubyte),ent[z_buffer[i][j]].color);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	add	eax, OFFSET _ent+228
	mov	esi, esp
	push	eax
	push	16					; 00000010H
	push	80					; 00000050H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8977 : 					glBufferSubData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float))+(16*sizeof(GLubyte)),8*sizeof(float),ent[z_buffer[i][j]].texcorlight);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	add	eax, OFFSET _ent+180
	mov	esi, esp
	push	eax
	push	32					; 00000020H
	push	96					; 00000060H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8978 : 					//glBufferSubData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float))+(16*sizeof(GLubyte))+(8*sizeof(GLfloat)),4*sizeof(float),ent[z_buffer[i][j]].texrepeat);
; 8979 : 
; 8980 : 					glDrawRangeElements(GL_TRIANGLES,0,6,6,GL_UNSIGNED_SHORT,0);

	mov	esi, esp
	push	0
	push	5123					; 00001403H
	push	6
	push	6
	push	0
	push	4
	call	DWORD PTR _GLeeFuncPtr_glDrawRangeElements
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8981 : 
; 8982 : 					glBindVertexArray(0);

	mov	esi, esp
	push	0
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN101@Renderer:

; 8983 : 				}
; 8984 : 			}

	jmp	$LN120@Renderer
$LN119@Renderer:

; 8985 : 
; 8986 : 			if(i==0) break;

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN92@Renderer
	jmp	SHORT $LN122@Renderer
$LN92@Renderer:

; 8987 : 		}

	jmp	$LN123@Renderer
$LN122@Renderer:

; 8988 : 
; 8989 : 		memset(z_buffer,0,57*(2048)*sizeof(int16));

	push	233472					; 00039000H
	push	0
	push	OFFSET _z_buffer
	call	_memset
	add	esp, 12					; 0000000cH

; 8990 : 		memset(z_slot,0,57*sizeof(int16));

	push	114					; 00000072H
	push	0
	push	OFFSET _z_slot
	call	_memset
	add	esp, 12					; 0000000cH

; 8991 : 		z_used=0;

	mov	BYTE PTR _z_used, 0

; 8992 : 
; 8993 : 		for(i=0;i<MAX_STRINGS;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN91@Renderer
$LN90@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN91@Renderer:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	SHORT $LN89@Renderer

; 8994 : 		{
; 8995 : 			if(st.strings[i].stat==1)

	imul	eax, DWORD PTR _i$[ebp], 1068
	movsx	ecx, BYTE PTR _st[eax+2762084]
	cmp	ecx, 1
	jne	SHORT $LN88@Renderer

; 8996 : 			{
; 8997 : 				st.strings[i].stat=2;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	BYTE PTR _st[eax+2762084], 2

; 8998 : 				continue;

	jmp	SHORT $LN90@Renderer

; 8999 : 			}
; 9000 : 			else

	jmp	SHORT $LN86@Renderer
$LN88@Renderer:

; 9001 : 			if(st.strings[i].stat==2)

	imul	eax, DWORD PTR _i$[ebp], 1068
	movsx	ecx, BYTE PTR _st[eax+2762084]
	cmp	ecx, 2
	jne	SHORT $LN86@Renderer

; 9002 : 			{
; 9003 : 				glDeleteTextures(1,&st.strings[i].data.data);

	imul	eax, DWORD PTR _i$[ebp], 1068
	add	eax, OFFSET _st+2762044
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9004 : 				st.strings[i].data.channel=0;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	DWORD PTR _st[eax+2762076], 0

; 9005 : 				st.strings[i].stat=0;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	BYTE PTR _st[eax+2762084], 0
$LN86@Renderer:

; 9006 : 			}
; 9007 : 		}

	jmp	$LN90@Renderer
$LN89@Renderer:

; 9008 : 		
; 9009 : 		for(i=0;i<vbdt_num;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN85@Renderer
$LN84@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN85@Renderer:
	movzx	eax, WORD PTR _vbdt_num
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN83@Renderer

; 9010 : 		{
; 9011 : 			if(vbdt[i].num_elements>0)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	test	edx, edx
	jle	SHORT $LN82@Renderer

; 9012 : 			{
; 9013 : 				vbdt[i].num_elements=0;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	xor	ecx, ecx
	mov	edx, DWORD PTR _vbdt
	mov	WORD PTR [edx+eax+46], cx
$LN82@Renderer:

; 9014 : 			}
; 9015 : 		}

	jmp	SHORT $LN84@Renderer
$LN83@Renderer:

; 9016 : 		
; 9017 : 	}
; 9018 : 	
; 9019 : #endif
; 9020 : 	
; 9021 : #ifdef _VBO_RENDER
; 9022 : 	if(st.renderer.VBO_ON)

	movzx	eax, BYTE PTR _st+2336452
	test	eax, eax
	je	$LN36@Renderer

; 9023 : 	{
; 9024 : 		glBindFramebuffer(GL_FRAMEBUFFER,st.renderer.FBO[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336776]
	push	edx
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glBindFramebuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9025 : 
; 9026 : 		if(st.num_lightmap>0)

	movzx	eax, BYTE PTR _st+261
	test	eax, eax
	jle	$LN77@Renderer

; 9027 : 		{
; 9028 : 			glDrawBuffers(1,&st.renderer.Buffers[2]);

	mov	eax, 4
	shl	eax, 1
	add	eax, OFFSET _st+2336856
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR _GLeeFuncPtr_glDrawBuffers
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9029 : 
; 9030 : 			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	mov	esi, esp
	push	16640					; 00004100H
	call	DWORD PTR __imp__glClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9031 : 
; 9032 : 			for(i=0;i<st.num_lightmap;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN79@Renderer
$LN78@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN79@Renderer:
	movzx	eax, BYTE PTR _st+261
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN77@Renderer

; 9033 : 			{
; 9034 : 				glUseProgram(st.renderer.Program[2]);

	mov	eax, 4
	shl	eax, 1
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glUseProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9035 : 				unif=glGetUniformLocation(st.renderer.Program[2],"texu");

	mov	esi, esp
	push	OFFSET ??_C@_04DBNNPNIH@texu?$AA@
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _unif$[ebp], eax

; 9036 : 				glUniform1i(unif,0);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _unif$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glUniform1i
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9037 : 
; 9038 : 				unif=glGetUniformLocation(st.renderer.Program[2],"normal");

	mov	esi, esp
	push	OFFSET ??_C@_06IKLLLDHL@normal?$AA@
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _unif$[ebp], eax

; 9039 : 				glUniform1f(unif,0);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _unif$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glUniform1f
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9040 : 
; 9041 : 				glActiveTexture(GL_TEXTURE0);

	mov	esi, esp
	push	33984					; 000084c0H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9042 : 				glBindTexture(GL_TEXTURE_2D,lmp[i].data.data);

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	esi, esp
	mov	ecx, DWORD PTR _lmp[eax+44]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9043 : 
; 9044 : 				glBindBuffer(GL_ARRAY_BUFFER,vbd.vbo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _vbd+8
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9045 : 				glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,vbd.ibo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _vbd+4
	push	eax
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9046 : 
; 9047 : 				glBufferData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float))+(16*sizeof(GLubyte)),NULL,GL_STREAM_DRAW);

	mov	esi, esp
	push	35040					; 000088e0H
	push	0
	push	96					; 00000060H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9048 : 				glBufferSubData(GL_ARRAY_BUFFER,0,12*sizeof(float),lmp[i].vertex);

	imul	eax, DWORD PTR _i$[ebp], 264
	add	eax, OFFSET _lmp+100
	mov	esi, esp
	push	eax
	push	48					; 00000030H
	push	0
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9049 : 				glBufferSubData(GL_ARRAY_BUFFER,12*sizeof(float),8*sizeof(float),texcoord);

	mov	esi, esp
	lea	eax, DWORD PTR _texcoord$[ebp]
	push	eax
	push	32					; 00000020H
	push	48					; 00000030H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9050 : 				glBufferSubData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float)),16*sizeof(GLubyte),vbd.color);

	mov	esi, esp
	mov	eax, DWORD PTR _vbd+28
	push	eax
	push	16					; 00000010H
	push	80					; 00000050H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9051 : 
; 9052 : 				glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*sizeof(GLushort)),vbd.index,GL_STREAM_DRAW);

	mov	esi, esp
	push	35040					; 000088e0H
	mov	eax, DWORD PTR _vbd+32
	push	eax
	push	12					; 0000000cH
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9053 : 				
; 9054 : 				pos=glGetAttribLocation(st.renderer.Program[2],"Position");

	mov	esi, esp
	push	OFFSET ??_C@_08GCJNLIKG@Position?$AA@
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pos$[ebp], eax

; 9055 : 				texc=glGetAttribLocation(st.renderer.Program[2],"TexCoord");

	mov	esi, esp
	push	OFFSET ??_C@_08NGMLKGCO@TexCoord?$AA@
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _texc$[ebp], eax

; 9056 : 				col=glGetAttribLocation(st.renderer.Program[2],"Color");

	mov	esi, esp
	push	OFFSET ??_C@_05PDOBBJNA@Color?$AA@
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _col$[ebp], eax

; 9057 : 
; 9058 : 				glEnableVertexAttribArray(pos);

	mov	esi, esp
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9059 : 				glEnableVertexAttribArray(texc);

	mov	esi, esp
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9060 : 				glEnableVertexAttribArray(col);

	mov	esi, esp
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9061 : 
; 9062 : 				glVertexAttribPointer(pos,3,GL_FLOAT,GL_FALSE,0,0);

	mov	esi, esp
	push	0
	push	0
	push	0
	push	5126					; 00001406H
	push	3
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9063 : 				glVertexAttribPointer(texc,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) (12*sizeof(GLfloat)));

	mov	esi, esp
	push	48					; 00000030H
	push	0
	push	0
	push	5126					; 00001406H
	push	2
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9064 : 				glVertexAttribPointer(col,4,GL_UNSIGNED_BYTE,GL_TRUE,0,(GLvoid*) ((12*sizeof(GLfloat))+(8*sizeof(GLfloat))));

	mov	esi, esp
	push	80					; 00000050H
	push	0
	push	1
	push	5121					; 00001401H
	push	4
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9065 : 				
; 9066 : 				glDrawRangeElements(GL_TRIANGLES,0,6,6,GL_UNSIGNED_SHORT,0);

	mov	esi, esp
	push	0
	push	5123					; 00001403H
	push	6
	push	6
	push	0
	push	4
	call	DWORD PTR _GLeeFuncPtr_glDrawRangeElements
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9067 : 				
; 9068 : 				glDisableVertexAttribArray(pos);

	mov	esi, esp
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9069 : 				glDisableVertexAttribArray(texc);

	mov	esi, esp
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9070 : 				glDisableVertexAttribArray(col);

	mov	esi, esp
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9071 : 				
; 9072 : 				glBindBuffer(GL_ARRAY_BUFFER,0);

	mov	esi, esp
	push	0
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9073 : 				glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);

	mov	esi, esp
	push	0
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9074 : 
; 9075 : 				glUseProgram(0);

	mov	esi, esp
	push	0
	call	DWORD PTR _GLeeFuncPtr_glUseProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9076 : 			}

	jmp	$LN78@Renderer
$LN77@Renderer:

; 9077 : 		}
; 9078 : 
; 9079 : 		//glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
; 9080 : 
; 9081 : 		glBindFramebuffer(GL_FRAMEBUFFER,0);

	mov	esi, esp
	push	0
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glBindFramebuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9082 : 		//glDrawBuffers(1,&st.renderer.Buffers[1]);
; 9083 : 
; 9084 : 		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	mov	esi, esp
	push	16640					; 00004100H
	call	DWORD PTR __imp__glClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9085 : 
; 9086 : 		glActiveTexture(GL_TEXTURE2);

	mov	esi, esp
	push	33986					; 000084c2H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9087 : 		glBindTexture(GL_TEXTURE_2D,st.renderer.FBTex[2]);

	mov	eax, 4
	shl	eax, 1
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336792]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9088 : 
; 9089 : 		glGenerateMipmap(GL_TEXTURE_2D);

	mov	esi, esp
	push	3553					; 00000de1H
	call	DWORD PTR _GLeeFuncPtr_glGenerateMipmap
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9090 : 
; 9091 : 		glUseProgram(st.renderer.Program[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glUseProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9092 : 
; 9093 : 		unif=glGetUniformLocation(st.renderer.Program[3],"texu");

	mov	esi, esp
	push	OFFSET ??_C@_04DBNNPNIH@texu?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _unif$[ebp], eax

; 9094 : 		glUniform1i(unif,0);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _unif$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glUniform1i
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9095 : 
; 9096 : 		unif=glGetUniformLocation(st.renderer.Program[3],"texu2");

	mov	esi, esp
	push	OFFSET ??_C@_05JOJNJPAP@texu2?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _unif$[ebp], eax

; 9097 : 		glUniform1i(unif,2);

	mov	esi, esp
	push	2
	mov	eax, DWORD PTR _unif$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glUniform1i
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9098 : 
; 9099 : 		unif=glGetUniformLocation(st.renderer.Program[3],"texu3");

	mov	esi, esp
	push	OFFSET ??_C@_05IHIGKOEO@texu3?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _unif$[ebp], eax

; 9100 : 		glUniform1i(unif,1);

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _unif$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glUniform1i
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9101 : 
; 9102 : 
; 9103 : 		for(i=z_used;i>-1;i--)

	movsx	eax, BYTE PTR _z_used
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN76@Renderer
$LN75@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN76@Renderer:
	cmp	DWORD PTR _i$[ebp], -1
	jle	$LN74@Renderer

; 9104 : 		{
; 9105 : 			for(j=0;j<z_slot[i];j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN73@Renderer
$LN72@Renderer:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN73@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _z_slot[eax*2]
	cmp	DWORD PTR _j$[ebp], ecx
	jge	$LN71@Renderer

; 9106 : 			{
; 9107 : 				if(ent[z_buffer[i][j]].data.vb_id!=-1)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movsx	ecx, WORD PTR _ent[eax+54]
	cmp	ecx, -1
	je	$LN70@Renderer

; 9108 : 				{
; 9109 : 					m=ent[z_buffer[i][j]].data.vb_id;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movsx	ecx, WORD PTR _ent[eax+54]
	mov	DWORD PTR _m$[ebp], ecx

; 9110 : 
; 9111 : 					glActiveTexture(GL_TEXTURE0);

	mov	esi, esp
	push	33984					; 000084c0H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9112 : 
; 9113 : 					if(tex_bound[0]!=vbdt[m].texture)

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _m$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _vbdt
	mov	ecx, DWORD PTR _tex_bound$[ebp+ecx]
	cmp	ecx, DWORD PTR [eax+edx+36]
	je	SHORT $LN69@Renderer

; 9114 : 					{
; 9115 : 						glBindTexture(GL_TEXTURE_2D,vbdt[m].texture);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+36]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9116 : 						tex_bound[0]=vbdt[m].texture;

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _vbdt
	mov	eax, DWORD PTR [ecx+eax+36]
	mov	DWORD PTR _tex_bound$[ebp+edx], eax
$LN69@Renderer:

; 9117 : 					}
; 9118 : 
; 9119 : 					if(i<16)

	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN68@Renderer

; 9120 : 						glUniform1i(st.renderer.unifs[4],3);

	mov	esi, esp
	push	3
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _st[eax+2336712]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glUniform1i
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9121 : 					else

	jmp	$LN64@Renderer
$LN68@Renderer:

; 9122 : 					{
; 9123 : 						glActiveTexture(GL_TEXTURE1);

	mov	esi, esp
	push	33985					; 000084c1H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9124 : 
; 9125 : 						if(vbdt[i].normal)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, BYTE PTR [ecx+eax+44]
	test	edx, edx
	je	$LN66@Renderer

; 9126 : 						{
; 9127 : 							if(tex_bound[1]!=vbdt[m].texture)

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _m$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _vbdt
	mov	eax, DWORD PTR _tex_bound$[ebp+eax]
	cmp	eax, DWORD PTR [edx+ecx+36]
	je	SHORT $LN65@Renderer

; 9128 : 							{
; 9129 : 								glBindTexture(GL_TEXTURE_2D,vbdt[m].Ntexture);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+40]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9130 : 								tex_bound[1]=vbdt[m].texture;

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _vbdt
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _tex_bound$[ebp+ecx], eax
$LN65@Renderer:

; 9131 : 							}
; 9132 : 							unif=glGetUniformLocation(st.renderer.Program[3],"normal");

	mov	esi, esp
	push	OFFSET ??_C@_06IKLLLDHL@normal?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _unif$[ebp], eax

; 9133 : 							glUniform1f(unif,1);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _unif$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glUniform1f
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9134 : 						}
; 9135 : 						else

	jmp	$LN64@Renderer
$LN66@Renderer:

; 9136 : 						{
; 9137 : 							if(tex_bound[1]!=vbdt[m].texture)

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _m$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _vbdt
	mov	eax, DWORD PTR _tex_bound$[ebp+eax]
	cmp	eax, DWORD PTR [edx+ecx+36]
	je	SHORT $LN63@Renderer

; 9138 : 							{
; 9139 : 								glBindTexture(GL_TEXTURE_2D,vbdt[m].texture);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+36]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9140 : 								tex_bound[1]=vbdt[m].texture;

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _vbdt
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _tex_bound$[ebp+ecx], eax
$LN63@Renderer:

; 9141 : 							}
; 9142 : 
; 9143 : 							unif=glGetUniformLocation(st.renderer.Program[3],"normal");

	mov	esi, esp
	push	OFFSET ??_C@_06IKLLLDHL@normal?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _unif$[ebp], eax

; 9144 : 							glUniform1f(unif,2);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _unif$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glUniform1f
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN64@Renderer:

; 9145 : 						}
; 9146 : 					}
; 9147 : 
; 9148 : 					//glBindVertexArray(vbdt[m].vao_id);
; 9149 : 					glBindBuffer(GL_ARRAY_BUFFER,vbdt[m].vbo_id);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+8]
	push	edx
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9150 : 					glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,vbdt[m].ibo_id);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+4]
	push	edx
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9151 : 
; 9152 : 					glBufferData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float))+(16*sizeof(GLubyte)),NULL,GL_STREAM_DRAW);

	mov	esi, esp
	push	35040					; 000088e0H
	push	0
	push	96					; 00000060H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9153 : 					glBufferSubData(GL_ARRAY_BUFFER,0,12*sizeof(float),vbdt[m].vertex);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+12]
	push	edx
	push	48					; 00000030H
	push	0
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9154 : 					glBufferSubData(GL_ARRAY_BUFFER,12*sizeof(float),8*sizeof(float),vbdt[m].texcoord);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+16]
	push	edx
	push	32					; 00000020H
	push	48					; 00000030H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9155 : 					glBufferSubData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float)),16*sizeof(GLubyte),vbdt[m].color);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+28]
	push	edx
	push	16					; 00000010H
	push	80					; 00000050H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9156 : 
; 9157 : 					glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*sizeof(GLushort)),vbdt[m].index,GL_STREAM_DRAW);

	mov	esi, esp
	push	35040					; 000088e0H
	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+32]
	push	edx
	push	12					; 0000000cH
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9158 : 
; 9159 : 					pos=glGetAttribLocation(st.renderer.Program[3],"Position");

	mov	esi, esp
	push	OFFSET ??_C@_08GCJNLIKG@Position?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pos$[ebp], eax

; 9160 : 					texc=glGetAttribLocation(st.renderer.Program[3],"TexCoord");

	mov	esi, esp
	push	OFFSET ??_C@_08NGMLKGCO@TexCoord?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _texc$[ebp], eax

; 9161 : 					col=glGetAttribLocation(st.renderer.Program[3],"Color");

	mov	esi, esp
	push	OFFSET ??_C@_05PDOBBJNA@Color?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _col$[ebp], eax

; 9162 : 
; 9163 : 					glEnableVertexAttribArray(pos);

	mov	esi, esp
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9164 : 					glEnableVertexAttribArray(texc);

	mov	esi, esp
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9165 : 					glEnableVertexAttribArray(col);

	mov	esi, esp
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9166 : 
; 9167 : 					glVertexAttribPointer(pos,3,GL_FLOAT,GL_FALSE,0,0);

	mov	esi, esp
	push	0
	push	0
	push	0
	push	5126					; 00001406H
	push	3
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9168 : 					glVertexAttribPointer(texc,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) (12*sizeof(GLfloat)));

	mov	esi, esp
	push	48					; 00000030H
	push	0
	push	0
	push	5126					; 00001406H
	push	2
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9169 : 					glVertexAttribPointer(col,4,GL_UNSIGNED_BYTE,GL_TRUE,0,(GLvoid*) ((12*sizeof(GLfloat))+(8*sizeof(GLfloat))));

	mov	esi, esp
	push	80					; 00000050H
	push	0
	push	1
	push	5121					; 00001401H
	push	4
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9170 : 
; 9171 : 					l=0;

	xor	eax, eax
	mov	WORD PTR _l$[ebp], ax

; 9172 : 					if(j<z_slot[i]-2)

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _z_slot[eax*2]
	sub	ecx, 2
	cmp	DWORD PTR _j$[ebp], ecx
	jge	$LN59@Renderer

; 9173 : 					{
; 9174 : 						for(m=j+1;m<z_slot[i];m++)

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _m$[ebp], eax
	jmp	SHORT $LN61@Renderer
$LN60@Renderer:
	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 1
	mov	DWORD PTR _m$[ebp], eax
$LN61@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _z_slot[eax*2]
	cmp	DWORD PTR _m$[ebp], ecx
	jge	SHORT $LN59@Renderer

; 9175 : 						{
; 9176 : 							if(ent[z_buffer[i][m]].data.vb_id==ent[z_buffer[i][j]].data.vb_id)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _m$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movsx	ecx, WORD PTR _ent[eax+54]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[edx+eax*2]
	imul	eax, edx, 264
	movsx	edx, WORD PTR _ent[eax+54]
	cmp	ecx, edx
	jne	SHORT $LN58@Renderer

; 9177 : 								l++;

	mov	ax, WORD PTR _l$[ebp]
	add	ax, 1
	mov	WORD PTR _l$[ebp], ax

; 9178 : 							else

	jmp	SHORT $LN57@Renderer
$LN58@Renderer:

; 9179 : 								break;

	jmp	SHORT $LN59@Renderer
$LN57@Renderer:

; 9180 : 						}

	jmp	SHORT $LN60@Renderer
$LN59@Renderer:

; 9181 : 					}
; 9182 : 
; 9183 : 					if(!l)

	movzx	eax, WORD PTR _l$[ebp]
	test	eax, eax
	jne	$LN56@Renderer

; 9184 : 						glDrawRangeElements(GL_TRIANGLES,(ent[z_buffer[i][j]].data.loc*6),(ent[z_buffer[i][j]].data.loc*6)+6,(ent[z_buffer[i][j]].data.loc*6)+6,GL_UNSIGNED_SHORT,0);

	mov	esi, esp
	push	0
	push	5123					; 00001403H
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movzx	ecx, WORD PTR _ent[eax+56]
	imul	edx, ecx, 6
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movzx	ecx, WORD PTR _ent[eax+56]
	imul	edx, ecx, 6
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movzx	ecx, WORD PTR _ent[eax+56]
	imul	edx, ecx, 6
	push	edx
	push	4
	call	DWORD PTR _GLeeFuncPtr_glDrawRangeElements
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9185 : 					else

	jmp	$LN55@Renderer
$LN56@Renderer:

; 9186 : 						glDrawRangeElements(GL_TRIANGLES,(ent[z_buffer[i][j]].data.loc*6),((ent[z_buffer[i][j]].data.loc+l)*6)+6,((ent[z_buffer[i][j]].data.loc+l)*6)+6,GL_UNSIGNED_SHORT,0);

	mov	esi, esp
	push	0
	push	5123					; 00001403H
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movzx	ecx, WORD PTR _ent[eax+56]
	movzx	edx, WORD PTR _l$[ebp]
	add	ecx, edx
	imul	eax, ecx, 6
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _j$[ebp]
	movsx	eax, WORD PTR _z_buffer[ecx+edx*2]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _ent[ecx+56]
	movzx	eax, WORD PTR _l$[ebp]
	add	edx, eax
	imul	ecx, edx, 6
	add	ecx, 6
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _z_buffer[edx+eax*2]
	imul	edx, ecx, 264
	movzx	eax, WORD PTR _ent[edx+56]
	imul	ecx, eax, 6
	push	ecx
	push	4
	call	DWORD PTR _GLeeFuncPtr_glDrawRangeElements
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN55@Renderer:

; 9187 : 
; 9188 : 					glDisableVertexAttribArray(pos);

	mov	esi, esp
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9189 : 					glDisableVertexAttribArray(texc);

	mov	esi, esp
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9190 : 					glDisableVertexAttribArray(col);

	mov	esi, esp
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9191 : 
; 9192 : 					glBindBuffer(GL_ARRAY_BUFFER,0);

	mov	esi, esp
	push	0
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9193 : 					glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);

	mov	esi, esp
	push	0
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9194 : 
; 9195 : 					if(l)

	movzx	eax, WORD PTR _l$[ebp]
	test	eax, eax
	je	SHORT $LN54@Renderer

; 9196 : 						j+=l;

	movzx	eax, WORD PTR _l$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _j$[ebp], eax
$LN54@Renderer:

; 9197 : 				}
; 9198 : 				else

	jmp	$LN53@Renderer
$LN70@Renderer:

; 9199 : 				{
; 9200 : 					glActiveTexture(GL_TEXTURE0);

	mov	esi, esp
	push	33984					; 000084c0H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9201 : 
; 9202 : 					if(tex_bound[0]!=ent[z_buffer[i][j]].data.data)

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[edx+eax*2]
	imul	eax, edx, 264
	mov	ecx, DWORD PTR _tex_bound$[ebp+ecx]
	cmp	ecx, DWORD PTR _ent[eax+44]
	je	SHORT $LN52@Renderer

; 9203 : 					{
; 9204 : 						glBindTexture(GL_TEXTURE_2D,ent[z_buffer[i][j]].data.data);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	mov	esi, esp
	mov	ecx, DWORD PTR _ent[eax+44]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9205 : 						tex_bound[0]=ent[z_buffer[i][j]].data.data;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent[eax+44]
	mov	DWORD PTR _tex_bound$[ebp+edx], eax
$LN52@Renderer:

; 9206 : 					}
; 9207 : 
; 9208 : 					if(i<16)

	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN51@Renderer

; 9209 : 						glUniform1i(st.renderer.unifs[4],3);

	mov	esi, esp
	push	3
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _st[eax+2336712]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glUniform1i
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9210 : 					else

	jmp	$LN47@Renderer
$LN51@Renderer:

; 9211 : 					{
; 9212 : 						glActiveTexture(GL_TEXTURE1);

	mov	esi, esp
	push	33985					; 000084c1H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9213 : 
; 9214 : 						if(ent[z_buffer[i][j]].data.normal)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movzx	ecx, BYTE PTR _ent[eax+52]
	test	ecx, ecx
	je	$LN49@Renderer

; 9215 : 						{
; 9216 : 							unif=glGetUniformLocation(st.renderer.Program[3],"normal");

	mov	esi, esp
	push	OFFSET ??_C@_06IKLLLDHL@normal?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _unif$[ebp], eax

; 9217 : 							glUniform1f(unif,1);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _unif$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glUniform1f
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9218 : 
; 9219 : 							if(tex_bound[1]!=ent[z_buffer[i][j]].data.data)

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _z_buffer[ecx+edx*2]
	imul	edx, ecx, 264
	mov	eax, DWORD PTR _tex_bound$[ebp+eax]
	cmp	eax, DWORD PTR _ent[edx+44]
	je	SHORT $LN48@Renderer

; 9220 : 							{
; 9221 : 								glBindTexture(GL_TEXTURE_2D,ent[z_buffer[i][j]].data.Ndata);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	mov	esi, esp
	mov	ecx, DWORD PTR _ent[eax+48]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9222 : 								tex_bound[1]=ent[z_buffer[i][j]].data.data;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent[eax+44]
	mov	DWORD PTR _tex_bound$[ebp+ecx], edx
$LN48@Renderer:

; 9223 : 							}
; 9224 : 						}
; 9225 : 						else

	jmp	$LN47@Renderer
$LN49@Renderer:

; 9226 : 						{
; 9227 : 							if(tex_bound[1]!=ent[z_buffer[i][j]].data.data)

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _z_buffer[ecx+edx*2]
	imul	edx, ecx, 264
	mov	eax, DWORD PTR _tex_bound$[ebp+eax]
	cmp	eax, DWORD PTR _ent[edx+44]
	je	SHORT $LN46@Renderer

; 9228 : 							{
; 9229 : 								glBindTexture(GL_TEXTURE_2D,ent[z_buffer[i][j]].data.data);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	mov	esi, esp
	mov	ecx, DWORD PTR _ent[eax+44]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9230 : 								tex_bound[1]=ent[z_buffer[i][j]].data.data;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent[eax+44]
	mov	DWORD PTR _tex_bound$[ebp+ecx], edx
$LN46@Renderer:

; 9231 : 							}
; 9232 : 
; 9233 : 							unif=glGetUniformLocation(st.renderer.Program[3],"normal");

	mov	esi, esp
	push	OFFSET ??_C@_06IKLLLDHL@normal?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _unif$[ebp], eax

; 9234 : 							glUniform1f(unif,2);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _unif$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glUniform1f
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN47@Renderer:

; 9235 : 						}
; 9236 : 					}
; 9237 : 
; 9238 : 					//glBindVertexArray(vbd.vao_id);
; 9239 : 
; 9240 : 					glBindBuffer(GL_ARRAY_BUFFER,vbd.vbo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _vbd+8
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9241 : 					glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,vbd.ibo_id);

	mov	esi, esp
	mov	eax, DWORD PTR _vbd+4
	push	eax
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9242 : 
; 9243 : 					glBufferData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float))+(16*sizeof(GLubyte)),NULL,GL_STREAM_DRAW);

	mov	esi, esp
	push	35040					; 000088e0H
	push	0
	push	96					; 00000060H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9244 : 					glBufferSubData(GL_ARRAY_BUFFER,0,12*sizeof(float),ent[z_buffer[i][j]].vertex);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	add	eax, OFFSET _ent+100
	mov	esi, esp
	push	eax
	push	48					; 00000030H
	push	0
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9245 : 					glBufferSubData(GL_ARRAY_BUFFER,12*sizeof(float),8*sizeof(float),ent[z_buffer[i][j]].texcor);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	add	eax, OFFSET _ent+148
	mov	esi, esp
	push	eax
	push	32					; 00000020H
	push	48					; 00000030H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9246 : 					glBufferSubData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float)),16*sizeof(GLubyte),ent[z_buffer[i][j]].color);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	add	eax, OFFSET _ent+228
	mov	esi, esp
	push	eax
	push	16					; 00000010H
	push	80					; 00000050H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9247 : 
; 9248 : 					glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*sizeof(GLushort)),vbd.index,GL_STREAM_DRAW);

	mov	esi, esp
	push	35040					; 000088e0H
	mov	eax, DWORD PTR _vbd+32
	push	eax
	push	12					; 0000000cH
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9249 : 
; 9250 : 					pos=glGetAttribLocation(st.renderer.Program[3],"Position");

	mov	esi, esp
	push	OFFSET ??_C@_08GCJNLIKG@Position?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pos$[ebp], eax

; 9251 : 					texc=glGetAttribLocation(st.renderer.Program[3],"TexCoord");

	mov	esi, esp
	push	OFFSET ??_C@_08NGMLKGCO@TexCoord?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _texc$[ebp], eax

; 9252 : 					col=glGetAttribLocation(st.renderer.Program[3],"Color");

	mov	esi, esp
	push	OFFSET ??_C@_05PDOBBJNA@Color?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _col$[ebp], eax

; 9253 : 
; 9254 : 					glEnableVertexAttribArray(pos);

	mov	esi, esp
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9255 : 					glEnableVertexAttribArray(texc);

	mov	esi, esp
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9256 : 					glEnableVertexAttribArray(col);

	mov	esi, esp
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9257 : 
; 9258 : 					glVertexAttribPointer(pos,3,GL_FLOAT,GL_FALSE,0,0);

	mov	esi, esp
	push	0
	push	0
	push	0
	push	5126					; 00001406H
	push	3
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9259 : 					glVertexAttribPointer(texc,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) (12*sizeof(GLfloat)));

	mov	esi, esp
	push	48					; 00000030H
	push	0
	push	0
	push	5126					; 00001406H
	push	2
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9260 : 					glVertexAttribPointer(col,4,GL_UNSIGNED_BYTE,GL_TRUE,0,(GLvoid*) ((12*sizeof(GLfloat))+(8*sizeof(GLfloat))));

	mov	esi, esp
	push	80					; 00000050H
	push	0
	push	1
	push	5121					; 00001401H
	push	4
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9261 : 
; 9262 : 					glDrawRangeElements(GL_TRIANGLES,0,6,6,GL_UNSIGNED_SHORT,0);

	mov	esi, esp
	push	0
	push	5123					; 00001403H
	push	6
	push	6
	push	0
	push	4
	call	DWORD PTR _GLeeFuncPtr_glDrawRangeElements
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9263 : 					
; 9264 : 					glDisableVertexAttribArray(pos);

	mov	esi, esp
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9265 : 					glDisableVertexAttribArray(texc);

	mov	esi, esp
	mov	eax, DWORD PTR _texc$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9266 : 					glDisableVertexAttribArray(col);

	mov	esi, esp
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9267 : 
; 9268 : 					glBindBuffer(GL_ARRAY_BUFFER,0);

	mov	esi, esp
	push	0
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9269 : 					glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);

	mov	esi, esp
	push	0
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN53@Renderer:

; 9270 : 				}
; 9271 : 			}

	jmp	$LN72@Renderer
$LN71@Renderer:

; 9272 : 
; 9273 : 			if(i==0) break;

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN45@Renderer
	jmp	SHORT $LN74@Renderer
$LN45@Renderer:

; 9274 : 		}

	jmp	$LN75@Renderer
$LN74@Renderer:

; 9275 : 
; 9276 : 		//glBindTexture(GL_TEXTURE_2D,st.renderer.FBTex[2]);
; 9277 : 
; 9278 : 		//glGenerateMipmap(GL_TEXTURE_2D);
; 9279 : 
; 9280 : 		memset(z_buffer,0,(5*8)*(2048));

	push	81920					; 00014000H
	push	0
	push	OFFSET _z_buffer
	call	_memset
	add	esp, 12					; 0000000cH

; 9281 : 		memset(z_slot,0,5*8);

	push	40					; 00000028H
	push	0
	push	OFFSET _z_slot
	call	_memset
	add	esp, 12					; 0000000cH

; 9282 : 		z_used=0;

	mov	BYTE PTR _z_used, 0

; 9283 : 
; 9284 : 		for(i=0;i<MAX_STRINGS;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN44@Renderer
$LN43@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN44@Renderer:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	SHORT $LN42@Renderer

; 9285 : 		{
; 9286 : 			if(st.strings[i].stat==1)

	imul	eax, DWORD PTR _i$[ebp], 1068
	movsx	ecx, BYTE PTR _st[eax+2762084]
	cmp	ecx, 1
	jne	SHORT $LN41@Renderer

; 9287 : 			{
; 9288 : 				st.strings[i].stat=2;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	BYTE PTR _st[eax+2762084], 2

; 9289 : 				continue;

	jmp	SHORT $LN43@Renderer

; 9290 : 			}
; 9291 : 			else

	jmp	SHORT $LN39@Renderer
$LN41@Renderer:

; 9292 : 			if(st.strings[i].stat==2)

	imul	eax, DWORD PTR _i$[ebp], 1068
	movsx	ecx, BYTE PTR _st[eax+2762084]
	cmp	ecx, 2
	jne	SHORT $LN39@Renderer

; 9293 : 			{
; 9294 : 				glDeleteTextures(1,&st.strings[i].data.data);

	imul	eax, DWORD PTR _i$[ebp], 1068
	add	eax, OFFSET _st+2762044
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9295 : 				st.strings[i].data.channel=0;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	DWORD PTR _st[eax+2762076], 0

; 9296 : 				st.strings[i].stat=0;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	BYTE PTR _st[eax+2762084], 0
$LN39@Renderer:

; 9297 : 			}
; 9298 : 		}

	jmp	$LN43@Renderer
$LN42@Renderer:

; 9299 : 		
; 9300 : 		for(i=0;i<vbdt_num;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN38@Renderer
$LN37@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN38@Renderer:
	movzx	eax, WORD PTR _vbdt_num
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN36@Renderer

; 9301 : 		{
; 9302 : 			if(vbdt[i].num_elements>0)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	test	edx, edx
	jle	SHORT $LN35@Renderer

; 9303 : 			{
; 9304 : 				vbdt[i].num_elements=0;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	xor	ecx, ecx
	mov	edx, DWORD PTR _vbdt
	mov	WORD PTR [edx+eax+46], cx
$LN35@Renderer:

; 9305 : 			}
; 9306 : 		}

	jmp	SHORT $LN37@Renderer
$LN36@Renderer:

; 9307 : 		
; 9308 : 	}
; 9309 : #endif
; 9310 : 
; 9311 : #ifdef _VA_RENDER
; 9312 : 
; 9313 : 	if(st.renderer.VA_ON)

	movzx	eax, BYTE PTR _st+2336453
	test	eax, eax
	je	$LN2@Renderer

; 9314 : 	{
; 9315 : 		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	mov	esi, esp
	push	16640					; 00004100H
	call	DWORD PTR __imp__glClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9316 : 		glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);

	mov	esi, esp
	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR __imp__glBlendFunc@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9317 : 
; 9318 : 		//glEnable(GL_ALPHA_TEST);
; 9319 : 		//glAlphaFunc(GL_EQUAL,1.0);
; 9320 : 
; 9321 : 		for(i=z_used;i>-1;i--)

	movsx	eax, BYTE PTR _z_used
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN33@Renderer
$LN32@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN33@Renderer:
	cmp	DWORD PTR _i$[ebp], -1
	jle	$LN31@Renderer

; 9322 : 		{
; 9323 : 			for(j=0;j<z_slot[i];j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN30@Renderer
$LN29@Renderer:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN30@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _z_slot[eax*2]
	cmp	DWORD PTR _j$[ebp], ecx
	jge	$LN28@Renderer

; 9324 : 			{
; 9325 : 				if(ent[z_buffer[i][j]].data.vb_id!=-1)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movsx	ecx, WORD PTR _ent[eax+54]
	cmp	ecx, -1
	je	$LN27@Renderer

; 9326 : 				{
; 9327 : 					m=ent[z_buffer[i][j]].data.vb_id;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movsx	ecx, WORD PTR _ent[eax+54]
	mov	DWORD PTR _m$[ebp], ecx

; 9328 : 
; 9329 : 					//glActiveTexture(GL_TEXTURE0);
; 9330 : 
; 9331 : 					if(tex_bound[0]!=vbdt[m].texture)

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _m$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _vbdt
	mov	ecx, DWORD PTR _tex_bound$[ebp+ecx]
	cmp	ecx, DWORD PTR [eax+edx+36]
	je	SHORT $LN26@Renderer

; 9332 : 					{
; 9333 : 						glBindTexture(GL_TEXTURE_2D,vbdt[m].texture);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+36]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9334 : 						tex_bound[0]=vbdt[m].texture;

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _vbdt
	mov	eax, DWORD PTR [ecx+eax+36]
	mov	DWORD PTR _tex_bound$[ebp+edx], eax
$LN26@Renderer:

; 9335 : 					}
; 9336 : 
; 9337 : 					//glBindTexture(GL_TEXTURE_2D,vbdt[i].texture);
; 9338 : 
; 9339 : 					glEnableClientState(GL_VERTEX_ARRAY);

	mov	esi, esp
	push	32884					; 00008074H
	call	DWORD PTR __imp__glEnableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9340 : 					glEnableClientState(GL_TEXTURE_COORD_ARRAY);

	mov	esi, esp
	push	32888					; 00008078H
	call	DWORD PTR __imp__glEnableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9341 : 					glEnableClientState(GL_COLOR_ARRAY);

	mov	esi, esp
	push	32886					; 00008076H
	call	DWORD PTR __imp__glEnableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9342 : 
; 9343 : 					glVertexPointer(3,GL_FLOAT,0,vbdt[m].vertex);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+12]
	push	edx
	push	0
	push	5126					; 00001406H
	push	3
	call	DWORD PTR __imp__glVertexPointer@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9344 : 					glTexCoordPointer(2,GL_FLOAT,0,vbdt[m].texcoord);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+16]
	push	edx
	push	0
	push	5126					; 00001406H
	push	2
	call	DWORD PTR __imp__glTexCoordPointer@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9345 : 					glColorPointer(4,GL_UNSIGNED_BYTE,0,vbdt[m].color);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+28]
	push	edx
	push	0
	push	5121					; 00001401H
	push	4
	call	DWORD PTR __imp__glColorPointer@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9346 : 
; 9347 : 					//glDrawRangeElements(GL_TRIANGLES,0,vbdt[i].num_elements*6,vbdt[i].num_elements*6,GL_UNSIGNED_SHORT,vbdt[i].index);
; 9348 : 
; 9349 : 					l=0;

	xor	eax, eax
	mov	WORD PTR _l$[ebp], ax

; 9350 : 					if(j<z_slot[i]-2)

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _z_slot[eax*2]
	sub	ecx, 2
	cmp	DWORD PTR _j$[ebp], ecx
	jge	$LN22@Renderer

; 9351 : 					{
; 9352 : 						for(m=j+1;m<z_slot[i];m++)

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _m$[ebp], eax
	jmp	SHORT $LN24@Renderer
$LN23@Renderer:
	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 1
	mov	DWORD PTR _m$[ebp], eax
$LN24@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _z_slot[eax*2]
	cmp	DWORD PTR _m$[ebp], ecx
	jge	SHORT $LN22@Renderer

; 9353 : 						{
; 9354 : 							if(ent[z_buffer[i][m]].data.vb_id==ent[z_buffer[i][j]].data.vb_id)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _m$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movsx	ecx, WORD PTR _ent[eax+54]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[edx+eax*2]
	imul	eax, edx, 264
	movsx	edx, WORD PTR _ent[eax+54]
	cmp	ecx, edx
	jne	SHORT $LN21@Renderer

; 9355 : 								l++;

	mov	ax, WORD PTR _l$[ebp]
	add	ax, 1
	mov	WORD PTR _l$[ebp], ax

; 9356 : 							else

	jmp	SHORT $LN20@Renderer
$LN21@Renderer:

; 9357 : 								break;

	jmp	SHORT $LN22@Renderer
$LN20@Renderer:

; 9358 : 						}

	jmp	SHORT $LN23@Renderer
$LN22@Renderer:

; 9359 : 					}
; 9360 : 
; 9361 : 					if(!l)

	movzx	eax, WORD PTR _l$[ebp]
	test	eax, eax
	jne	$LN19@Renderer

; 9362 : 						glDrawRangeElements(GL_TRIANGLES,(ent[z_buffer[i][j]].data.loc*6),(ent[z_buffer[i][j]].data.loc*6)+6,(ent[z_buffer[i][j]].data.loc*6)+6,GL_UNSIGNED_SHORT,vbdt[m].index);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+32]
	push	edx
	push	5123					; 00001403H
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movzx	ecx, WORD PTR _ent[eax+56]
	imul	edx, ecx, 6
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movzx	ecx, WORD PTR _ent[eax+56]
	imul	edx, ecx, 6
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movzx	ecx, WORD PTR _ent[eax+56]
	imul	edx, ecx, 6
	push	edx
	push	4
	call	DWORD PTR _GLeeFuncPtr_glDrawRangeElements
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9363 : 					else

	jmp	$LN18@Renderer
$LN19@Renderer:

; 9364 : 						glDrawRangeElements(GL_TRIANGLES,(ent[z_buffer[i][j]].data.loc*6),((ent[z_buffer[i][j]].data.loc+l)*6)+6,((ent[z_buffer[i][j]].data.loc+l)*6)+6,GL_UNSIGNED_SHORT,vbdt[m].index);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+32]
	push	edx
	push	5123					; 00001403H
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	movzx	ecx, WORD PTR _ent[eax+56]
	movzx	edx, WORD PTR _l$[ebp]
	add	ecx, edx
	imul	eax, ecx, 6
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _j$[ebp]
	movsx	eax, WORD PTR _z_buffer[ecx+edx*2]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _ent[ecx+56]
	movzx	eax, WORD PTR _l$[ebp]
	add	edx, eax
	imul	ecx, edx, 6
	add	ecx, 6
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _z_buffer[edx+eax*2]
	imul	edx, ecx, 264
	movzx	eax, WORD PTR _ent[edx+56]
	imul	ecx, eax, 6
	push	ecx
	push	4
	call	DWORD PTR _GLeeFuncPtr_glDrawRangeElements
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@Renderer:

; 9365 : 
; 9366 : 					//glBindVertexArray(0);
; 9367 : 
; 9368 : 					if(l)

	movzx	eax, WORD PTR _l$[ebp]
	test	eax, eax
	je	SHORT $LN17@Renderer

; 9369 : 						j+=l;

	movzx	eax, WORD PTR _l$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _j$[ebp], eax
$LN17@Renderer:

; 9370 : 
; 9371 : 					glDisableClientState(GL_VERTEX_ARRAY);

	mov	esi, esp
	push	32884					; 00008074H
	call	DWORD PTR __imp__glDisableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9372 : 					glDisableClientState(GL_TEXTURE_COORD_ARRAY);

	mov	esi, esp
	push	32888					; 00008078H
	call	DWORD PTR __imp__glDisableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9373 : 					glDisableClientState(GL_COLOR_ARRAY);

	mov	esi, esp
	push	32886					; 00008076H
	call	DWORD PTR __imp__glDisableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9374 : 				}
; 9375 : 				else

	jmp	$LN16@Renderer
$LN27@Renderer:

; 9376 : 				{
; 9377 : 					//glActiveTexture(GL_TEXTURE0);
; 9378 : 
; 9379 : 					if(tex_bound[0]!=ent[z_buffer[i][j]].data.data)

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[edx+eax*2]
	imul	eax, edx, 264
	mov	ecx, DWORD PTR _tex_bound$[ebp+ecx]
	cmp	ecx, DWORD PTR _ent[eax+44]
	je	SHORT $LN15@Renderer

; 9380 : 					{
; 9381 : 						glBindTexture(GL_TEXTURE_2D,ent[z_buffer[i][j]].data.data);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	mov	esi, esp
	mov	ecx, DWORD PTR _ent[eax+44]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9382 : 						tex_bound[0]=ent[z_buffer[i][j]].data.data;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent[eax+44]
	mov	DWORD PTR _tex_bound$[ebp+edx], eax
$LN15@Renderer:

; 9383 : 					}
; 9384 : 
; 9385 : 					glEnableClientState(GL_VERTEX_ARRAY);

	mov	esi, esp
	push	32884					; 00008074H
	call	DWORD PTR __imp__glEnableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9386 : 					glEnableClientState(GL_TEXTURE_COORD_ARRAY);

	mov	esi, esp
	push	32888					; 00008078H
	call	DWORD PTR __imp__glEnableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9387 : 					glEnableClientState(GL_COLOR_ARRAY);

	mov	esi, esp
	push	32886					; 00008076H
	call	DWORD PTR __imp__glEnableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9388 : 
; 9389 : 					glVertexPointer(3,GL_FLOAT,0,ent[z_buffer[i][j]].vertex);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	add	eax, OFFSET _ent+100
	mov	esi, esp
	push	eax
	push	0
	push	5126					; 00001406H
	push	3
	call	DWORD PTR __imp__glVertexPointer@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9390 : 					glTexCoordPointer(2,GL_FLOAT,0,ent[z_buffer[i][j]].texcor);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	add	eax, OFFSET _ent+148
	mov	esi, esp
	push	eax
	push	0
	push	5126					; 00001406H
	push	2
	call	DWORD PTR __imp__glTexCoordPointer@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9391 : 					glColorPointer(4,GL_UNSIGNED_BYTE,0,ent[z_buffer[i][j]].color);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR _z_buffer[eax+ecx*2]
	imul	eax, edx, 264
	add	eax, OFFSET _ent+228
	mov	esi, esp
	push	eax
	push	0
	push	5121					; 00001401H
	push	4
	call	DWORD PTR __imp__glColorPointer@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9392 : 
; 9393 : 					glDrawRangeElements(GL_TRIANGLES,0,6,6,GL_UNSIGNED_SHORT,vbd.index);

	mov	esi, esp
	mov	eax, DWORD PTR _vbd+32
	push	eax
	push	5123					; 00001403H
	push	6
	push	6
	push	0
	push	4
	call	DWORD PTR _GLeeFuncPtr_glDrawRangeElements
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9394 : 
; 9395 : 					glDisableClientState(GL_VERTEX_ARRAY);

	mov	esi, esp
	push	32884					; 00008074H
	call	DWORD PTR __imp__glDisableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9396 : 					glDisableClientState(GL_TEXTURE_COORD_ARRAY);

	mov	esi, esp
	push	32888					; 00008078H
	call	DWORD PTR __imp__glDisableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9397 : 					glDisableClientState(GL_COLOR_ARRAY);

	mov	esi, esp
	push	32886					; 00008076H
	call	DWORD PTR __imp__glDisableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@Renderer:

; 9398 : 				}
; 9399 : 			}

	jmp	$LN29@Renderer
$LN28@Renderer:

; 9400 : 		}

	jmp	$LN32@Renderer
$LN31@Renderer:

; 9401 : 
; 9402 : 		glDisable(GL_DEPTH_TEST);

	mov	esi, esp
	push	2929					; 00000b71H
	call	DWORD PTR __imp__glDisable@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9403 : 		
; 9404 : 		glBlendFunc(GL_DST_COLOR, GL_ZERO);

	mov	esi, esp
	push	0
	push	774					; 00000306H
	call	DWORD PTR __imp__glBlendFunc@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9405 : 
; 9406 : 		if(st.num_lightmap>0)

	movzx	eax, BYTE PTR _st+261
	test	eax, eax
	jle	$LN11@Renderer

; 9407 : 		{
; 9408 : 			for(i=0;i<st.num_lightmap;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@Renderer
$LN12@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@Renderer:
	movzx	eax, BYTE PTR _st+261
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN11@Renderer

; 9409 : 			{
; 9410 : 				glBindTexture(GL_TEXTURE_2D,lmp[i].data.data);

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	esi, esp
	mov	ecx, DWORD PTR _lmp[eax+44]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9411 : 
; 9412 : 				glEnableClientState(GL_VERTEX_ARRAY);

	mov	esi, esp
	push	32884					; 00008074H
	call	DWORD PTR __imp__glEnableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9413 : 				glEnableClientState(GL_TEXTURE_COORD_ARRAY);

	mov	esi, esp
	push	32888					; 00008078H
	call	DWORD PTR __imp__glEnableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9414 : 				glEnableClientState(GL_COLOR_ARRAY);

	mov	esi, esp
	push	32886					; 00008076H
	call	DWORD PTR __imp__glEnableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9415 : 
; 9416 : 				glVertexPointer(3,GL_FLOAT,0,lmp[i].vertex);

	imul	eax, DWORD PTR _i$[ebp], 264
	add	eax, OFFSET _lmp+100
	mov	esi, esp
	push	eax
	push	0
	push	5126					; 00001406H
	push	3
	call	DWORD PTR __imp__glVertexPointer@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9417 : 				glTexCoordPointer(2,GL_FLOAT,0,texcoord);

	mov	esi, esp
	lea	eax, DWORD PTR _texcoord$[ebp]
	push	eax
	push	0
	push	5126					; 00001406H
	push	2
	call	DWORD PTR __imp__glTexCoordPointer@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9418 : 				glColorPointer(4,GL_UNSIGNED_BYTE,0,vbd.color);

	mov	esi, esp
	mov	eax, DWORD PTR _vbd+28
	push	eax
	push	0
	push	5121					; 00001401H
	push	4
	call	DWORD PTR __imp__glColorPointer@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9419 : 
; 9420 : 				glDrawRangeElements(GL_TRIANGLES,0,6,6,GL_UNSIGNED_SHORT,vbd.index);

	mov	esi, esp
	mov	eax, DWORD PTR _vbd+32
	push	eax
	push	5123					; 00001403H
	push	6
	push	6
	push	0
	push	4
	call	DWORD PTR _GLeeFuncPtr_glDrawRangeElements
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9421 : 
; 9422 : 				glDisableClientState(GL_VERTEX_ARRAY);

	mov	esi, esp
	push	32884					; 00008074H
	call	DWORD PTR __imp__glDisableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9423 : 				glDisableClientState(GL_TEXTURE_COORD_ARRAY);

	mov	esi, esp
	push	32888					; 00008078H
	call	DWORD PTR __imp__glDisableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9424 : 				glDisableClientState(GL_COLOR_ARRAY);

	mov	esi, esp
	push	32886					; 00008076H
	call	DWORD PTR __imp__glDisableClientState@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9425 : 			}

	jmp	$LN12@Renderer
$LN11@Renderer:

; 9426 : 		}
; 9427 : 
; 9428 : 		glEnable(GL_DEPTH_TEST);

	mov	esi, esp
	push	2929					; 00000b71H
	call	DWORD PTR __imp__glEnable@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9429 : 
; 9430 : 		memset(z_buffer,0,(5*8)*(2048));

	push	81920					; 00014000H
	push	0
	push	OFFSET _z_buffer
	call	_memset
	add	esp, 12					; 0000000cH

; 9431 : 		memset(z_slot,0,5*8);

	push	40					; 00000028H
	push	0
	push	OFFSET _z_slot
	call	_memset
	add	esp, 12					; 0000000cH

; 9432 : 		z_used=0;

	mov	BYTE PTR _z_used, 0

; 9433 : 
; 9434 : 		for(i=0;i<MAX_STRINGS;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@Renderer
$LN9@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@Renderer:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	SHORT $LN8@Renderer

; 9435 : 		{
; 9436 : 			if(st.strings[i].stat==1)

	imul	eax, DWORD PTR _i$[ebp], 1068
	movsx	ecx, BYTE PTR _st[eax+2762084]
	cmp	ecx, 1
	jne	SHORT $LN7@Renderer

; 9437 : 			{
; 9438 : 				st.strings[i].stat=2;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	BYTE PTR _st[eax+2762084], 2

; 9439 : 				continue;

	jmp	SHORT $LN9@Renderer

; 9440 : 			}
; 9441 : 			else

	jmp	SHORT $LN5@Renderer
$LN7@Renderer:

; 9442 : 			if(st.strings[i].stat==2)

	imul	eax, DWORD PTR _i$[ebp], 1068
	movsx	ecx, BYTE PTR _st[eax+2762084]
	cmp	ecx, 2
	jne	SHORT $LN5@Renderer

; 9443 : 			{
; 9444 : 				glDeleteTextures(1,&st.strings[i].data.data);

	imul	eax, DWORD PTR _i$[ebp], 1068
	add	eax, OFFSET _st+2762044
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9445 : 				st.strings[i].data.channel=0;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	DWORD PTR _st[eax+2762076], 0

; 9446 : 				st.strings[i].stat=0;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	BYTE PTR _st[eax+2762084], 0
$LN5@Renderer:

; 9447 : 			}
; 9448 : 		}

	jmp	$LN9@Renderer
$LN8@Renderer:

; 9449 : 		
; 9450 : 		for(i=0;i<vbdt_num;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Renderer
$LN3@Renderer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Renderer:
	movzx	eax, WORD PTR _vbdt_num
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN2@Renderer

; 9451 : 		{
; 9452 : 			if(vbdt[i].num_elements>0)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	test	edx, edx
	jle	SHORT $LN1@Renderer

; 9453 : 			{
; 9454 : 				vbdt[i].num_elements=0;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	xor	ecx, ecx
	mov	edx, DWORD PTR _vbdt
	mov	WORD PTR [edx+eax+46], cx
$LN1@Renderer:

; 9455 : 			}
; 9456 : 		}

	jmp	SHORT $LN3@Renderer
$LN2@Renderer:

; 9457 : 	}
; 9458 : 
; 9459 : #endif
; 9460 : 
; 9461 : 	st.num_entities=0;

	mov	DWORD PTR _st+244, 0

; 9462 : 
; 9463 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 9464 : 	texone_num=0;

	xor	eax, eax
	mov	WORD PTR _texone_num, ax

; 9465 : #endif
; 9466 : 
; 9467 : 	st.num_lightmap=0;

	mov	BYTE PTR _st+261, 0

; 9468 : 	memset(&ent,0,MAX_GRAPHICS);

	push	2048					; 00000800H
	push	0
	push	OFFSET _ent
	call	_memset
	add	esp, 12					; 0000000cH

; 9469 : 	memset(&lmp,0,MAX_LIGHTMAPS);

	push	128					; 00000080H
	push	0
	push	OFFSET _lmp
	call	_memset
	add	esp, 12					; 0000000cH

; 9470 : 
; 9471 : 	//SDL_GL_SwapWindow(wn);
; 9472 : 
; 9473 : 	
; 9474 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN174@Renderer
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 612				; 00000264H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN174@Renderer:
	DD	5
	DD	$LN173@Renderer
$LN173@Renderer:
	DD	-88					; ffffffa8H
	DD	8
	DD	$LN168@Renderer
	DD	-300					; fffffed4H
	DD	48					; 00000030H
	DD	$LN169@Renderer
	DD	-340					; fffffeacH
	DD	32					; 00000020H
	DD	$LN170@Renderer
	DD	-356					; fffffe9cH
	DD	8
	DD	$LN171@Renderer
	DD	-416					; fffffe60H
	DD	4
	DD	$LN172@Renderer
$LN172@Renderer:
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
$LN171@Renderer:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$LN170@Renderer:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	0
$LN169@Renderer:
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
$LN168@Renderer:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
_Renderer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawStringUIv
_TEXT	SEGMENT
tv965 = -468						; size = 4
tv941 = -468						; size = 4
tv916 = -468						; size = 4
tv893 = -468						; size = 4
tv869 = -468						; size = 4
tv845 = -468						; size = 4
tv820 = -468						; size = 4
tv795 = -468						; size = 4
tv1083 = -464						; size = 4
tv1075 = -464						; size = 4
tv1067 = -464						; size = 4
tv1059 = -464						; size = 4
tv1051 = -464						; size = 4
tv1043 = -464						; size = 4
tv1035 = -464						; size = 4
tv1027 = -464						; size = 4
tv1081 = -460						; size = 4
tv1073 = -460						; size = 4
tv1065 = -460						; size = 4
tv1057 = -460						; size = 4
tv1049 = -460						; size = 4
tv1041 = -460						; size = 4
tv1033 = -460						; size = 4
tv1025 = -460						; size = 4
tv954 = -456						; size = 4
tv930 = -456						; size = 4
tv905 = -456						; size = 4
tv882 = -456						; size = 4
tv857 = -456						; size = 4
tv833 = -456						; size = 4
tv808 = -456						; size = 4
tv783 = -456						; size = 4
tv1079 = -452						; size = 4
tv1071 = -452						; size = 4
tv1063 = -452						; size = 4
tv1055 = -452						; size = 4
tv1047 = -452						; size = 4
tv1039 = -452						; size = 4
tv1031 = -452						; size = 4
tv1023 = -452						; size = 4
tv1077 = -448						; size = 4
tv1069 = -448						; size = 4
tv1061 = -448						; size = 4
tv1053 = -448						; size = 4
tv1045 = -448						; size = 4
tv1037 = -448						; size = 4
tv1029 = -448						; size = 4
tv1021 = -448						; size = 4
_msg$ = -248						; size = 4
_val$ = -233						; size = 1
_az$ = -224						; size = 4
_ay$ = -212						; size = 4
_ax$ = -200						; size = 4
_formatt$ = -176					; size = 2
_co$ = -164						; size = 4
_id$ = -152						; size = 4
_checked$ = -68						; size = 4
_k$ = -56						; size = 4
_j$ = -44						; size = 4
_i$ = -32						; size = 4
_valy$ = -17						; size = 1
_valx$ = -5						; size = 1
_text$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_sizex$ = 20						; size = 4
_sizey$ = 24						; size = 4
_ang$ = 28						; size = 2
_r$ = 32						; size = 1
_g$ = 36						; size = 1
_b$ = 40						; size = 1
_a$ = 44						; size = 1
_font$ = 48						; size = 1
_override_sizex$ = 52					; size = 4
_override_sizey$ = 56					; size = 4
_z$ = 60						; size = 1
_DrawStringUIv PROC					; COMDAT

; 6712 : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 468				; 000001d4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-468]
	mov	ecx, 117				; 00000075H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 6713 : 	uint8 valx=0, valy=0;

	mov	BYTE PTR _valx$[ebp], 0
	mov	BYTE PTR _valy$[ebp], 0

; 6714 : 	uint32 i=0, j=0, k=0, checked=0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _k$[ebp], 0
	mov	DWORD PTR _checked$[ebp], 0

; 6715 : 	int32 t1, t2, t3, t4, timej, timel, id=-1;

	mov	DWORD PTR _id$[ebp], -1

; 6716 : 
; 6717 : 	SDL_Color co;
; 6718 : 	uint16 formatt;
; 6719 : 
; 6720 : 	float tmp, ax, ay, az;
; 6721 : 
; 6722 : 	uint8 val=0;

	mov	BYTE PTR _val$[ebp], 0

; 6723 : 	
; 6724 : 	SDL_Surface *msg;
; 6725 : if(st.num_entities==MAX_GRAPHICS-1)

	cmp	DWORD PTR _st+244, 2047			; 000007ffH
	jne	SHORT $LN32@DrawString

; 6726 : 		return 2;

	mov	al, 2
	jmp	$LN33@DrawString
$LN32@DrawString:

; 6727 : 
; 6728 : 	//Checkbounds(x,y,sizex,sizey,ang,GAME_WIDTH,GAME_HEIGHT)) return 1;
; 6729 : 
; 6730 : 	for(i=0;i<MAX_STRINGS;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN31@DrawString
$LN30@DrawString:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN31@DrawString:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jae	$LN29@DrawString

; 6731 : 	{
; 6732 : 		if(st.strings[i].stat==2)

	imul	eax, DWORD PTR _i$[ebp], 1068
	movsx	ecx, BYTE PTR _st[eax+2762084]
	cmp	ecx, 2
	jne	$LN28@DrawString

; 6733 : 		{
; 6734 : 			if(strcmp(text,st.strings[i].string)==NULL)

	imul	eax, DWORD PTR _i$[ebp], 1068
	add	eax, OFFSET _st+2761020
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@DrawString

; 6735 : 			{
; 6736 : 				st.strings[i].stat=1;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	BYTE PTR _st[eax+2762084], 1

; 6737 : 				j=st.num_entities;

	mov	eax, DWORD PTR _st+244
	mov	DWORD PTR _j$[ebp], eax

; 6738 : 				st.strings[i].data.posx=i;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _st[eax+2762058], cx

; 6739 : 				memcpy(&ent[j].data,&st.strings[i].data,sizeof(TEX_DATA));

	push	40					; 00000028H
	imul	eax, DWORD PTR _i$[ebp], 1068
	add	eax, OFFSET _st+2762044
	push	eax
	imul	ecx, DWORD PTR _j$[ebp], 264
	add	ecx, OFFSET _ent+44
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6740 : 				id=i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _id$[ebp], eax

; 6741 : 				checked=1;

	mov	DWORD PTR _checked$[ebp], 1

; 6742 : 				break;

	jmp	$LN29@DrawString
$LN27@DrawString:

; 6743 : 			}
; 6744 : 		}
; 6745 : 		else

	jmp	SHORT $LN25@DrawString
$LN28@DrawString:

; 6746 : 		if(st.strings[i].stat==0 && checked==0)

	imul	eax, DWORD PTR _i$[ebp], 1068
	movsx	ecx, BYTE PTR _st[eax+2762084]
	test	ecx, ecx
	jne	SHORT $LN25@DrawString
	cmp	DWORD PTR _checked$[ebp], 0
	jne	SHORT $LN25@DrawString

; 6747 : 		{
; 6748 : 			checked=3;

	mov	DWORD PTR _checked$[ebp], 3

; 6749 : 			id=i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _id$[ebp], eax
$LN25@DrawString:

; 6750 : 		}
; 6751 : 
; 6752 : 		if(i==MAX_STRINGS-1)

	cmp	DWORD PTR _i$[ebp], 511			; 000001ffH
	jne	SHORT $LN21@DrawString

; 6753 : 		{
; 6754 : 			if(id!=-1 && checked==3)

	cmp	DWORD PTR _id$[ebp], -1
	je	SHORT $LN23@DrawString
	cmp	DWORD PTR _checked$[ebp], 3
	jne	SHORT $LN23@DrawString

; 6755 : 			{
; 6756 : 				st.strings[id].stat=1;

	imul	eax, DWORD PTR _id$[ebp], 1068
	mov	BYTE PTR _st[eax+2762084], 1

; 6757 : 				strcpy(st.strings[id].string,text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	imul	ecx, DWORD PTR _id$[ebp], 1068
	add	ecx, OFFSET _st+2761020
	push	ecx
	call	_strcpy
	add	esp, 8

; 6758 : 				checked=2;

	mov	DWORD PTR _checked$[ebp], 2

; 6759 : 			}
; 6760 : 			else

	jmp	SHORT $LN21@DrawString
$LN23@DrawString:

; 6761 : 			if(checked==0 && id==-1)

	cmp	DWORD PTR _checked$[ebp], 0
	jne	SHORT $LN21@DrawString
	cmp	DWORD PTR _id$[ebp], -1
	jne	SHORT $LN21@DrawString

; 6762 : 			{
; 6763 : 				LogApp("Warning: max number os strings reached");

	push	OFFSET ??_C@_0CH@GLOGGAHF@Warning?3?5max?5number?5os?5strings?5r@
	call	_SDL_Log
	add	esp, 4

; 6764 : 				return 2;

	mov	al, 2
	jmp	$LN33@DrawString
$LN21@DrawString:

; 6765 : 			}
; 6766 : 		}
; 6767 : 	}

	jmp	$LN30@DrawString
$LN29@DrawString:

; 6768 : 
; 6769 : 	i=st.num_entities;

	mov	eax, DWORD PTR _st+244
	mov	DWORD PTR _i$[ebp], eax

; 6770 : 
; 6771 : 	if(checked==2)

	cmp	DWORD PTR _checked$[ebp], 2
	jne	$LN20@DrawString

; 6772 : 	{
; 6773 : 
; 6774 : 		co.r=255;

	mov	BYTE PTR _co$[ebp], 255			; 000000ffH

; 6775 : 		co.g=255;

	mov	BYTE PTR _co$[ebp+1], 255		; 000000ffH

; 6776 : 		co.b=255;

	mov	BYTE PTR _co$[ebp+2], 255		; 000000ffH

; 6777 : 		co.a=255;

	mov	BYTE PTR _co$[ebp+3], 255		; 000000ffH

; 6778 : 
; 6779 : 		if(strlen(text)==0) 

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN19@DrawString

; 6780 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font," ",co);

	mov	eax, DWORD PTR _co$[ebp]
	push	eax
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	movzx	ecx, BYTE PTR _font$[ebp]
	imul	edx, ecx, 84
	mov	eax, DWORD PTR _st[edx+64344]
	push	eax
	call	_TTF_RenderUTF8_Blended
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _msg$[ebp], eax

; 6781 : 		else

	jmp	SHORT $LN18@DrawString
$LN19@DrawString:

; 6782 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font,text,co);

	mov	eax, DWORD PTR _co$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _font$[ebp]
	imul	eax, edx, 84
	mov	ecx, DWORD PTR _st[eax+64344]
	push	ecx
	call	_TTF_RenderUTF8_Blended
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _msg$[ebp], eax
$LN18@DrawString:

; 6783 : 	
; 6784 : 		if(msg->format->BytesPerPixel==4)

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+9]
	cmp	edx, 4
	jne	SHORT $LN17@DrawString

; 6785 : 		{
; 6786 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGBA;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+12], 255			; 000000ffH
	jne	SHORT $LN16@DrawString
	mov	eax, 6408				; 00001908H
	mov	WORD PTR _formatt$[ebp], ax
	jmp	SHORT $LN15@DrawString
$LN16@DrawString:

; 6787 : 			else formatt=GL_BGRA_EXT;

	mov	eax, 32993				; 000080e1H
	mov	WORD PTR _formatt$[ebp], ax
$LN15@DrawString:

; 6788 : 		} else

	jmp	SHORT $LN12@DrawString
$LN17@DrawString:

; 6789 : 		{
; 6790 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGB;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+12], 255			; 000000ffH
	jne	SHORT $LN13@DrawString
	mov	eax, 6407				; 00001907H
	mov	WORD PTR _formatt$[ebp], ax
	jmp	SHORT $LN12@DrawString
$LN13@DrawString:

; 6791 : 			else formatt=GL_BGR_EXT;

	mov	eax, 32992				; 000080e0H
	mov	WORD PTR _formatt$[ebp], ax
$LN12@DrawString:

; 6792 : 		}
; 6793 : 
; 6794 : 		glGenTextures(1,&ent[i].data.data);

	imul	eax, DWORD PTR _i$[ebp], 264
	add	eax, OFFSET _ent+44
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6795 : 		glBindTexture(GL_TEXTURE_2D,ent[i].data.data);

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	esi, esp
	mov	ecx, DWORD PTR _ent[eax+44]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6796 : 		glTexImage2D(GL_TEXTURE_2D,0,msg->format->BytesPerPixel,msg->w,msg->h,0,formatt,GL_UNSIGNED_BYTE,msg->pixels);

	mov	esi, esp
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	5121					; 00001401H
	movzx	edx, WORD PTR _formatt$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx+9]
	push	eax
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6797 : 
; 6798 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	mov	esi, esp
	push	9729					; 00002601H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6799 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	mov	esi, esp
	push	9729					; 00002601H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6800 : 
; 6801 : 		ent[i].data.channel=63; //magical number only used for rendering

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	DWORD PTR _ent[eax+76], 63		; 0000003fH

; 6802 : 
; 6803 : 		ent[i].data.posx=id;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	cx, WORD PTR _id$[ebp]
	mov	WORD PTR _ent[eax+58], cx

; 6804 : 
; 6805 : 		ent[i].data.normal=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	BYTE PTR _ent[eax+52], 0

; 6806 : 		ent[i].data.vb_id=-1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, -1
	mov	WORD PTR _ent[eax+54], cx

; 6807 : 
; 6808 : 		ent[i].data.w=msg->w;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _ent[eax+68], edx

; 6809 : 		ent[i].data.h=msg->h;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _ent[eax+72], edx

; 6810 : 
; 6811 : 		memcpy(&st.strings[id].data,&ent[i].data,sizeof(TEX_DATA));

	push	40					; 00000028H
	imul	eax, DWORD PTR _i$[ebp], 264
	add	eax, OFFSET _ent+44
	push	eax
	imul	ecx, DWORD PTR _id$[ebp], 1068
	add	ecx, OFFSET _st+2762044
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6812 : 
; 6813 : 		SDL_FreeSurface(msg);

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_SDL_FreeSurface
	add	esp, 4
$LN20@DrawString:

; 6814 : 	}
; 6815 : 
; 6816 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 6817 : 
; 6818 : 	ent[i].lightmapid=-1;

	imul	eax, DWORD PTR _i$[ebp], 264
	or	ecx, -1
	mov	WORD PTR _ent[eax+260], cx

; 6819 : 
; 6820 : 			
; 6821 : 			if(override_sizex!=0)

	cmp	DWORD PTR _override_sizex$[ebp], 0
	je	SHORT $LN11@DrawString

; 6822 : 				sizex=st.strings[id].data.w*(float)(override_sizex/1024.0f);

	imul	eax, DWORD PTR _id$[ebp], 1068
	cvtsi2ss xmm0, DWORD PTR _st[eax+2762068]
	cvtsi2ss xmm1, DWORD PTR _override_sizex$[ebp]
	divss	xmm1, DWORD PTR __real@44800000
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _sizex$[ebp], ecx
$LN11@DrawString:

; 6823 : 
; 6824 : 			if(override_sizey!=0)

	cmp	DWORD PTR _override_sizey$[ebp], 0
	je	SHORT $LN10@DrawString

; 6825 : 				sizey=st.strings[id].data.h*(float)(override_sizey/1024.0f);

	imul	eax, DWORD PTR _id$[ebp], 1068
	cvtsi2ss xmm0, DWORD PTR _st[eax+2762072]
	cvtsi2ss xmm1, DWORD PTR _override_sizey$[ebp]
	divss	xmm1, DWORD PTR __real@44800000
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _sizey$[ebp], ecx
$LN10@DrawString:

; 6826 : 
; 6827 : 			if(r==0 && g==0 && b==0)

	movzx	eax, BYTE PTR _r$[ebp]
	test	eax, eax
	jne	SHORT $LN9@DrawString
	movzx	eax, BYTE PTR _g$[ebp]
	test	eax, eax
	jne	SHORT $LN9@DrawString
	movzx	eax, BYTE PTR _b$[ebp]
	test	eax, eax
	jne	SHORT $LN9@DrawString

; 6828 : 				r=g=b=1;

	mov	BYTE PTR _b$[ebp], 1
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _g$[ebp], al
	mov	cl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _r$[ebp], cl
$LN9@DrawString:

; 6829 : 
; 6830 : 			if(z>7) z=7;

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 7
	jle	SHORT $LN8@DrawString
	mov	BYTE PTR _z$[ebp], 7
$LN8@DrawString:

; 6831 : 			//else if(z<0) z+=8;
; 6832 : 
; 6833 : 			z_buffer[z][z_slot[z]]=i;

	movsx	eax, BYTE PTR _z$[ebp]
	shl	eax, 12					; 0000000cH
	movsx	ecx, BYTE PTR _z$[ebp]
	movsx	edx, WORD PTR _z_slot[ecx*2]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _z_buffer[eax+edx*2], cx

; 6834 : 			z_slot[z]++;

	movsx	eax, BYTE PTR _z$[ebp]
	mov	cx, WORD PTR _z_slot[eax*2]
	add	cx, 1
	movsx	edx, BYTE PTR _z$[ebp]
	mov	WORD PTR _z_slot[edx*2], cx

; 6835 : 
; 6836 : 			if(z>z_used) z_used=z;

	movsx	eax, BYTE PTR _z$[ebp]
	movsx	ecx, BYTE PTR _z_used
	cmp	eax, ecx
	jle	SHORT $LN7@DrawString
	mov	al, BYTE PTR _z$[ebp]
	mov	BYTE PTR _z_used, al
$LN7@DrawString:

; 6837 : 
; 6838 : 			x+=sizex/2;

	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _x$[ebp], eax

; 6839 : 			//y-=sizey/2;
; 6840 : 
; 6841 : 			//timej=GetTicks();
; 6842 : 
; 6843 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1021[ebp], xmm0
	movss	DWORD PTR tv1023[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv783[ebp]
	movss	xmm0, DWORD PTR tv1023[ebp]
	mulss	xmm0, DWORD PTR tv783[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1025[ebp], xmm0
	movss	DWORD PTR tv1027[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv795[ebp]
	movss	xmm0, DWORD PTR tv1027[ebp]
	mulss	xmm0, DWORD PTR tv795[ebp]
	movss	xmm1, DWORD PTR tv1025[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1021[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 6844 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1029[ebp], xmm0
	movss	DWORD PTR tv1031[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv808[ebp]
	movss	xmm0, DWORD PTR tv1031[ebp]
	mulss	xmm0, DWORD PTR tv808[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1033[ebp], xmm0
	movss	DWORD PTR tv1035[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv820[ebp]
	movss	xmm0, DWORD PTR tv1035[ebp]
	mulss	xmm0, DWORD PTR tv820[ebp]
	movss	xmm1, DWORD PTR tv1033[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1029[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 6845 : 			ent[i].vertex[2]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movsx	edx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 6846 : 
; 6847 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1037[ebp], xmm0
	movss	DWORD PTR tv1039[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv833[ebp]
	movss	xmm0, DWORD PTR tv1039[ebp]
	mulss	xmm0, DWORD PTR tv833[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1041[ebp], xmm0
	movss	DWORD PTR tv1043[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv845[ebp]
	movss	xmm0, DWORD PTR tv1043[ebp]
	mulss	xmm0, DWORD PTR tv845[ebp]
	movss	xmm1, DWORD PTR tv1041[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1037[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 6848 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1045[ebp], xmm0
	movss	DWORD PTR tv1047[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv857[ebp]
	movss	xmm0, DWORD PTR tv1047[ebp]
	mulss	xmm0, DWORD PTR tv857[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1049[ebp], xmm0
	movss	DWORD PTR tv1051[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv869[ebp]
	movss	xmm0, DWORD PTR tv1051[ebp]
	mulss	xmm0, DWORD PTR tv869[ebp]
	movss	xmm1, DWORD PTR tv1049[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1045[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 6849 : 			ent[i].vertex[5]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	movsx	ecx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 6850 : 
; 6851 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1053[ebp], xmm0
	movss	DWORD PTR tv1055[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv882[ebp]
	movss	xmm0, DWORD PTR tv1055[ebp]
	mulss	xmm0, DWORD PTR tv882[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1057[ebp], xmm0
	movss	DWORD PTR tv1059[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv893[ebp]
	movss	xmm0, DWORD PTR tv1059[ebp]
	mulss	xmm0, DWORD PTR tv893[ebp]
	movss	xmm1, DWORD PTR tv1057[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1053[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 6
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 6852 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1061[ebp], xmm0
	movss	DWORD PTR tv1063[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv905[ebp]
	movss	xmm0, DWORD PTR tv1063[ebp]
	mulss	xmm0, DWORD PTR tv905[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1065[ebp], xmm0
	movss	DWORD PTR tv1067[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv916[ebp]
	movss	xmm0, DWORD PTR tv1067[ebp]
	mulss	xmm0, DWORD PTR tv916[ebp]
	movss	xmm1, DWORD PTR tv1065[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1061[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 7
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 6853 : 			ent[i].vertex[8]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 3
	movsx	edx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 6854 : 
; 6855 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1069[ebp], xmm0
	movss	DWORD PTR tv1071[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv930[ebp]
	movss	xmm0, DWORD PTR tv1071[ebp]
	mulss	xmm0, DWORD PTR tv930[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1073[ebp], xmm0
	movss	DWORD PTR tv1075[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv941[ebp]
	movss	xmm0, DWORD PTR tv1075[ebp]
	mulss	xmm0, DWORD PTR tv941[ebp]
	movss	xmm1, DWORD PTR tv1073[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1069[ebp]
	addss	xmm0, xmm1
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 9
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 6856 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1077[ebp], xmm0
	movss	DWORD PTR tv1079[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv954[ebp]
	movss	xmm0, DWORD PTR tv1079[ebp]
	mulss	xmm0, DWORD PTR tv954[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1081[ebp], xmm0
	movss	DWORD PTR tv1083[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv965[ebp]
	movss	xmm0, DWORD PTR tv1083[ebp]
	mulss	xmm0, DWORD PTR tv965[ebp]
	movss	xmm1, DWORD PTR tv1081[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1077[ebp]
	addss	xmm0, xmm1
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 10
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 6857 : 			ent[i].vertex[11]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 11
	movsx	ecx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 6858 : 
; 6859 : 			/*
; 6860 : 			ang/=10;
; 6861 : 
; 6862 : 			tmp=cos((ang*pi)/180);
; 6863 : 			tmp=mCos(ang*10);
; 6864 : 	*/
; 6865 : 			ax=(float) 1/(GAME_WIDTH/2);

	movss	xmm0, DWORD PTR __real@39000000
	movss	DWORD PTR _ax$[ebp], xmm0

; 6866 : 			ay=(float) 1/(9216.0f/2);

	movss	xmm0, DWORD PTR __real@39638e39
	movss	DWORD PTR _ay$[ebp], xmm0

; 6867 : 
; 6868 : 			ay*=-1.0f;

	movss	xmm0, DWORD PTR _ay$[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _ay$[ebp], xmm0

; 6869 : 
; 6870 : 			az=(float) 1/(4096/2);

	movss	xmm0, DWORD PTR __real@3a000000
	movss	DWORD PTR _az$[ebp], xmm0

; 6871 : 
; 6872 : 			
; 6873 : 				ent[i].texcor[0]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 6874 : 				ent[i].texcor[1]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 6875 : 				ent[i].texcor[2]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 6876 : 				ent[i].texcor[3]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 6877 : 				ent[i].texcor[4]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 6878 : 				ent[i].texcor[5]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 6879 : 				ent[i].texcor[6]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 6
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 6880 : 				ent[i].texcor[7]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 7
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 6881 : 
; 6882 : 			for(j=0;j<12;j+=3)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN6@DrawString
$LN5@DrawString:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 3
	mov	DWORD PTR _j$[ebp], eax
$LN6@DrawString:
	cmp	DWORD PTR _j$[ebp], 12			; 0000000cH
	jae	$LN4@DrawString

; 6883 : 			{
; 6884 : 				ent[i].vertex[j]*=ax;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+100]
	mulss	xmm0, DWORD PTR _ax$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 6885 : 				ent[i].vertex[j]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+100]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 6886 : 
; 6887 : 				ent[i].vertex[j+1]*=ay;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+104]
	mulss	xmm0, DWORD PTR _ay$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 6888 : 				ent[i].vertex[j+1]+=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+104]
	addss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 6889 : 				
; 6890 : 				ent[i].vertex[j+2]*=az;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+108]
	mulss	xmm0, DWORD PTR _az$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 6891 : 				ent[i].vertex[j+2]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+108]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 6892 : 			}

	jmp	$LN5@DrawString
$LN4@DrawString:

; 6893 : 
; 6894 : 			for(j=0;j<16;j+=4)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN3@DrawString
$LN2@DrawString:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 4
	mov	DWORD PTR _j$[ebp], eax
$LN3@DrawString:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jae	SHORT $LN1@DrawString

; 6895 : 			{
; 6896 : 				ent[i].color[j]=r;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _ent[eax+ecx+228], dl

; 6897 : 				ent[i].color[j+1]=g;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _ent[eax+ecx+229], dl

; 6898 : 				ent[i].color[j+2]=b;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _ent[eax+ecx+230], dl

; 6899 : 				ent[i].color[j+3]=a;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR _ent[eax+ecx+231], dl

; 6900 : 			}

	jmp	SHORT $LN2@DrawString
$LN1@DrawString:

; 6901 : 
; 6902 : 			
; 6903 : 				texone_ids[texone_num]=i;

	movzx	eax, WORD PTR _texone_num
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _texone_ids[eax*2], cx

; 6904 : 				texone_num++;

	mov	ax, WORD PTR _texone_num
	add	ax, 1
	mov	WORD PTR _texone_num, ax

; 6905 : 
; 6906 : #endif
; 6907 : 
; 6908 : 			st.num_entities++;

	mov	eax, DWORD PTR _st+244
	add	eax, 1
	mov	DWORD PTR _st+244, eax

; 6909 : 
; 6910 : 	return 0;

	xor	al, al
$LN33@DrawString:

; 6911 : 
; 6912 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN37@DrawString
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 468				; 000001d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@DrawString:
	DD	1
	DD	$LN36@DrawString
$LN36@DrawString:
	DD	-164					; ffffff5cH
	DD	4
	DD	$LN35@DrawString
$LN35@DrawString:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	0
_DrawStringUIv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawUI2
_TEXT	SEGMENT
tv931 = -348						; size = 4
tv907 = -348						; size = 4
tv882 = -348						; size = 4
tv859 = -348						; size = 4
tv835 = -348						; size = 4
tv811 = -348						; size = 4
tv786 = -348						; size = 4
tv761 = -348						; size = 4
tv1102 = -344						; size = 4
tv1094 = -344						; size = 4
tv1086 = -344						; size = 4
tv1078 = -344						; size = 4
tv1070 = -344						; size = 4
tv1062 = -344						; size = 4
tv1022 = -344						; size = 4
tv1014 = -344						; size = 4
tv1100 = -340						; size = 4
tv1092 = -340						; size = 4
tv1084 = -340						; size = 4
tv1076 = -340						; size = 4
tv1068 = -340						; size = 4
tv1060 = -340						; size = 4
tv1020 = -340						; size = 4
tv1012 = -340						; size = 4
tv920 = -336						; size = 4
tv896 = -336						; size = 4
tv871 = -336						; size = 4
tv848 = -336						; size = 4
tv823 = -336						; size = 4
tv799 = -336						; size = 4
tv774 = -336						; size = 4
tv749 = -336						; size = 4
tv1098 = -332						; size = 4
tv1090 = -332						; size = 4
tv1082 = -332						; size = 4
tv1074 = -332						; size = 4
tv1066 = -332						; size = 4
tv1058 = -332						; size = 4
tv1018 = -332						; size = 4
tv1010 = -332						; size = 4
tv1096 = -328						; size = 4
tv1088 = -328						; size = 4
tv1080 = -328						; size = 4
tv1072 = -328						; size = 4
tv1064 = -328						; size = 4
tv1056 = -328						; size = 4
tv1016 = -328						; size = 4
tv1008 = -328						; size = 4
_k$ = -128						; size = 4
_j$ = -116						; size = 4
_i$ = -104						; size = 4
_ty2$ = -92						; size = 4
_tx2$ = -80						; size = 4
_ty1$ = -68						; size = 4
_tx1$ = -56						; size = 4
_az$ = -44						; size = 4
_ay$ = -32						; size = 4
_ax$ = -20						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_sizex$ = 16						; size = 4
_sizey$ = 20						; size = 4
_ang$ = 24						; size = 2
_r$ = 28						; size = 1
_g$ = 32						; size = 1
_b$ = 36						; size = 1
_x1$ = 40						; size = 4
_y1$ = 44						; size = 4
_x2$ = 48						; size = 4
_y2$ = 52						; size = 4
_data$ = 56						; size = 40
_a$ = 96						; size = 1
_layer$ = 100						; size = 1
_DrawUI2 PROC						; COMDAT

; 5496 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-348]
	mov	ecx, 87					; 00000057H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5497 : 	float tmp, ax, ay, az, tx1, ty1, tx2, ty2;
; 5498 : 
; 5499 : 	uint32 i=0, j=0, k=0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _k$[ebp], 0

; 5500 : 			
; 5501 : 	if(st.num_entities==MAX_GRAPHICS-1)

	cmp	DWORD PTR _st+244, 2047			; 000007ffH
	jne	SHORT $LN16@DrawUI2

; 5502 : 		return 2;

	mov	al, 2
	jmp	$LN17@DrawUI2

; 5503 : 	else

	jmp	SHORT $LN15@DrawUI2
$LN16@DrawUI2:

; 5504 : 		i=st.num_entities;

	mov	eax, DWORD PTR _st+244
	mov	DWORD PTR _i$[ebp], eax
$LN15@DrawUI2:

; 5505 : 
; 5506 : 	ent[i].lightmapid=-1;

	imul	eax, DWORD PTR _i$[ebp], 264
	or	ecx, -1
	mov	WORD PTR _ent[eax+260], cx

; 5507 : 	
; 5508 : 			ent[i].data=data;

	imul	edi, DWORD PTR _i$[ebp], 264
	add	edi, OFFSET _ent+44
	mov	ecx, 10					; 0000000aH
	lea	esi, DWORD PTR _data$[ebp]
	rep movsd

; 5509 : 
; 5510 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 5511 : 
; 5512 : 			if(r==0 && g==0 && b==0)

	movzx	eax, BYTE PTR _r$[ebp]
	test	eax, eax
	jne	SHORT $LN14@DrawUI2
	movzx	eax, BYTE PTR _g$[ebp]
	test	eax, eax
	jne	SHORT $LN14@DrawUI2
	movzx	eax, BYTE PTR _b$[ebp]
	test	eax, eax
	jne	SHORT $LN14@DrawUI2

; 5513 : 				r=g=b=1;

	mov	BYTE PTR _b$[ebp], 1
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _g$[ebp], al
	mov	cl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _r$[ebp], cl
$LN14@DrawUI2:

; 5514 : 
; 5515 : 			x-=st.Camera.position.x;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, DWORD PTR _st+2335380
	mov	DWORD PTR _x$[ebp], eax

; 5516 : 			y-=st.Camera.position.y;

	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, DWORD PTR _st+2335384
	mov	DWORD PTR _y$[ebp], eax

; 5517 : 
; 5518 : 			sizex*=st.Camera.dimension.x;

	cvtsi2ss xmm0, DWORD PTR _sizex$[ebp]
	mulss	xmm0, DWORD PTR _st+2335396
	cvttss2si eax, xmm0
	mov	DWORD PTR _sizex$[ebp], eax

; 5519 : 			sizey*=st.Camera.dimension.y;

	cvtsi2ss xmm0, DWORD PTR _sizey$[ebp]
	mulss	xmm0, DWORD PTR _st+2335400
	cvttss2si eax, xmm0
	mov	DWORD PTR _sizey$[ebp], eax

; 5520 : 
; 5521 : 			if(layer>7) layer=7;

	movsx	eax, BYTE PTR _layer$[ebp]
	cmp	eax, 7
	jle	SHORT $LN13@DrawUI2
	mov	BYTE PTR _layer$[ebp], 7
$LN13@DrawUI2:

; 5522 : 			//else if(layer<0) layer+=8;
; 5523 : 
; 5524 : 			z_buffer[layer][z_slot[layer]]=i;

	movsx	eax, BYTE PTR _layer$[ebp]
	shl	eax, 12					; 0000000cH
	movsx	ecx, BYTE PTR _layer$[ebp]
	movsx	edx, WORD PTR _z_slot[ecx*2]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _z_buffer[eax+edx*2], cx

; 5525 : 			z_slot[layer]++;

	movsx	eax, BYTE PTR _layer$[ebp]
	mov	cx, WORD PTR _z_slot[eax*2]
	add	cx, 1
	movsx	edx, BYTE PTR _layer$[ebp]
	mov	WORD PTR _z_slot[edx*2], cx

; 5526 : 
; 5527 : 			if(layer>z_used) z_used=layer;

	movsx	eax, BYTE PTR _layer$[ebp]
	movsx	ecx, BYTE PTR _z_used
	cmp	eax, ecx
	jle	SHORT $LN12@DrawUI2
	mov	al, BYTE PTR _layer$[ebp]
	mov	BYTE PTR _z_used, al
$LN12@DrawUI2:

; 5528 : 
; 5529 : 			//timej=GetTicks();
; 5530 : 
; 5531 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1008[ebp], xmm0
	movss	DWORD PTR tv1010[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv749[ebp]
	movss	xmm0, DWORD PTR tv1010[ebp]
	mulss	xmm0, DWORD PTR tv749[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1012[ebp], xmm0
	movss	DWORD PTR tv1014[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv761[ebp]
	movss	xmm0, DWORD PTR tv1014[ebp]
	mulss	xmm0, DWORD PTR tv761[ebp]
	movss	xmm1, DWORD PTR tv1012[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1008[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 5532 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1016[ebp], xmm0
	movss	DWORD PTR tv1018[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv774[ebp]
	movss	xmm0, DWORD PTR tv1018[ebp]
	mulss	xmm0, DWORD PTR tv774[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1020[ebp], xmm0
	movss	DWORD PTR tv1022[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv786[ebp]
	movss	xmm0, DWORD PTR tv1022[ebp]
	mulss	xmm0, DWORD PTR tv786[ebp]
	movss	xmm1, DWORD PTR tv1020[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1016[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 5533 : 			ent[i].vertex[2]=layer;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movsx	edx, BYTE PTR _layer$[ebp]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 5534 : 
; 5535 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1056[ebp], xmm0
	movss	DWORD PTR tv1058[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv799[ebp]
	movss	xmm0, DWORD PTR tv1058[ebp]
	mulss	xmm0, DWORD PTR tv799[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1060[ebp], xmm0
	movss	DWORD PTR tv1062[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv811[ebp]
	movss	xmm0, DWORD PTR tv1062[ebp]
	mulss	xmm0, DWORD PTR tv811[ebp]
	movss	xmm1, DWORD PTR tv1060[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1056[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 5536 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1064[ebp], xmm0
	movss	DWORD PTR tv1066[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv823[ebp]
	movss	xmm0, DWORD PTR tv1066[ebp]
	mulss	xmm0, DWORD PTR tv823[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1068[ebp], xmm0
	movss	DWORD PTR tv1070[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv835[ebp]
	movss	xmm0, DWORD PTR tv1070[ebp]
	mulss	xmm0, DWORD PTR tv835[ebp]
	movss	xmm1, DWORD PTR tv1068[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1064[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 5537 : 			ent[i].vertex[5]=layer;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	movsx	ecx, BYTE PTR _layer$[ebp]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 5538 : 
; 5539 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1072[ebp], xmm0
	movss	DWORD PTR tv1074[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv848[ebp]
	movss	xmm0, DWORD PTR tv1074[ebp]
	mulss	xmm0, DWORD PTR tv848[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1076[ebp], xmm0
	movss	DWORD PTR tv1078[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv859[ebp]
	movss	xmm0, DWORD PTR tv1078[ebp]
	mulss	xmm0, DWORD PTR tv859[ebp]
	movss	xmm1, DWORD PTR tv1076[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1072[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 6
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 5540 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1080[ebp], xmm0
	movss	DWORD PTR tv1082[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv871[ebp]
	movss	xmm0, DWORD PTR tv1082[ebp]
	mulss	xmm0, DWORD PTR tv871[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1084[ebp], xmm0
	movss	DWORD PTR tv1086[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv882[ebp]
	movss	xmm0, DWORD PTR tv1086[ebp]
	mulss	xmm0, DWORD PTR tv882[ebp]
	movss	xmm1, DWORD PTR tv1084[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1080[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 7
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 5541 : 			ent[i].vertex[8]=layer;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 3
	movsx	edx, BYTE PTR _layer$[ebp]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 5542 : 
; 5543 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1088[ebp], xmm0
	movss	DWORD PTR tv1090[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv896[ebp]
	movss	xmm0, DWORD PTR tv1090[ebp]
	mulss	xmm0, DWORD PTR tv896[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1092[ebp], xmm0
	movss	DWORD PTR tv1094[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv907[ebp]
	movss	xmm0, DWORD PTR tv1094[ebp]
	mulss	xmm0, DWORD PTR tv907[ebp]
	movss	xmm1, DWORD PTR tv1092[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1088[ebp]
	addss	xmm0, xmm1
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 9
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 5544 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1096[ebp], xmm0
	movss	DWORD PTR tv1098[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv920[ebp]
	movss	xmm0, DWORD PTR tv1098[ebp]
	mulss	xmm0, DWORD PTR tv920[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1100[ebp], xmm0
	movss	DWORD PTR tv1102[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv931[ebp]
	movss	xmm0, DWORD PTR tv1102[ebp]
	mulss	xmm0, DWORD PTR tv931[ebp]
	movss	xmm1, DWORD PTR tv1100[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1096[ebp]
	addss	xmm0, xmm1
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 10
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 5545 : 			ent[i].vertex[11]=layer;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 11
	movsx	ecx, BYTE PTR _layer$[ebp]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 5546 : 
; 5547 : 			//timel=GetTicks() - timej;
; 5548 : 
; 5549 : 			//ang=1000;
; 5550 : 			/*
; 5551 : 			ang/=10;
; 5552 : 
; 5553 : 			tmp=cos((ang*pi)/180);
; 5554 : 			tmp=mCos(ang*10);
; 5555 : 	*/
; 5556 : 			ax=(float) 1/(GAME_WIDTH / 2);

	movss	xmm0, DWORD PTR __real@39000000
	movss	DWORD PTR _ax$[ebp], xmm0

; 5557 : 			ay=(float) 1/(9216.0f / 2);

	movss	xmm0, DWORD PTR __real@39638e39
	movss	DWORD PTR _ay$[ebp], xmm0

; 5558 : 
; 5559 : 			ay*=-1.0f;

	movss	xmm0, DWORD PTR _ay$[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _ay$[ebp], xmm0

; 5560 : 
; 5561 : 			az=(float) 1/(4096/2);

	movss	xmm0, DWORD PTR __real@3a000000
	movss	DWORD PTR _az$[ebp], xmm0

; 5562 : 
; 5563 : 			if(data.vb_id==-1)

	movsx	eax, WORD PTR _data$[ebp+10]
	cmp	eax, -1
	jne	$LN11@DrawUI2

; 5564 : 			{
; 5565 : 				ent[i].texcor[0]=x1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtsi2ss xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 5566 : 				ent[i].texcor[1]=y1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	cvtsi2ss xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 5567 : 				ent[i].texcor[2]=x2;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 5568 : 				ent[i].texcor[3]=y1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	cvtsi2ss xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 5569 : 				ent[i].texcor[4]=x2;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	cvtsi2ss xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 5570 : 				ent[i].texcor[5]=y2;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	cvtsi2ss xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 5571 : 				ent[i].texcor[6]=x1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 6
	cvtsi2ss xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 5572 : 				ent[i].texcor[7]=y2;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 7
	cvtsi2ss xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 5573 : 			}
; 5574 : 			else

	jmp	$LN10@DrawUI2
$LN11@DrawUI2:

; 5575 : 			{
; 5576 : 				tx1=(float) x1/32768;

	cvtsi2ss xmm0, DWORD PTR _x1$[ebp]
	divss	xmm0, DWORD PTR __real@47000000
	movss	DWORD PTR _tx1$[ebp], xmm0

; 5577 : 				ty1=(float) y1/32768;

	cvtsi2ss xmm0, DWORD PTR _y1$[ebp]
	divss	xmm0, DWORD PTR __real@47000000
	movss	DWORD PTR _ty1$[ebp], xmm0

; 5578 : 				tx2=(float) x2/32768;

	cvtsi2ss xmm0, DWORD PTR _x2$[ebp]
	divss	xmm0, DWORD PTR __real@47000000
	movss	DWORD PTR _tx2$[ebp], xmm0

; 5579 : 				ty2=(float) y2/32768;

	cvtsi2ss xmm0, DWORD PTR _y2$[ebp]
	divss	xmm0, DWORD PTR __real@47000000
	movss	DWORD PTR _ty2$[ebp], xmm0

; 5580 : 
; 5581 : 				ent[i].texcor[0]=data.posx+(tx1*data.sizex);

	movzx	eax, WORD PTR _data$[ebp+14]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+18]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _tx1$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _ent[edx+ecx+148], xmm0

; 5582 : 				ent[i].texcor[1]=data.posy+(ty1*data.sizey);

	movzx	eax, WORD PTR _data$[ebp+16]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+20]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _ty1$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _ent[edx+eax+148], xmm0

; 5583 : 
; 5584 : 				ent[i].texcor[2]=data.posx+(tx2*data.sizex);

	movzx	eax, WORD PTR _data$[ebp+14]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+18]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _tx2$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _ent[edx+eax+148], xmm0

; 5585 : 				ent[i].texcor[3]=data.posy+(ty1*data.sizey);

	movzx	eax, WORD PTR _data$[ebp+16]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+20]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _ty1$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 3
	movss	DWORD PTR _ent[edx+ecx+148], xmm0

; 5586 : 
; 5587 : 				ent[i].texcor[4]=data.posx+(tx2*data.sizex);

	movzx	eax, WORD PTR _data$[ebp+14]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+18]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _tx2$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	shl	eax, 2
	movss	DWORD PTR _ent[edx+eax+148], xmm0

; 5588 : 				ent[i].texcor[5]=data.posy+(ty2*data.sizey);

	movzx	eax, WORD PTR _data$[ebp+16]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+20]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _ty2$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 5
	movss	DWORD PTR _ent[edx+ecx+148], xmm0

; 5589 : 
; 5590 : 				ent[i].texcor[6]=data.posx+(tx1*data.sizex);

	movzx	eax, WORD PTR _data$[ebp+14]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+18]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _tx1$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 6
	movss	DWORD PTR _ent[edx+ecx+148], xmm0

; 5591 : 				ent[i].texcor[7]=data.posy+(ty2*data.sizey);

	movzx	eax, WORD PTR _data$[ebp+16]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+20]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _ty2$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 7
	movss	DWORD PTR _ent[edx+ecx+148], xmm0
$LN10@DrawUI2:

; 5592 : 			}
; 5593 : 
; 5594 : 			for(j=0;j<12;j+=3)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN9@DrawUI2
$LN8@DrawUI2:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 3
	mov	DWORD PTR _j$[ebp], eax
$LN9@DrawUI2:
	cmp	DWORD PTR _j$[ebp], 12			; 0000000cH
	jae	$LN7@DrawUI2

; 5595 : 			{
; 5596 : 				ent[i].vertex[j]*=ax;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+100]
	mulss	xmm0, DWORD PTR _ax$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 5597 : 				ent[i].vertex[j]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+100]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 5598 : 
; 5599 : 		 		ent[i].vertex[j+1]*=ay;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+104]
	mulss	xmm0, DWORD PTR _ay$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 5600 : 				ent[i].vertex[j+1]+=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+104]
	addss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 5601 : 				
; 5602 : 				ent[i].vertex[j+2]*=az;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+108]
	mulss	xmm0, DWORD PTR _az$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 5603 : 				ent[i].vertex[j+2]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+108]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 5604 : 				
; 5605 : 				if(j<8)

	cmp	DWORD PTR _j$[ebp], 8
	jae	$LN6@DrawUI2

; 5606 : 				{
; 5607 : 					ent[i].texcor[j]/=(float)32768;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+148]
	divss	xmm0, DWORD PTR __real@47000000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+148], xmm0

; 5608 : 					ent[i].texcor[j+1]/=(float)32768;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+152]
	divss	xmm0, DWORD PTR __real@47000000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+152], xmm0

; 5609 : 					ent[i].texcor[j+2]/=(float)32768;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+156]
	divss	xmm0, DWORD PTR __real@47000000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+156], xmm0
$LN6@DrawUI2:

; 5610 : 				}
; 5611 : 				
; 5612 : 			}

	jmp	$LN8@DrawUI2
$LN7@DrawUI2:

; 5613 : 
; 5614 : 			for(j=0;j<16;j+=4)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN5@DrawUI2
$LN4@DrawUI2:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 4
	mov	DWORD PTR _j$[ebp], eax
$LN5@DrawUI2:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jae	SHORT $LN3@DrawUI2

; 5615 : 			{
; 5616 : 				ent[i].color[j]=r;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _ent[eax+ecx+228], dl

; 5617 : 				ent[i].color[j+1]=g;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _ent[eax+ecx+229], dl

; 5618 : 				ent[i].color[j+2]=b;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _ent[eax+ecx+230], dl

; 5619 : 				ent[i].color[j+3]=a;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR _ent[eax+ecx+231], dl

; 5620 : 			}

	jmp	SHORT $LN4@DrawUI2
$LN3@DrawUI2:

; 5621 : 
; 5622 : 			if(data.vb_id!=-1)

	movsx	eax, WORD PTR _data$[ebp+10]
	cmp	eax, -1
	je	SHORT $LN2@DrawUI2

; 5623 : 			{
; 5624 : 				vbdt[data.vb_id].num_elements++;

	movsx	eax, WORD PTR _data$[ebp+10]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	dx, WORD PTR [ecx+eax+46]
	add	dx, 1
	movsx	eax, WORD PTR _data$[ebp+10]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	WORD PTR [ecx+eax+46], dx

; 5625 : 				ent[i].data.loc=vbdt[data.vb_id].num_elements-1;

	movsx	eax, WORD PTR _data$[ebp+10]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	sub	edx, 1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	WORD PTR _ent[eax+56], dx

; 5626 : 			}
; 5627 : 			else

	jmp	SHORT $LN1@DrawUI2
$LN2@DrawUI2:

; 5628 : 			{
; 5629 : 				texone_ids[texone_num]=i;

	movzx	eax, WORD PTR _texone_num
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _texone_ids[eax*2], cx

; 5630 : 				texone_num++;

	mov	ax, WORD PTR _texone_num
	add	ax, 1
	mov	WORD PTR _texone_num, ax
$LN1@DrawUI2:

; 5631 : 			}
; 5632 : 
; 5633 : #endif
; 5634 : 
; 5635 : 			st.num_entities++;

	mov	eax, DWORD PTR _st+244
	add	eax, 1
	mov	DWORD PTR _st+244, eax

; 5636 : 
; 5637 : 	return 0;

	xor	al, al
$LN17@DrawUI2:

; 5638 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 348				; 0000015cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_DrawUI2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawPolygon
_TEXT	SEGMENT
_az$ = -200						; size = 4
_ay$ = -188						; size = 4
_ax$ = -176						; size = 4
_vertex$ = -164						; size = 48
_k$ = -60						; size = 2
_j$ = -48						; size = 2
_i$ = -36						; size = 2
_valy$ = -21						; size = 1
_valx$ = -9						; size = 1
__$ArrayPad$ = -4					; size = 4
_vertex_s$ = 8						; size = 4
_r$ = 12						; size = 1
_g$ = 16						; size = 1
_b$ = 20						; size = 1
_a$ = 24						; size = 1
_z$ = 28						; size = 4
_DrawPolygon PROC					; COMDAT

; 4060 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 456				; 000001c8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-456]
	mov	ecx, 114				; 00000072H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4061 : 	uint8 valx=0, valy=0;

	mov	BYTE PTR _valx$[ebp], 0
	mov	BYTE PTR _valy$[ebp], 0

; 4062 : 
; 4063 : 	uint16 i=0, j=0, k=0;

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax

; 4064 : 
; 4065 : 	int32 x3, y3;
; 4066 : 
; 4067 : 	uint32 a1;
; 4068 : 
; 4069 : 	int16 ang;
; 4070 : 
; 4071 : 	Pos vertex[4];
; 4072 : 
; 4073 : 	float ax=1/(GAME_WIDTH/2), ay=1/(GAME_HEIGHT/2), az=1/(4096/2), ang2, tx1, ty1, tx2, ty2;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ax$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ay$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _az$[ebp], xmm0

; 4074 : 
; 4075 : 	memcpy(vertex,vertex_s,4*sizeof(Pos));

	push	48					; 00000030H
	mov	eax, DWORD PTR _vertex_s$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vertex$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4076 : 
; 4077 : 	i=st.num_entities;

	mov	ax, WORD PTR _st+244
	mov	WORD PTR _i$[ebp], ax

; 4078 : 
; 4079 : 	if(i==MAX_GRAPHICS-1 && ent[i].stat==USED)

	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, 2047				; 000007ffH
	jne	SHORT $LN15@DrawPolygo
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	cmp	DWORD PTR _ent[ecx+40], 1
	jne	SHORT $LN15@DrawPolygo

; 4080 : 		return 2;

	mov	al, 2
	jmp	$LN16@DrawPolygo
$LN15@DrawPolygo:

; 4081 : 
; 4082 : 		ent[i].stat=USED;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	DWORD PTR _ent[ecx+40], 1

; 4083 : 		st.num_entities++;

	mov	eax, DWORD PTR _st+244
	add	eax, 1
	mov	DWORD PTR _st+244, eax

; 4084 : 		ent[i].data.data=DataNT;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, DWORD PTR _DataNT
	mov	DWORD PTR _ent[ecx+44], edx

; 4085 : 		ent[i].data.vb_id=-1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	or	edx, -1
	mov	WORD PTR _ent[ecx+54], dx

; 4086 : 		ent[i].data.channel=0;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	DWORD PTR _ent[ecx+76], 0

; 4087 : 		ent[i].data.normal=0;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	BYTE PTR _ent[ecx+52], 0

; 4088 : 		ent[i].lightmapid=-2;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, -2					; fffffffeH
	mov	WORD PTR _ent[ecx+260], dx

; 4089 : 
; 4090 : 		if(z>56) z=56;

	cmp	DWORD PTR _z$[ebp], 56			; 00000038H
	jle	SHORT $LN14@DrawPolygo
	mov	DWORD PTR _z$[ebp], 56			; 00000038H
	jmp	SHORT $LN12@DrawPolygo
$LN14@DrawPolygo:

; 4091 : 		else if(z<16) z+=16;

	cmp	DWORD PTR _z$[ebp], 16			; 00000010H
	jge	SHORT $LN12@DrawPolygo
	mov	eax, DWORD PTR _z$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _z$[ebp], eax
$LN12@DrawPolygo:

; 4092 : 
; 4093 : 		z_buffer[z][z_slot[z]]=i;

	mov	eax, DWORD PTR _z$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _z$[ebp]
	movsx	edx, WORD PTR _z_slot[ecx*2]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _z_buffer[eax+edx*2], cx

; 4094 : 		z_slot[z]++;

	mov	eax, DWORD PTR _z$[ebp]
	mov	cx, WORD PTR _z_slot[eax*2]
	add	cx, 1
	mov	edx, DWORD PTR _z$[ebp]
	mov	WORD PTR _z_slot[edx*2], cx

; 4095 : 
; 4096 : 		if(z>z_used) z_used=z;

	movsx	eax, BYTE PTR _z_used
	cmp	DWORD PTR _z$[ebp], eax
	jle	SHORT $LN11@DrawPolygo
	mov	al, BYTE PTR _z$[ebp]
	mov	BYTE PTR _z_used, al
$LN11@DrawPolygo:

; 4097 : 
; 4098 : 		if(z>15)

	cmp	DWORD PTR _z$[ebp], 15			; 0000000fH
	jle	$LN7@DrawPolygo

; 4099 : 		{
; 4100 : 			for(j=0;j<4;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN9@DrawPolygo
$LN8@DrawPolygo:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN9@DrawPolygo:
	movzx	eax, WORD PTR _j$[ebp]
	cmp	eax, 4
	jge	$LN7@DrawPolygo

; 4101 : 			{
; 4102 : 
; 4103 : 				vertex[j].x-=st.Camera.position.x;

	movzx	eax, WORD PTR _j$[ebp]
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _vertex$[ebp+ecx]
	sub	edx, DWORD PTR _st+2335380
	movzx	eax, WORD PTR _j$[ebp]
	imul	ecx, eax, 12
	mov	DWORD PTR _vertex$[ebp+ecx], edx

; 4104 : 				vertex[j].y-=st.Camera.position.y;

	movzx	eax, WORD PTR _j$[ebp]
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _vertex$[ebp+ecx+4]
	sub	edx, DWORD PTR _st+2335384
	movzx	eax, WORD PTR _j$[ebp]
	imul	ecx, eax, 12
	mov	DWORD PTR _vertex$[ebp+ecx+4], edx

; 4105 : 
; 4106 : 				vertex[j].x*=st.Camera.dimension.x;

	movzx	eax, WORD PTR _j$[ebp]
	imul	ecx, eax, 12
	cvtsi2ss xmm0, DWORD PTR _vertex$[ebp+ecx]
	mulss	xmm0, DWORD PTR _st+2335396
	movzx	edx, WORD PTR _j$[ebp]
	imul	eax, edx, 12
	cvttss2si ecx, xmm0
	mov	DWORD PTR _vertex$[ebp+eax], ecx

; 4107 : 				vertex[j].y*=st.Camera.dimension.y;

	movzx	eax, WORD PTR _j$[ebp]
	imul	ecx, eax, 12
	cvtsi2ss xmm0, DWORD PTR _vertex$[ebp+ecx+4]
	mulss	xmm0, DWORD PTR _st+2335400
	movzx	edx, WORD PTR _j$[ebp]
	imul	eax, edx, 12
	cvttss2si ecx, xmm0
	mov	DWORD PTR _vertex$[ebp+eax+4], ecx

; 4108 : 
; 4109 : 			}

	jmp	$LN8@DrawPolygo
$LN7@DrawPolygo:

; 4110 : 		}
; 4111 : 
; 4112 : 		ent[i].vertex[0]=vertex[0].x;

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	edx, 4
	imul	edx, edx, 0
	cvtsi2ss xmm0, DWORD PTR _vertex$[ebp+ecx]
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 4113 : 		ent[i].vertex[1]=vertex[0].y;

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	edx, 4
	shl	edx, 0
	cvtsi2ss xmm0, DWORD PTR _vertex$[ebp+ecx+4]
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 4114 : 		ent[i].vertex[2]=z;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	shl	edx, 1
	cvtsi2ss xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR _ent[ecx+edx+100], xmm0

; 4115 : 
; 4116 : 		ent[i].vertex[3]=vertex[1].x;

	mov	eax, 12					; 0000000cH
	shl	eax, 0
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	mov	ecx, 4
	imul	ecx, ecx, 3
	cvtsi2ss xmm0, DWORD PTR _vertex$[ebp+eax]
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 4117 : 		ent[i].vertex[4]=vertex[1].y;

	mov	eax, 12					; 0000000cH
	shl	eax, 0
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	mov	ecx, 4
	shl	ecx, 2
	cvtsi2ss xmm0, DWORD PTR _vertex$[ebp+eax+4]
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 4118 : 		ent[i].vertex[5]=z;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 5
	cvtsi2ss xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 4119 : 
; 4120 : 		ent[i].vertex[6]=vertex[2].x;

	mov	eax, 12					; 0000000cH
	shl	eax, 1
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	mov	ecx, 4
	imul	ecx, ecx, 6
	cvtsi2ss xmm0, DWORD PTR _vertex$[ebp+eax]
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 4121 : 		ent[i].vertex[7]=vertex[2].y;

	mov	eax, 12					; 0000000cH
	shl	eax, 1
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	mov	ecx, 4
	imul	ecx, ecx, 7
	cvtsi2ss xmm0, DWORD PTR _vertex$[ebp+eax+4]
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 4122 : 		ent[i].vertex[8]=z;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	shl	edx, 3
	cvtsi2ss xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR _ent[ecx+edx+100], xmm0

; 4123 : 
; 4124 : 		ent[i].vertex[9]=vertex[3].x;

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	edx, 4
	imul	edx, edx, 9
	cvtsi2ss xmm0, DWORD PTR _vertex$[ebp+ecx]
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 4125 : 		ent[i].vertex[10]=vertex[3].y;

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	edx, 4
	imul	edx, edx, 10
	cvtsi2ss xmm0, DWORD PTR _vertex$[ebp+ecx+4]
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 4126 : 		ent[i].vertex[11]=z;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 11
	cvtsi2ss xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 4127 : 
; 4128 : 		ent[i].texcor[0]=0;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[ecx+eax+148], xmm0

; 4129 : 		ent[i].texcor[1]=0;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[ecx+edx+148], xmm0

; 4130 : 		ent[i].texcor[2]=0;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[ecx+edx+148], xmm0

; 4131 : 		ent[i].texcor[3]=0;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 3
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[ecx+eax+148], xmm0

; 4132 : 		ent[i].texcor[4]=0;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	shl	edx, 2
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[ecx+edx+148], xmm0

; 4133 : 		ent[i].texcor[5]=0;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 5
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[ecx+eax+148], xmm0

; 4134 : 		ent[i].texcor[6]=0;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 6
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[ecx+eax+148], xmm0

; 4135 : 		ent[i].texcor[7]=0;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 7
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[ecx+eax+148], xmm0

; 4136 : 
; 4137 : 
; 4138 : 		ax=(float) 1/(GAME_WIDTH/2);

	movss	xmm0, DWORD PTR __real@39000000
	movss	DWORD PTR _ax$[ebp], xmm0

; 4139 : 		ay=(float) 1/(GAME_HEIGHT/2);

	movss	xmm0, DWORD PTR __real@39638e39
	movss	DWORD PTR _ay$[ebp], xmm0

; 4140 : 
; 4141 : 		ay*=-1.0f;

	movss	xmm0, DWORD PTR _ay$[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _ay$[ebp], xmm0

; 4142 : 
; 4143 : 		az=(float) 1/(4096/2);

	movss	xmm0, DWORD PTR __real@3a000000
	movss	DWORD PTR _az$[ebp], xmm0

; 4144 : 
; 4145 : 		for(j=0;j<12;j+=3)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN6@DrawPolygo
$LN5@DrawPolygo:
	movzx	eax, WORD PTR _j$[ebp]
	add	eax, 3
	mov	WORD PTR _j$[ebp], ax
$LN6@DrawPolygo:
	movzx	eax, WORD PTR _j$[ebp]
	cmp	eax, 12					; 0000000cH
	jge	$LN4@DrawPolygo

; 4146 : 		{
; 4147 : 			ent[i].vertex[j]*=ax;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[ecx+edx*4+100]
	mulss	xmm0, DWORD PTR _ax$[ebp]
	movzx	eax, WORD PTR _j$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 4148 : 			ent[i].vertex[j]-=1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[ecx+edx*4+100]
	subss	xmm0, DWORD PTR __real@3f800000
	movzx	eax, WORD PTR _j$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 4149 : 
; 4150 : 			ent[i].vertex[j+1]*=ay;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[ecx+edx*4+104]
	mulss	xmm0, DWORD PTR _ay$[ebp]
	movzx	eax, WORD PTR _j$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 4151 : 			ent[i].vertex[j+1]+=1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[ecx+edx*4+104]
	addss	xmm0, DWORD PTR __real@3f800000
	movzx	eax, WORD PTR _j$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 4152 : 				
; 4153 : 			ent[i].vertex[j+2]*=az;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[ecx+edx*4+108]
	mulss	xmm0, DWORD PTR _az$[ebp]
	movzx	eax, WORD PTR _j$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 4154 : 			ent[i].vertex[j+2]-=1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[ecx+edx*4+108]
	subss	xmm0, DWORD PTR __real@3f800000
	movzx	eax, WORD PTR _j$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 4155 : 				
; 4156 : 		}

	jmp	$LN5@DrawPolygo
$LN4@DrawPolygo:

; 4157 : 
; 4158 : 		for(j=0;j<16;j+=4)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN3@DrawPolygo
$LN2@DrawPolygo:
	movzx	eax, WORD PTR _j$[ebp]
	add	eax, 4
	mov	WORD PTR _j$[ebp], ax
$LN3@DrawPolygo:
	movzx	eax, WORD PTR _j$[ebp]
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN1@DrawPolygo

; 4159 : 		{
; 4160 : 			ent[i].color[j]=r;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	mov	al, BYTE PTR _r$[ebp]
	mov	BYTE PTR _ent[ecx+edx+228], al

; 4161 : 			ent[i].color[j+1]=g;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	mov	al, BYTE PTR _g$[ebp]
	mov	BYTE PTR _ent[ecx+edx+229], al

; 4162 : 			ent[i].color[j+2]=b;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _ent[ecx+edx+230], al

; 4163 : 			ent[i].color[j+3]=a;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	mov	al, BYTE PTR _a$[ebp]
	mov	BYTE PTR _ent[ecx+edx+231], al

; 4164 : 		}

	jmp	SHORT $LN2@DrawPolygo
$LN1@DrawPolygo:

; 4165 : 
; 4166 : 		texone_ids[texone_num]=i;

	movzx	eax, WORD PTR _texone_num
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _texone_ids[eax*2], cx

; 4167 : 		texone_num++;

	mov	ax, WORD PTR _texone_num
	add	ax, 1
	mov	WORD PTR _texone_num, ax

; 4168 : 
; 4169 : 	return 0;

	xor	al, al
$LN16@DrawPolygo:

; 4170 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@DrawPolygo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 456				; 000001c8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@DrawPolygo:
	DD	1
	DD	$LN19@DrawPolygo
$LN19@DrawPolygo:
	DD	-164					; ffffff5cH
	DD	48					; 00000030H
	DD	$LN18@DrawPolygo
$LN18@DrawPolygo:
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
_DrawPolygon ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawUI
_TEXT	SEGMENT
tv987 = -372						; size = 4
tv963 = -372						; size = 4
tv938 = -372						; size = 4
tv915 = -372						; size = 4
tv891 = -372						; size = 4
tv867 = -372						; size = 4
tv842 = -372						; size = 4
tv817 = -372						; size = 4
tv1126 = -368						; size = 4
tv1118 = -368						; size = 4
tv1110 = -368						; size = 4
tv1102 = -368						; size = 4
tv1094 = -368						; size = 4
tv1086 = -368						; size = 4
tv1078 = -368						; size = 4
tv1070 = -368						; size = 4
tv1124 = -364						; size = 4
tv1116 = -364						; size = 4
tv1108 = -364						; size = 4
tv1100 = -364						; size = 4
tv1092 = -364						; size = 4
tv1084 = -364						; size = 4
tv1076 = -364						; size = 4
tv1068 = -364						; size = 4
tv976 = -360						; size = 4
tv952 = -360						; size = 4
tv927 = -360						; size = 4
tv904 = -360						; size = 4
tv879 = -360						; size = 4
tv855 = -360						; size = 4
tv830 = -360						; size = 4
tv805 = -360						; size = 4
tv1122 = -356						; size = 4
tv1114 = -356						; size = 4
tv1106 = -356						; size = 4
tv1098 = -356						; size = 4
tv1090 = -356						; size = 4
tv1082 = -356						; size = 4
tv1074 = -356						; size = 4
tv1066 = -356						; size = 4
tv1120 = -352						; size = 4
tv1112 = -352						; size = 4
tv1104 = -352						; size = 4
tv1096 = -352						; size = 4
tv1088 = -352						; size = 4
tv1080 = -352						; size = 4
tv1072 = -352						; size = 4
tv1064 = -352						; size = 4
_k$ = -152						; size = 4
_j$ = -140						; size = 4
_i$ = -128						; size = 4
_ty2$ = -92						; size = 4
_tx2$ = -80						; size = 4
_ty1$ = -68						; size = 4
_tx1$ = -56						; size = 4
_az$ = -44						; size = 4
_ay$ = -32						; size = 4
_ax$ = -20						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_sizex$ = 16						; size = 4
_sizey$ = 20						; size = 4
_ang$ = 24						; size = 2
_r$ = 28						; size = 1
_g$ = 32						; size = 1
_b$ = 36						; size = 1
_x1$ = 40						; size = 4
_y1$ = 44						; size = 4
_x2$ = 48						; size = 4
_y2$ = 52						; size = 4
_data$ = 56						; size = 40
_a$ = 96						; size = 1
_layer$ = 100						; size = 1
_DrawUI	PROC						; COMDAT

; 5341 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 372				; 00000174H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-372]
	mov	ecx, 93					; 0000005dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5342 : 	float tmp, ax, ay, az, tx1, ty1, tx2, ty2, sy, py;
; 5343 : 	
; 5344 : 	uint32 i=0, j=0, k=0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _k$[ebp], 0

; 5345 : 			
; 5346 : 	if(st.num_entities==MAX_GRAPHICS-1)

	cmp	DWORD PTR _st+244, 2047			; 000007ffH
	jne	SHORT $LN18@DrawUI

; 5347 : 		return 2;

	mov	al, 2
	jmp	$LN19@DrawUI

; 5348 : 	else

	jmp	SHORT $LN17@DrawUI
$LN18@DrawUI:

; 5349 : 		i=st.num_entities;

	mov	eax, DWORD PTR _st+244
	mov	DWORD PTR _i$[ebp], eax
$LN17@DrawUI:

; 5350 : 
; 5351 : 	ent[i].lightmapid=-1;

	imul	eax, DWORD PTR _i$[ebp], 264
	or	ecx, -1
	mov	WORD PTR _ent[eax+260], cx

; 5352 : 
; 5353 : 			if(data.vb_id!=-1)

	movsx	eax, WORD PTR _data$[ebp+10]
	cmp	eax, -1
	je	$LN16@DrawUI

; 5354 : 			{
; 5355 : 				ent[i].texrepeat[0]=(float) data.posx/32768;

	movzx	eax, WORD PTR _data$[ebp+14]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@47000000
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _ent[ecx+eax+212], xmm0

; 5356 : 				ent[i].texrepeat[1]=(float) data.posy/32768;

	movzx	eax, WORD PTR _data$[ebp+16]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@47000000
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _ent[ecx+edx+212], xmm0

; 5357 : 				ent[i].texrepeat[2]=(float) data.sizex/32768;

	movzx	eax, WORD PTR _data$[ebp+18]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@47000000
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _ent[ecx+edx+212], xmm0

; 5358 : 				ent[i].texrepeat[3]=(float) data.sizey/32768;

	movzx	eax, WORD PTR _data$[ebp+20]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@47000000
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 3
	movss	DWORD PTR _ent[ecx+eax+212], xmm0

; 5359 : 			}
; 5360 : 			else

	jmp	SHORT $LN15@DrawUI
$LN16@DrawUI:

; 5361 : 			{
; 5362 : 				ent[i].texrepeat[0]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+212], xmm0

; 5363 : 				ent[i].texrepeat[1]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+ecx+212], xmm0

; 5364 : 				ent[i].texrepeat[2]=1.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+ecx+212], xmm0

; 5365 : 				ent[i].texrepeat[3]=1.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+edx+212], xmm0
$LN15@DrawUI:

; 5366 : 			}
; 5367 : 	
; 5368 : 			ent[i].data=data;

	imul	edi, DWORD PTR _i$[ebp], 264
	add	edi, OFFSET _ent+44
	mov	ecx, 10					; 0000000aH
	lea	esi, DWORD PTR _data$[ebp]
	rep movsd

; 5369 : 
; 5370 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 5371 : 
; 5372 : 
; 5373 : 			if(r==0 && g==0 && b==0)

	movzx	eax, BYTE PTR _r$[ebp]
	test	eax, eax
	jne	SHORT $LN14@DrawUI
	movzx	eax, BYTE PTR _g$[ebp]
	test	eax, eax
	jne	SHORT $LN14@DrawUI
	movzx	eax, BYTE PTR _b$[ebp]
	test	eax, eax
	jne	SHORT $LN14@DrawUI

; 5374 : 				r=g=b=1;

	mov	BYTE PTR _b$[ebp], 1
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _g$[ebp], al
	mov	cl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _r$[ebp], cl
$LN14@DrawUI:

; 5375 : 
; 5376 : 			if(layer>7) layer=7;

	movsx	eax, BYTE PTR _layer$[ebp]
	cmp	eax, 7
	jle	SHORT $LN13@DrawUI
	mov	BYTE PTR _layer$[ebp], 7
$LN13@DrawUI:

; 5377 : 			//else if(layer<0) layer+=8;
; 5378 : 
; 5379 : 			z_buffer[layer][z_slot[layer]]=i;

	movsx	eax, BYTE PTR _layer$[ebp]
	shl	eax, 12					; 0000000cH
	movsx	ecx, BYTE PTR _layer$[ebp]
	movsx	edx, WORD PTR _z_slot[ecx*2]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _z_buffer[eax+edx*2], cx

; 5380 : 			z_slot[layer]++;

	movsx	eax, BYTE PTR _layer$[ebp]
	mov	cx, WORD PTR _z_slot[eax*2]
	add	cx, 1
	movsx	edx, BYTE PTR _layer$[ebp]
	mov	WORD PTR _z_slot[edx*2], cx

; 5381 : 
; 5382 : 			if(layer>z_used) z_used=layer;

	movsx	eax, BYTE PTR _layer$[ebp]
	movsx	ecx, BYTE PTR _z_used
	cmp	eax, ecx
	jle	SHORT $LN12@DrawUI
	mov	al, BYTE PTR _layer$[ebp]
	mov	BYTE PTR _z_used, al
$LN12@DrawUI:

; 5383 : 
; 5384 : 			//timej=GetTicks();
; 5385 : 
; 5386 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1064[ebp], xmm0
	movss	DWORD PTR tv1066[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv805[ebp]
	movss	xmm0, DWORD PTR tv1066[ebp]
	mulss	xmm0, DWORD PTR tv805[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1068[ebp], xmm0
	movss	DWORD PTR tv1070[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv817[ebp]
	movss	xmm0, DWORD PTR tv1070[ebp]
	mulss	xmm0, DWORD PTR tv817[ebp]
	movss	xmm1, DWORD PTR tv1068[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1064[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 5387 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1072[ebp], xmm0
	movss	DWORD PTR tv1074[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv830[ebp]
	movss	xmm0, DWORD PTR tv1074[ebp]
	mulss	xmm0, DWORD PTR tv830[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1076[ebp], xmm0
	movss	DWORD PTR tv1078[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv842[ebp]
	movss	xmm0, DWORD PTR tv1078[ebp]
	mulss	xmm0, DWORD PTR tv842[ebp]
	movss	xmm1, DWORD PTR tv1076[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1072[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 5388 : 			ent[i].vertex[2]=layer;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movsx	edx, BYTE PTR _layer$[ebp]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 5389 : 
; 5390 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1080[ebp], xmm0
	movss	DWORD PTR tv1082[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv855[ebp]
	movss	xmm0, DWORD PTR tv1082[ebp]
	mulss	xmm0, DWORD PTR tv855[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1084[ebp], xmm0
	movss	DWORD PTR tv1086[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv867[ebp]
	movss	xmm0, DWORD PTR tv1086[ebp]
	mulss	xmm0, DWORD PTR tv867[ebp]
	movss	xmm1, DWORD PTR tv1084[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1080[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 5391 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1088[ebp], xmm0
	movss	DWORD PTR tv1090[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv879[ebp]
	movss	xmm0, DWORD PTR tv1090[ebp]
	mulss	xmm0, DWORD PTR tv879[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1092[ebp], xmm0
	movss	DWORD PTR tv1094[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv891[ebp]
	movss	xmm0, DWORD PTR tv1094[ebp]
	mulss	xmm0, DWORD PTR tv891[ebp]
	movss	xmm1, DWORD PTR tv1092[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1088[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 5392 : 			ent[i].vertex[5]=layer;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	movsx	ecx, BYTE PTR _layer$[ebp]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 5393 : 
; 5394 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1096[ebp], xmm0
	movss	DWORD PTR tv1098[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv904[ebp]
	movss	xmm0, DWORD PTR tv1098[ebp]
	mulss	xmm0, DWORD PTR tv904[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1100[ebp], xmm0
	movss	DWORD PTR tv1102[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv915[ebp]
	movss	xmm0, DWORD PTR tv1102[ebp]
	mulss	xmm0, DWORD PTR tv915[ebp]
	movss	xmm1, DWORD PTR tv1100[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1096[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 6
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 5395 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1104[ebp], xmm0
	movss	DWORD PTR tv1106[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv927[ebp]
	movss	xmm0, DWORD PTR tv1106[ebp]
	mulss	xmm0, DWORD PTR tv927[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1108[ebp], xmm0
	movss	DWORD PTR tv1110[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv938[ebp]
	movss	xmm0, DWORD PTR tv1110[ebp]
	mulss	xmm0, DWORD PTR tv938[ebp]
	movss	xmm1, DWORD PTR tv1108[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1104[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 7
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 5396 : 			ent[i].vertex[8]=layer;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 3
	movsx	edx, BYTE PTR _layer$[ebp]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 5397 : 
; 5398 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1112[ebp], xmm0
	movss	DWORD PTR tv1114[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv952[ebp]
	movss	xmm0, DWORD PTR tv1114[ebp]
	mulss	xmm0, DWORD PTR tv952[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1116[ebp], xmm0
	movss	DWORD PTR tv1118[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv963[ebp]
	movss	xmm0, DWORD PTR tv1118[ebp]
	mulss	xmm0, DWORD PTR tv963[ebp]
	movss	xmm1, DWORD PTR tv1116[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1112[ebp]
	addss	xmm0, xmm1
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 9
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 5399 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1120[ebp], xmm0
	movss	DWORD PTR tv1122[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv976[ebp]
	movss	xmm0, DWORD PTR tv1122[ebp]
	mulss	xmm0, DWORD PTR tv976[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1124[ebp], xmm0
	movss	DWORD PTR tv1126[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv987[ebp]
	movss	xmm0, DWORD PTR tv1126[ebp]
	mulss	xmm0, DWORD PTR tv987[ebp]
	movss	xmm1, DWORD PTR tv1124[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1120[ebp]
	addss	xmm0, xmm1
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 10
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 5400 : 			ent[i].vertex[11]=layer;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 11
	movsx	ecx, BYTE PTR _layer$[ebp]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 5401 : 
; 5402 : 			//timel=GetTicks() - timej;
; 5403 : 
; 5404 : 			//ang=1000;
; 5405 : 			/*
; 5406 : 			ang/=10;
; 5407 : 
; 5408 : 			tmp=cos((ang*pi)/180);
; 5409 : 			tmp=mCos(ang*10);
; 5410 : 	*/
; 5411 : 			ax = (float) 1/(16384.0f  / 2.0f);

	movss	xmm0, DWORD PTR __real@39000000
	movss	DWORD PTR _ax$[ebp], xmm0

; 5412 : 			ay=(float) 1/(9216.0f / 2.0f);

	movss	xmm0, DWORD PTR __real@39638e39
	movss	DWORD PTR _ay$[ebp], xmm0

; 5413 : 
; 5414 : 			ay*=-1.0f;

	movss	xmm0, DWORD PTR _ay$[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _ay$[ebp], xmm0

; 5415 : 
; 5416 : 			az=(float) 1/(4096/2);

	movss	xmm0, DWORD PTR __real@3a000000
	movss	DWORD PTR _az$[ebp], xmm0

; 5417 : 
; 5418 : 			if(data.vb_id==-1)

	movsx	eax, WORD PTR _data$[ebp+10]
	cmp	eax, -1
	jne	$LN11@DrawUI

; 5419 : 			{
; 5420 : 				ent[i].texcor[0]=x1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtsi2ss xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 5421 : 				ent[i].texcor[1]=y1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	cvtsi2ss xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 5422 : 				ent[i].texcor[2]=x2;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 5423 : 				ent[i].texcor[3]=y1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	cvtsi2ss xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 5424 : 				ent[i].texcor[4]=x2;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	cvtsi2ss xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 5425 : 				ent[i].texcor[5]=y2;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	cvtsi2ss xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 5426 : 				ent[i].texcor[6]=x1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 6
	cvtsi2ss xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 5427 : 				ent[i].texcor[7]=y2;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 7
	cvtsi2ss xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 5428 : 			}
; 5429 : 			else

	jmp	$LN10@DrawUI
$LN11@DrawUI:

; 5430 : 			{
; 5431 : 				tx1=(float) x1/32768;

	cvtsi2ss xmm0, DWORD PTR _x1$[ebp]
	divss	xmm0, DWORD PTR __real@47000000
	movss	DWORD PTR _tx1$[ebp], xmm0

; 5432 : 				ty1=(float) y1/32768;

	cvtsi2ss xmm0, DWORD PTR _y1$[ebp]
	divss	xmm0, DWORD PTR __real@47000000
	movss	DWORD PTR _ty1$[ebp], xmm0

; 5433 : 				tx2=(float) x2/32768;

	cvtsi2ss xmm0, DWORD PTR _x2$[ebp]
	divss	xmm0, DWORD PTR __real@47000000
	movss	DWORD PTR _tx2$[ebp], xmm0

; 5434 : 				ty2=(float) y2/32768;

	cvtsi2ss xmm0, DWORD PTR _y2$[ebp]
	divss	xmm0, DWORD PTR __real@47000000
	movss	DWORD PTR _ty2$[ebp], xmm0

; 5435 : 
; 5436 : 				ent[i].texcor[0]=data.posx+(tx1*data.sizex);

	movzx	eax, WORD PTR _data$[ebp+14]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+18]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _tx1$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _ent[edx+ecx+148], xmm0

; 5437 : 				ent[i].texcor[1]=data.posy+(ty1*data.sizey);

	movzx	eax, WORD PTR _data$[ebp+16]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+20]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _ty1$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _ent[edx+eax+148], xmm0

; 5438 : 
; 5439 : 				ent[i].texcor[2]=data.posx+(tx2*data.sizex);

	movzx	eax, WORD PTR _data$[ebp+14]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+18]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _tx2$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _ent[edx+eax+148], xmm0

; 5440 : 				ent[i].texcor[3]=data.posy+(ty1*data.sizey);

	movzx	eax, WORD PTR _data$[ebp+16]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+20]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _ty1$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 3
	movss	DWORD PTR _ent[edx+ecx+148], xmm0

; 5441 : 
; 5442 : 				ent[i].texcor[4]=data.posx+(tx2*data.sizex);

	movzx	eax, WORD PTR _data$[ebp+14]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+18]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _tx2$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	shl	eax, 2
	movss	DWORD PTR _ent[edx+eax+148], xmm0

; 5443 : 				ent[i].texcor[5]=data.posy+(ty2*data.sizey);

	movzx	eax, WORD PTR _data$[ebp+16]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+20]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _ty2$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 5
	movss	DWORD PTR _ent[edx+ecx+148], xmm0

; 5444 : 
; 5445 : 				ent[i].texcor[6]=data.posx+(tx1*data.sizex);

	movzx	eax, WORD PTR _data$[ebp+14]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+18]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _tx1$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 6
	movss	DWORD PTR _ent[edx+ecx+148], xmm0

; 5446 : 				ent[i].texcor[7]=data.posy+(ty2*data.sizey);

	movzx	eax, WORD PTR _data$[ebp+16]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+20]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _ty2$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 7
	movss	DWORD PTR _ent[edx+ecx+148], xmm0
$LN10@DrawUI:

; 5447 : 			}
; 5448 : 
; 5449 : 			for(j=0;j<12;j+=3)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN9@DrawUI
$LN8@DrawUI:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 3
	mov	DWORD PTR _j$[ebp], eax
$LN9@DrawUI:
	cmp	DWORD PTR _j$[ebp], 12			; 0000000cH
	jae	$LN7@DrawUI

; 5450 : 			{
; 5451 : 				ent[i].vertex[j]*=ax;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+100]
	mulss	xmm0, DWORD PTR _ax$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 5452 : 				ent[i].vertex[j]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+100]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 5453 : 
; 5454 : 		 		ent[i].vertex[j+1]*=ay;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+104]
	mulss	xmm0, DWORD PTR _ay$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 5455 : 				ent[i].vertex[j+1]+=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+104]
	addss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 5456 : 				
; 5457 : 				ent[i].vertex[j+2]*=az;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+108]
	mulss	xmm0, DWORD PTR _az$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 5458 : 				ent[i].vertex[j+2]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+108]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 5459 : 				
; 5460 : 				if(j<8)

	cmp	DWORD PTR _j$[ebp], 8
	jae	$LN6@DrawUI

; 5461 : 				{
; 5462 : 					ent[i].texcor[j]/=(float)32768;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+148]
	divss	xmm0, DWORD PTR __real@47000000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+148], xmm0

; 5463 : 					ent[i].texcor[j+1]/=(float)32768;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+152]
	divss	xmm0, DWORD PTR __real@47000000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+152], xmm0

; 5464 : 					ent[i].texcor[j+2]/=(float)32768;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+156]
	divss	xmm0, DWORD PTR __real@47000000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+156], xmm0
$LN6@DrawUI:

; 5465 : 				}
; 5466 : 				
; 5467 : 			}

	jmp	$LN8@DrawUI
$LN7@DrawUI:

; 5468 : 
; 5469 : 			for(j=0;j<16;j+=4)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN5@DrawUI
$LN4@DrawUI:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 4
	mov	DWORD PTR _j$[ebp], eax
$LN5@DrawUI:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jae	SHORT $LN3@DrawUI

; 5470 : 			{
; 5471 : 				ent[i].color[j]=r;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _ent[eax+ecx+228], dl

; 5472 : 				ent[i].color[j+1]=g;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _ent[eax+ecx+229], dl

; 5473 : 				ent[i].color[j+2]=b;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _ent[eax+ecx+230], dl

; 5474 : 				ent[i].color[j+3]=a;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR _ent[eax+ecx+231], dl

; 5475 : 			}

	jmp	SHORT $LN4@DrawUI
$LN3@DrawUI:

; 5476 : 
; 5477 : 			if(data.vb_id!=-1)

	movsx	eax, WORD PTR _data$[ebp+10]
	cmp	eax, -1
	je	SHORT $LN2@DrawUI

; 5478 : 			{
; 5479 : 				vbdt[data.vb_id].num_elements++;

	movsx	eax, WORD PTR _data$[ebp+10]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	dx, WORD PTR [ecx+eax+46]
	add	dx, 1
	movsx	eax, WORD PTR _data$[ebp+10]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	WORD PTR [ecx+eax+46], dx

; 5480 : 				ent[i].data.loc=vbdt[data.vb_id].num_elements-1;

	movsx	eax, WORD PTR _data$[ebp+10]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	sub	edx, 1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	WORD PTR _ent[eax+56], dx

; 5481 : 			}
; 5482 : 			else

	jmp	SHORT $LN1@DrawUI
$LN2@DrawUI:

; 5483 : 			{
; 5484 : 				texone_ids[texone_num]=i;

	movzx	eax, WORD PTR _texone_num
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _texone_ids[eax*2], cx

; 5485 : 				texone_num++;

	mov	ax, WORD PTR _texone_num
	add	ax, 1
	mov	WORD PTR _texone_num, ax
$LN1@DrawUI:

; 5486 : 			}
; 5487 : 
; 5488 : #endif
; 5489 : 
; 5490 : 			st.num_entities++;

	mov	eax, DWORD PTR _st+244
	add	eax, 1
	mov	DWORD PTR _st+244, eax

; 5491 : 
; 5492 : 	return 0;

	xor	al, al
$LN19@DrawUI:

; 5493 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 372				; 00000174H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_DrawUI	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawStringUI
_TEXT	SEGMENT
tv986 = -444						; size = 4
tv962 = -444						; size = 4
tv937 = -444						; size = 4
tv914 = -444						; size = 4
tv890 = -444						; size = 4
tv866 = -444						; size = 4
tv841 = -444						; size = 4
tv816 = -444						; size = 4
tv1104 = -440						; size = 4
tv1096 = -440						; size = 4
tv1088 = -440						; size = 4
tv1080 = -440						; size = 4
tv1072 = -440						; size = 4
tv1064 = -440						; size = 4
tv1056 = -440						; size = 4
tv1048 = -440						; size = 4
tv1102 = -436						; size = 4
tv1094 = -436						; size = 4
tv1086 = -436						; size = 4
tv1078 = -436						; size = 4
tv1070 = -436						; size = 4
tv1062 = -436						; size = 4
tv1054 = -436						; size = 4
tv1046 = -436						; size = 4
tv975 = -432						; size = 4
tv951 = -432						; size = 4
tv926 = -432						; size = 4
tv903 = -432						; size = 4
tv878 = -432						; size = 4
tv854 = -432						; size = 4
tv829 = -432						; size = 4
tv804 = -432						; size = 4
tv1100 = -428						; size = 4
tv1092 = -428						; size = 4
tv1084 = -428						; size = 4
tv1076 = -428						; size = 4
tv1068 = -428						; size = 4
tv1060 = -428						; size = 4
tv1052 = -428						; size = 4
tv1044 = -428						; size = 4
tv1098 = -424						; size = 4
tv1090 = -424						; size = 4
tv1082 = -424						; size = 4
tv1074 = -424						; size = 4
tv1066 = -424						; size = 4
tv1058 = -424						; size = 4
tv1050 = -424						; size = 4
tv1042 = -424						; size = 4
_msg$ = -224						; size = 4
_val$ = -209						; size = 1
_az$ = -200						; size = 4
_ay$ = -188						; size = 4
_ax$ = -176						; size = 4
_formatt$ = -152					; size = 2
_co$ = -140						; size = 4
_id$ = -128						; size = 4
_checked$ = -44						; size = 4
_k$ = -32						; size = 4
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_text$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_sizex$ = 20						; size = 4
_sizey$ = 24						; size = 4
_ang$ = 28						; size = 2
_r$ = 32						; size = 1
_g$ = 36						; size = 1
_b$ = 40						; size = 1
_a$ = 44						; size = 1
_font$ = 48						; size = 1
_override_sizex$ = 52					; size = 4
_override_sizey$ = 56					; size = 4
_z$ = 60						; size = 1
_DrawStringUI PROC					; COMDAT

; 6915 : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 444				; 000001bcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-444]
	mov	ecx, 111				; 0000006fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 6916 : 	uint32 i=0, j=0, k=0, checked=0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _k$[ebp], 0
	mov	DWORD PTR _checked$[ebp], 0

; 6917 : 	int32 t1, t2, t3, t4, timej, timel, id=-1;

	mov	DWORD PTR _id$[ebp], -1

; 6918 : 
; 6919 : 	SDL_Color co;
; 6920 : 	uint16 formatt;
; 6921 : 
; 6922 : 	float tmp, ax, ay, az;
; 6923 : 
; 6924 : 	uint8 val=0;

	mov	BYTE PTR _val$[ebp], 0

; 6925 : 	
; 6926 : 	SDL_Surface *msg;
; 6927 : if(st.num_entities==MAX_GRAPHICS-1)

	cmp	DWORD PTR _st+244, 2047			; 000007ffH
	jne	SHORT $LN32@DrawString

; 6928 : 		return 2;

	mov	al, 2
	jmp	$LN33@DrawString
$LN32@DrawString:

; 6929 : 
; 6930 : 	//Checkbounds(x,y,sizex,sizey,ang,GAME_WIDTH,GAME_HEIGHT)) return 1;
; 6931 : 
; 6932 : 	for(i=0;i<MAX_STRINGS;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN31@DrawString
$LN30@DrawString:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN31@DrawString:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jae	$LN29@DrawString

; 6933 : 	{
; 6934 : 		if(st.strings[i].stat==2)

	imul	eax, DWORD PTR _i$[ebp], 1068
	movsx	ecx, BYTE PTR _st[eax+2762084]
	cmp	ecx, 2
	jne	SHORT $LN28@DrawString

; 6935 : 		{
; 6936 : 			if(strcmp(text,st.strings[i].string)==NULL)

	imul	eax, DWORD PTR _i$[ebp], 1068
	add	eax, OFFSET _st+2761020
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@DrawString

; 6937 : 			{
; 6938 : 				st.strings[i].stat=1;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	BYTE PTR _st[eax+2762084], 1

; 6939 : 				j=st.num_entities;

	mov	eax, DWORD PTR _st+244
	mov	DWORD PTR _j$[ebp], eax

; 6940 : 				st.strings[i].data.posx=i;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _st[eax+2762058], cx

; 6941 : 				memcpy(&ent[j].data,&st.strings[i].data,sizeof(TEX_DATA));

	push	40					; 00000028H
	imul	eax, DWORD PTR _i$[ebp], 1068
	add	eax, OFFSET _st+2762044
	push	eax
	imul	ecx, DWORD PTR _j$[ebp], 264
	add	ecx, OFFSET _ent+44
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6942 : 				id=i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _id$[ebp], eax

; 6943 : 				checked=1;

	mov	DWORD PTR _checked$[ebp], 1

; 6944 : 				break;

	jmp	$LN29@DrawString
$LN27@DrawString:

; 6945 : 			}
; 6946 : 		}
; 6947 : 		else

	jmp	SHORT $LN25@DrawString
$LN28@DrawString:

; 6948 : 		if(st.strings[i].stat==0 && checked==0)

	imul	eax, DWORD PTR _i$[ebp], 1068
	movsx	ecx, BYTE PTR _st[eax+2762084]
	test	ecx, ecx
	jne	SHORT $LN25@DrawString
	cmp	DWORD PTR _checked$[ebp], 0
	jne	SHORT $LN25@DrawString

; 6949 : 		{
; 6950 : 			checked=3;

	mov	DWORD PTR _checked$[ebp], 3

; 6951 : 			id=i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _id$[ebp], eax
$LN25@DrawString:

; 6952 : 		}
; 6953 : 
; 6954 : 		if(i==MAX_STRINGS-1)

	cmp	DWORD PTR _i$[ebp], 511			; 000001ffH
	jne	SHORT $LN21@DrawString

; 6955 : 		{
; 6956 : 			if(id!=-1 && checked==3)

	cmp	DWORD PTR _id$[ebp], -1
	je	SHORT $LN23@DrawString
	cmp	DWORD PTR _checked$[ebp], 3
	jne	SHORT $LN23@DrawString

; 6957 : 			{
; 6958 : 				st.strings[id].stat=1;

	imul	eax, DWORD PTR _id$[ebp], 1068
	mov	BYTE PTR _st[eax+2762084], 1

; 6959 : 				strcpy(st.strings[id].string,text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	imul	ecx, DWORD PTR _id$[ebp], 1068
	add	ecx, OFFSET _st+2761020
	push	ecx
	call	_strcpy
	add	esp, 8

; 6960 : 				checked=2;

	mov	DWORD PTR _checked$[ebp], 2

; 6961 : 			}
; 6962 : 			else

	jmp	SHORT $LN21@DrawString
$LN23@DrawString:

; 6963 : 			if(checked==0 && id==-1)

	cmp	DWORD PTR _checked$[ebp], 0
	jne	SHORT $LN21@DrawString
	cmp	DWORD PTR _id$[ebp], -1
	jne	SHORT $LN21@DrawString

; 6964 : 			{
; 6965 : 				LogApp("Warning: max number os strings reached");

	push	OFFSET ??_C@_0CH@GLOGGAHF@Warning?3?5max?5number?5os?5strings?5r@
	call	_SDL_Log
	add	esp, 4

; 6966 : 				return 2;

	mov	al, 2
	jmp	$LN33@DrawString
$LN21@DrawString:

; 6967 : 			}
; 6968 : 		}
; 6969 : 	}

	jmp	$LN30@DrawString
$LN29@DrawString:

; 6970 : 
; 6971 : 	i=st.num_entities;

	mov	eax, DWORD PTR _st+244
	mov	DWORD PTR _i$[ebp], eax

; 6972 : 
; 6973 : 	if(checked==2)

	cmp	DWORD PTR _checked$[ebp], 2
	jne	$LN20@DrawString

; 6974 : 	{
; 6975 : 
; 6976 : 		co.r=255;

	mov	BYTE PTR _co$[ebp], 255			; 000000ffH

; 6977 : 		co.g=255;

	mov	BYTE PTR _co$[ebp+1], 255		; 000000ffH

; 6978 : 		co.b=255;

	mov	BYTE PTR _co$[ebp+2], 255		; 000000ffH

; 6979 : 		co.a=255;

	mov	BYTE PTR _co$[ebp+3], 255		; 000000ffH

; 6980 : 
; 6981 : 		if(strlen(text)==0) 

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN19@DrawString

; 6982 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font," ",co);

	mov	eax, DWORD PTR _co$[ebp]
	push	eax
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	movzx	ecx, BYTE PTR _font$[ebp]
	imul	edx, ecx, 84
	mov	eax, DWORD PTR _st[edx+64344]
	push	eax
	call	_TTF_RenderUTF8_Blended
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _msg$[ebp], eax

; 6983 : 		else

	jmp	SHORT $LN18@DrawString
$LN19@DrawString:

; 6984 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font,text,co);

	mov	eax, DWORD PTR _co$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _font$[ebp]
	imul	eax, edx, 84
	mov	ecx, DWORD PTR _st[eax+64344]
	push	ecx
	call	_TTF_RenderUTF8_Blended
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _msg$[ebp], eax
$LN18@DrawString:

; 6985 : 	
; 6986 : 		if(msg->format->BytesPerPixel==4)

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+9]
	cmp	edx, 4
	jne	SHORT $LN17@DrawString

; 6987 : 		{
; 6988 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGBA;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+12], 255			; 000000ffH
	jne	SHORT $LN16@DrawString
	mov	eax, 6408				; 00001908H
	mov	WORD PTR _formatt$[ebp], ax
	jmp	SHORT $LN15@DrawString
$LN16@DrawString:

; 6989 : 			else formatt=GL_BGRA_EXT;

	mov	eax, 32993				; 000080e1H
	mov	WORD PTR _formatt$[ebp], ax
$LN15@DrawString:

; 6990 : 		} else

	jmp	SHORT $LN12@DrawString
$LN17@DrawString:

; 6991 : 		{
; 6992 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGB;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+12], 255			; 000000ffH
	jne	SHORT $LN13@DrawString
	mov	eax, 6407				; 00001907H
	mov	WORD PTR _formatt$[ebp], ax
	jmp	SHORT $LN12@DrawString
$LN13@DrawString:

; 6993 : 			else formatt=GL_BGR_EXT;

	mov	eax, 32992				; 000080e0H
	mov	WORD PTR _formatt$[ebp], ax
$LN12@DrawString:

; 6994 : 		}
; 6995 : 
; 6996 : 		glGenTextures(1,&ent[i].data.data);

	imul	eax, DWORD PTR _i$[ebp], 264
	add	eax, OFFSET _ent+44
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6997 : 		glBindTexture(GL_TEXTURE_2D,ent[i].data.data);

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	esi, esp
	mov	ecx, DWORD PTR _ent[eax+44]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6998 : 		glTexImage2D(GL_TEXTURE_2D,0,msg->format->BytesPerPixel,msg->w,msg->h,0,formatt,GL_UNSIGNED_BYTE,msg->pixels);

	mov	esi, esp
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	5121					; 00001401H
	movzx	edx, WORD PTR _formatt$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx+9]
	push	eax
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6999 : 
; 7000 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	mov	esi, esp
	push	9729					; 00002601H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7001 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	mov	esi, esp
	push	9729					; 00002601H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7002 : 
; 7003 : 		ent[i].data.channel=63; //magical number only used for rendering

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	DWORD PTR _ent[eax+76], 63		; 0000003fH

; 7004 : 
; 7005 : 		ent[i].data.posx=id;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	cx, WORD PTR _id$[ebp]
	mov	WORD PTR _ent[eax+58], cx

; 7006 : 
; 7007 : 		ent[i].data.normal=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	BYTE PTR _ent[eax+52], 0

; 7008 : 		ent[i].data.vb_id=-1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, -1
	mov	WORD PTR _ent[eax+54], cx

; 7009 : 
; 7010 : 		ent[i].data.w=msg->w;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _ent[eax+68], edx

; 7011 : 		ent[i].data.h=msg->h;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _ent[eax+72], edx

; 7012 : 
; 7013 : 		memcpy(&st.strings[id].data,&ent[i].data,sizeof(TEX_DATA));

	push	40					; 00000028H
	imul	eax, DWORD PTR _i$[ebp], 264
	add	eax, OFFSET _ent+44
	push	eax
	imul	ecx, DWORD PTR _id$[ebp], 1068
	add	ecx, OFFSET _st+2762044
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 7014 : 
; 7015 : 		SDL_FreeSurface(msg);

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_SDL_FreeSurface
	add	esp, 4
$LN20@DrawString:

; 7016 : 	}
; 7017 : 
; 7018 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 7019 : 
; 7020 : 	ent[i].lightmapid=-1;

	imul	eax, DWORD PTR _i$[ebp], 264
	or	ecx, -1
	mov	WORD PTR _ent[eax+260], cx

; 7021 : 
; 7022 : 			
; 7023 : 			if(override_sizex!=0)

	cmp	DWORD PTR _override_sizex$[ebp], 0
	je	SHORT $LN11@DrawString

; 7024 : 				sizex=st.strings[id].data.w*(float)(override_sizex/1024.0f);

	imul	eax, DWORD PTR _id$[ebp], 1068
	cvtsi2ss xmm0, DWORD PTR _st[eax+2762068]
	cvtsi2ss xmm1, DWORD PTR _override_sizex$[ebp]
	divss	xmm1, DWORD PTR __real@44800000
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _sizex$[ebp], ecx
$LN11@DrawString:

; 7025 : 
; 7026 : 			if(override_sizey!=0)

	cmp	DWORD PTR _override_sizey$[ebp], 0
	je	SHORT $LN10@DrawString

; 7027 : 				sizey=st.strings[id].data.h*(float)(override_sizey/1024.0f);

	imul	eax, DWORD PTR _id$[ebp], 1068
	cvtsi2ss xmm0, DWORD PTR _st[eax+2762072]
	cvtsi2ss xmm1, DWORD PTR _override_sizey$[ebp]
	divss	xmm1, DWORD PTR __real@44800000
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _sizey$[ebp], ecx
$LN10@DrawString:

; 7028 : 
; 7029 : 			ent[i].texrepeat[0]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+212], xmm0

; 7030 : 			ent[i].texrepeat[1]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+ecx+212], xmm0

; 7031 : 			ent[i].texrepeat[2]=1.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+ecx+212], xmm0

; 7032 : 			ent[i].texrepeat[3]=1.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+edx+212], xmm0

; 7033 : 
; 7034 : 			if(r==0 && g==0 && b==0)

	movzx	eax, BYTE PTR _r$[ebp]
	test	eax, eax
	jne	SHORT $LN9@DrawString
	movzx	eax, BYTE PTR _g$[ebp]
	test	eax, eax
	jne	SHORT $LN9@DrawString
	movzx	eax, BYTE PTR _b$[ebp]
	test	eax, eax
	jne	SHORT $LN9@DrawString

; 7035 : 				r=g=b=1;

	mov	BYTE PTR _b$[ebp], 1
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _g$[ebp], al
	mov	cl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _r$[ebp], cl
$LN9@DrawString:

; 7036 : 
; 7037 : 			if(z>7) z=7;

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 7
	jle	SHORT $LN8@DrawString
	mov	BYTE PTR _z$[ebp], 7
$LN8@DrawString:

; 7038 : 			//else if(z<0) z+=8;
; 7039 : 
; 7040 : 			z_buffer[z][z_slot[z]]=i;

	movsx	eax, BYTE PTR _z$[ebp]
	shl	eax, 12					; 0000000cH
	movsx	ecx, BYTE PTR _z$[ebp]
	movsx	edx, WORD PTR _z_slot[ecx*2]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _z_buffer[eax+edx*2], cx

; 7041 : 			z_slot[z]++;

	movsx	eax, BYTE PTR _z$[ebp]
	mov	cx, WORD PTR _z_slot[eax*2]
	add	cx, 1
	movsx	edx, BYTE PTR _z$[ebp]
	mov	WORD PTR _z_slot[edx*2], cx

; 7042 : 
; 7043 : 			if(z>z_used) z_used=z;

	movsx	eax, BYTE PTR _z$[ebp]
	movsx	ecx, BYTE PTR _z_used
	cmp	eax, ecx
	jle	SHORT $LN7@DrawString
	mov	al, BYTE PTR _z$[ebp]
	mov	BYTE PTR _z_used, al
$LN7@DrawString:

; 7044 : 
; 7045 : 			//timej=GetTicks();
; 7046 : 
; 7047 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1042[ebp], xmm0
	movss	DWORD PTR tv1044[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv804[ebp]
	movss	xmm0, DWORD PTR tv1044[ebp]
	mulss	xmm0, DWORD PTR tv804[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1046[ebp], xmm0
	movss	DWORD PTR tv1048[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv816[ebp]
	movss	xmm0, DWORD PTR tv1048[ebp]
	mulss	xmm0, DWORD PTR tv816[ebp]
	movss	xmm1, DWORD PTR tv1046[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1042[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 7048 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1050[ebp], xmm0
	movss	DWORD PTR tv1052[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv829[ebp]
	movss	xmm0, DWORD PTR tv1052[ebp]
	mulss	xmm0, DWORD PTR tv829[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1054[ebp], xmm0
	movss	DWORD PTR tv1056[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv841[ebp]
	movss	xmm0, DWORD PTR tv1056[ebp]
	mulss	xmm0, DWORD PTR tv841[ebp]
	movss	xmm1, DWORD PTR tv1054[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1050[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 7049 : 			ent[i].vertex[2]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movsx	edx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 7050 : 
; 7051 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1058[ebp], xmm0
	movss	DWORD PTR tv1060[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv854[ebp]
	movss	xmm0, DWORD PTR tv1060[ebp]
	mulss	xmm0, DWORD PTR tv854[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1062[ebp], xmm0
	movss	DWORD PTR tv1064[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv866[ebp]
	movss	xmm0, DWORD PTR tv1064[ebp]
	mulss	xmm0, DWORD PTR tv866[ebp]
	movss	xmm1, DWORD PTR tv1062[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1058[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 7052 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1066[ebp], xmm0
	movss	DWORD PTR tv1068[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv878[ebp]
	movss	xmm0, DWORD PTR tv1068[ebp]
	mulss	xmm0, DWORD PTR tv878[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1070[ebp], xmm0
	movss	DWORD PTR tv1072[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv890[ebp]
	movss	xmm0, DWORD PTR tv1072[ebp]
	mulss	xmm0, DWORD PTR tv890[ebp]
	movss	xmm1, DWORD PTR tv1070[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1066[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 7053 : 			ent[i].vertex[5]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	movsx	ecx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 7054 : 
; 7055 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1074[ebp], xmm0
	movss	DWORD PTR tv1076[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv903[ebp]
	movss	xmm0, DWORD PTR tv1076[ebp]
	mulss	xmm0, DWORD PTR tv903[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1078[ebp], xmm0
	movss	DWORD PTR tv1080[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv914[ebp]
	movss	xmm0, DWORD PTR tv1080[ebp]
	mulss	xmm0, DWORD PTR tv914[ebp]
	movss	xmm1, DWORD PTR tv1078[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1074[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 6
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 7056 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1082[ebp], xmm0
	movss	DWORD PTR tv1084[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv926[ebp]
	movss	xmm0, DWORD PTR tv1084[ebp]
	mulss	xmm0, DWORD PTR tv926[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1086[ebp], xmm0
	movss	DWORD PTR tv1088[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv937[ebp]
	movss	xmm0, DWORD PTR tv1088[ebp]
	mulss	xmm0, DWORD PTR tv937[ebp]
	movss	xmm1, DWORD PTR tv1086[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1082[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 7
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 7057 : 			ent[i].vertex[8]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 3
	movsx	edx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 7058 : 
; 7059 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1090[ebp], xmm0
	movss	DWORD PTR tv1092[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv951[ebp]
	movss	xmm0, DWORD PTR tv1092[ebp]
	mulss	xmm0, DWORD PTR tv951[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1094[ebp], xmm0
	movss	DWORD PTR tv1096[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv962[ebp]
	movss	xmm0, DWORD PTR tv1096[ebp]
	mulss	xmm0, DWORD PTR tv962[ebp]
	movss	xmm1, DWORD PTR tv1094[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1090[ebp]
	addss	xmm0, xmm1
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 9
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 7060 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1098[ebp], xmm0
	movss	DWORD PTR tv1100[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv975[ebp]
	movss	xmm0, DWORD PTR tv1100[ebp]
	mulss	xmm0, DWORD PTR tv975[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1102[ebp], xmm0
	movss	DWORD PTR tv1104[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv986[ebp]
	movss	xmm0, DWORD PTR tv1104[ebp]
	mulss	xmm0, DWORD PTR tv986[ebp]
	movss	xmm1, DWORD PTR tv1102[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1098[ebp]
	addss	xmm0, xmm1
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 10
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 7061 : 			ent[i].vertex[11]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 11
	movsx	ecx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 7062 : 
; 7063 : 			/*
; 7064 : 			ang/=10;
; 7065 : 
; 7066 : 			tmp=cos((ang*pi)/180);
; 7067 : 			tmp=mCos(ang*10);
; 7068 : 	*/
; 7069 : 			ax=(float) 1/(GAME_WIDTH/2);

	movss	xmm0, DWORD PTR __real@39000000
	movss	DWORD PTR _ax$[ebp], xmm0

; 7070 : 			ay=(float) 1/(9216.0f/2);

	movss	xmm0, DWORD PTR __real@39638e39
	movss	DWORD PTR _ay$[ebp], xmm0

; 7071 : 
; 7072 : 			ay*=-1.0f;

	movss	xmm0, DWORD PTR _ay$[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _ay$[ebp], xmm0

; 7073 : 
; 7074 : 			az=(float) 1/(4096/2);

	movss	xmm0, DWORD PTR __real@3a000000
	movss	DWORD PTR _az$[ebp], xmm0

; 7075 : 
; 7076 : 			
; 7077 : 				ent[i].texcor[0]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 7078 : 				ent[i].texcor[1]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 7079 : 				ent[i].texcor[2]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 7080 : 				ent[i].texcor[3]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 7081 : 				ent[i].texcor[4]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 7082 : 				ent[i].texcor[5]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 7083 : 				ent[i].texcor[6]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 6
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 7084 : 				ent[i].texcor[7]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 7
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 7085 : 
; 7086 : 			for(j=0;j<12;j+=3)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN6@DrawString
$LN5@DrawString:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 3
	mov	DWORD PTR _j$[ebp], eax
$LN6@DrawString:
	cmp	DWORD PTR _j$[ebp], 12			; 0000000cH
	jae	$LN4@DrawString

; 7087 : 			{
; 7088 : 				ent[i].vertex[j]*=ax;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+100]
	mulss	xmm0, DWORD PTR _ax$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 7089 : 				ent[i].vertex[j]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+100]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 7090 : 
; 7091 : 				ent[i].vertex[j+1]*=ay;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+104]
	mulss	xmm0, DWORD PTR _ay$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 7092 : 				ent[i].vertex[j+1]+=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+104]
	addss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 7093 : 				
; 7094 : 				ent[i].vertex[j+2]*=az;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+108]
	mulss	xmm0, DWORD PTR _az$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 7095 : 				ent[i].vertex[j+2]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+108]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 7096 : 			}

	jmp	$LN5@DrawString
$LN4@DrawString:

; 7097 : 
; 7098 : 			for(j=0;j<16;j+=4)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN3@DrawString
$LN2@DrawString:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 4
	mov	DWORD PTR _j$[ebp], eax
$LN3@DrawString:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jae	SHORT $LN1@DrawString

; 7099 : 			{
; 7100 : 				ent[i].color[j]=r;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _ent[eax+ecx+228], dl

; 7101 : 				ent[i].color[j+1]=g;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _ent[eax+ecx+229], dl

; 7102 : 				ent[i].color[j+2]=b;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _ent[eax+ecx+230], dl

; 7103 : 				ent[i].color[j+3]=a;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR _ent[eax+ecx+231], dl

; 7104 : 			}

	jmp	SHORT $LN2@DrawString
$LN1@DrawString:

; 7105 : 
; 7106 : 			
; 7107 : 				texone_ids[texone_num]=i;

	movzx	eax, WORD PTR _texone_num
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _texone_ids[eax*2], cx

; 7108 : 				texone_num++;

	mov	ax, WORD PTR _texone_num
	add	ax, 1
	mov	WORD PTR _texone_num, ax

; 7109 : 
; 7110 : #endif
; 7111 : 
; 7112 : 			st.num_entities++;

	mov	eax, DWORD PTR _st+244
	add	eax, 1
	mov	DWORD PTR _st+244, eax

; 7113 : 
; 7114 : 	return 0;

	xor	al, al
$LN33@DrawString:

; 7115 : 
; 7116 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN37@DrawString
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 444				; 000001bcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@DrawString:
	DD	1
	DD	$LN36@DrawString
$LN36@DrawString:
	DD	-140					; ffffff74H
	DD	4
	DD	$LN35@DrawString
$LN35@DrawString:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	0
_DrawStringUI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawString2UI
_TEXT	SEGMENT
tv991 = -444						; size = 4
tv967 = -444						; size = 4
tv942 = -444						; size = 4
tv919 = -444						; size = 4
tv895 = -444						; size = 4
tv871 = -444						; size = 4
tv846 = -444						; size = 4
tv821 = -444						; size = 4
tv1109 = -440						; size = 4
tv1101 = -440						; size = 4
tv1093 = -440						; size = 4
tv1085 = -440						; size = 4
tv1077 = -440						; size = 4
tv1069 = -440						; size = 4
tv1061 = -440						; size = 4
tv1053 = -440						; size = 4
tv1107 = -436						; size = 4
tv1099 = -436						; size = 4
tv1091 = -436						; size = 4
tv1083 = -436						; size = 4
tv1075 = -436						; size = 4
tv1067 = -436						; size = 4
tv1059 = -436						; size = 4
tv1051 = -436						; size = 4
tv980 = -432						; size = 4
tv956 = -432						; size = 4
tv931 = -432						; size = 4
tv908 = -432						; size = 4
tv883 = -432						; size = 4
tv859 = -432						; size = 4
tv834 = -432						; size = 4
tv809 = -432						; size = 4
tv1105 = -428						; size = 4
tv1097 = -428						; size = 4
tv1089 = -428						; size = 4
tv1081 = -428						; size = 4
tv1073 = -428						; size = 4
tv1065 = -428						; size = 4
tv1057 = -428						; size = 4
tv1049 = -428						; size = 4
tv1103 = -424						; size = 4
tv1095 = -424						; size = 4
tv1087 = -424						; size = 4
tv1079 = -424						; size = 4
tv1071 = -424						; size = 4
tv1063 = -424						; size = 4
tv1055 = -424						; size = 4
tv1047 = -424						; size = 4
_msg$ = -224						; size = 4
_val$ = -209						; size = 1
_az$ = -200						; size = 4
_ay$ = -188						; size = 4
_ax$ = -176						; size = 4
_formatt$ = -152					; size = 2
_co$ = -140						; size = 4
_id$ = -128						; size = 4
_checked$ = -44						; size = 4
_k$ = -32						; size = 4
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_text$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_sizex$ = 20						; size = 4
_sizey$ = 24						; size = 4
_ang$ = 28						; size = 2
_r$ = 32						; size = 1
_g$ = 36						; size = 1
_b$ = 40						; size = 1
_a$ = 44						; size = 1
_font$ = 48						; size = 1
_override_sizex$ = 52					; size = 4
_override_sizey$ = 56					; size = 4
_z$ = 60						; size = 1
_DrawString2UI PROC					; COMDAT

; 7119 : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 444				; 000001bcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-444]
	mov	ecx, 111				; 0000006fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 7120 : 	uint32 i=0, j=0, k=0, checked=0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _k$[ebp], 0
	mov	DWORD PTR _checked$[ebp], 0

; 7121 : 	int32 t1, t2, t3, t4, timej, timel, id=-1;

	mov	DWORD PTR _id$[ebp], -1

; 7122 : 
; 7123 : 	SDL_Color co;
; 7124 : 	uint16 formatt;
; 7125 : 
; 7126 : 	float tmp, ax, ay, az;
; 7127 : 
; 7128 : 	uint8 val=0;

	mov	BYTE PTR _val$[ebp], 0

; 7129 : 	
; 7130 : 	SDL_Surface *msg;
; 7131 : 
; 7132 : 	if(st.num_entities==MAX_GRAPHICS-1)

	cmp	DWORD PTR _st+244, 2047			; 000007ffH
	jne	SHORT $LN34@DrawString

; 7133 : 		return 2;

	mov	al, 2
	jmp	$LN35@DrawString
$LN34@DrawString:

; 7134 : 
; 7135 : 	//Checkbounds(x,y,sizex,sizey,ang,GAME_WIDTH,GAME_HEIGHT)) return 1;
; 7136 : 
; 7137 : 	for(i=0;i<MAX_STRINGS;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN33@DrawString
$LN32@DrawString:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN33@DrawString:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jae	$LN31@DrawString

; 7138 : 	{
; 7139 : 		if(st.strings[i].stat==2)

	imul	eax, DWORD PTR _i$[ebp], 1068
	movsx	ecx, BYTE PTR _st[eax+2762084]
	cmp	ecx, 2
	jne	SHORT $LN30@DrawString

; 7140 : 		{
; 7141 : 			if(strcmp(text,st.strings[i].string)==NULL)

	imul	eax, DWORD PTR _i$[ebp], 1068
	add	eax, OFFSET _st+2761020
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN29@DrawString

; 7142 : 			{
; 7143 : 				st.strings[i].stat=1;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	BYTE PTR _st[eax+2762084], 1

; 7144 : 				j=st.num_entities;

	mov	eax, DWORD PTR _st+244
	mov	DWORD PTR _j$[ebp], eax

; 7145 : 				st.strings[i].data.posx=i;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _st[eax+2762058], cx

; 7146 : 				memcpy(&ent[j].data,&st.strings[i].data,sizeof(TEX_DATA));

	push	40					; 00000028H
	imul	eax, DWORD PTR _i$[ebp], 1068
	add	eax, OFFSET _st+2762044
	push	eax
	imul	ecx, DWORD PTR _j$[ebp], 264
	add	ecx, OFFSET _ent+44
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 7147 : 				id=i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _id$[ebp], eax

; 7148 : 				checked=1;

	mov	DWORD PTR _checked$[ebp], 1

; 7149 : 				break;

	jmp	$LN31@DrawString
$LN29@DrawString:

; 7150 : 			}
; 7151 : 		}
; 7152 : 		else

	jmp	SHORT $LN27@DrawString
$LN30@DrawString:

; 7153 : 		if(st.strings[i].stat==0 && checked==0)

	imul	eax, DWORD PTR _i$[ebp], 1068
	movsx	ecx, BYTE PTR _st[eax+2762084]
	test	ecx, ecx
	jne	SHORT $LN27@DrawString
	cmp	DWORD PTR _checked$[ebp], 0
	jne	SHORT $LN27@DrawString

; 7154 : 		{
; 7155 : 			checked=3;

	mov	DWORD PTR _checked$[ebp], 3

; 7156 : 			id=i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _id$[ebp], eax
$LN27@DrawString:

; 7157 : 		}
; 7158 : 
; 7159 : 		if(i==MAX_STRINGS-1)

	cmp	DWORD PTR _i$[ebp], 511			; 000001ffH
	jne	SHORT $LN23@DrawString

; 7160 : 		{
; 7161 : 			if(id!=-1 && checked==3)

	cmp	DWORD PTR _id$[ebp], -1
	je	SHORT $LN25@DrawString
	cmp	DWORD PTR _checked$[ebp], 3
	jne	SHORT $LN25@DrawString

; 7162 : 			{
; 7163 : 				st.strings[id].stat=1;

	imul	eax, DWORD PTR _id$[ebp], 1068
	mov	BYTE PTR _st[eax+2762084], 1

; 7164 : 				strcpy(st.strings[id].string,text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	imul	ecx, DWORD PTR _id$[ebp], 1068
	add	ecx, OFFSET _st+2761020
	push	ecx
	call	_strcpy
	add	esp, 8

; 7165 : 				checked=2;

	mov	DWORD PTR _checked$[ebp], 2

; 7166 : 			}
; 7167 : 			else

	jmp	SHORT $LN23@DrawString
$LN25@DrawString:

; 7168 : 			if(checked==0 && id==-1)

	cmp	DWORD PTR _checked$[ebp], 0
	jne	SHORT $LN23@DrawString
	cmp	DWORD PTR _id$[ebp], -1
	jne	SHORT $LN23@DrawString

; 7169 : 			{
; 7170 : 				LogApp("Warning: max number os strings reached");

	push	OFFSET ??_C@_0CH@GLOGGAHF@Warning?3?5max?5number?5os?5strings?5r@
	call	_SDL_Log
	add	esp, 4

; 7171 : 				return 2;

	mov	al, 2
	jmp	$LN35@DrawString
$LN23@DrawString:

; 7172 : 			}
; 7173 : 		}
; 7174 : 	}

	jmp	$LN32@DrawString
$LN31@DrawString:

; 7175 : 
; 7176 : 	i=st.num_entities;

	mov	eax, DWORD PTR _st+244
	mov	DWORD PTR _i$[ebp], eax

; 7177 : 
; 7178 : 	if(checked==2)

	cmp	DWORD PTR _checked$[ebp], 2
	jne	$LN22@DrawString

; 7179 : 	{
; 7180 : 
; 7181 : 		co.r=255;

	mov	BYTE PTR _co$[ebp], 255			; 000000ffH

; 7182 : 		co.g=255;

	mov	BYTE PTR _co$[ebp+1], 255		; 000000ffH

; 7183 : 		co.b=255;

	mov	BYTE PTR _co$[ebp+2], 255		; 000000ffH

; 7184 : 		co.a=255;

	mov	BYTE PTR _co$[ebp+3], 255		; 000000ffH

; 7185 : 	
; 7186 : 		if(strlen(text)==0) 

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN21@DrawString

; 7187 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font," ",co);

	mov	eax, DWORD PTR _co$[ebp]
	push	eax
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	movzx	ecx, BYTE PTR _font$[ebp]
	imul	edx, ecx, 84
	mov	eax, DWORD PTR _st[edx+64344]
	push	eax
	call	_TTF_RenderUTF8_Blended
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _msg$[ebp], eax

; 7188 : 		else

	jmp	SHORT $LN20@DrawString
$LN21@DrawString:

; 7189 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font,text,co);

	mov	eax, DWORD PTR _co$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _font$[ebp]
	imul	eax, edx, 84
	mov	ecx, DWORD PTR _st[eax+64344]
	push	ecx
	call	_TTF_RenderUTF8_Blended
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _msg$[ebp], eax
$LN20@DrawString:

; 7190 : 	
; 7191 : 		if(msg->format->BytesPerPixel==4)

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+9]
	cmp	edx, 4
	jne	SHORT $LN19@DrawString

; 7192 : 		{
; 7193 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGBA;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+12], 255			; 000000ffH
	jne	SHORT $LN18@DrawString
	mov	eax, 6408				; 00001908H
	mov	WORD PTR _formatt$[ebp], ax
	jmp	SHORT $LN17@DrawString
$LN18@DrawString:

; 7194 : 			else formatt=GL_BGRA_EXT;

	mov	eax, 32993				; 000080e1H
	mov	WORD PTR _formatt$[ebp], ax
$LN17@DrawString:

; 7195 : 		} else

	jmp	SHORT $LN14@DrawString
$LN19@DrawString:

; 7196 : 		{
; 7197 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGB;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+12], 255			; 000000ffH
	jne	SHORT $LN15@DrawString
	mov	eax, 6407				; 00001907H
	mov	WORD PTR _formatt$[ebp], ax
	jmp	SHORT $LN14@DrawString
$LN15@DrawString:

; 7198 : 			else formatt=GL_BGR_EXT;

	mov	eax, 32992				; 000080e0H
	mov	WORD PTR _formatt$[ebp], ax
$LN14@DrawString:

; 7199 : 		}
; 7200 : 
; 7201 : 		glGenTextures(1,&ent[i].data.data);

	imul	eax, DWORD PTR _i$[ebp], 264
	add	eax, OFFSET _ent+44
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7202 : 		glBindTexture(GL_TEXTURE_2D,ent[i].data.data);

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	esi, esp
	mov	ecx, DWORD PTR _ent[eax+44]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7203 : 		glTexImage2D(GL_TEXTURE_2D,0,msg->format->BytesPerPixel,msg->w,msg->h,0,formatt,GL_UNSIGNED_BYTE,msg->pixels);

	mov	esi, esp
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	5121					; 00001401H
	movzx	edx, WORD PTR _formatt$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx+9]
	push	eax
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7204 : 
; 7205 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	mov	esi, esp
	push	9729					; 00002601H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7206 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	mov	esi, esp
	push	9729					; 00002601H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7207 : 
; 7208 : 		ent[i].data.channel=63; //magical number only used for rendering

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	DWORD PTR _ent[eax+76], 63		; 0000003fH

; 7209 : 
; 7210 : 		ent[i].data.posx=id;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	cx, WORD PTR _id$[ebp]
	mov	WORD PTR _ent[eax+58], cx

; 7211 : 
; 7212 : 		ent[i].data.normal=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	BYTE PTR _ent[eax+52], 0

; 7213 : 		ent[i].data.vb_id=-1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, -1
	mov	WORD PTR _ent[eax+54], cx

; 7214 : 
; 7215 : 		ent[i].data.w=msg->w;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _ent[eax+68], edx

; 7216 : 		ent[i].data.h=msg->h;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _ent[eax+72], edx

; 7217 : 
; 7218 : 		memcpy(&st.strings[id].data,&ent[i].data,sizeof(TEX_DATA));

	push	40					; 00000028H
	imul	eax, DWORD PTR _i$[ebp], 264
	add	eax, OFFSET _ent+44
	push	eax
	imul	ecx, DWORD PTR _id$[ebp], 1068
	add	ecx, OFFSET _st+2762044
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 7219 : 
; 7220 : 		SDL_FreeSurface(msg);

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_SDL_FreeSurface
	add	esp, 4
$LN22@DrawString:

; 7221 : 	}
; 7222 : 
; 7223 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 7224 : 
; 7225 : 	ent[i].lightmapid=-1;

	imul	eax, DWORD PTR _i$[ebp], 264
	or	ecx, -1
	mov	WORD PTR _ent[eax+260], cx

; 7226 : 
; 7227 : 			
; 7228 : 			if(override_sizex!=0)

	cmp	DWORD PTR _override_sizex$[ebp], 0
	je	SHORT $LN13@DrawString

; 7229 : 				sizex=st.strings[id].data.w*(float)(override_sizex/1024.0f);

	imul	eax, DWORD PTR _id$[ebp], 1068
	cvtsi2ss xmm0, DWORD PTR _st[eax+2762068]
	cvtsi2ss xmm1, DWORD PTR _override_sizex$[ebp]
	divss	xmm1, DWORD PTR __real@44800000
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _sizex$[ebp], ecx
$LN13@DrawString:

; 7230 : 
; 7231 : 			if(override_sizey!=0)

	cmp	DWORD PTR _override_sizey$[ebp], 0
	je	SHORT $LN12@DrawString

; 7232 : 				sizey=st.strings[id].data.h*(float)(override_sizey/1024.0f);

	imul	eax, DWORD PTR _id$[ebp], 1068
	cvtsi2ss xmm0, DWORD PTR _st[eax+2762072]
	cvtsi2ss xmm1, DWORD PTR _override_sizey$[ebp]
	divss	xmm1, DWORD PTR __real@44800000
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _sizey$[ebp], ecx
$LN12@DrawString:

; 7233 : 
; 7234 : 			ent[i].texrepeat[0]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+212], xmm0

; 7235 : 			ent[i].texrepeat[1]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+ecx+212], xmm0

; 7236 : 			ent[i].texrepeat[2]=1.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+ecx+212], xmm0

; 7237 : 			ent[i].texrepeat[3]=1.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+edx+212], xmm0

; 7238 : 
; 7239 : 			if(r==0 && g==0 && b==0)

	movzx	eax, BYTE PTR _r$[ebp]
	test	eax, eax
	jne	SHORT $LN11@DrawString
	movzx	eax, BYTE PTR _g$[ebp]
	test	eax, eax
	jne	SHORT $LN11@DrawString
	movzx	eax, BYTE PTR _b$[ebp]
	test	eax, eax
	jne	SHORT $LN11@DrawString

; 7240 : 				r=g=b=1;

	mov	BYTE PTR _b$[ebp], 1
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _g$[ebp], al
	mov	cl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _r$[ebp], cl
$LN11@DrawString:

; 7241 : 
; 7242 : 			if(z>15) z=15;

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 15					; 0000000fH
	jle	SHORT $LN10@DrawString
	mov	BYTE PTR _z$[ebp], 15			; 0000000fH
	jmp	SHORT $LN8@DrawString
$LN10@DrawString:

; 7243 : 			else if(z<8) z+=8;

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 8
	jge	SHORT $LN8@DrawString
	movsx	eax, BYTE PTR _z$[ebp]
	add	eax, 8
	mov	BYTE PTR _z$[ebp], al
$LN8@DrawString:

; 7244 : 
; 7245 : 			z_buffer[z][z_slot[z]]=i;

	movsx	eax, BYTE PTR _z$[ebp]
	shl	eax, 12					; 0000000cH
	movsx	ecx, BYTE PTR _z$[ebp]
	movsx	edx, WORD PTR _z_slot[ecx*2]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _z_buffer[eax+edx*2], cx

; 7246 : 			z_slot[z]++;

	movsx	eax, BYTE PTR _z$[ebp]
	mov	cx, WORD PTR _z_slot[eax*2]
	add	cx, 1
	movsx	edx, BYTE PTR _z$[ebp]
	mov	WORD PTR _z_slot[edx*2], cx

; 7247 : 
; 7248 : 			if(z>z_used) z_used=z;

	movsx	eax, BYTE PTR _z$[ebp]
	movsx	ecx, BYTE PTR _z_used
	cmp	eax, ecx
	jle	SHORT $LN7@DrawString
	mov	al, BYTE PTR _z$[ebp]
	mov	BYTE PTR _z_used, al
$LN7@DrawString:

; 7249 : 
; 7250 : 			//timej=GetTicks();
; 7251 : 
; 7252 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1047[ebp], xmm0
	movss	DWORD PTR tv1049[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv809[ebp]
	movss	xmm0, DWORD PTR tv1049[ebp]
	mulss	xmm0, DWORD PTR tv809[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1051[ebp], xmm0
	movss	DWORD PTR tv1053[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv821[ebp]
	movss	xmm0, DWORD PTR tv1053[ebp]
	mulss	xmm0, DWORD PTR tv821[ebp]
	movss	xmm1, DWORD PTR tv1051[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1047[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 7253 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1055[ebp], xmm0
	movss	DWORD PTR tv1057[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv834[ebp]
	movss	xmm0, DWORD PTR tv1057[ebp]
	mulss	xmm0, DWORD PTR tv834[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1059[ebp], xmm0
	movss	DWORD PTR tv1061[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv846[ebp]
	movss	xmm0, DWORD PTR tv1061[ebp]
	mulss	xmm0, DWORD PTR tv846[ebp]
	movss	xmm1, DWORD PTR tv1059[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1055[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 7254 : 			ent[i].vertex[2]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movsx	edx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 7255 : 
; 7256 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1063[ebp], xmm0
	movss	DWORD PTR tv1065[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv859[ebp]
	movss	xmm0, DWORD PTR tv1065[ebp]
	mulss	xmm0, DWORD PTR tv859[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1067[ebp], xmm0
	movss	DWORD PTR tv1069[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv871[ebp]
	movss	xmm0, DWORD PTR tv1069[ebp]
	mulss	xmm0, DWORD PTR tv871[ebp]
	movss	xmm1, DWORD PTR tv1067[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1063[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 7257 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1071[ebp], xmm0
	movss	DWORD PTR tv1073[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv883[ebp]
	movss	xmm0, DWORD PTR tv1073[ebp]
	mulss	xmm0, DWORD PTR tv883[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1075[ebp], xmm0
	movss	DWORD PTR tv1077[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv895[ebp]
	movss	xmm0, DWORD PTR tv1077[ebp]
	mulss	xmm0, DWORD PTR tv895[ebp]
	movss	xmm1, DWORD PTR tv1075[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1071[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 7258 : 			ent[i].vertex[5]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	movsx	ecx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 7259 : 
; 7260 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1079[ebp], xmm0
	movss	DWORD PTR tv1081[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv908[ebp]
	movss	xmm0, DWORD PTR tv1081[ebp]
	mulss	xmm0, DWORD PTR tv908[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1083[ebp], xmm0
	movss	DWORD PTR tv1085[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv919[ebp]
	movss	xmm0, DWORD PTR tv1085[ebp]
	mulss	xmm0, DWORD PTR tv919[ebp]
	movss	xmm1, DWORD PTR tv1083[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1079[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 6
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 7261 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1087[ebp], xmm0
	movss	DWORD PTR tv1089[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv931[ebp]
	movss	xmm0, DWORD PTR tv1089[ebp]
	mulss	xmm0, DWORD PTR tv931[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1091[ebp], xmm0
	movss	DWORD PTR tv1093[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv942[ebp]
	movss	xmm0, DWORD PTR tv1093[ebp]
	mulss	xmm0, DWORD PTR tv942[ebp]
	movss	xmm1, DWORD PTR tv1091[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1087[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 7
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 7262 : 			ent[i].vertex[8]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 3
	movsx	edx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 7263 : 
; 7264 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1095[ebp], xmm0
	movss	DWORD PTR tv1097[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv956[ebp]
	movss	xmm0, DWORD PTR tv1097[ebp]
	mulss	xmm0, DWORD PTR tv956[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1099[ebp], xmm0
	movss	DWORD PTR tv1101[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv967[ebp]
	movss	xmm0, DWORD PTR tv1101[ebp]
	mulss	xmm0, DWORD PTR tv967[ebp]
	movss	xmm1, DWORD PTR tv1099[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1095[ebp]
	addss	xmm0, xmm1
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 9
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 7265 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1103[ebp], xmm0
	movss	DWORD PTR tv1105[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv980[ebp]
	movss	xmm0, DWORD PTR tv1105[ebp]
	mulss	xmm0, DWORD PTR tv980[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1107[ebp], xmm0
	movss	DWORD PTR tv1109[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv991[ebp]
	movss	xmm0, DWORD PTR tv1109[ebp]
	mulss	xmm0, DWORD PTR tv991[ebp]
	movss	xmm1, DWORD PTR tv1107[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1103[ebp]
	addss	xmm0, xmm1
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 10
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 7266 : 			ent[i].vertex[11]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 11
	movsx	ecx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 7267 : 			/*
; 7268 : 			ang/=10;
; 7269 : 
; 7270 : 			tmp=cos((ang*pi)/180);
; 7271 : 			tmp=mCos(ang*10);
; 7272 : 	*/
; 7273 : 			ax=(float) 1/(GAME_WIDTH/2);

	movss	xmm0, DWORD PTR __real@39000000
	movss	DWORD PTR _ax$[ebp], xmm0

; 7274 : 			ay=(float) 1/(9216.0f/2);

	movss	xmm0, DWORD PTR __real@39638e39
	movss	DWORD PTR _ay$[ebp], xmm0

; 7275 : 
; 7276 : 			ay*=-1.0f;

	movss	xmm0, DWORD PTR _ay$[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _ay$[ebp], xmm0

; 7277 : 
; 7278 : 			az=(float) 1/(4096/2);

	movss	xmm0, DWORD PTR __real@3a000000
	movss	DWORD PTR _az$[ebp], xmm0

; 7279 : 
; 7280 : 			
; 7281 : 				ent[i].texcor[0]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 7282 : 				ent[i].texcor[1]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 7283 : 				ent[i].texcor[2]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 7284 : 				ent[i].texcor[3]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 7285 : 				ent[i].texcor[4]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 7286 : 				ent[i].texcor[5]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 7287 : 				ent[i].texcor[6]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 6
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 7288 : 				ent[i].texcor[7]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 7
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 7289 : 
; 7290 : 			for(j=0;j<12;j+=3)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN6@DrawString
$LN5@DrawString:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 3
	mov	DWORD PTR _j$[ebp], eax
$LN6@DrawString:
	cmp	DWORD PTR _j$[ebp], 12			; 0000000cH
	jae	$LN4@DrawString

; 7291 : 			{
; 7292 : 				ent[i].vertex[j]*=ax;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+100]
	mulss	xmm0, DWORD PTR _ax$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 7293 : 				ent[i].vertex[j]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+100]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 7294 : 
; 7295 : 				ent[i].vertex[j+1]*=ay;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+104]
	mulss	xmm0, DWORD PTR _ay$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 7296 : 				ent[i].vertex[j+1]+=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+104]
	addss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 7297 : 				
; 7298 : 				ent[i].vertex[j+2]*=az;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+108]
	mulss	xmm0, DWORD PTR _az$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 7299 : 				ent[i].vertex[j+2]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+108]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 7300 : 			}

	jmp	$LN5@DrawString
$LN4@DrawString:

; 7301 : 
; 7302 : 			for(j=0;j<16;j+=4)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN3@DrawString
$LN2@DrawString:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 4
	mov	DWORD PTR _j$[ebp], eax
$LN3@DrawString:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jae	SHORT $LN1@DrawString

; 7303 : 			{
; 7304 : 				ent[i].color[j]=r;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _ent[eax+ecx+228], dl

; 7305 : 				ent[i].color[j+1]=g;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _ent[eax+ecx+229], dl

; 7306 : 				ent[i].color[j+2]=b;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _ent[eax+ecx+230], dl

; 7307 : 				ent[i].color[j+3]=a;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR _ent[eax+ecx+231], dl

; 7308 : 			}

	jmp	SHORT $LN2@DrawString
$LN1@DrawString:

; 7309 : 
; 7310 : 			
; 7311 : 				texone_ids[texone_num]=i;

	movzx	eax, WORD PTR _texone_num
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _texone_ids[eax*2], cx

; 7312 : 				texone_num++;

	mov	ax, WORD PTR _texone_num
	add	ax, 1
	mov	WORD PTR _texone_num, ax

; 7313 : 
; 7314 : #endif
; 7315 : 
; 7316 : 			st.num_entities++;

	mov	eax, DWORD PTR _st+244
	add	eax, 1
	mov	DWORD PTR _st+244, eax

; 7317 : 
; 7318 : 	return 0;

	xor	al, al
$LN35@DrawString:

; 7319 : 
; 7320 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN39@DrawString
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 444				; 000001bcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN39@DrawString:
	DD	1
	DD	$LN38@DrawString
$LN38@DrawString:
	DD	-140					; ffffff74H
	DD	4
	DD	$LN37@DrawString
$LN37@DrawString:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	0
_DrawString2UI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawString2
_TEXT	SEGMENT
tv1127 = -444						; size = 4
tv1103 = -444						; size = 4
tv1078 = -444						; size = 4
tv1055 = -444						; size = 4
tv1031 = -444						; size = 4
tv1007 = -444						; size = 4
tv982 = -444						; size = 4
tv957 = -444						; size = 4
tv1257 = -440						; size = 4
tv1249 = -440						; size = 4
tv1241 = -440						; size = 4
tv1233 = -440						; size = 4
tv1225 = -440						; size = 4
tv1217 = -440						; size = 4
tv1209 = -440						; size = 4
tv1201 = -440						; size = 4
tv1255 = -436						; size = 4
tv1247 = -436						; size = 4
tv1239 = -436						; size = 4
tv1231 = -436						; size = 4
tv1223 = -436						; size = 4
tv1215 = -436						; size = 4
tv1207 = -436						; size = 4
tv1199 = -436						; size = 4
tv1116 = -432						; size = 4
tv1092 = -432						; size = 4
tv1067 = -432						; size = 4
tv1044 = -432						; size = 4
tv1019 = -432						; size = 4
tv995 = -432						; size = 4
tv970 = -432						; size = 4
tv945 = -432						; size = 4
tv1253 = -428						; size = 4
tv1245 = -428						; size = 4
tv1237 = -428						; size = 4
tv1229 = -428						; size = 4
tv1221 = -428						; size = 4
tv1213 = -428						; size = 4
tv1205 = -428						; size = 4
tv1197 = -428						; size = 4
tv1251 = -424						; size = 4
tv1243 = -424						; size = 4
tv1235 = -424						; size = 4
tv1227 = -424						; size = 4
tv1219 = -424						; size = 4
tv1211 = -424						; size = 4
tv1203 = -424						; size = 4
tv1195 = -424						; size = 4
_msg$ = -224						; size = 4
_val$ = -209						; size = 1
_az$ = -200						; size = 4
_ay$ = -188						; size = 4
_ax$ = -176						; size = 4
_tmp$ = -164						; size = 4
_formatt$ = -152					; size = 2
_co$ = -140						; size = 4
_id$ = -128						; size = 4
_checked$ = -44						; size = 4
_k$ = -32						; size = 4
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_text$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_sizex$ = 20						; size = 4
_sizey$ = 24						; size = 4
_ang$ = 28						; size = 2
_r$ = 32						; size = 1
_g$ = 36						; size = 1
_b$ = 40						; size = 1
_a$ = 44						; size = 1
_font$ = 48						; size = 1
_override_sizex$ = 52					; size = 4
_override_sizey$ = 56					; size = 4
_z$ = 60						; size = 1
_DrawString2 PROC					; COMDAT

; 6464 : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 444				; 000001bcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-444]
	mov	ecx, 111				; 0000006fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 6465 : 	uint32 i=0, j=0, k=0, checked=0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _k$[ebp], 0
	mov	DWORD PTR _checked$[ebp], 0

; 6466 : 	int32 t1, t2, t3, t4, timej, timel, id=-1;

	mov	DWORD PTR _id$[ebp], -1

; 6467 : 
; 6468 : 	SDL_Color co;
; 6469 : 	uint16 formatt;
; 6470 : 
; 6471 : 	float tmp, ax, ay, az;
; 6472 : 
; 6473 : 	uint8 val=0;

	mov	BYTE PTR _val$[ebp], 0

; 6474 : 	
; 6475 : 	SDL_Surface *msg;
; 6476 : 
; 6477 : 	if(st.num_entities==MAX_GRAPHICS-1)

	cmp	DWORD PTR _st+244, 2047			; 000007ffH
	jne	SHORT $LN39@DrawString

; 6478 : 		return 2;

	mov	al, 2
	jmp	$LN40@DrawString
$LN39@DrawString:

; 6479 : 
; 6480 : 	//Checkbounds(x,y,sizex,sizey,ang,GAME_WIDTH,9216)) return 1;
; 6481 : 
; 6482 : 	for(i=0;i<MAX_STRINGS;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN38@DrawString
$LN37@DrawString:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN38@DrawString:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jae	$LN36@DrawString

; 6483 : 	{
; 6484 : 		if(st.strings[i].stat==2)

	imul	eax, DWORD PTR _i$[ebp], 1068
	movsx	ecx, BYTE PTR _st[eax+2762084]
	cmp	ecx, 2
	jne	SHORT $LN35@DrawString

; 6485 : 		{
; 6486 : 			if(strcmp(text,st.strings[i].string)==NULL)

	imul	eax, DWORD PTR _i$[ebp], 1068
	add	eax, OFFSET _st+2761020
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN34@DrawString

; 6487 : 			{
; 6488 : 				st.strings[i].stat=1;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	BYTE PTR _st[eax+2762084], 1

; 6489 : 				j=st.num_entities;

	mov	eax, DWORD PTR _st+244
	mov	DWORD PTR _j$[ebp], eax

; 6490 : 				st.strings[i].data.posx=i;

	imul	eax, DWORD PTR _i$[ebp], 1068
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _st[eax+2762058], cx

; 6491 : 				memcpy(&ent[j].data,&st.strings[i].data,sizeof(TEX_DATA));

	push	40					; 00000028H
	imul	eax, DWORD PTR _i$[ebp], 1068
	add	eax, OFFSET _st+2762044
	push	eax
	imul	ecx, DWORD PTR _j$[ebp], 264
	add	ecx, OFFSET _ent+44
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6492 : 				id=i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _id$[ebp], eax

; 6493 : 				checked=1;

	mov	DWORD PTR _checked$[ebp], 1

; 6494 : 				break;

	jmp	$LN36@DrawString
$LN34@DrawString:

; 6495 : 			}
; 6496 : 		}
; 6497 : 		else

	jmp	SHORT $LN32@DrawString
$LN35@DrawString:

; 6498 : 		if(st.strings[i].stat==0 && checked==0)

	imul	eax, DWORD PTR _i$[ebp], 1068
	movsx	ecx, BYTE PTR _st[eax+2762084]
	test	ecx, ecx
	jne	SHORT $LN32@DrawString
	cmp	DWORD PTR _checked$[ebp], 0
	jne	SHORT $LN32@DrawString

; 6499 : 		{
; 6500 : 			checked=3;

	mov	DWORD PTR _checked$[ebp], 3

; 6501 : 			id=i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _id$[ebp], eax
$LN32@DrawString:

; 6502 : 		}
; 6503 : 
; 6504 : 		if(i==MAX_STRINGS-1)

	cmp	DWORD PTR _i$[ebp], 511			; 000001ffH
	jne	SHORT $LN28@DrawString

; 6505 : 		{
; 6506 : 			if(id!=-1 && checked==3)

	cmp	DWORD PTR _id$[ebp], -1
	je	SHORT $LN30@DrawString
	cmp	DWORD PTR _checked$[ebp], 3
	jne	SHORT $LN30@DrawString

; 6507 : 			{
; 6508 : 				st.strings[id].stat=1;

	imul	eax, DWORD PTR _id$[ebp], 1068
	mov	BYTE PTR _st[eax+2762084], 1

; 6509 : 				strcpy(st.strings[id].string,text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	imul	ecx, DWORD PTR _id$[ebp], 1068
	add	ecx, OFFSET _st+2761020
	push	ecx
	call	_strcpy
	add	esp, 8

; 6510 : 				checked=2;

	mov	DWORD PTR _checked$[ebp], 2

; 6511 : 			}
; 6512 : 			else

	jmp	SHORT $LN28@DrawString
$LN30@DrawString:

; 6513 : 			if(checked==0 && id==-1)

	cmp	DWORD PTR _checked$[ebp], 0
	jne	SHORT $LN28@DrawString
	cmp	DWORD PTR _id$[ebp], -1
	jne	SHORT $LN28@DrawString

; 6514 : 			{
; 6515 : 				LogApp("Warning: max number os strings reached");

	push	OFFSET ??_C@_0CH@GLOGGAHF@Warning?3?5max?5number?5os?5strings?5r@
	call	_SDL_Log
	add	esp, 4

; 6516 : 				return 2;

	mov	al, 2
	jmp	$LN40@DrawString
$LN28@DrawString:

; 6517 : 			}
; 6518 : 		}
; 6519 : 	}

	jmp	$LN37@DrawString
$LN36@DrawString:

; 6520 : 
; 6521 : 	i=st.num_entities;

	mov	eax, DWORD PTR _st+244
	mov	DWORD PTR _i$[ebp], eax

; 6522 : 
; 6523 : 	if(checked==2)

	cmp	DWORD PTR _checked$[ebp], 2
	jne	$LN27@DrawString

; 6524 : 	{
; 6525 : 
; 6526 : 		co.r=255;

	mov	BYTE PTR _co$[ebp], 255			; 000000ffH

; 6527 : 		co.g=255;

	mov	BYTE PTR _co$[ebp+1], 255		; 000000ffH

; 6528 : 		co.b=255;

	mov	BYTE PTR _co$[ebp+2], 255		; 000000ffH

; 6529 : 		co.a=255;

	mov	BYTE PTR _co$[ebp+3], 255		; 000000ffH

; 6530 : 	
; 6531 : 		if(strlen(text)==0) 

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN26@DrawString

; 6532 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font," ",co);

	mov	eax, DWORD PTR _co$[ebp]
	push	eax
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	movzx	ecx, BYTE PTR _font$[ebp]
	imul	edx, ecx, 84
	mov	eax, DWORD PTR _st[edx+64344]
	push	eax
	call	_TTF_RenderUTF8_Blended
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _msg$[ebp], eax

; 6533 : 		else

	jmp	SHORT $LN25@DrawString
$LN26@DrawString:

; 6534 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font,text,co);

	mov	eax, DWORD PTR _co$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _font$[ebp]
	imul	eax, edx, 84
	mov	ecx, DWORD PTR _st[eax+64344]
	push	ecx
	call	_TTF_RenderUTF8_Blended
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _msg$[ebp], eax
$LN25@DrawString:

; 6535 : 	
; 6536 : 		if(msg->format->BytesPerPixel==4)

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+9]
	cmp	edx, 4
	jne	SHORT $LN24@DrawString

; 6537 : 		{
; 6538 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGBA;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+12], 255			; 000000ffH
	jne	SHORT $LN23@DrawString
	mov	eax, 6408				; 00001908H
	mov	WORD PTR _formatt$[ebp], ax
	jmp	SHORT $LN22@DrawString
$LN23@DrawString:

; 6539 : 			else formatt=GL_BGRA_EXT;

	mov	eax, 32993				; 000080e1H
	mov	WORD PTR _formatt$[ebp], ax
$LN22@DrawString:

; 6540 : 		} else

	jmp	SHORT $LN19@DrawString
$LN24@DrawString:

; 6541 : 		{
; 6542 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGB;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+12], 255			; 000000ffH
	jne	SHORT $LN20@DrawString
	mov	eax, 6407				; 00001907H
	mov	WORD PTR _formatt$[ebp], ax
	jmp	SHORT $LN19@DrawString
$LN20@DrawString:

; 6543 : 			else formatt=GL_BGR_EXT;

	mov	eax, 32992				; 000080e0H
	mov	WORD PTR _formatt$[ebp], ax
$LN19@DrawString:

; 6544 : 		}
; 6545 : 
; 6546 : 		glGenTextures(1,&ent[i].data.data);

	imul	eax, DWORD PTR _i$[ebp], 264
	add	eax, OFFSET _ent+44
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6547 : 		glBindTexture(GL_TEXTURE_2D,ent[i].data.data);

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	esi, esp
	mov	ecx, DWORD PTR _ent[eax+44]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6548 : 		glTexImage2D(GL_TEXTURE_2D,0,msg->format->BytesPerPixel,msg->w,msg->h,0,formatt,GL_UNSIGNED_BYTE,msg->pixels);

	mov	esi, esp
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	5121					; 00001401H
	movzx	edx, WORD PTR _formatt$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [edx+9]
	push	eax
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6549 : 
; 6550 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	mov	esi, esp
	push	9729					; 00002601H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6551 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	mov	esi, esp
	push	9729					; 00002601H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6552 : 
; 6553 : 		ent[i].data.channel=63; //magical number only used for rendering

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	DWORD PTR _ent[eax+76], 63		; 0000003fH

; 6554 : 
; 6555 : 		ent[i].data.posx=id;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	cx, WORD PTR _id$[ebp]
	mov	WORD PTR _ent[eax+58], cx

; 6556 : 
; 6557 : 		ent[i].data.normal=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	BYTE PTR _ent[eax+52], 0

; 6558 : 		ent[i].data.vb_id=-1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, -1
	mov	WORD PTR _ent[eax+54], cx

; 6559 : 
; 6560 : 		ent[i].data.w=msg->w;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _ent[eax+68], edx

; 6561 : 		ent[i].data.h=msg->h;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _ent[eax+72], edx

; 6562 : 
; 6563 : 		ent[i].lightmapid=-1;

	imul	eax, DWORD PTR _i$[ebp], 264
	or	ecx, -1
	mov	WORD PTR _ent[eax+260], cx

; 6564 : 
; 6565 : 		memcpy(&st.strings[id].data,&ent[i].data,sizeof(TEX_DATA));

	push	40					; 00000028H
	imul	eax, DWORD PTR _i$[ebp], 264
	add	eax, OFFSET _ent+44
	push	eax
	imul	ecx, DWORD PTR _id$[ebp], 1068
	add	ecx, OFFSET _st+2762044
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6566 : 
; 6567 : 		SDL_FreeSurface(msg);

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_SDL_FreeSurface
	add	esp, 4
$LN27@DrawString:

; 6568 : 	}
; 6569 : 
; 6570 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 6571 : 
; 6572 : 	ent[i].lightmapid=-1;

	imul	eax, DWORD PTR _i$[ebp], 264
	or	ecx, -1
	mov	WORD PTR _ent[eax+260], cx

; 6573 : 
; 6574 : 			if(override_sizex!=0)

	cmp	DWORD PTR _override_sizex$[ebp], 0
	je	SHORT $LN18@DrawString

; 6575 : 				sizex=st.strings[id].data.w*(float)(override_sizex/1024.0f);

	imul	eax, DWORD PTR _id$[ebp], 1068
	cvtsi2ss xmm0, DWORD PTR _st[eax+2762068]
	cvtsi2ss xmm1, DWORD PTR _override_sizex$[ebp]
	divss	xmm1, DWORD PTR __real@44800000
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _sizex$[ebp], ecx
$LN18@DrawString:

; 6576 : 
; 6577 : 			if(override_sizey!=0)

	cmp	DWORD PTR _override_sizey$[ebp], 0
	je	SHORT $LN17@DrawString

; 6578 : 				sizey=st.strings[id].data.h*(float)(override_sizey/1024.0f);

	imul	eax, DWORD PTR _id$[ebp], 1068
	cvtsi2ss xmm0, DWORD PTR _st[eax+2762072]
	cvtsi2ss xmm1, DWORD PTR _override_sizey$[ebp]
	divss	xmm1, DWORD PTR __real@44800000
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _sizey$[ebp], ecx
$LN17@DrawString:

; 6579 : 
; 6580 : 			ent[i].texrepeat[0]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+212], xmm0

; 6581 : 			ent[i].texrepeat[1]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+ecx+212], xmm0

; 6582 : 			ent[i].texrepeat[2]=1.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+ecx+212], xmm0

; 6583 : 			ent[i].texrepeat[3]=1.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+edx+212], xmm0

; 6584 : 
; 6585 : 			if(r==0 && g==0 && b==0)

	movzx	eax, BYTE PTR _r$[ebp]
	test	eax, eax
	jne	SHORT $LN16@DrawString
	movzx	eax, BYTE PTR _g$[ebp]
	test	eax, eax
	jne	SHORT $LN16@DrawString
	movzx	eax, BYTE PTR _b$[ebp]
	test	eax, eax
	jne	SHORT $LN16@DrawString

; 6586 : 				r=g=b=1;

	mov	BYTE PTR _b$[ebp], 1
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _g$[ebp], al
	mov	cl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _r$[ebp], cl
$LN16@DrawString:

; 6587 : 
; 6588 : 			if(z>39 && z<48)

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 39					; 00000027H
	jle	SHORT $LN15@DrawString
	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 48					; 00000030H
	jge	SHORT $LN15@DrawString

; 6589 : 			{
; 6590 : 				
; 6591 : 				x-=(float) st.Camera.position.x*st.Current_Map.bck2_v;

	cvtsi2ss xmm0, DWORD PTR _st+2335380
	mulss	xmm0, DWORD PTR _st+66852
	cvtsi2ss xmm1, DWORD PTR _x$[ebp]
	subss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _x$[ebp], eax

; 6592 : 				y-=(float) st.Camera.position.y*st.Current_Map.bck2_v;

	cvtsi2ss xmm0, DWORD PTR _st+2335384
	mulss	xmm0, DWORD PTR _st+66852
	cvtsi2ss xmm1, DWORD PTR _y$[ebp]
	subss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _y$[ebp], eax

; 6593 : 			}
; 6594 : 			else

	jmp	$LN11@DrawString
$LN15@DrawString:

; 6595 : 			if(z>31 && z<40)

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 31					; 0000001fH
	jle	$LN13@DrawString
	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 40					; 00000028H
	jge	$LN13@DrawString

; 6596 : 			{
; 6597 : 				
; 6598 : 				x-=(float) st.Camera.position.x*st.Current_Map.bck1_v;

	cvtsi2ss xmm0, DWORD PTR _st+2335380
	mulss	xmm0, DWORD PTR _st+66856
	cvtsi2ss xmm1, DWORD PTR _x$[ebp]
	subss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _x$[ebp], eax

; 6599 : 				y-=(float) st.Camera.position.y*st.Current_Map.bck1_v;

	cvtsi2ss xmm0, DWORD PTR _st+2335384
	mulss	xmm0, DWORD PTR _st+66856
	cvtsi2ss xmm1, DWORD PTR _y$[ebp]
	subss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _y$[ebp], eax

; 6600 : 
; 6601 : 				sizex*=st.Camera.dimension.x;

	cvtsi2ss xmm0, DWORD PTR _sizex$[ebp]
	mulss	xmm0, DWORD PTR _st+2335396
	cvttss2si eax, xmm0
	mov	DWORD PTR _sizex$[ebp], eax

; 6602 : 				sizey*=st.Camera.dimension.y;

	cvtsi2ss xmm0, DWORD PTR _sizey$[ebp]
	mulss	xmm0, DWORD PTR _st+2335400
	cvttss2si eax, xmm0
	mov	DWORD PTR _sizey$[ebp], eax

; 6603 : 
; 6604 : 				x*=st.Camera.dimension.x;

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _st+2335396
	cvttss2si eax, xmm0
	mov	DWORD PTR _x$[ebp], eax

; 6605 : 				y*=st.Camera.dimension.y;

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR _st+2335400
	cvttss2si eax, xmm0
	mov	DWORD PTR _y$[ebp], eax

; 6606 : 			}
; 6607 : 			else

	jmp	SHORT $LN11@DrawString
$LN13@DrawString:

; 6608 : 			if(z>23 && z<32)

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 23					; 00000017H
	jle	SHORT $LN11@DrawString
	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 32					; 00000020H
	jge	SHORT $LN11@DrawString

; 6609 : 			{
; 6610 : 				x-=st.Camera.position.x;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, DWORD PTR _st+2335380
	mov	DWORD PTR _x$[ebp], eax

; 6611 : 				y-=st.Camera.position.y;

	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, DWORD PTR _st+2335384
	mov	DWORD PTR _y$[ebp], eax

; 6612 : 
; 6613 : 				sizex*=st.Camera.dimension.x;

	cvtsi2ss xmm0, DWORD PTR _sizex$[ebp]
	mulss	xmm0, DWORD PTR _st+2335396
	cvttss2si eax, xmm0
	mov	DWORD PTR _sizex$[ebp], eax

; 6614 : 				sizey*=st.Camera.dimension.y;

	cvtsi2ss xmm0, DWORD PTR _sizey$[ebp]
	mulss	xmm0, DWORD PTR _st+2335400
	cvttss2si eax, xmm0
	mov	DWORD PTR _sizey$[ebp], eax

; 6615 : 
; 6616 : 				x*=st.Camera.dimension.x;

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _st+2335396
	cvttss2si eax, xmm0
	mov	DWORD PTR _x$[ebp], eax

; 6617 : 				y*=st.Camera.dimension.y;

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR _st+2335400
	cvttss2si eax, xmm0
	mov	DWORD PTR _y$[ebp], eax
$LN11@DrawString:

; 6618 : 			}
; 6619 : 			if(z>15 && z<24)

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 15					; 0000000fH
	jle	$LN10@DrawString
	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 24					; 00000018H
	jge	$LN10@DrawString

; 6620 : 			{
; 6621 : 				x-=(float) st.Camera.position.x*st.Current_Map.fr_v;

	cvtsi2ss xmm0, DWORD PTR _st+2335380
	mulss	xmm0, DWORD PTR _st+66860
	cvtsi2ss xmm1, DWORD PTR _x$[ebp]
	subss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _x$[ebp], eax

; 6622 : 				y-=(float) st.Camera.position.y*st.Current_Map.fr_v;

	cvtsi2ss xmm0, DWORD PTR _st+2335384
	mulss	xmm0, DWORD PTR _st+66860
	cvtsi2ss xmm1, DWORD PTR _y$[ebp]
	subss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _y$[ebp], eax

; 6623 : 
; 6624 : 				sizex*=st.Camera.dimension.x;

	cvtsi2ss xmm0, DWORD PTR _sizex$[ebp]
	mulss	xmm0, DWORD PTR _st+2335396
	cvttss2si eax, xmm0
	mov	DWORD PTR _sizex$[ebp], eax

; 6625 : 				sizey*=st.Camera.dimension.y;

	cvtsi2ss xmm0, DWORD PTR _sizey$[ebp]
	mulss	xmm0, DWORD PTR _st+2335400
	cvttss2si eax, xmm0
	mov	DWORD PTR _sizey$[ebp], eax

; 6626 : 
; 6627 : 				x*=st.Camera.dimension.x;

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _st+2335396
	cvttss2si eax, xmm0
	mov	DWORD PTR _x$[ebp], eax

; 6628 : 				y*=st.Camera.dimension.y;

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR _st+2335400
	cvttss2si eax, xmm0
	mov	DWORD PTR _y$[ebp], eax
$LN10@DrawString:

; 6629 : 			}
; 6630 : 
; 6631 : 			if(z>15) z=15;

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 15					; 0000000fH
	jle	SHORT $LN9@DrawString
	mov	BYTE PTR _z$[ebp], 15			; 0000000fH
$LN9@DrawString:

; 6632 : 			if(z<8) z=8;

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 8
	jge	SHORT $LN8@DrawString
	mov	BYTE PTR _z$[ebp], 8
$LN8@DrawString:

; 6633 : 
; 6634 : 			z_buffer[z][z_slot[z]]=i;

	movsx	eax, BYTE PTR _z$[ebp]
	shl	eax, 12					; 0000000cH
	movsx	ecx, BYTE PTR _z$[ebp]
	movsx	edx, WORD PTR _z_slot[ecx*2]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _z_buffer[eax+edx*2], cx

; 6635 : 			z_slot[z]++;

	movsx	eax, BYTE PTR _z$[ebp]
	mov	cx, WORD PTR _z_slot[eax*2]
	add	cx, 1
	movsx	edx, BYTE PTR _z$[ebp]
	mov	WORD PTR _z_slot[edx*2], cx

; 6636 : 
; 6637 : 			if(z>z_used) z_used=z;

	movsx	eax, BYTE PTR _z$[ebp]
	movsx	ecx, BYTE PTR _z_used
	cmp	eax, ecx
	jle	SHORT $LN7@DrawString
	mov	al, BYTE PTR _z$[ebp]
	mov	BYTE PTR _z_used, al
$LN7@DrawString:

; 6638 : 
; 6639 : 			//timej=GetTicks();
; 6640 : 
; 6641 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1195[ebp], xmm0
	movss	DWORD PTR tv1197[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv945[ebp]
	movss	xmm0, DWORD PTR tv1197[ebp]
	mulss	xmm0, DWORD PTR tv945[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1199[ebp], xmm0
	movss	DWORD PTR tv1201[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv957[ebp]
	movss	xmm0, DWORD PTR tv1201[ebp]
	mulss	xmm0, DWORD PTR tv957[ebp]
	movss	xmm1, DWORD PTR tv1199[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1195[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 6642 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1203[ebp], xmm0
	movss	DWORD PTR tv1205[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv970[ebp]
	movss	xmm0, DWORD PTR tv1205[ebp]
	mulss	xmm0, DWORD PTR tv970[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1207[ebp], xmm0
	movss	DWORD PTR tv1209[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv982[ebp]
	movss	xmm0, DWORD PTR tv1209[ebp]
	mulss	xmm0, DWORD PTR tv982[ebp]
	movss	xmm1, DWORD PTR tv1207[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1203[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 6643 : 			ent[i].vertex[2]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movsx	edx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 6644 : 
; 6645 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1211[ebp], xmm0
	movss	DWORD PTR tv1213[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv995[ebp]
	movss	xmm0, DWORD PTR tv1213[ebp]
	mulss	xmm0, DWORD PTR tv995[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1215[ebp], xmm0
	movss	DWORD PTR tv1217[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv1007[ebp]
	movss	xmm0, DWORD PTR tv1217[ebp]
	mulss	xmm0, DWORD PTR tv1007[ebp]
	movss	xmm1, DWORD PTR tv1215[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1211[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 6646 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1219[ebp], xmm0
	movss	DWORD PTR tv1221[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv1019[ebp]
	movss	xmm0, DWORD PTR tv1221[ebp]
	mulss	xmm0, DWORD PTR tv1019[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1223[ebp], xmm0
	movss	DWORD PTR tv1225[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv1031[ebp]
	movss	xmm0, DWORD PTR tv1225[ebp]
	mulss	xmm0, DWORD PTR tv1031[ebp]
	movss	xmm1, DWORD PTR tv1223[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1219[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 6647 : 			ent[i].vertex[5]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	movsx	ecx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 6648 : 
; 6649 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1227[ebp], xmm0
	movss	DWORD PTR tv1229[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv1044[ebp]
	movss	xmm0, DWORD PTR tv1229[ebp]
	mulss	xmm0, DWORD PTR tv1044[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1231[ebp], xmm0
	movss	DWORD PTR tv1233[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv1055[ebp]
	movss	xmm0, DWORD PTR tv1233[ebp]
	mulss	xmm0, DWORD PTR tv1055[ebp]
	movss	xmm1, DWORD PTR tv1231[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1227[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 6
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 6650 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1235[ebp], xmm0
	movss	DWORD PTR tv1237[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv1067[ebp]
	movss	xmm0, DWORD PTR tv1237[ebp]
	mulss	xmm0, DWORD PTR tv1067[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1239[ebp], xmm0
	movss	DWORD PTR tv1241[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv1078[ebp]
	movss	xmm0, DWORD PTR tv1241[ebp]
	mulss	xmm0, DWORD PTR tv1078[ebp]
	movss	xmm1, DWORD PTR tv1239[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1235[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 7
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 6651 : 			ent[i].vertex[8]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 3
	movsx	edx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 6652 : 
; 6653 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1243[ebp], xmm0
	movss	DWORD PTR tv1245[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv1092[ebp]
	movss	xmm0, DWORD PTR tv1245[ebp]
	mulss	xmm0, DWORD PTR tv1092[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1247[ebp], xmm0
	movss	DWORD PTR tv1249[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv1103[ebp]
	movss	xmm0, DWORD PTR tv1249[ebp]
	mulss	xmm0, DWORD PTR tv1103[ebp]
	movss	xmm1, DWORD PTR tv1247[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1243[ebp]
	addss	xmm0, xmm1
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 9
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 6654 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1251[ebp], xmm0
	movss	DWORD PTR tv1253[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv1116[ebp]
	movss	xmm0, DWORD PTR tv1253[ebp]
	mulss	xmm0, DWORD PTR tv1116[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1255[ebp], xmm0
	movss	DWORD PTR tv1257[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv1127[ebp]
	movss	xmm0, DWORD PTR tv1257[ebp]
	mulss	xmm0, DWORD PTR tv1127[ebp]
	movss	xmm1, DWORD PTR tv1255[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1251[ebp]
	addss	xmm0, xmm1
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 10
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 6655 : 			ent[i].vertex[11]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 11
	movsx	ecx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 6656 : 
; 6657 : 			ang/=10;

	movsx	eax, WORD PTR _ang$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	WORD PTR _ang$[ebp], ax

; 6658 : 
; 6659 : 			tmp=cos((ang*pi)/180);

	movsx	eax, WORD PTR _ang$[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm0, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	DWORD PTR _tmp$[ebp]

; 6660 : 			tmp=mCos(ang*10);

	movsx	eax, WORD PTR _ang$[ebp]
	imul	ecx, eax, 10
	push	ecx
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR _tmp$[ebp]

; 6661 : 	
; 6662 : 			ax=(float) 1/(16384.0f/2);

	movss	xmm0, DWORD PTR __real@39000000
	movss	DWORD PTR _ax$[ebp], xmm0

; 6663 : 			ay=(float) 1/(9216.0f/2);

	movss	xmm0, DWORD PTR __real@39638e39
	movss	DWORD PTR _ay$[ebp], xmm0

; 6664 : 
; 6665 : 			ay*=-1.0f;

	movss	xmm0, DWORD PTR _ay$[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _ay$[ebp], xmm0

; 6666 : 
; 6667 : 			az=(float) 1/(4096/2);

	movss	xmm0, DWORD PTR __real@3a000000
	movss	DWORD PTR _az$[ebp], xmm0

; 6668 : 
; 6669 : 			
; 6670 : 				ent[i].texcor[0]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 6671 : 				ent[i].texcor[1]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 6672 : 				ent[i].texcor[2]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 6673 : 				ent[i].texcor[3]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 6674 : 				ent[i].texcor[4]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 6675 : 				ent[i].texcor[5]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 6676 : 				ent[i].texcor[6]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 6
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 6677 : 				ent[i].texcor[7]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 7
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 6678 : 
; 6679 : 			for(j=0;j<12;j+=3)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN6@DrawString
$LN5@DrawString:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 3
	mov	DWORD PTR _j$[ebp], eax
$LN6@DrawString:
	cmp	DWORD PTR _j$[ebp], 12			; 0000000cH
	jae	$LN4@DrawString

; 6680 : 			{
; 6681 : 				ent[i].vertex[j]*=ax;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+100]
	mulss	xmm0, DWORD PTR _ax$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 6682 : 				ent[i].vertex[j]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+100]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 6683 : 
; 6684 : 				ent[i].vertex[j+1]*=ay;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+104]
	mulss	xmm0, DWORD PTR _ay$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 6685 : 				ent[i].vertex[j+1]+=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+104]
	addss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 6686 : 				
; 6687 : 				ent[i].vertex[j+2]*=az;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+108]
	mulss	xmm0, DWORD PTR _az$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 6688 : 				ent[i].vertex[j+2]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+108]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 6689 : 			}

	jmp	$LN5@DrawString
$LN4@DrawString:

; 6690 : 
; 6691 : 			for(j=0;j<16;j+=4)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN3@DrawString
$LN2@DrawString:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 4
	mov	DWORD PTR _j$[ebp], eax
$LN3@DrawString:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jae	SHORT $LN1@DrawString

; 6692 : 			{
; 6693 : 				ent[i].color[j]=r;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _ent[eax+ecx+228], dl

; 6694 : 				ent[i].color[j+1]=g;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _ent[eax+ecx+229], dl

; 6695 : 				ent[i].color[j+2]=b;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _ent[eax+ecx+230], dl

; 6696 : 				ent[i].color[j+3]=a;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR _ent[eax+ecx+231], dl

; 6697 : 			}

	jmp	SHORT $LN2@DrawString
$LN1@DrawString:

; 6698 : 
; 6699 : 			
; 6700 : 				texone_ids[texone_num]=i;

	movzx	eax, WORD PTR _texone_num
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _texone_ids[eax*2], cx

; 6701 : 				texone_num++;

	mov	ax, WORD PTR _texone_num
	add	ax, 1
	mov	WORD PTR _texone_num, ax

; 6702 : 
; 6703 : #endif
; 6704 : 
; 6705 : 			st.num_entities++;

	mov	eax, DWORD PTR _st+244
	add	eax, 1
	mov	DWORD PTR _st+244, eax

; 6706 : 
; 6707 : 	return 0;

	xor	al, al
$LN40@DrawString:

; 6708 : 
; 6709 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN44@DrawString
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 444				; 000001bcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN44@DrawString:
	DD	1
	DD	$LN43@DrawString
$LN43@DrawString:
	DD	-140					; ffffff74H
	DD	4
	DD	$LN42@DrawString
$LN42@DrawString:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	0
_DrawString2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawLine
_TEXT	SEGMENT
tv1028 = -456						; size = 4
tv1021 = -456						; size = 4
tv1013 = -456						; size = 4
tv1006 = -456						; size = 4
tv998 = -456						; size = 4
tv991 = -456						; size = 4
tv983 = -456						; size = 4
tv976 = -456						; size = 4
tv1239 = -452						; size = 4
tv1235 = -452						; size = 4
tv1231 = -452						; size = 4
tv1227 = -452						; size = 4
tv1223 = -452						; size = 4
tv1219 = -452						; size = 4
tv1183 = -452						; size = 4
tv1179 = -452						; size = 4
tv1096 = -452						; size = 4
tv1088 = -452						; size = 4
tv1080 = -452						; size = 4
tv1072 = -452						; size = 4
tv1064 = -452						; size = 4
tv1056 = -452						; size = 4
tv1048 = -452						; size = 4
tv1040 = -452						; size = 4
tv1255 = -448						; size = 4
tv1253 = -448						; size = 4
tv1251 = -448						; size = 4
tv1249 = -448						; size = 4
tv1247 = -448						; size = 4
tv1245 = -448						; size = 4
tv1243 = -448						; size = 4
tv1241 = -448						; size = 4
tv1237 = -448						; size = 4
tv1233 = -448						; size = 4
tv1229 = -448						; size = 4
tv1225 = -448						; size = 4
tv1221 = -448						; size = 4
tv1217 = -448						; size = 4
tv1181 = -448						; size = 4
tv1177 = -448						; size = 4
$T1 = -437						; size = 1
$T2 = -425						; size = 1
$T3 = -413						; size = 1
$T4 = -401						; size = 1
_ty2$ = -200						; size = 4
_tx2$ = -188						; size = 4
_ty1$ = -176						; size = 4
_tx1$ = -164						; size = 4
_ang2$ = -152						; size = 4
_az$ = -140						; size = 4
_ay$ = -128						; size = 4
_ax$ = -116						; size = 4
_ang$ = -104						; size = 2
_y3$ = -80						; size = 4
_x3$ = -68						; size = 4
_k$ = -56						; size = 2
_j$ = -44						; size = 2
_i$ = -32						; size = 2
_valy$ = -17						; size = 1
_valx$ = -5						; size = 1
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
_r$ = 24						; size = 1
_g$ = 28						; size = 1
_b$ = 32						; size = 1
_a$ = 36						; size = 1
_linewidth$ = 40					; size = 2
_z$ = 44						; size = 4
_DrawLine PROC						; COMDAT

; 5869 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 456				; 000001c8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-456]
	mov	ecx, 114				; 00000072H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T4[ebp], 0
	mov	BYTE PTR $T3[ebp], 0
	mov	BYTE PTR $T2[ebp], 0
	mov	BYTE PTR $T1[ebp], 0

; 5870 : 	uint8 valx=0, valy=0;

	mov	BYTE PTR _valx$[ebp], 0
	mov	BYTE PTR _valy$[ebp], 0

; 5871 : 
; 5872 : 	uint16 i=0, j=0, k=0;

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax

; 5873 : 
; 5874 : 	int32 x3, y3;
; 5875 : 
; 5876 : 	uint32 a1;
; 5877 : 
; 5878 : 	int16 ang;
; 5879 : 
; 5880 : 	float ax=1/(GAME_WIDTH/2), ay=1/(9216.0f/2), az=1/(4096/2), ang2, tx1, ty1, tx2, ty2;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ax$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@39638e39
	movss	DWORD PTR _ay$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _az$[ebp], xmm0

; 5881 : 
; 5882 : 	i=st.num_entities;

	mov	ax, WORD PTR _st+244
	mov	WORD PTR _i$[ebp], ax

; 5883 : 
; 5884 : 	if(i==MAX_GRAPHICS-1 && ent[i].stat==USED)

	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, 2047				; 000007ffH
	jne	SHORT $LN12@DrawLine
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	cmp	DWORD PTR _ent[ecx+40], 1
	jne	SHORT $LN12@DrawLine

; 5885 : 		return 2;

	mov	al, 2
	jmp	$LN13@DrawLine
$LN12@DrawLine:

; 5886 : 
; 5887 : 	//if(ent[i].stat==DEAD)
; 5888 : 	//{
; 5889 : 		ent[i].stat=USED;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	DWORD PTR _ent[ecx+40], 1

; 5890 : 		st.num_entities++;

	mov	eax, DWORD PTR _st+244
	add	eax, 1
	mov	DWORD PTR _st+244, eax

; 5891 : 		ent[i].data.data=DataNT;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, DWORD PTR _DataNT
	mov	DWORD PTR _ent[ecx+44], edx

; 5892 : 		ent[i].data.vb_id=-1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	or	edx, -1
	mov	WORD PTR _ent[ecx+54], dx

; 5893 : 		ent[i].data.channel=0;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	DWORD PTR _ent[ecx+76], 0

; 5894 : 		ent[i].data.normal=0;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	BYTE PTR _ent[ecx+52], 0

; 5895 : 		ent[i].lightmapid=-1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	or	edx, -1
	mov	WORD PTR _ent[ecx+260], dx

; 5896 : 
; 5897 : 		if(z>56) z=56;

	cmp	DWORD PTR _z$[ebp], 56			; 00000038H
	jle	SHORT $LN11@DrawLine
	mov	DWORD PTR _z$[ebp], 56			; 00000038H
$LN11@DrawLine:

; 5898 : 		//else if(z<16) z+=16;
; 5899 : 
; 5900 : 		z_buffer[z][z_slot[z]]=i;

	mov	eax, DWORD PTR _z$[ebp]
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _z$[ebp]
	movsx	edx, WORD PTR _z_slot[ecx*2]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _z_buffer[eax+edx*2], cx

; 5901 : 		z_slot[z]++;

	mov	eax, DWORD PTR _z$[ebp]
	mov	cx, WORD PTR _z_slot[eax*2]
	add	cx, 1
	mov	edx, DWORD PTR _z$[ebp]
	mov	WORD PTR _z_slot[edx*2], cx

; 5902 : 
; 5903 : 		if(z>z_used) z_used=z;

	movsx	eax, BYTE PTR _z_used
	cmp	DWORD PTR _z$[ebp], eax
	jle	SHORT $LN10@DrawLine
	mov	al, BYTE PTR _z$[ebp]
	mov	BYTE PTR _z_used, al
$LN10@DrawLine:

; 5904 : 		
; 5905 : 		if(z>15)

	cmp	DWORD PTR _z$[ebp], 15			; 0000000fH
	jle	$LN9@DrawLine

; 5906 : 		{
; 5907 : 			tx1=x;

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	BYTE PTR $T1[ebp], 1
	movss	DWORD PTR _tx1$[ebp], xmm0

; 5908 : 			ty1=y;

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	BYTE PTR $T2[ebp], 1
	movss	DWORD PTR _ty1$[ebp], xmm0

; 5909 : 			tx2=x2;

	cvtsi2ss xmm0, DWORD PTR _x2$[ebp]
	mov	BYTE PTR $T3[ebp], 1
	movss	DWORD PTR _tx2$[ebp], xmm0

; 5910 : 			ty2=y2;

	cvtsi2ss xmm0, DWORD PTR _y2$[ebp]
	mov	BYTE PTR $T4[ebp], 1
	movss	DWORD PTR _ty2$[ebp], xmm0

; 5911 : 
; 5912 : 			x-=st.Camera.position.x;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, DWORD PTR _st+2335380
	mov	DWORD PTR _x$[ebp], eax

; 5913 : 			y-=st.Camera.position.y;

	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, DWORD PTR _st+2335384
	mov	DWORD PTR _y$[ebp], eax

; 5914 : 
; 5915 : 			x2-=st.Camera.position.x;

	mov	eax, DWORD PTR _x2$[ebp]
	sub	eax, DWORD PTR _st+2335380
	mov	DWORD PTR _x2$[ebp], eax

; 5916 : 			y2-=st.Camera.position.y;

	mov	eax, DWORD PTR _y2$[ebp]
	sub	eax, DWORD PTR _st+2335384
	mov	DWORD PTR _y2$[ebp], eax

; 5917 : 
; 5918 : 			x*=st.Camera.dimension.x;

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _st+2335396
	cvttss2si eax, xmm0
	mov	DWORD PTR _x$[ebp], eax

; 5919 : 			y*=st.Camera.dimension.y;

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR _st+2335400
	cvttss2si eax, xmm0
	mov	DWORD PTR _y$[ebp], eax

; 5920 : 
; 5921 : 			x2*=st.Camera.dimension.x;

	cvtsi2ss xmm0, DWORD PTR _x2$[ebp]
	mulss	xmm0, DWORD PTR _st+2335396
	cvttss2si eax, xmm0
	mov	DWORD PTR _x2$[ebp], eax

; 5922 : 			y2*=st.Camera.dimension.y;

	cvtsi2ss xmm0, DWORD PTR _y2$[ebp]
	mulss	xmm0, DWORD PTR _st+2335400
	cvttss2si eax, xmm0
	mov	DWORD PTR _y2$[ebp], eax

; 5923 : 
; 5924 : 			linewidth*=st.Camera.dimension.x;

	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _st+2335396
	cvttss2si ecx, xmm0
	mov	WORD PTR _linewidth$[ebp], cx
$LN9@DrawLine:

; 5925 : 		}
; 5926 : 		
; 5927 : 		x3=x2-x;

	mov	eax, DWORD PTR _x2$[ebp]
	sub	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _x3$[ebp], eax

; 5928 : 		y3=y2-y;

	mov	eax, DWORD PTR _y2$[ebp]
	sub	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _y3$[ebp], eax

; 5929 : 
; 5930 : 		ang2=atan2((float)y3,(float)x3);

	cvtsi2ss xmm0, DWORD PTR _x3$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y3$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _ang2$[ebp]

; 5931 : 		if(ang2==pi)

	cvtss2sd xmm0, DWORD PTR _ang2$[ebp]
	ucomisd	xmm0, QWORD PTR __real@400921fb53c8d4f1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@DrawLine

; 5932 : 			ang2=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ang2$[ebp], xmm0
$LN8@DrawLine:

; 5933 : 		ang2+=pi;

	cvtss2sd xmm0, DWORD PTR _ang2$[ebp]
	addsd	xmm0, QWORD PTR __real@400921fb53c8d4f1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _ang2$[ebp], xmm0

; 5934 : 		ang2=(180/pi)*ang2;

	cvtss2sd xmm0, DWORD PTR _ang2$[ebp]
	mulsd	xmm0, QWORD PTR __real@404ca5dc1af05a77
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _ang2$[ebp], xmm0

; 5935 : 		ang=ang2;

	cvttss2si eax, DWORD PTR _ang2$[ebp]
	mov	WORD PTR _ang$[ebp], ax

; 5936 : 		ang*=10;

	movsx	eax, WORD PTR _ang$[ebp]
	imul	ecx, eax, 10
	mov	WORD PTR _ang$[ebp], cx

; 5937 : 
; 5938 : 		linewidth/=2;

	movsx	eax, WORD PTR _linewidth$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	WORD PTR _linewidth$[ebp], ax

; 5939 : 		
; 5940 : 		ent[i].vertex[0]=(float) x-(linewidth*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1177[ebp], xmm0
	movss	DWORD PTR tv1179[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv976[ebp]
	movss	xmm0, DWORD PTR tv1179[ebp]
	mulss	xmm0, DWORD PTR tv976[ebp]
	movss	xmm1, DWORD PTR tv1177[ebp]
	subss	xmm1, xmm0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _ent[eax+edx+100], xmm1

; 5941 : 		ent[i].vertex[1]=(float) y+(linewidth*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1181[ebp], xmm0
	movss	DWORD PTR tv1183[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv983[ebp]
	movss	xmm0, DWORD PTR tv1183[ebp]
	mulss	xmm0, DWORD PTR tv983[ebp]
	movss	xmm1, DWORD PTR tv1181[ebp]
	addss	xmm1, xmm0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _ent[eax+ecx+100], xmm1

; 5942 : 		ent[i].vertex[2]=z;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	shl	edx, 1
	cvtsi2ss xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR _ent[ecx+edx+100], xmm0

; 5943 : 
; 5944 : 		ent[i].vertex[3]=(float) x2-(linewidth*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x2$[ebp]
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1217[ebp], xmm0
	movss	DWORD PTR tv1219[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv991[ebp]
	movss	xmm0, DWORD PTR tv1219[ebp]
	mulss	xmm0, DWORD PTR tv991[ebp]
	movss	xmm1, DWORD PTR tv1217[ebp]
	subss	xmm1, xmm0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR _ent[eax+edx+100], xmm1

; 5945 : 		ent[i].vertex[4]=(float) y2+(linewidth*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y2$[ebp]
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1221[ebp], xmm0
	movss	DWORD PTR tv1223[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv998[ebp]
	movss	xmm0, DWORD PTR tv1223[ebp]
	mulss	xmm0, DWORD PTR tv998[ebp]
	movss	xmm1, DWORD PTR tv1221[ebp]
	addss	xmm1, xmm0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	shl	ecx, 2
	movss	DWORD PTR _ent[eax+ecx+100], xmm1

; 5946 : 		ent[i].vertex[5]=z;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 5
	cvtsi2ss xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 5947 : 
; 5948 : 		ent[i].vertex[6]=(float) x2+(linewidth*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x2$[ebp]
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1225[ebp], xmm0
	movss	DWORD PTR tv1227[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv1006[ebp]
	movss	xmm0, DWORD PTR tv1227[ebp]
	mulss	xmm0, DWORD PTR tv1006[ebp]
	movss	xmm1, DWORD PTR tv1225[ebp]
	addss	xmm1, xmm0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	imul	edx, ecx, 6
	movss	DWORD PTR _ent[eax+edx+100], xmm1

; 5949 : 		ent[i].vertex[7]=(float) y2-(linewidth*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y2$[ebp]
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1229[ebp], xmm0
	movss	DWORD PTR tv1231[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv1013[ebp]
	movss	xmm0, DWORD PTR tv1231[ebp]
	mulss	xmm0, DWORD PTR tv1013[ebp]
	movss	xmm1, DWORD PTR tv1229[ebp]
	subss	xmm1, xmm0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	imul	edx, ecx, 7
	movss	DWORD PTR _ent[eax+edx+100], xmm1

; 5950 : 		ent[i].vertex[8]=z;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	shl	edx, 3
	cvtsi2ss xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR _ent[ecx+edx+100], xmm0

; 5951 : 
; 5952 : 		ent[i].vertex[9]=(float) x+(linewidth*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1233[ebp], xmm0
	movss	DWORD PTR tv1235[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv1021[ebp]
	movss	xmm0, DWORD PTR tv1235[ebp]
	mulss	xmm0, DWORD PTR tv1021[ebp]
	movss	xmm1, DWORD PTR tv1233[ebp]
	addss	xmm1, xmm0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	imul	edx, ecx, 9
	movss	DWORD PTR _ent[eax+edx+100], xmm1

; 5953 : 		ent[i].vertex[10]=(float) y-(linewidth*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1237[ebp], xmm0
	movss	DWORD PTR tv1239[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv1028[ebp]
	movss	xmm0, DWORD PTR tv1239[ebp]
	mulss	xmm0, DWORD PTR tv1028[ebp]
	movss	xmm1, DWORD PTR tv1237[ebp]
	subss	xmm1, xmm0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	imul	edx, ecx, 10
	movss	DWORD PTR _ent[eax+edx+100], xmm1

; 5954 : 		ent[i].vertex[11]=z;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 11
	cvtsi2ss xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 5955 : 
; 5956 : 		ax=(float) 1/(GAME_WIDTH/2);

	movss	xmm0, DWORD PTR __real@39000000
	movss	DWORD PTR _ax$[ebp], xmm0

; 5957 : 		ay=(float) 1/(9216.0f/2);

	movss	xmm0, DWORD PTR __real@39638e39
	movss	DWORD PTR _ay$[ebp], xmm0

; 5958 : 
; 5959 : 		ay*=-1.0f;

	movss	xmm0, DWORD PTR _ay$[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _ay$[ebp], xmm0

; 5960 : 
; 5961 : 		az=(float) 1/(4096/2);

	movss	xmm0, DWORD PTR __real@3a000000
	movss	DWORD PTR _az$[ebp], xmm0

; 5962 : 		
; 5963 : 		if(z>15)

	cmp	DWORD PTR _z$[ebp], 15			; 0000000fH
	jle	$LN7@DrawLine

; 5964 : 		{
; 5965 : 			/*
; 5966 : 			ent[i].texcorlight[0]=(float)tx1+(((tx1-(tx2/2))-tx1)*mCos(ang) - ((ty1-(ty2/2))-ty1)*mSin(ang));
; 5967 : 			ent[i].texcorlight[1]=(float)ty1+(((tx1-(tx2/2))-tx1)*mSin(ang) + ((ty1-(ty2/2))-ty1)*mCos(ang));
; 5968 : 
; 5969 : 			ent[i].texcorlight[2]=(float)tx1+(((tx1+(tx2/2))-tx1)*mCos(ang) - ((ty1-(ty2/2))-ty1)*mSin(ang));
; 5970 : 			ent[i].texcorlight[3]=(float)ty1+(((tx1+(tx2/2))-tx1)*mSin(ang) + ((ty1-(ty2/2))-ty1)*mCos(ang));
; 5971 : 
; 5972 : 			ent[i].texcorlight[4]=(float)tx1+(((tx1+(tx2/2))-tx1)*mCos(ang) - ((ty1+(ty2/2))-ty1)*mSin(ang));
; 5973 : 			ent[i].texcorlight[5]=(float)ty1+(((tx1+(tx2/2))-tx1)*mSin(ang) + ((ty1+(ty2/2))-ty1)*mCos(ang));
; 5974 : 
; 5975 : 			ent[i].texcorlight[6]=(float)tx1+(((tx1-(tx2/2))-tx1)*mCos(ang) - ((ty1+(ty2/2))-ty1)*mSin(ang));
; 5976 : 			ent[i].texcorlight[7]=(float)ty1+(((tx1-(tx2/2))-tx1)*mSin(ang) + ((ty1+(ty2/2))-ty1)*mCos(ang));
; 5977 : 			*/
; 5978 : 		
; 5979 : 			ent[i].texcorlight[0]=(float) tx1-(linewidth*mSin(ang));

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN15@DrawLine
	push	OFFSET $LN16@DrawLine
	call	__RTC_UninitUse
	add	esp, 4
$LN15@DrawLine:
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1241[ebp], xmm0
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv1040[ebp]
	movss	xmm0, DWORD PTR tv1241[ebp]
	mulss	xmm0, DWORD PTR tv1040[ebp]
	movss	xmm1, DWORD PTR _tx1$[ebp]
	subss	xmm1, xmm0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _ent[eax+edx+180], xmm1

; 5980 : 			ent[i].texcorlight[1]=(float) ty1+(linewidth*mCos(ang));

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN17@DrawLine
	push	OFFSET $LN18@DrawLine
	call	__RTC_UninitUse
	add	esp, 4
$LN17@DrawLine:
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1243[ebp], xmm0
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv1048[ebp]
	movss	xmm0, DWORD PTR tv1243[ebp]
	mulss	xmm0, DWORD PTR tv1048[ebp]
	addss	xmm0, DWORD PTR _ty1$[ebp]
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _ent[eax+ecx+180], xmm0

; 5981 : 
; 5982 : 			ent[i].texcorlight[2]=(float) tx2-(linewidth*mSin(ang));

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN19@DrawLine
	push	OFFSET $LN20@DrawLine
	call	__RTC_UninitUse
	add	esp, 4
$LN19@DrawLine:
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1245[ebp], xmm0
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv1056[ebp]
	movss	xmm0, DWORD PTR tv1245[ebp]
	mulss	xmm0, DWORD PTR tv1056[ebp]
	movss	xmm1, DWORD PTR _tx2$[ebp]
	subss	xmm1, xmm0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _ent[eax+ecx+180], xmm1

; 5983 : 			ent[i].texcorlight[3]=(float) ty2+(linewidth*mCos(ang));

	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN21@DrawLine
	push	OFFSET $LN22@DrawLine
	call	__RTC_UninitUse
	add	esp, 4
$LN21@DrawLine:
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1247[ebp], xmm0
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv1064[ebp]
	movss	xmm0, DWORD PTR tv1247[ebp]
	mulss	xmm0, DWORD PTR tv1064[ebp]
	addss	xmm0, DWORD PTR _ty2$[ebp]
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR _ent[eax+edx+180], xmm0

; 5984 : 
; 5985 : 			ent[i].texcorlight[4]=(float) tx2+(linewidth*mSin(ang));

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN23@DrawLine
	push	OFFSET $LN20@DrawLine
	call	__RTC_UninitUse
	add	esp, 4
$LN23@DrawLine:
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1249[ebp], xmm0
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv1072[ebp]
	movss	xmm0, DWORD PTR tv1249[ebp]
	mulss	xmm0, DWORD PTR tv1072[ebp]
	addss	xmm0, DWORD PTR _tx2$[ebp]
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	shl	ecx, 2
	movss	DWORD PTR _ent[eax+ecx+180], xmm0

; 5986 : 			ent[i].texcorlight[5]=(float) ty2-(linewidth*mCos(ang));

	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN24@DrawLine
	push	OFFSET $LN22@DrawLine
	call	__RTC_UninitUse
	add	esp, 4
$LN24@DrawLine:
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1251[ebp], xmm0
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv1080[ebp]
	movss	xmm0, DWORD PTR tv1251[ebp]
	mulss	xmm0, DWORD PTR tv1080[ebp]
	movss	xmm1, DWORD PTR _ty2$[ebp]
	subss	xmm1, xmm0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	imul	edx, ecx, 5
	movss	DWORD PTR _ent[eax+edx+180], xmm1

; 5987 : 
; 5988 : 			ent[i].texcorlight[6]=(float) tx1+(linewidth*mSin(ang));

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN25@DrawLine
	push	OFFSET $LN16@DrawLine
	call	__RTC_UninitUse
	add	esp, 4
$LN25@DrawLine:
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1253[ebp], xmm0
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv1088[ebp]
	movss	xmm0, DWORD PTR tv1253[ebp]
	mulss	xmm0, DWORD PTR tv1088[ebp]
	addss	xmm0, DWORD PTR _tx1$[ebp]
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	imul	edx, ecx, 6
	movss	DWORD PTR _ent[eax+edx+180], xmm0

; 5989 : 			ent[i].texcorlight[7]=(float) ty1-(linewidth*mCos(ang));

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN26@DrawLine
	push	OFFSET $LN18@DrawLine
	call	__RTC_UninitUse
	add	esp, 4
$LN26@DrawLine:
	movsx	eax, WORD PTR _linewidth$[ebp]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1255[ebp], xmm0
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv1096[ebp]
	movss	xmm0, DWORD PTR tv1255[ebp]
	mulss	xmm0, DWORD PTR tv1096[ebp]
	movss	xmm1, DWORD PTR _ty1$[ebp]
	subss	xmm1, xmm0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	imul	edx, ecx, 7
	movss	DWORD PTR _ent[eax+edx+180], xmm1

; 5990 : 
; 5991 : 			WTSf(&ent[i].texcorlight[0],&ent[i].texcorlight[1]);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR _ent[ecx+edx+180]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	mov	eax, 4
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _ent[edx+ecx+180]
	push	edx
	call	_WTSf
	add	esp, 8

; 5992 : 			WTSf(&ent[i].texcorlight[2],&ent[i].texcorlight[3]);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 3
	lea	ecx, DWORD PTR _ent[ecx+eax+180]
	push	ecx
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	shl	ecx, 1
	lea	edx, DWORD PTR _ent[eax+ecx+180]
	push	edx
	call	_WTSf
	add	esp, 8

; 5993 : 			WTSf(&ent[i].texcorlight[4],&ent[i].texcorlight[5]);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 5
	lea	ecx, DWORD PTR _ent[ecx+eax+180]
	push	ecx
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	shl	ecx, 2
	lea	edx, DWORD PTR _ent[eax+ecx+180]
	push	edx
	call	_WTSf
	add	esp, 8

; 5994 : 			WTSf(&ent[i].texcorlight[6],&ent[i].texcorlight[7]);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 7
	lea	ecx, DWORD PTR _ent[ecx+eax+180]
	push	ecx
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	mov	ecx, 4
	imul	edx, ecx, 6
	lea	eax, DWORD PTR _ent[eax+edx+180]
	push	eax
	call	_WTSf
	add	esp, 8

; 5995 : 			
; 5996 : 			ent[i].texcorlight[0]/=(float) st.screenx;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 0
	movzx	edx, WORD PTR _st+228
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _ent[ecx+eax+180]
	divss	xmm1, xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	movss	DWORD PTR _ent[eax+ecx+180], xmm1

; 5997 : 			ent[i].texcorlight[1]/=(float) st.screeny;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	shl	edx, 0
	movzx	eax, WORD PTR _st+230
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _ent[ecx+edx+180]
	divss	xmm1, xmm0
	mov	ecx, 4
	shl	ecx, 0
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	movss	DWORD PTR _ent[eax+ecx+180], xmm1

; 5998 : 			ent[i].texcorlight[2]/=(float) st.screenx;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	shl	edx, 1
	movzx	eax, WORD PTR _st+228
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _ent[ecx+edx+180]
	divss	xmm1, xmm0
	mov	ecx, 4
	shl	ecx, 1
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	movss	DWORD PTR _ent[eax+ecx+180], xmm1

; 5999 : 			ent[i].texcorlight[3]/=(float) st.screeny;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 3
	movzx	edx, WORD PTR _st+230
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _ent[ecx+eax+180]
	divss	xmm1, xmm0
	mov	eax, 4
	imul	ecx, eax, 3
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	movss	DWORD PTR _ent[eax+ecx+180], xmm1

; 6000 : 			ent[i].texcorlight[4]/=(float) st.screenx;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	shl	edx, 2
	movzx	eax, WORD PTR _st+228
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _ent[ecx+edx+180]
	divss	xmm1, xmm0
	mov	ecx, 4
	shl	ecx, 2
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	movss	DWORD PTR _ent[eax+ecx+180], xmm1

; 6001 : 			ent[i].texcorlight[5]/=(float) st.screeny;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 5
	movzx	edx, WORD PTR _st+230
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _ent[ecx+eax+180]
	divss	xmm1, xmm0
	mov	eax, 4
	imul	ecx, eax, 5
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	movss	DWORD PTR _ent[eax+ecx+180], xmm1

; 6002 : 			ent[i].texcorlight[6]/=(float) st.screenx;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 6
	movzx	edx, WORD PTR _st+228
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _ent[ecx+eax+180]
	divss	xmm1, xmm0
	mov	eax, 4
	imul	ecx, eax, 6
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	movss	DWORD PTR _ent[eax+ecx+180], xmm1

; 6003 : 			ent[i].texcorlight[7]/=(float) st.screeny;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 7
	movzx	edx, WORD PTR _st+230
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _ent[ecx+eax+180]
	divss	xmm1, xmm0
	mov	eax, 4
	imul	ecx, eax, 7
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 264
	movss	DWORD PTR _ent[eax+ecx+180], xmm1

; 6004 : 
; 6005 : 			ent[i].texcorlight[1]*=-1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _ent[ecx+edx+180]
	mulss	xmm0, DWORD PTR __real@bf800000
	mov	eax, 4
	shl	eax, 0
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	movss	DWORD PTR _ent[edx+eax+180], xmm0

; 6006 : 			ent[i].texcorlight[3]*=-1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 3
	movss	xmm0, DWORD PTR _ent[ecx+eax+180]
	mulss	xmm0, DWORD PTR __real@bf800000
	mov	ecx, 4
	imul	edx, ecx, 3
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movss	DWORD PTR _ent[ecx+edx+180], xmm0

; 6007 : 			ent[i].texcorlight[5]*=-1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 5
	movss	xmm0, DWORD PTR _ent[ecx+eax+180]
	mulss	xmm0, DWORD PTR __real@bf800000
	mov	ecx, 4
	imul	edx, ecx, 5
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movss	DWORD PTR _ent[ecx+edx+180], xmm0

; 6008 : 			ent[i].texcorlight[7]*=-1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 7
	movss	xmm0, DWORD PTR _ent[ecx+eax+180]
	mulss	xmm0, DWORD PTR __real@bf800000
	mov	ecx, 4
	imul	edx, ecx, 7
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movss	DWORD PTR _ent[ecx+edx+180], xmm0
$LN7@DrawLine:

; 6009 : 		}
; 6010 : 
; 6011 : 		ent[i].texcor[0]=0.0f;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[ecx+eax+148], xmm0

; 6012 : 		ent[i].texcor[1]=0.0f;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[ecx+edx+148], xmm0

; 6013 : 		ent[i].texcor[2]=1.0f;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[ecx+edx+148], xmm0

; 6014 : 		ent[i].texcor[3]=0.0f;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 3
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[ecx+eax+148], xmm0

; 6015 : 		ent[i].texcor[4]=1.0f;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	shl	edx, 2
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[ecx+edx+148], xmm0

; 6016 : 		ent[i].texcor[5]=1.0f;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 5
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[ecx+eax+148], xmm0

; 6017 : 		ent[i].texcor[6]=0.0f;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 6
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ent[ecx+eax+148], xmm0

; 6018 : 		ent[i].texcor[7]=1.0f;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	mov	edx, 4
	imul	eax, edx, 7
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[ecx+eax+148], xmm0

; 6019 : 
; 6020 : 		for(j=0;j<12;j+=3)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN6@DrawLine
$LN5@DrawLine:
	movzx	eax, WORD PTR _j$[ebp]
	add	eax, 3
	mov	WORD PTR _j$[ebp], ax
$LN6@DrawLine:
	movzx	eax, WORD PTR _j$[ebp]
	cmp	eax, 12					; 0000000cH
	jge	$LN4@DrawLine

; 6021 : 		{
; 6022 : 			ent[i].vertex[j]*=ax;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[ecx+edx*4+100]
	mulss	xmm0, DWORD PTR _ax$[ebp]
	movzx	eax, WORD PTR _j$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 6023 : 			ent[i].vertex[j]-=1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[ecx+edx*4+100]
	subss	xmm0, DWORD PTR __real@3f800000
	movzx	eax, WORD PTR _j$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 6024 : 
; 6025 : 			ent[i].vertex[j+1]*=ay;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[ecx+edx*4+104]
	mulss	xmm0, DWORD PTR _ay$[ebp]
	movzx	eax, WORD PTR _j$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 6026 : 			ent[i].vertex[j+1]+=1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[ecx+edx*4+104]
	addss	xmm0, DWORD PTR __real@3f800000
	movzx	eax, WORD PTR _j$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 6027 : 				
; 6028 : 			ent[i].vertex[j+2]*=az;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[ecx+edx*4+108]
	mulss	xmm0, DWORD PTR _az$[ebp]
	movzx	eax, WORD PTR _j$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 6029 : 			ent[i].vertex[j+2]-=1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[ecx+edx*4+108]
	subss	xmm0, DWORD PTR __real@3f800000
	movzx	eax, WORD PTR _j$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 264
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 6030 : 				
; 6031 : 		}

	jmp	$LN5@DrawLine
$LN4@DrawLine:

; 6032 : 
; 6033 : 		for(j=0;j<16;j+=4)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN3@DrawLine
$LN2@DrawLine:
	movzx	eax, WORD PTR _j$[ebp]
	add	eax, 4
	mov	WORD PTR _j$[ebp], ax
$LN3@DrawLine:
	movzx	eax, WORD PTR _j$[ebp]
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN1@DrawLine

; 6034 : 		{
; 6035 : 			ent[i].color[j]=r;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	mov	al, BYTE PTR _r$[ebp]
	mov	BYTE PTR _ent[ecx+edx+228], al

; 6036 : 			ent[i].color[j+1]=g;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	mov	al, BYTE PTR _g$[ebp]
	mov	BYTE PTR _ent[ecx+edx+229], al

; 6037 : 			ent[i].color[j+2]=b;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _ent[ecx+edx+230], al

; 6038 : 			ent[i].color[j+3]=a;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 264
	movzx	edx, WORD PTR _j$[ebp]
	mov	al, BYTE PTR _a$[ebp]
	mov	BYTE PTR _ent[ecx+edx+231], al

; 6039 : 		}

	jmp	SHORT $LN2@DrawLine
$LN1@DrawLine:

; 6040 : 
; 6041 : 		texone_ids[texone_num]=i;

	movzx	eax, WORD PTR _texone_num
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _texone_ids[eax*2], cx

; 6042 : 		texone_num++;

	mov	ax, WORD PTR _texone_num
	add	ax, 1
	mov	WORD PTR _texone_num, ax

; 6043 : 	//}
; 6044 : 
; 6045 : 	return 0;

	xor	al, al
$LN13@DrawLine:

; 6046 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 456				; 000001c8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@DrawLine:
$LN22@DrawLine:
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	50					; 00000032H
	DB	0
$LN20@DrawLine:
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	50					; 00000032H
	DB	0
$LN18@DrawLine:
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	49					; 00000031H
	DB	0
$LN16@DrawLine:
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	49					; 00000031H
	DB	0
_DrawLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawObj
_TEXT	SEGMENT
tv1015 = -468						; size = 4
tv991 = -468						; size = 4
tv966 = -468						; size = 4
tv943 = -468						; size = 4
tv919 = -468						; size = 4
tv895 = -468						; size = 4
tv870 = -468						; size = 4
tv845 = -468						; size = 4
tv1198 = -464						; size = 4
tv1190 = -464						; size = 4
tv1182 = -464						; size = 4
tv1174 = -464						; size = 4
tv1166 = -464						; size = 4
tv1158 = -464						; size = 4
tv1118 = -464						; size = 4
tv1110 = -464						; size = 4
tv1196 = -460						; size = 4
tv1188 = -460						; size = 4
tv1180 = -460						; size = 4
tv1172 = -460						; size = 4
tv1164 = -460						; size = 4
tv1156 = -460						; size = 4
tv1116 = -460						; size = 4
tv1108 = -460						; size = 4
tv1004 = -456						; size = 4
tv980 = -456						; size = 4
tv955 = -456						; size = 4
tv932 = -456						; size = 4
tv907 = -456						; size = 4
tv883 = -456						; size = 4
tv858 = -456						; size = 4
tv833 = -456						; size = 4
tv1194 = -452						; size = 4
tv1186 = -452						; size = 4
tv1178 = -452						; size = 4
tv1170 = -452						; size = 4
tv1162 = -452						; size = 4
tv1154 = -452						; size = 4
tv1114 = -452						; size = 4
tv1106 = -452						; size = 4
tv1192 = -448						; size = 4
tv1184 = -448						; size = 4
tv1176 = -448						; size = 4
tv1168 = -448						; size = 4
tv1160 = -448						; size = 4
tv1152 = -448						; size = 4
tv1112 = -448						; size = 4
tv1104 = -448						; size = 4
_dim$ = -248						; size = 12
_t4$ = -204						; size = 4
_t3$ = -192						; size = 4
_k$ = -156						; size = 4
_j$ = -144						; size = 4
_i$ = -132						; size = 4
_valy$ = -117						; size = 1
_valx$ = -105						; size = 1
_ty2$ = -96						; size = 4
_tx2$ = -84						; size = 4
_ty1$ = -72						; size = 4
_tx1$ = -60						; size = 4
_az$ = -48						; size = 4
_ay$ = -36						; size = 4
_ax$ = -24						; size = 4
_tmp$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_sizex$ = 16						; size = 4
_sizey$ = 20						; size = 4
_ang$ = 24						; size = 2
_r$ = 28						; size = 1
_g$ = 32						; size = 1
_b$ = 36						; size = 1
_data$ = 40						; size = 40
_a$ = 80						; size = 1
_x1$ = 84						; size = 4
_y1$ = 88						; size = 4
_x2$ = 92						; size = 4
_y2$ = 96						; size = 4
_z$ = 100						; size = 1
_lightmap_id$ = 104					; size = 2
_DrawObj PROC						; COMDAT

; 4684 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 468				; 000001d4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-468]
	mov	ecx, 117				; 00000075H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4685 : 	float tmp, ax, ay, az, tx1, ty1, tx2, ty2;
; 4686 : 
; 4687 : 	uint8 valx=0, valy=0;

	mov	BYTE PTR _valx$[ebp], 0
	mov	BYTE PTR _valy$[ebp], 0

; 4688 : 	uint32 i=0, j=0, k=0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _k$[ebp], 0

; 4689 : 	int32 t1, t2, t3, t4, timej, timel;
; 4690 : 
; 4691 : 	PosF dim=st.Camera.dimension;

	mov	eax, DWORD PTR _st+2335396
	mov	DWORD PTR _dim$[ebp], eax
	mov	ecx, DWORD PTR _st+2335400
	mov	DWORD PTR _dim$[ebp+4], ecx
	mov	edx, DWORD PTR _st+2335404
	mov	DWORD PTR _dim$[ebp+8], edx

; 4692 : 	
; 4693 : 	x-=st.Camera.position.x;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, DWORD PTR _st+2335380
	mov	DWORD PTR _x$[ebp], eax

; 4694 : 	y-=st.Camera.position.y;

	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, DWORD PTR _st+2335384
	mov	DWORD PTR _y$[ebp], eax

; 4695 : 	
; 4696 : 	if(dim.x<0) dim.x*=-1;

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _dim$[ebp]
	jbe	SHORT $LN31@DrawObj
	movss	xmm0, DWORD PTR _dim$[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _dim$[ebp], xmm0
$LN31@DrawObj:

; 4697 : 	if(dim.y<0) dim.y*=-1;

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _dim$[ebp+4]
	jbe	SHORT $LN30@DrawObj
	movss	xmm0, DWORD PTR _dim$[ebp+4]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _dim$[ebp+4], xmm0
$LN30@DrawObj:

; 4698 : 
; 4699 : 	if(dim.x<10) dim.x=GAME_WIDTH/dim.x;

	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR _dim$[ebp]
	jbe	SHORT $LN29@DrawObj
	movss	xmm0, DWORD PTR __real@46800000
	divss	xmm0, DWORD PTR _dim$[ebp]
	movss	DWORD PTR _dim$[ebp], xmm0
	jmp	SHORT $LN28@DrawObj
$LN29@DrawObj:

; 4700 : 	else dim.x*=GAME_WIDTH;

	movss	xmm0, DWORD PTR _dim$[ebp]
	mulss	xmm0, DWORD PTR __real@46800000
	movss	DWORD PTR _dim$[ebp], xmm0
$LN28@DrawObj:

; 4701 : 	if(dim.y<10) dim.y=GAME_HEIGHT/dim.y;

	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR _dim$[ebp+4]
	jbe	SHORT $LN27@DrawObj
	movss	xmm0, DWORD PTR __real@46100000
	divss	xmm0, DWORD PTR _dim$[ebp+4]
	movss	DWORD PTR _dim$[ebp+4], xmm0
	jmp	SHORT $LN26@DrawObj
$LN27@DrawObj:

; 4702 : 	else dim.y*=GAME_HEIGHT;

	movss	xmm0, DWORD PTR _dim$[ebp+4]
	mulss	xmm0, DWORD PTR __real@46100000
	movss	DWORD PTR _dim$[ebp+4], xmm0
$LN26@DrawObj:

; 4703 : 
; 4704 : 	t3=(int32) dim.x;

	cvttss2si eax, DWORD PTR _dim$[ebp]
	mov	DWORD PTR _t3$[ebp], eax

; 4705 : 	t4=(int32) dim.y;

	cvttss2si eax, DWORD PTR _dim$[ebp+4]
	mov	DWORD PTR _t4$[ebp], eax

; 4706 : 
; 4707 : 	//Checkbounds(x,y,sizex,sizey,ang,t3,t4)) return 1;
; 4708 : 			
; 4709 : 	if(st.num_entities==MAX_GRAPHICS-1)

	cmp	DWORD PTR _st+244, 2047			; 000007ffH
	jne	SHORT $LN25@DrawObj

; 4710 : 		return 2;

	mov	al, 2
	jmp	$LN32@DrawObj

; 4711 : 	else

	jmp	SHORT $LN24@DrawObj
$LN25@DrawObj:

; 4712 : 		i=st.num_entities;

	mov	eax, DWORD PTR _st+244
	mov	DWORD PTR _i$[ebp], eax
$LN24@DrawObj:

; 4713 : 
; 4714 : 	ent[i].lightmapid=lightmap_id;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	cx, WORD PTR _lightmap_id$[ebp]
	mov	WORD PTR _ent[eax+260], cx

; 4715 : 	
; 4716 : 			ent[i].data=data;

	imul	edi, DWORD PTR _i$[ebp], 264
	add	edi, OFFSET _ent+44
	mov	ecx, 10					; 0000000aH
	lea	esi, DWORD PTR _data$[ebp]
	rep movsd

; 4717 : 
; 4718 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 4719 : 
; 4720 : 			if(r==0 && g==0 && b==0)

	movzx	eax, BYTE PTR _r$[ebp]
	test	eax, eax
	jne	SHORT $LN23@DrawObj
	movzx	eax, BYTE PTR _g$[ebp]
	test	eax, eax
	jne	SHORT $LN23@DrawObj
	movzx	eax, BYTE PTR _b$[ebp]
	test	eax, eax
	jne	SHORT $LN23@DrawObj

; 4721 : 				r=g=b=1;

	mov	BYTE PTR _b$[ebp], 1
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _g$[ebp], al
	mov	cl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _r$[ebp], cl
$LN23@DrawObj:

; 4722 : 
; 4723 : 			sizex*=st.Camera.dimension.x;

	cvtsi2ss xmm0, DWORD PTR _sizex$[ebp]
	mulss	xmm0, DWORD PTR _st+2335396
	cvttss2si eax, xmm0
	mov	DWORD PTR _sizex$[ebp], eax

; 4724 : 			sizey*=st.Camera.dimension.y;

	cvtsi2ss xmm0, DWORD PTR _sizey$[ebp]
	mulss	xmm0, DWORD PTR _st+2335400
	cvttss2si eax, xmm0
	mov	DWORD PTR _sizey$[ebp], eax

; 4725 : 
; 4726 : 			if(z>56) 

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 56					; 00000038H
	jle	SHORT $LN22@DrawObj

; 4727 : 				z=56;

	mov	BYTE PTR _z$[ebp], 56			; 00000038H

; 4728 : 			else 

	jmp	SHORT $LN20@DrawObj
$LN22@DrawObj:

; 4729 : 				if(z<16) 

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN20@DrawObj

; 4730 : 					z+=16;

	movsx	eax, BYTE PTR _z$[ebp]
	add	eax, 16					; 00000010H
	mov	BYTE PTR _z$[ebp], al
$LN20@DrawObj:

; 4731 : 
; 4732 : 			z_buffer[z][z_slot[z]]=i;

	movsx	eax, BYTE PTR _z$[ebp]
	shl	eax, 12					; 0000000cH
	movsx	ecx, BYTE PTR _z$[ebp]
	movsx	edx, WORD PTR _z_slot[ecx*2]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _z_buffer[eax+edx*2], cx

; 4733 : 			z_slot[z]++;

	movsx	eax, BYTE PTR _z$[ebp]
	mov	cx, WORD PTR _z_slot[eax*2]
	add	cx, 1
	movsx	edx, BYTE PTR _z$[ebp]
	mov	WORD PTR _z_slot[edx*2], cx

; 4734 : 
; 4735 : 			if(z>z_used) z_used=z;

	movsx	eax, BYTE PTR _z$[ebp]
	movsx	ecx, BYTE PTR _z_used
	cmp	eax, ecx
	jle	SHORT $LN19@DrawObj
	mov	al, BYTE PTR _z$[ebp]
	mov	BYTE PTR _z_used, al
$LN19@DrawObj:

; 4736 : 
; 4737 : 			if(z>47)

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 47					; 0000002fH
	jle	SHORT $LN18@DrawObj

; 4738 : 			{
; 4739 : 				x+=st.Camera.position.x;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _st+2335380
	mov	DWORD PTR _x$[ebp], eax

; 4740 : 				y+=st.Camera.position.y;

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _st+2335384
	mov	DWORD PTR _y$[ebp], eax

; 4741 : 			}
; 4742 : 			else

	jmp	$LN12@DrawObj
$LN18@DrawObj:

; 4743 : 			if(z>39 && z<48)

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 39					; 00000027H
	jle	SHORT $LN16@DrawObj
	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 48					; 00000030H
	jge	SHORT $LN16@DrawObj

; 4744 : 			{
; 4745 : 				x+=st.Camera.position.x;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _st+2335380
	mov	DWORD PTR _x$[ebp], eax

; 4746 : 				y+=st.Camera.position.y;

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _st+2335384
	mov	DWORD PTR _y$[ebp], eax

; 4747 : 			}
; 4748 : 			else

	jmp	SHORT $LN12@DrawObj
$LN16@DrawObj:

; 4749 : 			if(z>31 && z<40)

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 31					; 0000001fH
	jle	SHORT $LN14@DrawObj
	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 40					; 00000028H
	jge	SHORT $LN14@DrawObj

; 4750 : 			{
; 4751 : 				x+=st.Camera.position.x;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _st+2335380
	mov	DWORD PTR _x$[ebp], eax

; 4752 : 				y+=st.Camera.position.y;

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _st+2335384
	mov	DWORD PTR _y$[ebp], eax

; 4753 : 			}
; 4754 : 			else

	jmp	SHORT $LN12@DrawObj
$LN14@DrawObj:

; 4755 : 			if(z>15 && z<24)

	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 15					; 0000000fH
	jle	SHORT $LN12@DrawObj
	movsx	eax, BYTE PTR _z$[ebp]
	cmp	eax, 24					; 00000018H
	jge	SHORT $LN12@DrawObj

; 4756 : 			{
; 4757 : 				x-=st.Camera.position.x;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, DWORD PTR _st+2335380
	mov	DWORD PTR _x$[ebp], eax

; 4758 : 				y-=st.Camera.position.y;

	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, DWORD PTR _st+2335384
	mov	DWORD PTR _y$[ebp], eax
$LN12@DrawObj:

; 4759 : 			}
; 4760 : 			
; 4761 : 			x*=st.Camera.dimension.x;

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _st+2335396
	cvttss2si eax, xmm0
	mov	DWORD PTR _x$[ebp], eax

; 4762 : 			y*=st.Camera.dimension.y;

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR _st+2335400
	cvttss2si eax, xmm0
	mov	DWORD PTR _y$[ebp], eax

; 4763 : 
; 4764 : 			//timej=GetTicks();
; 4765 : 
; 4766 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1104[ebp], xmm0
	movss	DWORD PTR tv1106[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv833[ebp]
	movss	xmm0, DWORD PTR tv1106[ebp]
	mulss	xmm0, DWORD PTR tv833[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1108[ebp], xmm0
	movss	DWORD PTR tv1110[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv845[ebp]
	movss	xmm0, DWORD PTR tv1110[ebp]
	mulss	xmm0, DWORD PTR tv845[ebp]
	movss	xmm1, DWORD PTR tv1108[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1104[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 4767 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1112[ebp], xmm0
	movss	DWORD PTR tv1114[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv858[ebp]
	movss	xmm0, DWORD PTR tv1114[ebp]
	mulss	xmm0, DWORD PTR tv858[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1116[ebp], xmm0
	movss	DWORD PTR tv1118[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv870[ebp]
	movss	xmm0, DWORD PTR tv1118[ebp]
	mulss	xmm0, DWORD PTR tv870[ebp]
	movss	xmm1, DWORD PTR tv1116[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1112[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 4768 : 			ent[i].vertex[2]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movsx	edx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 4769 : 
; 4770 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1152[ebp], xmm0
	movss	DWORD PTR tv1154[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv883[ebp]
	movss	xmm0, DWORD PTR tv1154[ebp]
	mulss	xmm0, DWORD PTR tv883[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1156[ebp], xmm0
	movss	DWORD PTR tv1158[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv895[ebp]
	movss	xmm0, DWORD PTR tv1158[ebp]
	mulss	xmm0, DWORD PTR tv895[ebp]
	movss	xmm1, DWORD PTR tv1156[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1152[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 4771 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1160[ebp], xmm0
	movss	DWORD PTR tv1162[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv907[ebp]
	movss	xmm0, DWORD PTR tv1162[ebp]
	mulss	xmm0, DWORD PTR tv907[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1164[ebp], xmm0
	movss	DWORD PTR tv1166[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv919[ebp]
	movss	xmm0, DWORD PTR tv1166[ebp]
	mulss	xmm0, DWORD PTR tv919[ebp]
	movss	xmm1, DWORD PTR tv1164[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1160[ebp]
	addss	xmm0, xmm1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 4772 : 			ent[i].vertex[5]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	movsx	ecx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 4773 : 
; 4774 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1168[ebp], xmm0
	movss	DWORD PTR tv1170[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv932[ebp]
	movss	xmm0, DWORD PTR tv1170[ebp]
	mulss	xmm0, DWORD PTR tv932[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1172[ebp], xmm0
	movss	DWORD PTR tv1174[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv943[ebp]
	movss	xmm0, DWORD PTR tv1174[ebp]
	mulss	xmm0, DWORD PTR tv943[ebp]
	movss	xmm1, DWORD PTR tv1172[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1168[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 6
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 4775 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1176[ebp], xmm0
	movss	DWORD PTR tv1178[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv955[ebp]
	movss	xmm0, DWORD PTR tv1178[ebp]
	mulss	xmm0, DWORD PTR tv955[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	ecx, WORD PTR _ang$[ebp]
	push	ecx
	movss	DWORD PTR tv1180[ebp], xmm0
	movss	DWORD PTR tv1182[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv966[ebp]
	movss	xmm0, DWORD PTR tv1182[ebp]
	mulss	xmm0, DWORD PTR tv966[ebp]
	movss	xmm1, DWORD PTR tv1180[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1176[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 7
	movss	DWORD PTR _ent[edx+ecx+100], xmm0

; 4776 : 			ent[i].vertex[8]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 3
	movsx	edx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _ent[eax+ecx+100], xmm0

; 4777 : 
; 4778 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1184[ebp], xmm0
	movss	DWORD PTR tv1186[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv980[ebp]
	movss	xmm0, DWORD PTR tv1186[ebp]
	mulss	xmm0, DWORD PTR tv980[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1188[ebp], xmm0
	movss	DWORD PTR tv1190[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv991[ebp]
	movss	xmm0, DWORD PTR tv1190[ebp]
	mulss	xmm0, DWORD PTR tv991[ebp]
	movss	xmm1, DWORD PTR tv1188[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1184[ebp]
	addss	xmm0, xmm1
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 9
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 4779 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	sub	ecx, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, ecx
	movzx	edx, WORD PTR _ang$[ebp]
	push	edx
	movss	DWORD PTR tv1192[ebp], xmm0
	movss	DWORD PTR tv1194[ebp], xmm1
	call	_mSin
	add	esp, 4
	fstp	DWORD PTR tv1004[ebp]
	movss	xmm0, DWORD PTR tv1194[ebp]
	mulss	xmm0, DWORD PTR tv1004[ebp]
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	movzx	eax, WORD PTR _ang$[ebp]
	push	eax
	movss	DWORD PTR tv1196[ebp], xmm0
	movss	DWORD PTR tv1198[ebp], xmm1
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR tv1015[ebp]
	movss	xmm0, DWORD PTR tv1198[ebp]
	mulss	xmm0, DWORD PTR tv1015[ebp]
	movss	xmm1, DWORD PTR tv1196[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1192[ebp]
	addss	xmm0, xmm1
	imul	ecx, DWORD PTR _i$[ebp], 264
	mov	edx, 4
	imul	eax, edx, 10
	movss	DWORD PTR _ent[ecx+eax+100], xmm0

; 4780 : 			ent[i].vertex[11]=z;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 11
	movsx	ecx, BYTE PTR _z$[ebp]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _ent[eax+edx+100], xmm0

; 4781 : 
; 4782 : 			//timel=GetTicks() - timej;
; 4783 : 
; 4784 : 			//ang=1000;
; 4785 : 
; 4786 : 			ang/=10;

	movsx	eax, WORD PTR _ang$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	WORD PTR _ang$[ebp], ax

; 4787 : 
; 4788 : 			tmp=cos((ang*pi)/180);

	movsx	eax, WORD PTR _ang$[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm0, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	DWORD PTR _tmp$[ebp]

; 4789 : 			tmp=mCos(ang*10);

	movsx	eax, WORD PTR _ang$[ebp]
	imul	ecx, eax, 10
	push	ecx
	call	_mCos
	add	esp, 4
	fstp	DWORD PTR _tmp$[ebp]

; 4790 : 	
; 4791 : 			ax=(float) 1/(GAME_WIDTH/2);

	movss	xmm0, DWORD PTR __real@39000000
	movss	DWORD PTR _ax$[ebp], xmm0

; 4792 : 			ay=(float) 1/(GAME_HEIGHT/2);

	movss	xmm0, DWORD PTR __real@39638e39
	movss	DWORD PTR _ay$[ebp], xmm0

; 4793 : 
; 4794 : 			ay*=-1.0f;

	movss	xmm0, DWORD PTR _ay$[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _ay$[ebp], xmm0

; 4795 : 
; 4796 : 			az=(float) 1/(4096/2);

	movss	xmm0, DWORD PTR __real@3a000000
	movss	DWORD PTR _az$[ebp], xmm0

; 4797 : 
; 4798 : 			if(data.vb_id==-1)

	movsx	eax, WORD PTR _data$[ebp+10]
	cmp	eax, -1
	jne	$LN11@DrawObj

; 4799 : 			{
; 4800 : 				ent[i].texcor[0]=x1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtsi2ss xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 4801 : 				ent[i].texcor[1]=y1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	cvtsi2ss xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 4802 : 				ent[i].texcor[2]=x2;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 4803 : 				ent[i].texcor[3]=y1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	cvtsi2ss xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 4804 : 				ent[i].texcor[4]=x2;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	cvtsi2ss xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _ent[eax+ecx+148], xmm0

; 4805 : 				ent[i].texcor[5]=y2;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	cvtsi2ss xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 4806 : 				ent[i].texcor[6]=x1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 6
	cvtsi2ss xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 4807 : 				ent[i].texcor[7]=y2;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 7
	cvtsi2ss xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _ent[eax+edx+148], xmm0

; 4808 : 			}
; 4809 : 			else

	jmp	$LN10@DrawObj
$LN11@DrawObj:

; 4810 : 			{
; 4811 : 				tx1=(float) x1/32768;

	cvtsi2ss xmm0, DWORD PTR _x1$[ebp]
	divss	xmm0, DWORD PTR __real@47000000
	movss	DWORD PTR _tx1$[ebp], xmm0

; 4812 : 				ty1=(float) y1/32768;

	cvtsi2ss xmm0, DWORD PTR _y1$[ebp]
	divss	xmm0, DWORD PTR __real@47000000
	movss	DWORD PTR _ty1$[ebp], xmm0

; 4813 : 				tx2=(float) x2/32768;

	cvtsi2ss xmm0, DWORD PTR _x2$[ebp]
	divss	xmm0, DWORD PTR __real@47000000
	movss	DWORD PTR _tx2$[ebp], xmm0

; 4814 : 				ty2=(float) y2/32768;

	cvtsi2ss xmm0, DWORD PTR _y2$[ebp]
	divss	xmm0, DWORD PTR __real@47000000
	movss	DWORD PTR _ty2$[ebp], xmm0

; 4815 : 
; 4816 : 				ent[i].texcor[0]=data.posx+(tx1*data.sizex);

	movzx	eax, WORD PTR _data$[ebp+14]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+18]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _tx1$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _ent[edx+ecx+148], xmm0

; 4817 : 				ent[i].texcor[1]=data.posy+(ty1*data.sizey);

	movzx	eax, WORD PTR _data$[ebp+16]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+20]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _ty1$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _ent[edx+eax+148], xmm0

; 4818 : 
; 4819 : 				ent[i].texcor[2]=data.posx+(tx2*data.sizex);

	movzx	eax, WORD PTR _data$[ebp+14]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+18]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _tx2$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _ent[edx+eax+148], xmm0

; 4820 : 				ent[i].texcor[3]=data.posy+(ty1*data.sizey);

	movzx	eax, WORD PTR _data$[ebp+16]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+20]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _ty1$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 3
	movss	DWORD PTR _ent[edx+ecx+148], xmm0

; 4821 : 
; 4822 : 				ent[i].texcor[4]=data.posx+(tx2*data.sizex);

	movzx	eax, WORD PTR _data$[ebp+14]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+18]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _tx2$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	shl	eax, 2
	movss	DWORD PTR _ent[edx+eax+148], xmm0

; 4823 : 				ent[i].texcor[5]=data.posy+(ty2*data.sizey);

	movzx	eax, WORD PTR _data$[ebp+16]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+20]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _ty2$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 5
	movss	DWORD PTR _ent[edx+ecx+148], xmm0

; 4824 : 
; 4825 : 				ent[i].texcor[6]=data.posx+(tx1*data.sizex);

	movzx	eax, WORD PTR _data$[ebp+14]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+18]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _tx1$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 6
	movss	DWORD PTR _ent[edx+ecx+148], xmm0

; 4826 : 				ent[i].texcor[7]=data.posy+(ty2*data.sizey);

	movzx	eax, WORD PTR _data$[ebp+16]
	cvtsi2ss xmm0, eax
	movzx	ecx, WORD PTR _data$[ebp+20]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _ty2$[ebp]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, 4
	imul	ecx, eax, 7
	movss	DWORD PTR _ent[edx+ecx+148], xmm0
$LN10@DrawObj:

; 4827 : 			}
; 4828 : 
; 4829 : 			for(j=0;j<12;j+=3)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN9@DrawObj
$LN8@DrawObj:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 3
	mov	DWORD PTR _j$[ebp], eax
$LN9@DrawObj:
	cmp	DWORD PTR _j$[ebp], 12			; 0000000cH
	jae	$LN7@DrawObj

; 4830 : 			{
; 4831 : 				ent[i].vertex[j]*=ax;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+100]
	mulss	xmm0, DWORD PTR _ax$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 4832 : 				ent[i].vertex[j]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+100]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+100], xmm0

; 4833 : 
; 4834 : 		 		ent[i].vertex[j+1]*=ay;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+104]
	mulss	xmm0, DWORD PTR _ay$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 4835 : 				ent[i].vertex[j+1]+=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+104]
	addss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+104], xmm0

; 4836 : 				
; 4837 : 				ent[i].vertex[j+2]*=az;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+108]
	mulss	xmm0, DWORD PTR _az$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 4838 : 				ent[i].vertex[j+2]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+108]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+108], xmm0

; 4839 : 				
; 4840 : 				if(j<8)

	cmp	DWORD PTR _j$[ebp], 8
	jae	$LN6@DrawObj

; 4841 : 				{
; 4842 : 					ent[i].texcor[j]/=(float)32768;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+148]
	divss	xmm0, DWORD PTR __real@47000000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+148], xmm0

; 4843 : 					ent[i].texcor[j+1]/=(float)32768;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+152]
	divss	xmm0, DWORD PTR __real@47000000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+152], xmm0

; 4844 : 					ent[i].texcor[j+2]/=(float)32768;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _ent[eax+ecx*4+156]
	divss	xmm0, DWORD PTR __real@47000000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _ent[edx+eax*4+156], xmm0
$LN6@DrawObj:

; 4845 : 				}
; 4846 : 				
; 4847 : 			}

	jmp	$LN8@DrawObj
$LN7@DrawObj:

; 4848 : 
; 4849 : 			/*
; 4850 : 			ent[i].texcor[0]/=tx1;
; 4851 : 			ent[i].texcor[1]/=ty1;
; 4852 : 			ent[i].texcor[2]*=tx2;
; 4853 : 			ent[i].texcor[3]/=ty1;
; 4854 : 			ent[i].texcor[4]*=tx2;
; 4855 : 			ent[i].texcor[5]*=ty2;
; 4856 : 			ent[i].texcor[6]/=tx1;
; 4857 : 			ent[i].texcor[7]*=ty2;
; 4858 : 			*/
; 4859 : 
; 4860 : 			for(j=0;j<16;j+=4)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN5@DrawObj
$LN4@DrawObj:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 4
	mov	DWORD PTR _j$[ebp], eax
$LN5@DrawObj:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jae	SHORT $LN3@DrawObj

; 4861 : 			{
; 4862 : 				ent[i].color[j]=r;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _ent[eax+ecx+228], dl

; 4863 : 				ent[i].color[j+1]=g;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _ent[eax+ecx+229], dl

; 4864 : 				ent[i].color[j+2]=b;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _ent[eax+ecx+230], dl

; 4865 : 				ent[i].color[j+3]=a;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR _ent[eax+ecx+231], dl

; 4866 : 			}

	jmp	$LN4@DrawObj
$LN3@DrawObj:

; 4867 : 
; 4868 : 			if(data.vb_id!=-1)

	movsx	eax, WORD PTR _data$[ebp+10]
	cmp	eax, -1
	je	SHORT $LN2@DrawObj

; 4869 : 			{
; 4870 : 				vbdt[data.vb_id].num_elements++;

	movsx	eax, WORD PTR _data$[ebp+10]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	dx, WORD PTR [ecx+eax+46]
	add	dx, 1
	movsx	eax, WORD PTR _data$[ebp+10]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	WORD PTR [ecx+eax+46], dx

; 4871 : 				ent[i].data.loc=vbdt[data.vb_id].num_elements-1;

	movsx	eax, WORD PTR _data$[ebp+10]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	movzx	edx, WORD PTR [ecx+eax+46]
	sub	edx, 1
	imul	eax, DWORD PTR _i$[ebp], 264
	mov	WORD PTR _ent[eax+56], dx

; 4872 : 			}
; 4873 : 			else

	jmp	SHORT $LN1@DrawObj
$LN2@DrawObj:

; 4874 : 			{
; 4875 : 				texone_ids[texone_num]=i;

	movzx	eax, WORD PTR _texone_num
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _texone_ids[eax*2], cx

; 4876 : 				texone_num++;

	mov	ax, WORD PTR _texone_num
	add	ax, 1
	mov	WORD PTR _texone_num, ax
$LN1@DrawObj:

; 4877 : 			}
; 4878 : 
; 4879 : #endif
; 4880 : 
; 4881 : 			st.num_entities++;

	mov	eax, DWORD PTR _st+244
	add	eax, 1
	mov	DWORD PTR _st+244, eax

; 4882 : 
; 4883 : 	return 0;

	xor	al, al
$LN32@DrawObj:

; 4884 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN36@DrawObj
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 468				; 000001d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN36@DrawObj:
	DD	1
	DD	$LN35@DrawObj
$LN35@DrawObj:
	DD	-248					; ffffff08H
	DD	12					; 0000000cH
	DD	$LN34@DrawObj
$LN34@DrawObj:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	0
_DrawObj ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _BASICBKD
_TEXT	SEGMENT
_k$ = -80						; size = 4
_j$ = -68						; size = 4
_i$ = -56						; size = 4
_az$ = -44						; size = 4
_ay$ = -32						; size = 4
_ax$ = -20						; size = 4
_r$ = 8							; size = 1
_g$ = 12						; size = 1
_b$ = 16						; size = 1
_BASICBKD PROC						; COMDAT

; 4617 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4618 : 	float tmp, ax, ay, az;
; 4619 : 
; 4620 : 	uint32 i=0, j=0, k=0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _k$[ebp], 0

; 4621 : 
; 4622 : 	i=0;

	mov	DWORD PTR _i$[ebp], 0

; 4623 : 
; 4624 : 	lmp[i].data.data=st.game_lightmaps[0].tex;

	mov	eax, 500				; 000001f4H
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _st[ecx+492]
	mov	DWORD PTR _lmp[edx+44], eax

; 4625 : 	lmp[i].ang=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	xor	ecx, ecx
	mov	WORD PTR _lmp[eax+96], cx

; 4626 : 
; 4627 : 			lmp[i].vertex[0]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _lmp[eax+edx+100], xmm0

; 4628 : 			lmp[i].vertex[1]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _lmp[eax+ecx+100], xmm0

; 4629 : 			lmp[i].vertex[2]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _lmp[eax+ecx+100], xmm0

; 4630 : 
; 4631 : 			lmp[i].vertex[3]=16384.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@46800000
	movss	DWORD PTR _lmp[eax+edx+100], xmm0

; 4632 : 			lmp[i].vertex[4]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _lmp[eax+ecx+100], xmm0

; 4633 : 			lmp[i].vertex[5]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _lmp[eax+edx+100], xmm0

; 4634 : 
; 4635 : 			lmp[i].vertex[6]=16384.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 6
	movss	xmm0, DWORD PTR __real@46800000
	movss	DWORD PTR _lmp[eax+edx+100], xmm0

; 4636 : 			lmp[i].vertex[7]=9216.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 7
	movss	xmm0, DWORD PTR __real@46100000
	movss	DWORD PTR _lmp[eax+edx+100], xmm0

; 4637 : 			lmp[i].vertex[8]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 3
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _lmp[eax+ecx+100], xmm0

; 4638 : 
; 4639 : 			lmp[i].vertex[9]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 9
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _lmp[eax+edx+100], xmm0

; 4640 : 			lmp[i].vertex[10]=9216.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 10
	movss	xmm0, DWORD PTR __real@46100000
	movss	DWORD PTR _lmp[eax+edx+100], xmm0

; 4641 : 			lmp[i].vertex[11]=0.0f;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 11
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _lmp[eax+edx+100], xmm0

; 4642 : 
; 4643 : 			ax=(float) 1/(GAME_WIDTH/2);

	movss	xmm0, DWORD PTR __real@39000000
	movss	DWORD PTR _ax$[ebp], xmm0

; 4644 : 			ay=(float) 1/(GAME_HEIGHT/2);

	movss	xmm0, DWORD PTR __real@39638e39
	movss	DWORD PTR _ay$[ebp], xmm0

; 4645 : 
; 4646 : 			ay*=-1.0f;

	movss	xmm0, DWORD PTR _ay$[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _ay$[ebp], xmm0

; 4647 : 
; 4648 : 			az=(float) 1/(4096/2);

	movss	xmm0, DWORD PTR __real@3a000000
	movss	DWORD PTR _az$[ebp], xmm0

; 4649 : 
; 4650 : 			lmp[i].texcor[0]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _lmp[eax+edx+148], xmm0

; 4651 : 			lmp[i].texcor[1]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _lmp[eax+ecx+148], xmm0

; 4652 : 			lmp[i].texcor[2]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lmp[eax+ecx+148], xmm0

; 4653 : 			lmp[i].texcor[3]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _lmp[eax+edx+148], xmm0

; 4654 : 			lmp[i].texcor[4]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	shl	ecx, 2
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lmp[eax+ecx+148], xmm0

; 4655 : 			lmp[i].texcor[5]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 5
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lmp[eax+edx+148], xmm0

; 4656 : 			lmp[i].texcor[6]=0;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 6
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _lmp[eax+edx+148], xmm0

; 4657 : 			lmp[i].texcor[7]=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, 4
	imul	edx, ecx, 7
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lmp[eax+edx+148], xmm0

; 4658 : 
; 4659 : 			for(j=0;j<12;j+=3)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN6@BASICBKD
$LN5@BASICBKD:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 3
	mov	DWORD PTR _j$[ebp], eax
$LN6@BASICBKD:
	cmp	DWORD PTR _j$[ebp], 12			; 0000000cH
	jae	$LN4@BASICBKD

; 4660 : 			{
; 4661 : 				lmp[i].vertex[j]*=ax;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _lmp[eax+ecx*4+100]
	mulss	xmm0, DWORD PTR _ax$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _lmp[edx+eax*4+100], xmm0

; 4662 : 				lmp[i].vertex[j]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _lmp[eax+ecx*4+100]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _lmp[edx+eax*4+100], xmm0

; 4663 : 
; 4664 : 				lmp[i].vertex[j+1]*=ay;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _lmp[eax+ecx*4+104]
	mulss	xmm0, DWORD PTR _ay$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _lmp[edx+eax*4+104], xmm0

; 4665 : 				lmp[i].vertex[j+1]+=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _lmp[eax+ecx*4+104]
	addss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _lmp[edx+eax*4+104], xmm0

; 4666 : 				
; 4667 : 				lmp[i].vertex[j+2]*=az;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _lmp[eax+ecx*4+108]
	mulss	xmm0, DWORD PTR _az$[ebp]
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _lmp[edx+eax*4+108], xmm0

; 4668 : 				lmp[i].vertex[j+2]-=1;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _lmp[eax+ecx*4+108]
	subss	xmm0, DWORD PTR __real@3f800000
	imul	edx, DWORD PTR _i$[ebp], 264
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _lmp[edx+eax*4+108], xmm0

; 4669 : 			}

	jmp	$LN5@BASICBKD
$LN4@BASICBKD:

; 4670 : 
; 4671 : 			for(j=0;j<16;j+=4)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN3@BASICBKD
$LN2@BASICBKD:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 4
	mov	DWORD PTR _j$[ebp], eax
$LN3@BASICBKD:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jae	SHORT $LN1@BASICBKD

; 4672 : 			{
; 4673 : 				lmp[i].color[j]=r;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _lmp[eax+ecx+228], dl

; 4674 : 				lmp[i].color[j+1]=g;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _lmp[eax+ecx+229], dl

; 4675 : 				lmp[i].color[j+2]=b;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _lmp[eax+ecx+230], dl

; 4676 : 				lmp[i].color[j+3]=255;

	imul	eax, DWORD PTR _i$[ebp], 264
	mov	ecx, DWORD PTR _j$[ebp]
	mov	BYTE PTR _lmp[eax+ecx+231], 255		; 000000ffH

; 4677 : 			}

	jmp	SHORT $LN2@BASICBKD
$LN1@BASICBKD:

; 4678 : 
; 4679 : 			st.num_lightmap++;

	mov	al, BYTE PTR _st+261
	add	al, 1
	mov	BYTE PTR _st+261, al

; 4680 : 
; 4681 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_BASICBKD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CalTan32u
_TEXT	SEGMENT
_ang$ = 8						; size = 2
_val$ = 12						; size = 4
_CalTan32u PROC						; COMDAT

; 343  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 344  : 	if(ang>3600) ang-=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	cmp	eax, 3600				; 00000e10H
	jle	SHORT $LN3@CalTan32u
	movsx	eax, WORD PTR _ang$[ebp]
	sub	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
	jmp	SHORT $LN1@CalTan32u
$LN3@CalTan32u:

; 345  : 	else if(ang<0) ang+=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	test	eax, eax
	jge	SHORT $LN1@CalTan32u
	movsx	eax, WORD PTR _ang$[ebp]
	add	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
$LN1@CalTan32u:

; 346  : 
; 347  : 	*val*=(uint32)(st.TanTable[ang]*100);

	movsx	eax, WORD PTR _ang$[ebp]
	movss	xmm0, DWORD PTR _st[eax*4+2746616]
	mulss	xmm0, DWORD PTR __real@42c80000
	call	__ftoui3
	mov	ecx, DWORD PTR _val$[ebp]
	imul	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [edx], eax

; 348  : 	*val/=100;

	mov	eax, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [eax]
	xor	edx, edx
	mov	ecx, 100				; 00000064H
	div	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [edx], eax

; 349  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_CalTan32u ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CalSin32u
_TEXT	SEGMENT
_ang$ = 8						; size = 2
_val$ = 12						; size = 4
_CalSin32u PROC						; COMDAT

; 334  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 335  : 	if(ang>3600) ang-=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	cmp	eax, 3600				; 00000e10H
	jle	SHORT $LN3@CalSin32u
	movsx	eax, WORD PTR _ang$[ebp]
	sub	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
	jmp	SHORT $LN1@CalSin32u
$LN3@CalSin32u:

; 336  : 	else if(ang<0) ang+=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	test	eax, eax
	jge	SHORT $LN1@CalSin32u
	movsx	eax, WORD PTR _ang$[ebp]
	add	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
$LN1@CalSin32u:

; 337  : 
; 338  : 	*val*=(uint32)(st.SinTable[ang]*100);

	movsx	eax, WORD PTR _ang$[ebp]
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, DWORD PTR __real@42c80000
	call	__ftoui3
	mov	ecx, DWORD PTR _val$[ebp]
	imul	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [edx], eax

; 339  : 	*val/=100;

	mov	eax, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [eax]
	xor	edx, edx
	mov	ecx, 100				; 00000064H
	div	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [edx], eax

; 340  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_CalSin32u ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CalCos32u
_TEXT	SEGMENT
_ang$ = 8						; size = 2
_val$ = 12						; size = 4
_CalCos32u PROC						; COMDAT

; 325  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 326  : 	if(ang>3600) ang-=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	cmp	eax, 3600				; 00000e10H
	jle	SHORT $LN3@CalCos32u
	movsx	eax, WORD PTR _ang$[ebp]
	sub	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
	jmp	SHORT $LN1@CalCos32u
$LN3@CalCos32u:

; 327  : 	else if(ang<0) ang+=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	test	eax, eax
	jge	SHORT $LN1@CalCos32u
	movsx	eax, WORD PTR _ang$[ebp]
	add	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
$LN1@CalCos32u:

; 328  : 
; 329  : 	*val*=(uint32)(st.CosTable[ang]*100);

	movsx	eax, WORD PTR _ang$[ebp]
	movss	xmm0, DWORD PTR _st[eax*4+2717808]
	mulss	xmm0, DWORD PTR __real@42c80000
	call	__ftoui3
	mov	ecx, DWORD PTR _val$[ebp]
	imul	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [edx], eax

; 330  : 	*val/=100;

	mov	eax, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [eax]
	xor	edx, edx
	mov	ecx, 100				; 00000064H
	div	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [edx], eax

; 331  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_CalCos32u ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CalTan16u
_TEXT	SEGMENT
_ang$ = 8						; size = 2
_val$ = 12						; size = 4
_CalTan16u PROC						; COMDAT

; 316  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 317  : 	if(ang>3600) ang-=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	cmp	eax, 3600				; 00000e10H
	jle	SHORT $LN3@CalTan16u
	movsx	eax, WORD PTR _ang$[ebp]
	sub	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
	jmp	SHORT $LN1@CalTan16u
$LN3@CalTan16u:

; 318  : 	else if(ang<0) ang+=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	test	eax, eax
	jge	SHORT $LN1@CalTan16u
	movsx	eax, WORD PTR _ang$[ebp]
	add	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
$LN1@CalTan16u:

; 319  : 
; 320  : 	*val*=(uint16)(st.TanTable[ang]*100);

	movsx	eax, WORD PTR _ang$[ebp]
	movss	xmm0, DWORD PTR _st[eax*4+2746616]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvttss2si ecx, xmm0
	movzx	edx, cx
	mov	eax, DWORD PTR _val$[ebp]
	movzx	ecx, WORD PTR [eax]
	imul	ecx, edx
	mov	edx, DWORD PTR _val$[ebp]
	mov	WORD PTR [edx], cx

; 321  : 	*val/=100;

	mov	eax, DWORD PTR _val$[ebp]
	movzx	eax, WORD PTR [eax]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	WORD PTR [edx], ax

; 322  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CalTan16u ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CalSin16u
_TEXT	SEGMENT
_ang$ = 8						; size = 2
_val$ = 12						; size = 4
_CalSin16u PROC						; COMDAT

; 307  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 308  : 	if(ang>3600) ang-=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	cmp	eax, 3600				; 00000e10H
	jle	SHORT $LN3@CalSin16u
	movsx	eax, WORD PTR _ang$[ebp]
	sub	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
	jmp	SHORT $LN1@CalSin16u
$LN3@CalSin16u:

; 309  : 	else if(ang<0) ang+=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	test	eax, eax
	jge	SHORT $LN1@CalSin16u
	movsx	eax, WORD PTR _ang$[ebp]
	add	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
$LN1@CalSin16u:

; 310  : 
; 311  : 	*val*=(uint16)(st.SinTable[ang]*100);

	movsx	eax, WORD PTR _ang$[ebp]
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvttss2si ecx, xmm0
	movzx	edx, cx
	mov	eax, DWORD PTR _val$[ebp]
	movzx	ecx, WORD PTR [eax]
	imul	ecx, edx
	mov	edx, DWORD PTR _val$[ebp]
	mov	WORD PTR [edx], cx

; 312  : 	*val/=100;

	mov	eax, DWORD PTR _val$[ebp]
	movzx	eax, WORD PTR [eax]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	WORD PTR [edx], ax

; 313  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CalSin16u ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CalCos16u
_TEXT	SEGMENT
_ang$ = 8						; size = 2
_val$ = 12						; size = 4
_CalCos16u PROC						; COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 299  : 	if(ang>3600) ang-=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	cmp	eax, 3600				; 00000e10H
	jle	SHORT $LN3@CalCos16u
	movsx	eax, WORD PTR _ang$[ebp]
	sub	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
	jmp	SHORT $LN1@CalCos16u
$LN3@CalCos16u:

; 300  : 	else if(ang<0) ang+=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	test	eax, eax
	jge	SHORT $LN1@CalCos16u
	movsx	eax, WORD PTR _ang$[ebp]
	add	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
$LN1@CalCos16u:

; 301  : 
; 302  : 	*val*=(uint16)(st.CosTable[ang]*100);

	movsx	eax, WORD PTR _ang$[ebp]
	movss	xmm0, DWORD PTR _st[eax*4+2717808]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvttss2si ecx, xmm0
	movzx	edx, cx
	mov	eax, DWORD PTR _val$[ebp]
	movzx	ecx, WORD PTR [eax]
	imul	ecx, edx
	mov	edx, DWORD PTR _val$[ebp]
	mov	WORD PTR [edx], cx

; 303  : 	*val/=100;

	mov	eax, DWORD PTR _val$[ebp]
	movzx	eax, WORD PTR [eax]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	WORD PTR [edx], ax

; 304  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CalCos16u ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CalTan32s
_TEXT	SEGMENT
_ang$ = 8						; size = 2
_val$ = 12						; size = 4
_CalTan32s PROC						; COMDAT

; 287  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 288  : 	if(ang>3600) ang-=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	cmp	eax, 3600				; 00000e10H
	jle	SHORT $LN3@CalTan32s
	movsx	eax, WORD PTR _ang$[ebp]
	sub	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
	jmp	SHORT $LN1@CalTan32s
$LN3@CalTan32s:

; 289  : 	else if(ang<0) ang+=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	test	eax, eax
	jge	SHORT $LN1@CalTan32s
	movsx	eax, WORD PTR _ang$[ebp]
	add	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
$LN1@CalTan32s:

; 290  : 
; 291  : 	*val*=(int32)(st.TanTable[ang]*100);

	movsx	eax, WORD PTR _ang$[ebp]
	movss	xmm0, DWORD PTR _st[eax*4+2746616]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _val$[ebp]
	imul	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], ecx

; 292  : 	*val/=100;

	mov	eax, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [eax]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [edx], eax

; 293  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CalTan32s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CalSin32s
_TEXT	SEGMENT
_ang$ = 8						; size = 2
_val$ = 12						; size = 4
_CalSin32s PROC						; COMDAT

; 278  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 279  : 	if(ang>3600) ang-=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	cmp	eax, 3600				; 00000e10H
	jle	SHORT $LN3@CalSin32s
	movsx	eax, WORD PTR _ang$[ebp]
	sub	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
	jmp	SHORT $LN1@CalSin32s
$LN3@CalSin32s:

; 280  : 	else if(ang<0) ang+=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	test	eax, eax
	jge	SHORT $LN1@CalSin32s
	movsx	eax, WORD PTR _ang$[ebp]
	add	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
$LN1@CalSin32s:

; 281  : 
; 282  : 	*val*=(int32)(st.SinTable[ang]*100);

	movsx	eax, WORD PTR _ang$[ebp]
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _val$[ebp]
	imul	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], ecx

; 283  : 	*val/=100;

	mov	eax, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [eax]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [edx], eax

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CalSin32s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CalCos32s
_TEXT	SEGMENT
_ang$ = 8						; size = 2
_val$ = 12						; size = 4
_CalCos32s PROC						; COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 270  : 	if(ang>3600) ang-=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	cmp	eax, 3600				; 00000e10H
	jle	SHORT $LN3@CalCos32s
	movsx	eax, WORD PTR _ang$[ebp]
	sub	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
	jmp	SHORT $LN1@CalCos32s
$LN3@CalCos32s:

; 271  : 	else if(ang<0) ang+=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	test	eax, eax
	jge	SHORT $LN1@CalCos32s
	movsx	eax, WORD PTR _ang$[ebp]
	add	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
$LN1@CalCos32s:

; 272  : 
; 273  : 	*val*=(int32)(st.CosTable[ang]*100);

	movsx	eax, WORD PTR _ang$[ebp]
	movss	xmm0, DWORD PTR _st[eax*4+2717808]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _val$[ebp]
	imul	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], ecx

; 274  : 	*val/=100;

	mov	eax, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [eax]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [edx], eax

; 275  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CalCos32s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CalTan16s
_TEXT	SEGMENT
_ang$ = 8						; size = 2
_val$ = 12						; size = 4
_CalTan16s PROC						; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 261  : 	if(ang>3600) ang-=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	cmp	eax, 3600				; 00000e10H
	jle	SHORT $LN3@CalTan16s
	movsx	eax, WORD PTR _ang$[ebp]
	sub	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
	jmp	SHORT $LN1@CalTan16s
$LN3@CalTan16s:

; 262  : 	else if(ang<0) ang+=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	test	eax, eax
	jge	SHORT $LN1@CalTan16s
	movsx	eax, WORD PTR _ang$[ebp]
	add	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
$LN1@CalTan16s:

; 263  : 
; 264  : 	*val*=(int16)(st.TanTable[ang]*100);

	movsx	eax, WORD PTR _ang$[ebp]
	movss	xmm0, DWORD PTR _st[eax*4+2746616]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvttss2si ecx, xmm0
	movsx	edx, cx
	mov	eax, DWORD PTR _val$[ebp]
	movsx	ecx, WORD PTR [eax]
	imul	ecx, edx
	mov	edx, DWORD PTR _val$[ebp]
	mov	WORD PTR [edx], cx

; 265  : 	*val/=100;

	mov	eax, DWORD PTR _val$[ebp]
	movsx	eax, WORD PTR [eax]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	WORD PTR [edx], ax

; 266  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CalTan16s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CalSin16s
_TEXT	SEGMENT
_ang$ = 8						; size = 2
_val$ = 12						; size = 4
_CalSin16s PROC						; COMDAT

; 251  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 252  : 	if(ang>3600) ang-=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	cmp	eax, 3600				; 00000e10H
	jle	SHORT $LN3@CalSin16s
	movsx	eax, WORD PTR _ang$[ebp]
	sub	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
	jmp	SHORT $LN1@CalSin16s
$LN3@CalSin16s:

; 253  : 	else if(ang<0) ang+=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	test	eax, eax
	jge	SHORT $LN1@CalSin16s
	movsx	eax, WORD PTR _ang$[ebp]
	add	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
$LN1@CalSin16s:

; 254  : 
; 255  : 	*val*=(int16)(st.SinTable[ang]*100);

	movsx	eax, WORD PTR _ang$[ebp]
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvttss2si ecx, xmm0
	movsx	edx, cx
	mov	eax, DWORD PTR _val$[ebp]
	movsx	ecx, WORD PTR [eax]
	imul	ecx, edx
	mov	edx, DWORD PTR _val$[ebp]
	mov	WORD PTR [edx], cx

; 256  : 	*val/=100;

	mov	eax, DWORD PTR _val$[ebp]
	movsx	eax, WORD PTR [eax]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	WORD PTR [edx], ax

; 257  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CalSin16s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CalCos16s
_TEXT	SEGMENT
_ang$ = 8						; size = 2
_val$ = 12						; size = 4
_CalCos16s PROC						; COMDAT

; 242  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 243  : 	if(ang>3600) ang-=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	cmp	eax, 3600				; 00000e10H
	jle	SHORT $LN3@CalCos16s
	movsx	eax, WORD PTR _ang$[ebp]
	sub	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
	jmp	SHORT $LN1@CalCos16s
$LN3@CalCos16s:

; 244  : 	else if(ang<0) ang+=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	test	eax, eax
	jge	SHORT $LN1@CalCos16s
	movsx	eax, WORD PTR _ang$[ebp]
	add	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
$LN1@CalCos16s:

; 245  : 
; 246  : 	*val*=(int16)(st.CosTable[ang]*100);

	movsx	eax, WORD PTR _ang$[ebp]
	movss	xmm0, DWORD PTR _st[eax*4+2717808]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvttss2si ecx, xmm0
	movsx	edx, cx
	mov	eax, DWORD PTR _val$[ebp]
	movsx	ecx, WORD PTR [eax]
	imul	ecx, edx
	mov	edx, DWORD PTR _val$[ebp]
	mov	WORD PTR [edx], cx

; 247  : 	*val/=100;

	mov	eax, DWORD PTR _val$[ebp]
	movsx	eax, WORD PTR [eax]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	WORD PTR [edx], ax

; 248  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CalCos16s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _mTan
_TEXT	SEGMENT
_ang$ = 8						; size = 2
_mTan	PROC						; COMDAT

; 232  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 233  : 	if(ang>3600) ang-=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	cmp	eax, 3600				; 00000e10H
	jle	SHORT $LN3@mTan
	movsx	eax, WORD PTR _ang$[ebp]
	sub	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
	jmp	SHORT $LN1@mTan
$LN3@mTan:

; 234  : 	else if(ang<0) ang+=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	test	eax, eax
	jge	SHORT $LN1@mTan
	movsx	eax, WORD PTR _ang$[ebp]
	add	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
$LN1@mTan:

; 235  : 
; 236  : 	return st.TanTable[ang];

	movsx	eax, WORD PTR _ang$[ebp]
	fld	DWORD PTR _st[eax*4+2746616]

; 237  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_mTan	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _mSin
_TEXT	SEGMENT
_ang$ = 8						; size = 2
_mSin	PROC						; COMDAT

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 225  : 	if(ang>3600) ang-=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	cmp	eax, 3600				; 00000e10H
	jle	SHORT $LN3@mSin
	movsx	eax, WORD PTR _ang$[ebp]
	sub	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
	jmp	SHORT $LN1@mSin
$LN3@mSin:

; 226  : 	else if(ang<0) ang+=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	test	eax, eax
	jge	SHORT $LN1@mSin
	movsx	eax, WORD PTR _ang$[ebp]
	add	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
$LN1@mSin:

; 227  : 
; 228  : 	return st.SinTable[ang];

	movsx	eax, WORD PTR _ang$[ebp]
	fld	DWORD PTR _st[eax*4+2732212]

; 229  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_mSin	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _mCos
_TEXT	SEGMENT
_ang$ = 8						; size = 2
_mCos	PROC						; COMDAT

; 216  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 217  : 	if(ang>3600) ang-=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	cmp	eax, 3600				; 00000e10H
	jle	SHORT $LN3@mCos
	movsx	eax, WORD PTR _ang$[ebp]
	sub	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
	jmp	SHORT $LN1@mCos
$LN3@mCos:

; 218  : 	else if(ang<0) ang+=3600;

	movsx	eax, WORD PTR _ang$[ebp]
	test	eax, eax
	jge	SHORT $LN1@mCos
	movsx	eax, WORD PTR _ang$[ebp]
	add	eax, 3600				; 00000e10H
	mov	WORD PTR _ang$[ebp], ax
$LN1@mCos:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	eax, WORD PTR _ang$[ebp]
	fld	DWORD PTR _st[eax*4+2717808]

; 221  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_mCos	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _ResetVB
_TEXT	SEGMENT
_i$ = -8						; size = 2
_ResetVB PROC						; COMDAT

; 1213 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1214 : 	uint16 i=0;

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax

; 1215 : 
; 1216 : 	for(i=0;i<vbdt_num;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN7@ResetVB
$LN6@ResetVB:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN7@ResetVB:
	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _vbdt_num
	cmp	eax, ecx
	jge	$LN5@ResetVB

; 1217 : 	{
; 1218 : 		if(vbdt[i].color)

	movzx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	cmp	DWORD PTR [ecx+eax+28], 0
	je	SHORT $LN4@ResetVB

; 1219 : 			free(vbdt[i].color);

	movzx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+28]
	push	edx
	call	_free
	add	esp, 4
$LN4@ResetVB:

; 1220 : 
; 1221 : 		if(vbdt[i].index)

	movzx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	cmp	DWORD PTR [ecx+eax+32], 0
	je	SHORT $LN3@ResetVB

; 1222 : 			free(vbdt[i].index);

	movzx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+32]
	push	edx
	call	_free
	add	esp, 4
$LN3@ResetVB:

; 1223 : 
; 1224 : 		if(vbdt[i].texcoord)

	movzx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	cmp	DWORD PTR [ecx+eax+16], 0
	je	SHORT $LN2@ResetVB

; 1225 : 			free(vbdt[i].texcoord);

	movzx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+16]
	push	edx
	call	_free
	add	esp, 4
$LN2@ResetVB:

; 1226 : 
; 1227 : 		if(vbdt[i].vertex)

	movzx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	cmp	DWORD PTR [ecx+eax+12], 0
	je	SHORT $LN1@ResetVB

; 1228 : 			free(vbdt[i].vertex);

	movzx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+12]
	push	edx
	call	_free
	add	esp, 4
$LN1@ResetVB:

; 1229 : 	}

	jmp	$LN6@ResetVB
$LN5@ResetVB:

; 1230 : 
; 1231 : 	free(vbdt);

	mov	eax, DWORD PTR _vbdt
	push	eax
	call	_free
	add	esp, 4

; 1232 : 
; 1233 : 	vbdt_num=0;

	xor	eax, eax
	mov	WORD PTR _vbdt_num, ax

; 1234 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_ResetVB ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _WTSf
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_WTSf	PROC						; COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 202  : 	*x-=st.Camera.position.x;

	cvtsi2ss xmm0, DWORD PTR _st+2335380
	mov	eax, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx], xmm1

; 203  : 	*y-=st.Camera.position.y;

	cvtsi2ss xmm0, DWORD PTR _st+2335384
	mov	eax, DWORD PTR _y$[ebp]
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx], xmm1

; 204  : 
; 205  : 	*x=(float) ((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;

	movzx	eax, WORD PTR _st+228
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR [ecx]
	divss	xmm0, DWORD PTR __real@46800000
	mulss	xmm0, DWORD PTR _st+2335396
	mov	edx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [edx], xmm0

; 206  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;

	movzx	eax, WORD PTR _st+230
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR [ecx]
	divss	xmm0, DWORD PTR __real@46100000
	mulss	xmm0, DWORD PTR _st+2335400
	mov	edx, DWORD PTR _y$[ebp]
	movss	DWORD PTR [edx], xmm0

; 207  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_WTSf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT @WTS@8
_TEXT	SEGMENT
_y$ = -20						; size = 4
_x$ = -8						; size = 4
@WTS@8	PROC						; COMDAT
; _x$ = ecx
; _y$ = edx

; 186  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _y$[ebp], edx
	mov	DWORD PTR _x$[ebp], ecx

; 187  : 	*x-=st.Camera.position.x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _st+2335380
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [edx], ecx

; 188  : 	*y-=st.Camera.position.y;

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _st+2335384
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR [edx], ecx

; 189  : 
; 190  : 	*x=((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;

	movzx	eax, WORD PTR _st+228
	mov	ecx, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR [ecx]
	cdq
	and	edx, 16383				; 00003fffH
	add	eax, edx
	sar	eax, 14					; 0000000eH
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _st+2335396
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR [eax], edx

; 191  : 	*y=((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;

	movzx	eax, WORD PTR _st+230
	mov	ecx, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 9216				; 00002400H
	idiv	ecx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _st+2335400
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR [eax], edx

; 192  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
@WTS@8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _POT
_TEXT	SEGMENT
_value$ = 8						; size = 4
_POT	PROC						; COMDAT

; 170  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 171  : 	if(value != 0)

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN1@POT

; 172  :     {
; 173  :         value--;

	mov	eax, DWORD PTR _value$[ebp]
	sub	eax, 1
	mov	DWORD PTR _value$[ebp], eax

; 174  :         value |= (value >> 1); //Or first 2 bits

	mov	eax, DWORD PTR _value$[ebp]
	shr	eax, 1
	or	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax

; 175  :         value |= (value >> 2); //Or next 2 bits

	mov	eax, DWORD PTR _value$[ebp]
	shr	eax, 2
	or	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax

; 176  :         value |= (value >> 4); //Or next 4 bits

	mov	eax, DWORD PTR _value$[ebp]
	shr	eax, 4
	or	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax

; 177  :         value |= (value >> 8); //Or next 8 bits

	mov	eax, DWORD PTR _value$[ebp]
	shr	eax, 8
	or	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax

; 178  :         value |= (value >> 16); //Or next 16 bits

	mov	eax, DWORD PTR _value$[ebp]
	shr	eax, 16					; 00000010H
	or	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax

; 179  :         value++;

	mov	eax, DWORD PTR _value$[ebp]
	add	eax, 1
	mov	DWORD PTR _value$[ebp], eax
$LN1@POT:

; 180  :     }
; 181  : 
; 182  : 	return value;

	mov	eax, DWORD PTR _value$[ebp]

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_POT	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _STWci
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_STWci	PROC						; COMDAT

; 152  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 153  : 	*x=((((*x*GAME_WIDTH)/st.screenx)));

	mov	eax, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	eax, 14					; 0000000eH
	movzx	ecx, WORD PTR _st+228
	cdq
	idiv	ecx
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [edx], eax

; 154  : 	*y=((((*y*GAME_HEIGHT)/st.screeny)));

	mov	eax, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR [eax], 9216
	movzx	ecx, WORD PTR _st+230
	cdq
	idiv	ecx
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR [edx], eax

; 155  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_STWci	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _RestartVideo
_TEXT	SEGMENT
_RestartVideo PROC					; COMDAT

; 2204 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2205 : 	
; 2206 : 	LogApp("Video restarted");

	push	OFFSET ??_C@_0BA@NDONFOIB@Video?5restarted?$AA@
	call	_SDL_Log
	add	esp, 4

; 2207 : 
; 2208 : 	//SDL_DestroyWindow(wn);
; 2209 : 
; 2210 : //	wn=SDL_CreateWindow(st.WINDOW_NAME,SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED,st.screenx,st.screeny, st.fullscreen==1 ? SDL_WINDOW_FULLSCREEN : NULL | SDL_WINDOW_OPENGL);
; 2211 : 
; 2212 : 	if(wn==NULL)

	cmp	DWORD PTR _wn, 0
	jne	SHORT $LN2@RestartVid

; 2213 : 	{
; 2214 : 		if(st.fullscreen) LogApp("Error setting fullscreen video mode %d x %d %d bits - %s",st.screenx,st.screeny,st.bpp,SDL_GetError());

	movzx	eax, BYTE PTR _st+233
	test	eax, eax
	je	SHORT $LN3@RestartVid
	call	_SDL_GetError
	push	eax
	movzx	eax, BYTE PTR _st+232
	push	eax
	movzx	ecx, WORD PTR _st+230
	push	ecx
	movzx	edx, WORD PTR _st+228
	push	edx
	push	OFFSET ??_C@_0DJ@GHPNMNEC@Error?5setting?5fullscreen?5video?5m@
	call	_SDL_Log
	add	esp, 20					; 00000014H
	jmp	SHORT $LN2@RestartVid
$LN3@RestartVid:

; 2215 : 		else LogApp("Error setting windowed video mode %d x %d %d bits - %s",st.screenx,st.screeny,st.bpp,SDL_GetError());

	call	_SDL_GetError
	push	eax
	movzx	eax, BYTE PTR _st+232
	push	eax
	movzx	ecx, WORD PTR _st+230
	push	ecx
	movzx	edx, WORD PTR _st+228
	push	edx
	push	OFFSET ??_C@_0DH@KKJPEJIP@Error?5setting?5windowed?5video?5mod@
	call	_SDL_Log
	add	esp, 20					; 00000014H
$LN2@RestartVid:

; 2216 : 	}
; 2217 : 
; 2218 : 	//LogApp("Window created, %d x %d, %d bits",st.screenx,st.screeny,st.bpp);
; 2219 : 
; 2220 : 	//SDL_GL_MakeCurrent(wn,st.glc);
; 2221 : 
; 2222 : 	//SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
; 2223 : //	SDL_RenderPresent(st.glc);
; 2224 : 
; 2225 : 	glViewport(0,0,st.screenx,st.screeny);

	movzx	eax, WORD PTR _st+230
	mov	esi, esp
	push	eax
	movzx	ecx, WORD PTR _st+228
	push	ecx
	push	0
	push	0
	call	DWORD PTR __imp__glViewport@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2226 : 
; 2227 : 	glClearColor(0,0,0,0);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR __imp__glClearColor@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2228 : 	glMatrixMode(GL_PROJECTION);

	mov	esi, esp
	push	5889					; 00001701H
	call	DWORD PTR __imp__glMatrixMode@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2229 : 	glLoadIdentity();

	mov	esi, esp
	call	DWORD PTR __imp__glLoadIdentity@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2230 : 	glOrtho(0,st.screenx,st.screeny,0,0,1);

	mov	esi, esp
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [esp], xmm0
	movzx	eax, WORD PTR _st+230
	cvtsi2sd xmm0, eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	movzx	ecx, WORD PTR _st+228
	cvtsi2sd xmm0, ecx
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__glOrtho@48
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2231 : 	glMatrixMode(GL_MODELVIEW);

	mov	esi, esp
	push	5888					; 00001700H
	call	DWORD PTR __imp__glMatrixMode@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2232 : 	glLoadIdentity();

	mov	esi, esp
	call	DWORD PTR __imp__glLoadIdentity@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2233 : 	glEnable(GL_BLEND);

	mov	esi, esp
	push	3042					; 00000be2H
	call	DWORD PTR __imp__glEnable@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2234 : 	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	mov	esi, esp
	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR __imp__glBlendFunc@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2235 : 	glEnable(GL_TEXTURE_2D);

	mov	esi, esp
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glEnable@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2236 : 	SDL_GL_SetSwapInterval(st.vsync);

	movzx	eax, BYTE PTR _st+241
	push	eax
	call	_SDL_GL_SetSwapInterval
	add	esp, 4

; 2237 : 
; 2238 : 	glBindRenderbuffer(GL_RENDERBUFFER, st.renderer.RBO[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336824]
	push	edx
	push	36161					; 00008d41H
	call	DWORD PTR _GLeeFuncPtr_glBindRenderbuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2239 : 	glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, st.screenx, st.screeny);

	movzx	eax, WORD PTR _st+230
	mov	esi, esp
	push	eax
	movzx	ecx, WORD PTR _st+228
	push	ecx
	push	6402					; 00001902H
	push	36161					; 00008d41H
	call	DWORD PTR _GLeeFuncPtr_glRenderbufferStorage
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2240 : 
; 2241 : 	glBindRenderbuffer(GL_RENDERBUFFER, 0);

	mov	esi, esp
	push	0
	push	36161					; 00008d41H
	call	DWORD PTR _GLeeFuncPtr_glBindRenderbuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2242 : 
; 2243 : 	glBindTexture(GL_TEXTURE_2D, st.renderer.FBTex[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336792]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2244 : 	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, st.screenx, st.screeny, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);

	mov	esi, esp
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	ecx, WORD PTR _st+228
	push	ecx
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2245 : 
; 2246 : 	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, st.renderer.FBTex[0], 0);

	mov	esi, esp
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _st[ecx+2336792]
	push	edx
	push	3553					; 00000de1H
	push	36064					; 00008ce0H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2247 : 
; 2248 : 	glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, st.renderer.RBO[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336824]
	push	edx
	push	36161					; 00008d41H
	push	36096					; 00008d00H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferRenderbuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2249 : 
; 2250 : 	glBindTexture(GL_TEXTURE_2D, st.renderer.FBTex[1]);

	mov	eax, 4
	shl	eax, 0
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336792]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2251 : 	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, st.screenx, st.screeny, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);

	mov	esi, esp
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	ecx, WORD PTR _st+228
	push	ecx
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2252 : 
; 2253 : 	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, st.renderer.FBTex[1], 0);

	mov	esi, esp
	push	0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _st[eax+2336792]
	push	ecx
	push	3553					; 00000de1H
	push	36065					; 00008ce1H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2254 : 
; 2255 : 	glBindTexture(GL_TEXTURE_2D, st.renderer.FBTex[2]);

	mov	eax, 4
	shl	eax, 1
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336792]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2256 : 	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, st.screenx, st.screeny, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);

	mov	esi, esp
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	ecx, WORD PTR _st+228
	push	ecx
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2257 : 
; 2258 : 	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, GL_TEXTURE_2D, st.renderer.FBTex[2], 0);

	mov	esi, esp
	push	0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _st[eax+2336792]
	push	ecx
	push	3553					; 00000de1H
	push	36066					; 00008ce2H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2259 : 
; 2260 : 	glBindTexture(GL_TEXTURE_2D, st.renderer.FBTex[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336792]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2261 : 	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, st.screenx, st.screeny, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);

	mov	esi, esp
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	ecx, WORD PTR _st+228
	push	ecx
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2262 : 
; 2263 : 	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT3, GL_TEXTURE_2D, st.renderer.FBTex[3], 0);

	mov	esi, esp
	push	0
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336792]
	push	edx
	push	3553					; 00000de1H
	push	36067					; 00008ce3H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2264 : 
; 2265 : 	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	mov	esi, esp
	push	0
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glBindFramebuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2266 : 	
; 2267 : 	if(SDL_GetRelativeMouseMode())

	call	_SDL_GetRelativeMouseMode
	test	eax, eax
	je	SHORT $LN1@RestartVid

; 2268 : 	{
; 2269 : 		SDL_SetRelativeMouseMode(SDL_FALSE);

	push	0
	call	_SDL_SetRelativeMouseMode
	add	esp, 4

; 2270 : 		SDL_SetRelativeMouseMode(SDL_TRUE);

	push	1
	call	_SDL_SetRelativeMouseMode
	add	esp, 4
$LN1@RestartVid:

; 2271 : 	}
; 2272 : 	
; 2273 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_RestartVideo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _LogIn
_TEXT	SEGMENT
_file$ = -8						; size = 4
_userdata$ = 8						; size = 4
_category$ = 12						; size = 4
_log$ = 16						; size = 4
_message$ = 20						; size = 4
_LogIn	PROC						; COMDAT

; 80   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 81   : 	FILE *file;
; 82   : 	size_t size;
; 83   : 	if((file=fopen("mgear.log","a+"))==NULL)

	push	OFFSET ??_C@_02DPNLHKJD@a?$CL?$AA@
	push	OFFSET ??_C@_09JFHIBJMD@mgear?4log?$AA@
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _file$[ebp], eax
	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN2@LogIn

; 84   : 	{
; 85   : 		if(MessageBox(NULL,L"Opening log file failed",NULL,MB_OK | MB_ICONERROR)==IDOK)

	mov	esi, esp
	push	16					; 00000010H
	push	0
	push	OFFSET ??_C@_1DA@PFAEBODD@?$AAO?$AAp?$AAe?$AAn?$AAi?$AAn?$AAg?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN2@LogIn

; 86   : 			Quit();

	call	_Quit
$LN2@LogIn:

; 87   : 	}
; 88   : 
; 89   : 	fseek(file,0,SEEK_END);

	push	2
	push	0
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 90   : 	fprintf(file,"%s\n",message);

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 91   : 
; 92   : 	fclose(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 93   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_LogIn	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CreateLog
_TEXT	SEGMENT
_version$ = -20						; size = 4
_file$ = -8						; size = 4
_CreateLog PROC						; COMDAT

; 96   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 97   : 	FILE *file;
; 98   : 	float version=_ENGINE_VERSION;

	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _version$[ebp], xmm0

; 99   : 	if((file=fopen("mgear.log","w"))==NULL)

	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	OFFSET ??_C@_09JFHIBJMD@mgear?4log?$AA@
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _file$[ebp], eax
	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN1@CreateLog

; 100  : 	{
; 101  : 		if(MessageBox(NULL,L"Create log failed",NULL,MB_OK | MB_ICONERROR)==IDOK) 

	mov	esi, esp
	push	16					; 00000010H
	push	0
	push	OFFSET ??_C@_1CE@CDPPCMAP@?$AAC?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN1@CreateLog

; 102  : 			exit(1);

	push	1
	call	_exit
$LN1@CreateLog:

; 103  : 	}
; 104  : 
; 105  : 	SDL_LogSetOutputFunction(&LogIn,NULL);

	push	0
	push	OFFSET _LogIn
	call	_SDL_LogSetOutputFunction
	add	esp, 8

; 106  : 
; 107  : 	fprintf(file,"%s %.2f\n",st.WindowTitle,version);

	cvtss2sd xmm0, DWORD PTR _version$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET _st+196
	push	OFFSET ??_C@_08PJPFOJIA@?$CFs?5?$CF?42f?6?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fprintf
	add	esp, 20					; 00000014H

; 108  : 	fprintf(file,"Engine started\n");

	push	OFFSET ??_C@_0BA@BIGBPAJK@Engine?5started?6?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 109  : 	fprintf(file,"Log created\n");

	push	OFFSET ??_C@_0N@JPOOLMEG@Log?5created?6?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 110  : 
; 111  : 	fclose(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$LN3@CreateLog:

; 112  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_CreateLog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _FPSCounter
_TEXT	SEGMENT
tv84 = -204						; size = 8
tv81 = -196						; size = 4
_FPSCounter PROC					; COMDAT

; 132  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 133  : 	if((SDL_GetTicks() - st.FPSTime)!=0)

	call	_SDL_GetTicks
	sub	eax, DWORD PTR _st+2335432
	je	$LN1@FPSCounter

; 134  : 	{
; 135  : 		st.FPS=SDL_GetTicks()-st.FPSTime;

	call	_SDL_GetTicks
	sub	eax, DWORD PTR _st+2335432
	mov	DWORD PTR tv81[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv81[ebp]
	mov	eax, DWORD PTR tv81[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv84[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv84[ebp]
	movss	DWORD PTR _st+2335436, xmm0

; 136  : 		st.FPS=1000/st.FPS;

	movss	xmm0, DWORD PTR __real@447a0000
	divss	xmm0, DWORD PTR _st+2335436
	movss	DWORD PTR _st+2335436, xmm0

; 137  : 		sprintf(st.WINDOW_NAME,"%s fps: %.2f",st.WindowTitle,st.FPS);

	cvtss2sd xmm0, DWORD PTR _st+2335436
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET _st+196
	push	OFFSET ??_C@_0N@NDCMMGFF@?$CFs?5fps?3?5?$CF?42f?$AA@
	push	OFFSET _st+132
	call	_sprintf
	add	esp, 20					; 00000014H

; 138  : 		//if(st.FPS<50) printf("%d\n",st.time);
; 139  : 		//st.FPS=0;
; 140  : 		st.FPSTime=SDL_GetTicks();

	call	_SDL_GetTicks
	mov	DWORD PTR _st+2335432, eax

; 141  : 		SDL_SetWindowTitle(wn,st.WINDOW_NAME);

	push	OFFSET _st+132
	mov	eax, DWORD PTR _wn
	push	eax
	call	_SDL_SetWindowTitle
	add	esp, 8
$LN1@FPSCounter:

; 142  : 	}
; 143  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_FPSCounter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT @GetTimerM@0
_TEXT	SEGMENT
@GetTimerM@0 PROC					; COMDAT

; 127  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx

; 128  : 	return st.time;

	mov	eax, DWORD PTR _st+64272
	mov	edx, DWORD PTR _st+64276

; 129  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
@GetTimerM@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT @SetTimerM@8
_TEXT	SEGMENT
_x$ = 8							; size = 8
@SetTimerM@8 PROC					; COMDAT

; 122  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx

; 123  : 	st.time+=x;

	mov	eax, DWORD PTR _st+64272
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _st+64276
	adc	ecx, DWORD PTR _x$[ebp+4]
	mov	DWORD PTR _st+64272, eax
	mov	DWORD PTR _st+64276, ecx

; 124  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
@SetTimerM@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _InitMGG
_TEXT	SEGMENT
_i$ = -8						; size = 2
_InitMGG PROC						; COMDAT

; 3461 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3462 : 	uint16 i;
; 3463 : 
; 3464 : 	for(i=0; i<MAX_MAP_MGG; i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN9@InitMGG
$LN8@InitMGG:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN9@InitMGG:
	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN7@InitMGG

; 3465 : 	{
; 3466 : 		memset(&mgg_map[i],0,sizeof(_MGG));

	push	60					; 0000003cH
	push	0
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 60
	add	ecx, OFFSET _mgg_map
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 3467 : 		mgg_map[i].type=NONE;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 60
	mov	DWORD PTR _mgg_map[ecx+36], 2

; 3468 : 	}

	jmp	SHORT $LN8@InitMGG
$LN7@InitMGG:

; 3469 : 
; 3470 : 	for(i=0; i<MAX_GAME_MGG; i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN6@InitMGG
$LN5@InitMGG:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN6@InitMGG:
	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, 128				; 00000080H
	jge	SHORT $LN4@InitMGG

; 3471 : 	{
; 3472 : 		memset(&mgg_game[i],0,sizeof(_MGG));

	push	60					; 0000003cH
	push	0
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 60
	add	ecx, OFFSET _mgg_game
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 3473 : 		mgg_game[i].type=NONE;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 60
	mov	DWORD PTR _mgg_game[ecx+36], 2

; 3474 : 	}

	jmp	SHORT $LN5@InitMGG
$LN4@InitMGG:

; 3475 : 
; 3476 : 	for(i=0; i<3; i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN3@InitMGG
$LN2@InitMGG:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN3@InitMGG:
	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, 3
	jge	SHORT $LN10@InitMGG

; 3477 : 	{
; 3478 : 		memset(&mgg_sys[i],0,sizeof(_MGG));

	push	60					; 0000003cH
	push	0
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 60
	add	ecx, OFFSET _mgg_sys
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 3479 : 		mgg_sys[i].type=NONE;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 60
	mov	DWORD PTR _mgg_sys[ecx+36], 2

; 3480 : 	}

	jmp	SHORT $LN2@InitMGG
$LN10@InitMGG:

; 3481 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_InitMGG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _FreeMGG
_TEXT	SEGMENT
_i$ = -8						; size = 4
_file$ = 8						; size = 4
_FreeMGG PROC						; COMDAT

; 3429 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3430 : 	uint32 i;
; 3431 : 
; 3432 : 	file->type=NONE;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+36], 2

; 3433 : 
; 3434 : 	for(i=0; i<file->num_frames; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@FreeMGG
$LN3@FreeMGG:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@FreeMGG:
	mov	eax, DWORD PTR _file$[ebp]
	movzx	ecx, WORD PTR [eax+32]
	cmp	DWORD PTR _i$[ebp], ecx
	jae	SHORT $LN2@FreeMGG

; 3435 : 	{
; 3436 : 		glDeleteTextures(1, &file->frames[i].data);

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	add	edx, eax
	mov	esi, esp
	push	edx
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3437 : 
; 3438 : 		if(file->frames[i].normal)

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	movzx	eax, BYTE PTR [edx+eax+8]
	test	eax, eax
	je	SHORT $LN1@FreeMGG

; 3439 : 			glDeleteTextures(1, &file->frames[i].Ndata);

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	lea	eax, DWORD PTR [edx+eax+4]
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@FreeMGG:

; 3440 : 
; 3441 : 		file->size[i].x=NULL;

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [edx+eax], 0

; 3442 : 		file->size[i].y=NULL;

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [edx+eax+4], 0

; 3443 : 	}

	jmp	$LN3@FreeMGG
$LN2@FreeMGG:

; 3444 : 
; 3445 : 	free(file->frames);

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_free
	add	esp, 4

; 3446 : 	free(file->anim);

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	_free
	add	esp, 4

; 3447 : 	free(file->size);

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	_free
	add	esp, 4

; 3448 : 
; 3449 : 	file->num_frames=NULL;

	xor	eax, eax
	mov	ecx, DWORD PTR _file$[ebp]
	mov	WORD PTR [ecx+32], ax

; 3450 : 	
; 3451 : 	file->num_anims=NULL;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+52], 0

; 3452 : 
; 3453 : 	memset(file->name,0,32);

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3454 : 
; 3455 : 	memset(file,0,sizeof(_MGG));

	push	60					; 0000003cH
	push	0
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3456 : 
; 3457 : 	file->type=NONE;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+36], 2

; 3458 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_FreeMGG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _LoadMGG
_TEXT	SEGMENT
_mgisize$ = -107076					; size = 4
_imgh$ = -107064					; size = 2
_imgw$ = -107052					; size = 2
_RLE$ = -107037						; size = 1
_MGIcolor$ = -107025					; size = 1
_checkmgg$ = -107004					; size = 4
_mga$ = -106992						; size = 4
_normalsize$ = -106980					; size = 32768
_normals$ = -74204					; size = 8192
_imgdata$ = -66004					; size = 4
_offy$ = -65956						; size = 4
_offx$ = -65944						; size = 4
_currh$ = -65932					; size = 4
_h$ = -65920						; size = 4
_w$ = -65908						; size = 4
_imgatlas$ = -65896					; size = 4
_channel2$ = -65884					; size = 2
_sizey$ = -65848					; size = 4
_sizex$ = -65836					; size = 4
_posy$ = -65824						; size = 4
_posx$ = -65812						; size = 4
_framealone$ = -65800					; size = 4
_frameoffset$ = -65788					; size = 32768
_framesize$ = -33012					; size = 32768
_o$ = -236						; size = 2
_n$ = -224						; size = 2
_m$ = -212						; size = 2
_l$ = -200						; size = 2
_k$ = -188						; size = 2
_j$ = -176						; size = 2
_i$ = -164						; size = 2
_header$ = -152						; size = 21
_mggf$ = -120						; size = 76
_data$ = -36						; size = 4
_file$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_mgg$ = 8						; size = 4
_name$ = 12						; size = 4
_LoadMGG PROC						; COMDAT

; 2444 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 107272				; 0001a308H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-107272]
	mov	ecx, 26818				; 000068c2H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2445 : 	FILE *file, *file2;
; 2446 : 	unsigned char *data;
; 2447 : 	_MGGFORMAT mggf;
; 2448 : 	char header[21];
; 2449 : 	 uint16 i=0, j=0, k=0, l=0, m=0, n=0, o=0;

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	xor	eax, eax
	mov	WORD PTR _l$[ebp], ax
	xor	eax, eax
	mov	WORD PTR _m$[ebp], ax
	xor	eax, eax
	mov	WORD PTR _n$[ebp], ax
	xor	eax, eax
	mov	WORD PTR _o$[ebp], ax

; 2450 : 	uint32 framesize[MAX_FRAMES], frameoffset[MAX_FRAMES], *framealone;
; 2451 : 	uint16 *posx, *posy, *sizex, *sizey, *dimx, *dimy, channel2;
; 2452 : 	uint8 *imgatlas;
; 2453 : 	uint16 *w, *h, *currh, *offx, *offy;
; 2454 : 	int width, height, channel;
; 2455 : 	unsigned char *imgdata;
; 2456 : 	uint8 normals[MAX_FRAMES];
; 2457 : 	uint32 normalsize[MAX_FRAMES];
; 2458 : 	_MGGANIM *mga;
; 2459 : 	int32 checkmgg;
; 2460 : 
; 2461 : 	//MGI format specs
; 2462 : 	char mgiheader[3];
; 2463 : 	uint8 MGIcolor;
; 2464 : 	uint8 RLE;
; 2465 : 	uint16 imgw, imgh;
; 2466 : 
; 2467 : 	size_t mgisize;
; 2468 : 
; 2469 : 	checkmgg=CheckMGGInSystem(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_CheckMGGInSystem
	add	esp, 4
	mov	DWORD PTR _checkmgg$[ebp], eax

; 2470 : 
; 2471 : 	if(checkmgg==-2)

	cmp	DWORD PTR _checkmgg$[ebp], -2		; fffffffeH
	jne	SHORT $LN143@LoadMGG

; 2472 : 		return 0;

	xor	eax, eax
	jmp	$LN144@LoadMGG

; 2473 : 	else

	jmp	SHORT $LN141@LoadMGG
$LN143@LoadMGG:

; 2474 : 	if(checkmgg>0)

	cmp	DWORD PTR _checkmgg$[ebp], 0
	jle	SHORT $LN141@LoadMGG

; 2475 : 	//{
; 2476 : 		//LogApp("This MGG is already loaded
; 2477 : 		return 0;

	xor	eax, eax
	jmp	$LN144@LoadMGG
$LN141@LoadMGG:

; 2478 : 	//}
; 2479 : 
; 2480 : 	memset(&normals,0,MAX_FRAMES*sizeof(uint8));

	push	8192					; 00002000H
	push	0
	lea	eax, DWORD PTR _normals$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2481 : 
; 2482 : 	/*
; 2483 : 	if((file=DecompressFile(name))==NULL)
; 2484 : 	{
; 2485 : 		LogApp("Error reading MGG file %s",name);
; 2486 : 			return 0;
; 2487 : 	}
; 2488 : 	*/
; 2489 : 
; 2490 : 	
; 2491 : 	if((file=fopen(name,"rb"))==NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _file$[ebp], eax
	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN140@LoadMGG

; 2492 : 	{
; 2493 : 		LogApp("Error reading MGG file %s",name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BK@JNFOJKPO@Error?5reading?5MGG?5file?5?$CFs?$AA@
	call	_SDL_Log
	add	esp, 8

; 2494 : 			return -2;

	mov	eax, -2					; fffffffeH
	jmp	$LN144@LoadMGG
$LN140@LoadMGG:

; 2495 : 	}
; 2496 : 
; 2497 : 	rewind(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_rewind
	add	esp, 4

; 2498 : 
; 2499 : 	fread(header,21,1,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	21					; 00000015H
	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 2500 : 
; 2501 : 	if(strcmp(header,"MGG File Version 1")!=NULL)

	push	OFFSET ??_C@_0BD@IGEJGLBO@MGG?5File?5Version?51?$AA@
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN139@LoadMGG

; 2502 : 	{
; 2503 : 		LogApp("Invalid MGG file header %s",header);

	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	push	OFFSET ??_C@_0BL@HGJNDNHB@Invalid?5MGG?5file?5header?5?$CFs?$AA@
	call	_SDL_Log
	add	esp, 8

; 2504 : 		fclose(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 2505 : 		return 0;

	xor	eax, eax
	jmp	$LN144@LoadMGG
$LN139@LoadMGG:

; 2506 : 	}
; 2507 : 
; 2508 : 	fread(&mggf,sizeof(_MGGFORMAT),1,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	76					; 0000004cH
	lea	ecx, DWORD PTR _mggf$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 2509 : 
; 2510 : 	if((mggf.type!=SPRITEM && mggf.type!=TEXTUREM && mggf.type!=NONE) || (mggf.num_animations<0 || mggf.num_animations>MAX_ANIMATIONS) || (mggf.num_frames<0 || mggf.num_frames>MAX_FRAMES))

	cmp	DWORD PTR _mggf$[ebp+36], 0
	je	SHORT $LN136@LoadMGG
	cmp	DWORD PTR _mggf$[ebp+36], 1
	je	SHORT $LN136@LoadMGG
	cmp	DWORD PTR _mggf$[ebp+36], 2
	jne	SHORT $LN135@LoadMGG
$LN136@LoadMGG:
	cmp	DWORD PTR _mggf$[ebp+48], 0
	jb	SHORT $LN135@LoadMGG
	cmp	DWORD PTR _mggf$[ebp+48], 64		; 00000040H
	ja	SHORT $LN135@LoadMGG
	movzx	eax, WORD PTR _mggf$[ebp+32]
	test	eax, eax
	jl	SHORT $LN135@LoadMGG
	movzx	eax, WORD PTR _mggf$[ebp+32]
	cmp	eax, 8192				; 00002000H
	jle	SHORT $LN138@LoadMGG
$LN135@LoadMGG:

; 2511 : 	{
; 2512 : 		fclose(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 2513 : 		LogApp("Invalid MGG file info %s",name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@MDEIDPPP@Invalid?5MGG?5file?5info?5?$CFs?$AA@
	call	_SDL_Log
	add	esp, 8

; 2514 : 		return 0;

	xor	eax, eax
	jmp	$LN144@LoadMGG
$LN138@LoadMGG:

; 2515 : 	}
; 2516 : 
; 2517 : 	strcpy(mgg->name,mggf.name);

	lea	eax, DWORD PTR _mggf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mgg$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2518 : 
; 2519 : 	mgg->num_frames=mggf.num_frames;

	mov	eax, DWORD PTR _mgg$[ebp]
	mov	cx, WORD PTR _mggf$[ebp+32]
	mov	WORD PTR [eax+32], cx

; 2520 : 
; 2521 : 	mgg->type=mggf.type;

	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR _mggf$[ebp+36]
	mov	DWORD PTR [eax+36], ecx

; 2522 : 	
; 2523 : 	mgg->num_anims=mggf.num_animations;

	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR _mggf$[ebp+48]
	mov	DWORD PTR [eax+52], ecx

; 2524 : 
; 2525 : 	mgg->frames=(TEX_DATA*) calloc(mgg->num_frames,sizeof(TEX_DATA));

	push	40					; 00000028H
	mov	eax, DWORD PTR _mgg$[ebp]
	movzx	ecx, WORD PTR [eax+32]
	push	ecx
	call	_calloc
	add	esp, 8
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	DWORD PTR [edx+40], eax

; 2526 : 
; 2527 : 	framealone=(uint32*)calloc(mgg->num_frames,sizeof(uint32));

	push	4
	mov	eax, DWORD PTR _mgg$[ebp]
	movzx	ecx, WORD PTR [eax+32]
	push	ecx
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _framealone$[ebp], eax

; 2528 : 
; 2529 : 	mga=(_MGGANIM*) malloc(mgg->num_anims*sizeof(_MGGANIM));

	mov	eax, DWORD PTR _mgg$[ebp]
	imul	ecx, DWORD PTR [eax+52], 42
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _mga$[ebp], eax

; 2530 : 	mgg->anim=(_MGGANIM*) malloc(mgg->num_anims*sizeof(_MGGANIM));

	mov	eax, DWORD PTR _mgg$[ebp]
	imul	ecx, DWORD PTR [eax+52], 42
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	DWORD PTR [edx+56], eax

; 2531 : 
; 2532 : 	fread(mga,sizeof(_MGGANIM),mgg->num_anims,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	push	42					; 0000002aH
	mov	eax, DWORD PTR _mga$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 2533 : 
; 2534 : 	for(i=0;i<mgg->num_anims;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN134@LoadMGG
$LN133@LoadMGG:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN134@LoadMGG:
	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _mgg$[ebp]
	cmp	eax, DWORD PTR [ecx+52]
	jae	SHORT $LN132@LoadMGG

; 2535 : 	{
; 2536 : 		mgg->anim[i]=mga[i];

	movzx	eax, WORD PTR _i$[ebp]
	imul	esi, eax, 42
	add	esi, DWORD PTR _mga$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 42
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	edi, DWORD PTR [eax+56]
	add	edi, edx
	mov	ecx, 10					; 0000000aH
	rep movsd
	movsw

; 2537 : 		mgg->anim[i].current_frame*=10;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 42
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+56]
	movzx	ecx, WORD PTR [eax+ecx+34]
	imul	edx, ecx, 10
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 42
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [eax+56]
	mov	WORD PTR [eax+ecx+34], dx

; 2538 : 	}

	jmp	SHORT $LN133@LoadMGG
$LN132@LoadMGG:

; 2539 : 
; 2540 : 	rewind(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_rewind
	add	esp, 4

; 2541 : 	fseek(file,mggf.framesize_offset,SEEK_CUR);

	push	1
	mov	eax, DWORD PTR _mggf$[ebp+60]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 2542 : 	fread(framesize,sizeof(uint32),mggf.num_singletex+mggf.num_atlas,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	movzx	ecx, WORD PTR _mggf$[ebp+42]
	movzx	edx, BYTE PTR _mggf$[ebp+40]
	add	ecx, edx
	push	ecx
	push	4
	lea	eax, DWORD PTR _framesize$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 2543 : 	fread(frameoffset,sizeof(uint32),mggf.num_singletex+mggf.num_atlas,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	movzx	ecx, WORD PTR _mggf$[ebp+42]
	movzx	edx, BYTE PTR _mggf$[ebp+40]
	add	ecx, edx
	push	ecx
	push	4
	lea	eax, DWORD PTR _frameoffset$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 2544 : 	fread(normals,sizeof(uint8),mggf.num_singletex+mggf.num_atlas,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	movzx	ecx, WORD PTR _mggf$[ebp+42]
	movzx	edx, BYTE PTR _mggf$[ebp+40]
	add	ecx, edx
	push	ecx
	push	1
	lea	eax, DWORD PTR _normals$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 2545 : 	fread(normalsize,sizeof(uint32),mggf.num_singletex+mggf.num_atlas,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	movzx	ecx, WORD PTR _mggf$[ebp+42]
	movzx	edx, BYTE PTR _mggf$[ebp+40]
	add	ecx, edx
	push	ecx
	push	4
	lea	eax, DWORD PTR _normalsize$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 2546 : 
; 2547 : 	mgg->size=(Pos*) malloc(mgg->num_frames*sizeof(Pos));

	mov	eax, DWORD PTR _mgg$[ebp]
	movzx	ecx, WORD PTR [eax+32]
	imul	edx, ecx, 12
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 2548 : 	mgg->atlas=(GLint*) malloc(mggf.num_atlas*sizeof(GLint));

	movzx	eax, BYTE PTR _mggf$[ebp+40]
	shl	eax, 2
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 2549 : 
; 2550 : 	for(i=0, j=0;i<mggf.num_singletex+mggf.num_atlas;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN131@LoadMGG
$LN130@LoadMGG:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN131@LoadMGG:
	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+42]
	movzx	edx, BYTE PTR _mggf$[ebp+40]
	add	ecx, edx
	cmp	eax, ecx
	jge	$LN129@LoadMGG

; 2551 : 	{
; 2552 : 		
; 2553 : 		if(i==0) fseek(file,mggf.textures_offset+1,SEEK_SET);

	movzx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	jne	SHORT $LN128@LoadMGG
	push	0
	mov	eax, DWORD PTR _mggf$[ebp+52]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 2554 : 		else

	jmp	SHORT $LN127@LoadMGG
$LN128@LoadMGG:

; 2555 : 			fseek(file,frameoffset[i-1]+1,SEEK_SET);

	push	0
	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _frameoffset$[ebp+eax*4-4]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH
$LN127@LoadMGG:

; 2556 : 		
; 2557 : 		data=malloc(framesize[i]);

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _framesize$[ebp+eax*4]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _data$[ebp], eax

; 2558 : 
; 2559 : 		if(data==NULL)

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN126@LoadMGG

; 2560 : 		{
; 2561 : 			LogApp("Error allocating memory for texture %d, size %d, file %s",i,framesize[i],name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _framesize$[ebp+ecx*4]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0DJ@PPPGBEPE@Error?5allocating?5memory?5for?5text@
	call	_SDL_Log
	add	esp, 16					; 00000010H

; 2562 : 			continue;

	jmp	$LN130@LoadMGG
$LN126@LoadMGG:

; 2563 : 		}
; 2564 : 
; 2565 : 		fread(data,framesize[i],1,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	movzx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _framesize$[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 2566 : 
; 2567 : 		if(j<mggf.num_atlas)

	movzx	eax, WORD PTR _j$[ebp]
	movzx	ecx, BYTE PTR _mggf$[ebp+40]
	cmp	eax, ecx
	jge	$LN125@LoadMGG

; 2568 : 		{
; 2569 : 			//imgdata=SOIL_load_image_from_memory((unsigned char*)data,framesize[i],&width,&height,&channel,SOIL_LOAD_AUTO);
; 2570 : 
; 2571 : 			//mgg->atlas[i]=SOIL_create_OGL_texture(imgdata,width,height,channel,0,SOIL_FLAG_TEXTURE_REPEATS); //mgg->atlas[i]=SOIL_load_OGL_texture_from_memory((unsigned char*)data,framesize[i],SOIL_LOAD_AUTO,0,SOIL_FLAG_TEXTURE_REPEATS);
; 2572 : 
; 2573 : 			if (data[0] == 'M' && data[1] == 'G' && data[2] == 'I')

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 77					; 0000004dH
	jne	$LN124@LoadMGG
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 71					; 00000047H
	jne	$LN124@LoadMGG
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 73					; 00000049H
	jne	$LN124@LoadMGG

; 2574 : 			{
; 2575 : 				MGIcolor = data[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _data$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _MGIcolor$[ebp], al

; 2576 : 				RLE = data[4];

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _data$[ebp]
	mov	dl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _RLE$[ebp], dl

; 2577 : 				imgw = data[5] << 8;

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	shl	eax, 8
	mov	WORD PTR _imgw$[ebp], ax

; 2578 : 				imgw |= data[6];

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	movzx	ecx, WORD PTR _imgw$[ebp]
	or	ecx, eax
	mov	WORD PTR _imgw$[ebp], cx

; 2579 : 
; 2580 : 				imgh = data[7] << 8;

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	shl	eax, 8
	mov	WORD PTR _imgh$[ebp], ax

; 2581 : 				imgh |= data[8];

	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	movzx	eax, WORD PTR _imgh$[ebp]
	or	eax, edx
	mov	WORD PTR _imgh$[ebp], ax

; 2582 : 				
; 2583 : 				mgisize = imgw * imgh * MGIcolor;

	movzx	eax, WORD PTR _imgw$[ebp]
	movzx	ecx, WORD PTR _imgh$[ebp]
	imul	eax, ecx
	movzx	edx, BYTE PTR _MGIcolor$[ebp]
	imul	eax, edx
	mov	DWORD PTR _mgisize$[ebp], eax

; 2584 : 
; 2585 : 				imgdata = malloc(mgisize);

	mov	eax, DWORD PTR _mgisize$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _imgdata$[ebp], eax

; 2586 : 
; 2587 : 				memcpy(imgdata, data + 9, mgisize);

	mov	eax, DWORD PTR _mgisize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 9
	push	ecx
	mov	edx, DWORD PTR _imgdata$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2588 : 
; 2589 : 				glGenTextures(1, &mgg->atlas[i]);

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2590 : 				glBindTexture(GL_TEXTURE_2D,mgg->atlas[i]);

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	esi, esp
	mov	eax, DWORD PTR [edx+eax*4]
	push	eax
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2591 : 
; 2592 : 				if (MGIcolor == 3)

	movzx	eax, BYTE PTR _MGIcolor$[ebp]
	cmp	eax, 3
	jne	SHORT $LN123@LoadMGG

; 2593 : 					glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, imgw, imgh, 0, GL_RGB, GL_UNSIGNED_BYTE, imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	push	6407					; 00001907H
	push	0
	movzx	ecx, WORD PTR _imgh$[ebp]
	push	ecx
	movzx	edx, WORD PTR _imgw$[ebp]
	push	edx
	push	32849					; 00008051H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2594 : 				else

	jmp	SHORT $LN121@LoadMGG
$LN123@LoadMGG:

; 2595 : 				if (MGIcolor == 4)

	movzx	eax, BYTE PTR _MGIcolor$[ebp]
	cmp	eax, 4
	jne	SHORT $LN121@LoadMGG

; 2596 : 					glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, imgw, imgh, 0, GL_RGBA, GL_UNSIGNED_BYTE, imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	push	6408					; 00001908H
	push	0
	movzx	ecx, WORD PTR _imgh$[ebp]
	push	ecx
	movzx	edx, WORD PTR _imgw$[ebp]
	push	edx
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN121@LoadMGG:

; 2597 : 
; 2598 : 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	mov	esi, esp
	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2599 : 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	mov	esi, esp
	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN124@LoadMGG:

; 2600 : 
; 2601 : 			}
; 2602 : 
; 2603 : 			if(mggf.mipmap)

	movsx	eax, BYTE PTR _mggf$[ebp+72]
	test	eax, eax
	je	SHORT $LN120@LoadMGG

; 2604 : 			{
; 2605 : 				glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);

	mov	esi, esp
	push	9728					; 00002600H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2606 : 				glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);

	mov	esi, esp
	push	9728					; 00002600H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2607 : 			}
; 2608 : 			else

	jmp	SHORT $LN119@LoadMGG
$LN120@LoadMGG:

; 2609 : 				glGenerateMipmap(GL_TEXTURE_2D);

	mov	esi, esp
	push	3553					; 00000de1H
	call	DWORD PTR _GLeeFuncPtr_glGenerateMipmap
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN119@LoadMGG:

; 2610 : 
; 2611 : 			mgg->frames[i].channel=MGIcolor;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, BYTE PTR _MGIcolor$[ebp]
	mov	DWORD PTR [eax+ecx+32], edx

; 2612 : 			mgg->frames[i].w=imgw;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _imgw$[ebp]
	mov	DWORD PTR [eax+ecx+24], edx

; 2613 : 			mgg->frames[i].h=imgh;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _imgh$[ebp]
	mov	DWORD PTR [eax+ecx+28], edx

; 2614 : 
; 2615 : 			if(mgg->atlas[i]==NULL)

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	cmp	DWORD PTR [edx+eax*4], 0
	jne	SHORT $LN118@LoadMGG

; 2616 : 				LogApp("Error loading texture from memory");

	push	OFFSET ??_C@_0CC@PLAHMHNO@Error?5loading?5texture?5from?5memor@
	call	_SDL_Log
	add	esp, 4
$LN118@LoadMGG:

; 2617 : 
; 2618 : 			if (data)						

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN117@LoadMGG

; 2619 : 				free(data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_free
	add	esp, 4
$LN117@LoadMGG:

; 2620 : 			if (imgdata)

	cmp	DWORD PTR _imgdata$[ebp], 0
	je	SHORT $LN116@LoadMGG

; 2621 : 				free(imgdata);

	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	call	_free
	add	esp, 4
$LN116@LoadMGG:

; 2622 : 
; 2623 : 			if(normals[i])

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _normals$[ebp+eax]
	test	ecx, ecx
	je	$LN115@LoadMGG

; 2624 : 			{
; 2625 : 				fseek(file,frameoffset[i]-normalsize[i],SEEK_SET);

	push	0
	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _frameoffset$[ebp+eax*4]
	sub	edx, DWORD PTR _normalsize$[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 2626 : 		
; 2627 : 				data=malloc(normalsize[i]);

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _normalsize$[ebp+eax*4]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _data$[ebp], eax

; 2628 : 
; 2629 : 				if(data==NULL)

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN114@LoadMGG

; 2630 : 				{
; 2631 : 					LogApp("Error allocating memory for normal mapping texture %d, size %d, file %s",i,normalsize[i],name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _normalsize$[ebp+ecx*4]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0EI@OCDBEPGI@Error?5allocating?5memory?5for?5norm@
	call	_SDL_Log
	add	esp, 16					; 00000010H

; 2632 : 					continue;

	jmp	$LN130@LoadMGG
$LN114@LoadMGG:

; 2633 : 				}
; 2634 : 
; 2635 : 				fread(data,normalsize[i],1,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	movzx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _normalsize$[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 2636 : 
; 2637 : 				//imgdata=SOIL_load_image_from_memory((unsigned char*)data,normalsize[i],&width,&height,&channel,SOIL_LOAD_AUTO);
; 2638 : 				//mgg->frames[i].Ndata=SOIL_create_OGL_texture(imgdata,width,height,channel,0,SOIL_FLAG_TEXTURE_REPEATS);
; 2639 : 
; 2640 : 				if (data[0] == 'M' && data[1] == 'G' && data[2] == 'I')

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 77					; 0000004dH
	jne	$LN113@LoadMGG
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 71					; 00000047H
	jne	$LN113@LoadMGG
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 73					; 00000049H
	jne	$LN113@LoadMGG

; 2641 : 				{
; 2642 : 					MGIcolor = data[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _data$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _MGIcolor$[ebp], al

; 2643 : 					RLE = data[4];

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _data$[ebp]
	mov	dl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _RLE$[ebp], dl

; 2644 : 					imgw = data[5] << 8;

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	shl	eax, 8
	mov	WORD PTR _imgw$[ebp], ax

; 2645 : 					imgw |= data[6];

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	movzx	ecx, WORD PTR _imgw$[ebp]
	or	ecx, eax
	mov	WORD PTR _imgw$[ebp], cx

; 2646 : 
; 2647 : 					imgh = data[7] << 8;

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	shl	eax, 8
	mov	WORD PTR _imgh$[ebp], ax

; 2648 : 					imgh |= data[8];

	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	movzx	eax, WORD PTR _imgh$[ebp]
	or	eax, edx
	mov	WORD PTR _imgh$[ebp], ax

; 2649 : 
; 2650 : 					mgisize = imgw * imgh * MGIcolor;

	movzx	eax, WORD PTR _imgw$[ebp]
	movzx	ecx, WORD PTR _imgh$[ebp]
	imul	eax, ecx
	movzx	edx, BYTE PTR _MGIcolor$[ebp]
	imul	eax, edx
	mov	DWORD PTR _mgisize$[ebp], eax

; 2651 : 
; 2652 : 					imgdata = malloc(mgisize);

	mov	eax, DWORD PTR _mgisize$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _imgdata$[ebp], eax

; 2653 : 
; 2654 : 					memcpy(imgdata, data + 9, mgisize);

	mov	eax, DWORD PTR _mgisize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 9
	push	ecx
	mov	edx, DWORD PTR _imgdata$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2655 : 
; 2656 : 					glGenTextures(1, &mgg->frames[i].Ndata);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	lea	ecx, DWORD PTR [eax+ecx+4]
	mov	esi, esp
	push	ecx
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2657 : 					glBindTexture(GL_TEXTURE_2D, mgg->frames[i].Ndata);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+ecx+4]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2658 : 
; 2659 : 					if (MGIcolor == 3)

	movzx	eax, BYTE PTR _MGIcolor$[ebp]
	cmp	eax, 3
	jne	SHORT $LN112@LoadMGG

; 2660 : 						glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, imgw, imgh, 0, GL_RGB, GL_UNSIGNED_BYTE, imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	push	6407					; 00001907H
	push	0
	movzx	ecx, WORD PTR _imgh$[ebp]
	push	ecx
	movzx	edx, WORD PTR _imgw$[ebp]
	push	edx
	push	32849					; 00008051H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2661 : 					else

	jmp	SHORT $LN110@LoadMGG
$LN112@LoadMGG:

; 2662 : 					if (MGIcolor == 4)

	movzx	eax, BYTE PTR _MGIcolor$[ebp]
	cmp	eax, 4
	jne	SHORT $LN110@LoadMGG

; 2663 : 						glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, imgw, imgh, 0, GL_RGBA, GL_UNSIGNED_BYTE, imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	push	6408					; 00001908H
	push	0
	movzx	ecx, WORD PTR _imgh$[ebp]
	push	ecx
	movzx	edx, WORD PTR _imgw$[ebp]
	push	edx
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN110@LoadMGG:

; 2664 : 
; 2665 : 					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	mov	esi, esp
	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2666 : 					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	mov	esi, esp
	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN113@LoadMGG:

; 2667 : 
; 2668 : 				}
; 2669 : 
; 2670 : 				if(mggf.mipmap)

	movsx	eax, BYTE PTR _mggf$[ebp+72]
	test	eax, eax
	je	SHORT $LN109@LoadMGG

; 2671 : 				{
; 2672 : 					glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);

	mov	esi, esp
	push	9728					; 00002600H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2673 : 					glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);

	mov	esi, esp
	push	9728					; 00002600H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2674 : 				}
; 2675 : 				else

	jmp	SHORT $LN108@LoadMGG
$LN109@LoadMGG:

; 2676 : 					glGenerateMipmap(GL_TEXTURE_2D);

	mov	esi, esp
	push	3553					; 00000de1H
	call	DWORD PTR _GLeeFuncPtr_glGenerateMipmap
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN108@LoadMGG:

; 2677 : 
; 2678 : 				mgg->frames[i].normal=1;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	BYTE PTR [eax+ecx+8], 1

; 2679 : 
; 2680 : 				if(mgg->frames[i].Ndata==NULL)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+4], 0
	jne	SHORT $LN107@LoadMGG

; 2681 : 					LogApp("Error loading normal mapping texture from memory");

	push	OFFSET ??_C@_0DB@EBPLCLOB@Error?5loading?5normal?5mapping?5tex@
	call	_SDL_Log
	add	esp, 4
$LN107@LoadMGG:

; 2682 : 
; 2683 : 					if (data)						

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN106@LoadMGG

; 2684 : 						free(data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_free
	add	esp, 4
$LN106@LoadMGG:

; 2685 : 					if (imgdata)

	cmp	DWORD PTR _imgdata$[ebp], 0
	je	SHORT $LN105@LoadMGG

; 2686 : 						free(imgdata);

	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	call	_free
	add	esp, 4
$LN105@LoadMGG:

; 2687 : 			}
; 2688 : 			else

	jmp	SHORT $LN104@LoadMGG
$LN115@LoadMGG:

; 2689 : 				mgg->frames[i].normal=0;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	BYTE PTR [eax+ecx+8], 0
$LN104@LoadMGG:

; 2690 : 
; 2691 : 			j++;

	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax

; 2692 : 		}
; 2693 : 		else

	jmp	$LN103@LoadMGG
$LN125@LoadMGG:

; 2694 : 		{
; 2695 : 			i-=mggf.num_atlas;

	movzx	eax, BYTE PTR _mggf$[ebp+40]
	movzx	ecx, WORD PTR _i$[ebp]
	sub	ecx, eax
	mov	WORD PTR _i$[ebp], cx

; 2696 : 			//imgdata=SOIL_load_image_from_memory((unsigned char*)data,framesize[i],&width,&height,&channel,SOIL_LOAD_AUTO);
; 2697 : 			//mgg->frames[i+(mggf.num_frames-mggf.num_singletex)].data=SOIL_create_OGL_texture(imgdata,width,height,channel,0,SOIL_FLAG_TEXTURE_REPEATS);//SOIL_load_OGL_texture_from_memory((unsigned char*)data,framesize[i],SOIL_LOAD_AUTO,0,SOIL_FLAG_TEXTURE_REPEATS);
; 2698 : 
; 2699 : 			if (data[0] == 'M' && data[1] == 'G' && data[2] == 'I')

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 77					; 0000004dH
	jne	$LN102@LoadMGG
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 71					; 00000047H
	jne	$LN102@LoadMGG
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 73					; 00000049H
	jne	$LN102@LoadMGG

; 2700 : 			{
; 2701 : 				MGIcolor = data[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _data$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _MGIcolor$[ebp], al

; 2702 : 				RLE = data[4];

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _data$[ebp]
	mov	dl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _RLE$[ebp], dl

; 2703 : 				imgw = data[5] << 8;

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	shl	eax, 8
	mov	WORD PTR _imgw$[ebp], ax

; 2704 : 				imgw |= data[6];

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	movzx	ecx, WORD PTR _imgw$[ebp]
	or	ecx, eax
	mov	WORD PTR _imgw$[ebp], cx

; 2705 : 
; 2706 : 				imgh = data[7] << 8;

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	shl	eax, 8
	mov	WORD PTR _imgh$[ebp], ax

; 2707 : 				imgh |= data[8];

	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	movzx	eax, WORD PTR _imgh$[ebp]
	or	eax, edx
	mov	WORD PTR _imgh$[ebp], ax

; 2708 : 
; 2709 : 				mgisize = imgw * imgh * MGIcolor;

	movzx	eax, WORD PTR _imgw$[ebp]
	movzx	ecx, WORD PTR _imgh$[ebp]
	imul	eax, ecx
	movzx	edx, BYTE PTR _MGIcolor$[ebp]
	imul	eax, edx
	mov	DWORD PTR _mgisize$[ebp], eax

; 2710 : 
; 2711 : 				imgdata = malloc(mgisize);

	mov	eax, DWORD PTR _mgisize$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _imgdata$[ebp], eax

; 2712 : 
; 2713 : 				memcpy(imgdata, data + 9, mgisize);

	mov	eax, DWORD PTR _mgisize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 9
	push	ecx
	mov	edx, DWORD PTR _imgdata$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2714 : 
; 2715 : 				glGenTextures(1, &mgg->frames[i + (mggf.num_frames - mggf.num_singletex)].data);

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+32]
	movzx	edx, WORD PTR _mggf$[ebp+42]
	sub	ecx, edx
	add	eax, ecx
	imul	eax, eax, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	add	edx, eax
	mov	esi, esp
	push	edx
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2716 : 				glBindTexture(GL_TEXTURE_2D, mgg->frames[i + (mggf.num_frames - mggf.num_singletex)].data);

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+32]
	movzx	edx, WORD PTR _mggf$[ebp+42]
	sub	ecx, edx
	add	eax, ecx
	imul	eax, eax, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	esi, esp
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2717 : 
; 2718 : 				if (MGIcolor == 3)

	movzx	eax, BYTE PTR _MGIcolor$[ebp]
	cmp	eax, 3
	jne	SHORT $LN101@LoadMGG

; 2719 : 					glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, imgw, imgh, 0, GL_RGB, GL_UNSIGNED_BYTE, imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	push	6407					; 00001907H
	push	0
	movzx	ecx, WORD PTR _imgh$[ebp]
	push	ecx
	movzx	edx, WORD PTR _imgw$[ebp]
	push	edx
	push	32849					; 00008051H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2720 : 				else

	jmp	SHORT $LN99@LoadMGG
$LN101@LoadMGG:

; 2721 : 				if (MGIcolor == 4)

	movzx	eax, BYTE PTR _MGIcolor$[ebp]
	cmp	eax, 4
	jne	SHORT $LN99@LoadMGG

; 2722 : 					glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, imgw, imgh, 0, GL_RGBA, GL_UNSIGNED_BYTE, imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	push	6408					; 00001908H
	push	0
	movzx	ecx, WORD PTR _imgh$[ebp]
	push	ecx
	movzx	edx, WORD PTR _imgw$[ebp]
	push	edx
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN99@LoadMGG:

; 2723 : 
; 2724 : 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	mov	esi, esp
	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2725 : 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	mov	esi, esp
	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN102@LoadMGG:

; 2726 : 
; 2727 : 			}
; 2728 : 
; 2729 : 			//glGenerateMipmap(GL_TEXTURE_2D);
; 2730 : 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	mov	esi, esp
	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2731 : 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

	mov	esi, esp
	push	10497					; 00002901H
	push	10243					; 00002803H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2732 : 
; 2733 : 			if(mggf.mipmap)

	movsx	eax, BYTE PTR _mggf$[ebp+72]
	test	eax, eax
	je	SHORT $LN98@LoadMGG

; 2734 : 			{
; 2735 : 				glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);

	mov	esi, esp
	push	9728					; 00002600H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2736 : 				glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);

	mov	esi, esp
	push	9728					; 00002600H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2737 : 			}
; 2738 : 			else

	jmp	SHORT $LN97@LoadMGG
$LN98@LoadMGG:

; 2739 : 				glGenerateMipmap(GL_TEXTURE_2D);

	mov	esi, esp
	push	3553					; 00000de1H
	call	DWORD PTR _GLeeFuncPtr_glGenerateMipmap
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN97@LoadMGG:

; 2740 : 
; 2741 : 			mgg->frames[i+(mggf.num_texinatlas)].w=imgw;

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	add	eax, ecx
	imul	edx, eax, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	movzx	eax, WORD PTR _imgw$[ebp]
	mov	DWORD PTR [ecx+edx+24], eax

; 2742 : 			mgg->frames[i+(mggf.num_texinatlas)].h=imgh;

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	add	eax, ecx
	imul	edx, eax, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	movzx	eax, WORD PTR _imgh$[ebp]
	mov	DWORD PTR [ecx+edx+28], eax

; 2743 : 			mgg->frames[i+(mggf.num_texinatlas)].channel=MGIcolor;

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	add	eax, ecx
	imul	edx, eax, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	movzx	eax, BYTE PTR _MGIcolor$[ebp]
	mov	DWORD PTR [ecx+edx+32], eax

; 2744 : 
; 2745 : 			mgg->frames[i+(mggf.num_texinatlas)].posx=0;

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	add	eax, ecx
	imul	edx, eax, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	xor	eax, eax
	mov	WORD PTR [ecx+edx+14], ax

; 2746 : 			mgg->frames[i+(mggf.num_texinatlas)].posy=0;

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	add	eax, ecx
	imul	edx, eax, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	xor	eax, eax
	mov	WORD PTR [ecx+edx+16], ax

; 2747 : 			mgg->frames[i+mggf.num_texinatlas].vb_id=-1;

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	add	eax, ecx
	imul	edx, eax, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	eax, -1
	mov	WORD PTR [ecx+edx+10], ax

; 2748 : 
; 2749 : 			if(mgg->frames[i+(mggf.num_texinatlas)].data==NULL)

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	add	eax, ecx
	imul	edx, eax, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	cmp	DWORD PTR [ecx+edx], 0
	jne	SHORT $LN96@LoadMGG

; 2750 : 				LogApp("Error loading texture from memory");

	push	OFFSET ??_C@_0CC@PLAHMHNO@Error?5loading?5texture?5from?5memor@
	call	_SDL_Log
	add	esp, 4
$LN96@LoadMGG:

; 2751 : 
; 2752 : 			if (data)						

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN95@LoadMGG

; 2753 : 				free(data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_free
	add	esp, 4
$LN95@LoadMGG:

; 2754 : 			if(imgdata)

	cmp	DWORD PTR _imgdata$[ebp], 0
	je	SHORT $LN94@LoadMGG

; 2755 : 				free(imgdata);

	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	call	_free
	add	esp, 4
$LN94@LoadMGG:

; 2756 : 
; 2757 : 			if(normals[i])

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _normals$[ebp+eax]
	test	ecx, ecx
	je	$LN93@LoadMGG

; 2758 : 			{
; 2759 : 				fseek(file,frameoffset[i]-normalsize[i],SEEK_SET);

	push	0
	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _frameoffset$[ebp+eax*4]
	sub	edx, DWORD PTR _normalsize$[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 2760 : 		
; 2761 : 				data=malloc(normalsize[i]);

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _normalsize$[ebp+eax*4]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _data$[ebp], eax

; 2762 : 
; 2763 : 				if(data==NULL)

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN92@LoadMGG

; 2764 : 				{
; 2765 : 					LogApp("Error allocating memory for normal mapping texture %d, size %d, file %s",i,normalsize[i],name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _normalsize$[ebp+ecx*4]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0EI@OCDBEPGI@Error?5allocating?5memory?5for?5norm@
	call	_SDL_Log
	add	esp, 16					; 00000010H

; 2766 : 					continue;

	jmp	$LN130@LoadMGG
$LN92@LoadMGG:

; 2767 : 				}
; 2768 : 
; 2769 : 				fread(data,normalsize[i],1,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	movzx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _normalsize$[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 2770 : 
; 2771 : 				//imgdata=SOIL_load_image_from_memory((unsigned char*)data,normalsize[i],&width,&height,&channel,SOIL_LOAD_AUTO);
; 2772 : 				//mgg->frames[i+(mggf.num_texinatlas)].Ndata=SOIL_create_OGL_texture(imgdata,width,height,channel,0,SOIL_FLAG_TEXTURE_REPEATS || SOIL_FLAG_MIPMAPS);
; 2773 : 
; 2774 : 				if (data[0] == 'M' && data[1] == 'G' && data[2] == 'I')

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 77					; 0000004dH
	jne	$LN91@LoadMGG
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 71					; 00000047H
	jne	$LN91@LoadMGG
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 73					; 00000049H
	jne	$LN91@LoadMGG

; 2775 : 				{
; 2776 : 					MGIcolor = data[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _data$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _MGIcolor$[ebp], al

; 2777 : 					RLE = data[4];

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _data$[ebp]
	mov	dl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _RLE$[ebp], dl

; 2778 : 					imgw = data[5] << 8;

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	shl	eax, 8
	mov	WORD PTR _imgw$[ebp], ax

; 2779 : 					imgw |= data[6];

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	movzx	ecx, WORD PTR _imgw$[ebp]
	or	ecx, eax
	mov	WORD PTR _imgw$[ebp], cx

; 2780 : 
; 2781 : 					imgh = data[7] << 8;

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	shl	eax, 8
	mov	WORD PTR _imgh$[ebp], ax

; 2782 : 					imgh |= data[8];

	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	movzx	eax, WORD PTR _imgh$[ebp]
	or	eax, edx
	mov	WORD PTR _imgh$[ebp], ax

; 2783 : 
; 2784 : 					mgisize = imgw * imgh * MGIcolor;

	movzx	eax, WORD PTR _imgw$[ebp]
	movzx	ecx, WORD PTR _imgh$[ebp]
	imul	eax, ecx
	movzx	edx, BYTE PTR _MGIcolor$[ebp]
	imul	eax, edx
	mov	DWORD PTR _mgisize$[ebp], eax

; 2785 : 
; 2786 : 					imgdata = malloc(mgisize);

	mov	eax, DWORD PTR _mgisize$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _imgdata$[ebp], eax

; 2787 : 
; 2788 : 					memcpy(imgdata, data + 9, mgisize);

	mov	eax, DWORD PTR _mgisize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 9
	push	ecx
	mov	edx, DWORD PTR _imgdata$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2789 : 
; 2790 : 					//glGenTextures(1, &mgg->frames[i + (mggf.num_texinatlas)].Ndata);
; 2791 : 					//glBindTexture(GL_TEXTURE_2D, mgg->frames[i + (mggf.num_texinatlas)].Ndata);
; 2792 : 
; 2793 : 					glGenTextures(1, &mgg->frames[i + (mggf.num_frames - mggf.num_singletex)].Ndata);

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+32]
	movzx	edx, WORD PTR _mggf$[ebp+42]
	sub	ecx, edx
	add	eax, ecx
	imul	eax, eax, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	lea	eax, DWORD PTR [edx+eax+4]
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2794 : 					glBindTexture(GL_TEXTURE_2D, mgg->frames[i + (mggf.num_frames - mggf.num_singletex)].Ndata);

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+32]
	movzx	edx, WORD PTR _mggf$[ebp+42]
	sub	ecx, edx
	add	eax, ecx
	imul	eax, eax, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	esi, esp
	mov	eax, DWORD PTR [edx+eax+4]
	push	eax
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2795 : 					
; 2796 : 					if (MGIcolor == 3)

	movzx	eax, BYTE PTR _MGIcolor$[ebp]
	cmp	eax, 3
	jne	SHORT $LN90@LoadMGG

; 2797 : 						glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, imgw, imgh, 0, GL_RGB, GL_UNSIGNED_BYTE, imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	push	6407					; 00001907H
	push	0
	movzx	ecx, WORD PTR _imgh$[ebp]
	push	ecx
	movzx	edx, WORD PTR _imgw$[ebp]
	push	edx
	push	32849					; 00008051H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2798 : 					else

	jmp	SHORT $LN88@LoadMGG
$LN90@LoadMGG:

; 2799 : 					if (MGIcolor == 4)

	movzx	eax, BYTE PTR _MGIcolor$[ebp]
	cmp	eax, 4
	jne	SHORT $LN88@LoadMGG

; 2800 : 						glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, imgw, imgh, 0, GL_RGBA, GL_UNSIGNED_BYTE, imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	push	6408					; 00001908H
	push	0
	movzx	ecx, WORD PTR _imgh$[ebp]
	push	ecx
	movzx	edx, WORD PTR _imgw$[ebp]
	push	edx
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN88@LoadMGG:

; 2801 : 
; 2802 : 					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	mov	esi, esp
	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2803 : 					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	mov	esi, esp
	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN91@LoadMGG:

; 2804 : 
; 2805 : 				}
; 2806 : 
; 2807 : 				if(mggf.mipmap)

	movsx	eax, BYTE PTR _mggf$[ebp+72]
	test	eax, eax
	je	SHORT $LN87@LoadMGG

; 2808 : 				{
; 2809 : 					glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);

	mov	esi, esp
	push	9728					; 00002600H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2810 : 					glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);

	mov	esi, esp
	push	9728					; 00002600H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2811 : 				}
; 2812 : 				else

	jmp	SHORT $LN86@LoadMGG
$LN87@LoadMGG:

; 2813 : 					glGenerateMipmap(GL_TEXTURE_2D);

	mov	esi, esp
	push	3553					; 00000de1H
	call	DWORD PTR _GLeeFuncPtr_glGenerateMipmap
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN86@LoadMGG:

; 2814 : 
; 2815 : 				mgg->frames[i+(mggf.num_texinatlas)].normal=1;

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	add	eax, ecx
	imul	edx, eax, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	BYTE PTR [ecx+edx+8], 1

; 2816 : 
; 2817 : 				if(mgg->frames[i+(mggf.num_texinatlas)].Ndata==NULL)

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	add	eax, ecx
	imul	edx, eax, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	cmp	DWORD PTR [ecx+edx+4], 0
	jne	SHORT $LN85@LoadMGG

; 2818 : 					LogApp("Error loading normal mapping texture from memory");

	push	OFFSET ??_C@_0DB@EBPLCLOB@Error?5loading?5normal?5mapping?5tex@
	call	_SDL_Log
	add	esp, 4
$LN85@LoadMGG:

; 2819 : 
; 2820 : 				if(data)						

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN84@LoadMGG

; 2821 : 					free(data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_free
	add	esp, 4
$LN84@LoadMGG:

; 2822 : 				if(imgdata)

	cmp	DWORD PTR _imgdata$[ebp], 0
	je	SHORT $LN83@LoadMGG

; 2823 : 					free(imgdata);

	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	call	_free
	add	esp, 4
$LN83@LoadMGG:

; 2824 : 
; 2825 : 			}
; 2826 : 			else

	jmp	SHORT $LN82@LoadMGG
$LN93@LoadMGG:

; 2827 : 				mgg->frames[i+(mggf.num_texinatlas)].normal=0;

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	add	eax, ecx
	imul	edx, eax, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	BYTE PTR [ecx+edx+8], 0
$LN82@LoadMGG:

; 2828 : 
; 2829 : 			i+=mggf.num_atlas;

	movzx	eax, BYTE PTR _mggf$[ebp+40]
	movzx	ecx, WORD PTR _i$[ebp]
	add	ecx, eax
	mov	WORD PTR _i$[ebp], cx
$LN103@LoadMGG:

; 2830 : 		}
; 2831 : 	}

	jmp	$LN130@LoadMGG
$LN129@LoadMGG:

; 2832 : 		
; 2833 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 2834 : 	if(mggf.num_atlas>0)

	movzx	eax, BYTE PTR _mggf$[ebp+40]
	test	eax, eax
	jle	$LN78@LoadMGG

; 2835 : 	{
; 2836 : 		for(i=0;i<mggf.num_atlas;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN80@LoadMGG
$LN79@LoadMGG:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN80@LoadMGG:
	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _mggf$[ebp+40]
	cmp	eax, ecx
	jge	$LN78@LoadMGG

; 2837 : 		{
; 2838 : 			if(!vbdt_num)

	movzx	eax, WORD PTR _vbdt_num
	test	eax, eax
	jne	SHORT $LN77@LoadMGG

; 2839 : 			{
; 2840 : 				vbdt_num++;

	mov	ax, WORD PTR _vbdt_num
	add	ax, 1
	mov	WORD PTR _vbdt_num, ax

; 2841 : 				vbdt=(VB_DATAT*) malloc(sizeof(VB_DATAT));

	push	64					; 00000040H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _vbdt, eax

; 2842 : 				if(!vbdt)

	cmp	DWORD PTR _vbdt, 0
	jne	SHORT $LN76@LoadMGG

; 2843 : 					LogApp("Error could not allocate memory for the Vertex Buffer");

	push	OFFSET ??_C@_0DG@BNCAOHGG@Error?5could?5not?5allocate?5memory?5@
	call	_SDL_Log
	add	esp, 4
$LN76@LoadMGG:

; 2844 : 			}
; 2845 : 			else

	jmp	SHORT $LN75@LoadMGG
$LN77@LoadMGG:

; 2846 : 			{
; 2847 : 				vbdt_num++;

	mov	ax, WORD PTR _vbdt_num
	add	ax, 1
	mov	WORD PTR _vbdt_num, ax

; 2848 : 				vbdt=(VB_DATAT*) realloc(vbdt,vbdt_num*sizeof(VB_DATAT));

	movzx	eax, WORD PTR _vbdt_num
	shl	eax, 6
	push	eax
	mov	ecx, DWORD PTR _vbdt
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _vbdt, eax
$LN75@LoadMGG:

; 2849 : 			}
; 2850 : 
; 2851 : 			vbdt[vbdt_num-1].num_elements=0;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	xor	ecx, ecx
	mov	edx, DWORD PTR _vbdt
	mov	WORD PTR [edx+eax+46], cx

; 2852 : 			vbdt[vbdt_num-1].texture=mgg->atlas[i];

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	movzx	ecx, WORD PTR _vbdt_num
	sub	ecx, 1
	shl	ecx, 6
	mov	esi, DWORD PTR _vbdt
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [esi+ecx+36], edx

; 2853 : 
; 2854 : 			vbdt[vbdt_num-1].normal=mgg->frames[i].normal;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _vbdt_num
	sub	edx, 1
	shl	edx, 6
	mov	esi, DWORD PTR _vbdt
	mov	al, BYTE PTR [eax+ecx+8]
	mov	BYTE PTR [esi+edx+44], al

; 2855 : 
; 2856 : 			
; 2857 : 			if(mgg->frames[i].normal)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	ecx, BYTE PTR [eax+ecx+8]
	test	ecx, ecx
	je	SHORT $LN74@LoadMGG

; 2858 : 				vbdt[vbdt_num-1].Ntexture=mgg->frames[i].Ndata;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _vbdt_num
	sub	edx, 1
	shl	edx, 6
	mov	esi, DWORD PTR _vbdt
	mov	eax, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR [esi+edx+40], eax
$LN74@LoadMGG:

; 2859 : 
; 2860 : 			mgg->frames[i].vb_id=vbdt_num-1;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	WORD PTR [ecx+edx+10], ax

; 2861 : 
; 2862 : 			vbdt[vbdt_num-1].buffer_elements=8;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	mov	ecx, 8
	mov	edx, DWORD PTR _vbdt
	mov	WORD PTR [edx+eax+48], cx

; 2863 : 			
; 2864 : #ifdef _VAO_RENDER
; 2865 : 			if(st.renderer.VAO_ON) CreateVAO(&vbdt[vbdt_num-1],0,3);

	movzx	eax, BYTE PTR _st+2336440
	test	eax, eax
	je	SHORT $LN73@LoadMGG
	push	3
	push	0
	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	add	eax, DWORD PTR _vbdt
	push	eax
	call	_CreateVAO
	add	esp, 12					; 0000000cH
$LN73@LoadMGG:

; 2866 : #endif
; 2867 : #ifdef _VBO_RENDER
; 2868 : 			if(st.renderer.VBO_ON) CreateVBO(&vbdt[vbdt_num-1], 0);

	movzx	eax, BYTE PTR _st+2336452
	test	eax, eax
	je	SHORT $LN72@LoadMGG
	push	0
	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	add	eax, DWORD PTR _vbdt
	push	eax
	call	_CreateVBO
	add	esp, 8
$LN72@LoadMGG:

; 2869 : #endif
; 2870 : 		}

	jmp	$LN79@LoadMGG
$LN78@LoadMGG:

; 2871 : 
; 2872 : 	}
; 2873 : #endif
; 2874 : 
; 2875 : 	fseek(file,mggf.possize_offset,SEEK_SET);

	push	0
	mov	eax, DWORD PTR _mggf$[ebp+56]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 2876 : 
; 2877 : 	posx=(uint16*) malloc((mggf.num_texinatlas)*sizeof(uint16));

	movzx	eax, WORD PTR _mggf$[ebp+44]
	shl	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _posx$[ebp], eax

; 2878 : 	posy=(uint16*) malloc((mggf.num_texinatlas)*sizeof(uint16));

	movzx	eax, WORD PTR _mggf$[ebp+44]
	shl	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _posy$[ebp], eax

; 2879 : 	sizex=(uint16*) malloc((mggf.num_texinatlas)*sizeof(uint16));

	movzx	eax, WORD PTR _mggf$[ebp+44]
	shl	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _sizex$[ebp], eax

; 2880 : 	sizey=(uint16*) malloc((mggf.num_texinatlas)*sizeof(uint16));

	movzx	eax, WORD PTR _mggf$[ebp+44]
	shl	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _sizey$[ebp], eax

; 2881 : 	imgatlas=(uint8*) malloc((mggf.num_texinatlas)*sizeof(uint8));

	movzx	eax, WORD PTR _mggf$[ebp+44]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _imgatlas$[ebp], eax

; 2882 : 	offx=malloc(mggf.num_frames*sizeof(int16));

	movzx	eax, WORD PTR _mggf$[ebp+32]
	shl	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _offx$[ebp], eax

; 2883 : 	offy=malloc(mggf.num_frames*sizeof(int16));

	movzx	eax, WORD PTR _mggf$[ebp+32]
	shl	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _offy$[ebp], eax

; 2884 : 
; 2885 : 	fread(posx,sizeof(uint16),(mggf.num_texinatlas),file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	push	ecx
	push	2
	mov	edx, DWORD PTR _posx$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 2886 : 	fread(posy,sizeof(uint16),(mggf.num_texinatlas),file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	push	ecx
	push	2
	mov	edx, DWORD PTR _posy$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 2887 : 	fread(sizex,sizeof(uint16),(mggf.num_texinatlas),file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	push	ecx
	push	2
	mov	edx, DWORD PTR _sizex$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 2888 : 	fread(sizey,sizeof(uint16),(mggf.num_texinatlas),file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	push	ecx
	push	2
	mov	edx, DWORD PTR _sizey$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 2889 : 	fread(imgatlas,sizeof(uint8),(mggf.num_texinatlas),file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	push	ecx
	push	1
	mov	edx, DWORD PTR _imgatlas$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 2890 : 
; 2891 : 	for(i=mggf.num_atlas-1;i<mggf.num_texinatlas;i++)

	movzx	eax, BYTE PTR _mggf$[ebp+40]
	sub	eax, 1
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN71@LoadMGG
$LN70@LoadMGG:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN71@LoadMGG:
	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	cmp	eax, ecx
	jge	$LN69@LoadMGG

; 2892 : 	{
; 2893 : 		mgg->frames[i].data=mgg->atlas[imgatlas[i]];

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _imgatlas$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	movzx	eax, WORD PTR _i$[ebp]
	imul	eax, eax, 40
	mov	esi, DWORD PTR _mgg$[ebp]
	mov	esi, DWORD PTR [esi+40]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [esi+eax], ecx

; 2894 : 		mgg->frames[i].posx=posx[i];

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	esi, DWORD PTR _posx$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx+14], ax

; 2895 : 		mgg->frames[i].posy=posy[i];

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	esi, DWORD PTR _posy$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx+16], ax

; 2896 : 		mgg->frames[i].sizex=sizex[i];

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	esi, DWORD PTR _sizex$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx+18], ax

; 2897 : 		mgg->frames[i].sizey=sizey[i];

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	esi, DWORD PTR _sizey$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx+20], ax

; 2898 : 		mgg->frames[i].vb_id=mgg->frames[imgatlas[i]].vb_id;

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _imgatlas$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	imul	eax, edx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	ecx, ecx, 40
	mov	esi, DWORD PTR _mgg$[ebp]
	mov	esi, DWORD PTR [esi+40]
	mov	dx, WORD PTR [edx+eax+10]
	mov	WORD PTR [esi+ecx+10], dx

; 2899 : 		mgg->frames[i].w=mgg->frames[imgatlas[i]].w;

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _imgatlas$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	imul	eax, edx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	ecx, ecx, 40
	mov	esi, DWORD PTR _mgg$[ebp]
	mov	esi, DWORD PTR [esi+40]
	mov	edx, DWORD PTR [edx+eax+24]
	mov	DWORD PTR [esi+ecx+24], edx

; 2900 : 		mgg->frames[i].h=mgg->frames[imgatlas[i]].h;

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _imgatlas$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	imul	eax, edx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	ecx, ecx, 40
	mov	esi, DWORD PTR _mgg$[ebp]
	mov	esi, DWORD PTR [esi+40]
	mov	edx, DWORD PTR [edx+eax+28]
	mov	DWORD PTR [esi+ecx+28], edx

; 2901 : 	}

	jmp	$LN70@LoadMGG
$LN69@LoadMGG:

; 2902 : 	
; 2903 : 	fseek(file,mggf.framealone_offset,SEEK_SET);

	push	0
	mov	eax, DWORD PTR _mggf$[ebp+64]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 2904 : 
; 2905 : 	fread(framealone,sizeof(uint32),mgg->num_frames,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mgg$[ebp]
	movzx	edx, WORD PTR [ecx+32]
	push	edx
	push	4
	mov	eax, DWORD PTR _framealone$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 2906 : 
; 2907 : 	fseek(file,mggf.frameoffset_offset,SEEK_SET);

	push	0
	mov	eax, DWORD PTR _mggf$[ebp+68]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 2908 : 
; 2909 : 	fread(offx,sizeof(int16),mgg->num_frames,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mgg$[ebp]
	movzx	edx, WORD PTR [ecx+32]
	push	edx
	push	2
	mov	eax, DWORD PTR _offx$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 2910 : 	fread(offy,sizeof(int16),mgg->num_frames,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mgg$[ebp]
	movzx	edx, WORD PTR [ecx+32]
	push	edx
	push	2
	mov	eax, DWORD PTR _offy$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 2911 : 
; 2912 : 	for(i=0;i<mgg->num_frames;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN68@LoadMGG
$LN67@LoadMGG:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN68@LoadMGG:
	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _mgg$[ebp]
	movzx	edx, WORD PTR [ecx+32]
	cmp	eax, edx
	jge	SHORT $LN66@LoadMGG

; 2913 : 	{
; 2914 : 		mgg->frames[i].x_offset=(offx[i]*GAME_WIDTH)/st.screenx;

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _offx$[ebp]
	movzx	eax, WORD PTR [ecx+eax*2]
	shl	eax, 14					; 0000000eH
	movzx	ecx, WORD PTR _st+228
	cdq
	idiv	ecx
	movzx	edx, WORD PTR _i$[ebp]
	imul	ecx, edx, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [edx+40]
	mov	WORD PTR [edx+ecx+36], ax

; 2915 : 		mgg->frames[i].y_offset=(offy[i]*GAME_HEIGHT)/st.screeny;

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _offy$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	imul	eax, edx, 9216
	movzx	ecx, WORD PTR _st+230
	cdq
	idiv	ecx
	movzx	edx, WORD PTR _i$[ebp]
	imul	ecx, edx, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [edx+40]
	mov	WORD PTR [edx+ecx+38], ax

; 2916 : 	}

	jmp	$LN67@LoadMGG
$LN66@LoadMGG:

; 2917 : 
; 2918 : 
; 2919 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 2920 : 
; 2921 : 	k=vbdt_num;

	mov	ax, WORD PTR _vbdt_num
	mov	WORD PTR _k$[ebp], ax

; 2922 : 	
; 2923 : 	if(mggf.num_frames>1)

	movzx	eax, WORD PTR _mggf$[ebp+32]
	cmp	eax, 1
	jle	$LN62@LoadMGG

; 2924 : 	{
; 2925 : 		for(i=(mggf.num_texinatlas), j=mggf.num_atlas;i<mggf.num_frames;i++, j++)

	mov	ax, WORD PTR _mggf$[ebp+44]
	mov	WORD PTR _i$[ebp], ax
	movzx	cx, BYTE PTR _mggf$[ebp+40]
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN64@LoadMGG
$LN63@LoadMGG:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN64@LoadMGG:
	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+32]
	cmp	eax, ecx
	jge	$LN62@LoadMGG

; 2926 : 		{	
; 2927 : 			if(framealone[i] && i==mggf.num_frames-1) 

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _framealone$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN61@LoadMGG
	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+32]
	sub	ecx, 1
	cmp	eax, ecx
	jne	SHORT $LN61@LoadMGG

; 2928 : 				break;

	jmp	$LN62@LoadMGG
$LN61@LoadMGG:

; 2929 : 
; 2930 : 			if(framealone[i]) 

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _framealone$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN60@LoadMGG

; 2931 : 				continue;

	jmp	SHORT $LN63@LoadMGG
$LN60@LoadMGG:

; 2932 : 
; 2933 : 			if(i==(mggf.num_texinatlas) && (mgg->frames[i].w<1024 && mgg->frames[i].h<1024) && !mgg->frames[i].normal)

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+44]
	cmp	eax, ecx
	jne	$LN59@LoadMGG
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+24], 1024		; 00000400H
	jge	$LN59@LoadMGG
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+28], 1024		; 00000400H
	jge	$LN59@LoadMGG
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	ecx, BYTE PTR [eax+ecx+8]
	test	ecx, ecx
	jne	$LN59@LoadMGG

; 2934 : 			{
; 2935 : 				if(!vbdt_num)

	movzx	eax, WORD PTR _vbdt_num
	test	eax, eax
	jne	$LN58@LoadMGG

; 2936 : 				{
; 2937 : 					vbdt_num++;

	mov	ax, WORD PTR _vbdt_num
	add	ax, 1
	mov	WORD PTR _vbdt_num, ax

; 2938 : 					l=vbdt_num-1;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	mov	WORD PTR _l$[ebp], ax

; 2939 : 					vbdt=(VB_DATAT*) malloc(sizeof(VB_DATAT));

	push	64					; 00000040H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _vbdt, eax

; 2940 : 
; 2941 : 					vbdt[l].normal=0;

	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	BYTE PTR [ecx+eax+44], 0

; 2942 : 
; 2943 : 					vbdt[l].buffer_elements=8;

	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	mov	ecx, 8
	mov	edx, DWORD PTR _vbdt
	mov	WORD PTR [edx+eax+48], cx

; 2944 : 
; 2945 : 			#ifdef _VAO_RENDER
; 2946 : 			if(st.renderer.VAO_ON) CreateVAO(&vbdt[l],0,3);

	movzx	eax, BYTE PTR _st+2336440
	test	eax, eax
	je	SHORT $LN57@LoadMGG
	push	3
	push	0
	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _vbdt
	push	eax
	call	_CreateVAO
	add	esp, 12					; 0000000cH
$LN57@LoadMGG:

; 2947 : 			#endif
; 2948 : 			#ifdef _VBO_RENDER
; 2949 : 			if(st.renderer.VBO_ON) CreateVBO(&vbdt[l], 0);

	movzx	eax, BYTE PTR _st+2336452
	test	eax, eax
	je	SHORT $LN56@LoadMGG
	push	0
	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _vbdt
	push	eax
	call	_CreateVBO
	add	esp, 8
$LN56@LoadMGG:

; 2950 : 			#endif
; 2951 : 
; 2952 : 					w=(int16*) calloc(vbdt_num,sizeof(int16));

	push	2
	movzx	eax, WORD PTR _vbdt_num
	push	eax
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _w$[ebp], eax

; 2953 : 					h=(int16*) calloc(vbdt_num,sizeof(int16));

	push	2
	movzx	eax, WORD PTR _vbdt_num
	push	eax
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _h$[ebp], eax

; 2954 : 					currh=(int16*) calloc(vbdt_num,sizeof(int16));

	push	2
	movzx	eax, WORD PTR _vbdt_num
	push	eax
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _currh$[ebp], eax

; 2955 : 
; 2956 : 					if(!vbdt)

	cmp	DWORD PTR _vbdt, 0
	jne	SHORT $LN55@LoadMGG

; 2957 : 						LogApp("Error could not allocate memory for the Vertex Buffer");

	push	OFFSET ??_C@_0DG@BNCAOHGG@Error?5could?5not?5allocate?5memory?5@
	call	_SDL_Log
	add	esp, 4
$LN55@LoadMGG:

; 2958 : 				}
; 2959 : 				else

	jmp	$LN54@LoadMGG
$LN58@LoadMGG:

; 2960 : 				{
; 2961 : 					vbdt_num++;

	mov	ax, WORD PTR _vbdt_num
	add	ax, 1
	mov	WORD PTR _vbdt_num, ax

; 2962 : 					l=vbdt_num-1;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	mov	WORD PTR _l$[ebp], ax

; 2963 : 					vbdt=(VB_DATAT*) realloc(vbdt,vbdt_num*sizeof(VB_DATAT));

	movzx	eax, WORD PTR _vbdt_num
	shl	eax, 6
	push	eax
	mov	ecx, DWORD PTR _vbdt
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _vbdt, eax

; 2964 : 
; 2965 : 					vbdt[l].normal=0;

	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	BYTE PTR [ecx+eax+44], 0

; 2966 : 
; 2967 : 					vbdt[l].buffer_elements=8;

	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	mov	ecx, 8
	mov	edx, DWORD PTR _vbdt
	mov	WORD PTR [edx+eax+48], cx

; 2968 : 
; 2969 : 					#ifdef _VAO_RENDER
; 2970 : 					if(st.renderer.VAO_ON) CreateVAO(&vbdt[l],0,3);

	movzx	eax, BYTE PTR _st+2336440
	test	eax, eax
	je	SHORT $LN53@LoadMGG
	push	3
	push	0
	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _vbdt
	push	eax
	call	_CreateVAO
	add	esp, 12					; 0000000cH
$LN53@LoadMGG:

; 2971 : 					#endif
; 2972 : 					#ifdef _VBO_RENDER
; 2973 : 					if(st.renderer.VBO_ON) CreateVBO(&vbdt[l], 0);

	movzx	eax, BYTE PTR _st+2336452
	test	eax, eax
	je	SHORT $LN52@LoadMGG
	push	0
	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _vbdt
	push	eax
	call	_CreateVBO
	add	esp, 8
$LN52@LoadMGG:

; 2974 : 					#endif
; 2975 : 
; 2976 : 					w=(int16*) calloc(vbdt_num,sizeof(int16));

	push	2
	movzx	eax, WORD PTR _vbdt_num
	push	eax
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _w$[ebp], eax

; 2977 : 					h=(int16*) calloc(vbdt_num,sizeof(int16));

	push	2
	movzx	eax, WORD PTR _vbdt_num
	push	eax
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _h$[ebp], eax

; 2978 : 					currh=(int16*) calloc(vbdt_num,sizeof(int16));

	push	2
	movzx	eax, WORD PTR _vbdt_num
	push	eax
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _currh$[ebp], eax

; 2979 : 
; 2980 : 					if(vbdt_num>1)

	movzx	eax, WORD PTR _vbdt_num
	cmp	eax, 1
	jle	SHORT $LN48@LoadMGG

; 2981 : 					{
; 2982 : 						for(n=0;n<vbdt_num-2;n++)

	xor	eax, eax
	mov	WORD PTR _n$[ebp], ax
	jmp	SHORT $LN50@LoadMGG
$LN49@LoadMGG:
	mov	ax, WORD PTR _n$[ebp]
	add	ax, 1
	mov	WORD PTR _n$[ebp], ax
$LN50@LoadMGG:
	movzx	eax, WORD PTR _n$[ebp]
	movzx	ecx, WORD PTR _vbdt_num
	sub	ecx, 2
	cmp	eax, ecx
	jge	SHORT $LN48@LoadMGG

; 2983 : 							currh[n]=w[n]=h[n]=-1;

	movzx	eax, WORD PTR _n$[ebp]
	mov	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _h$[ebp]
	mov	WORD PTR [edx+eax*2], cx
	movzx	eax, WORD PTR _n$[ebp]
	mov	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _w$[ebp]
	mov	WORD PTR [edx+eax*2], cx
	movzx	eax, WORD PTR _n$[ebp]
	mov	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _currh$[ebp]
	mov	WORD PTR [edx+eax*2], cx
	jmp	SHORT $LN49@LoadMGG
$LN48@LoadMGG:

; 2984 : 					}
; 2985 : 
; 2986 : 					currh[l]=w[l]=h[l]=0;

	movzx	eax, WORD PTR _l$[ebp]
	xor	ecx, ecx
	mov	edx, DWORD PTR _h$[ebp]
	mov	WORD PTR [edx+eax*2], cx
	movzx	eax, WORD PTR _l$[ebp]
	xor	ecx, ecx
	mov	edx, DWORD PTR _w$[ebp]
	mov	WORD PTR [edx+eax*2], cx
	movzx	eax, WORD PTR _l$[ebp]
	xor	ecx, ecx
	mov	edx, DWORD PTR _currh$[ebp]
	mov	WORD PTR [edx+eax*2], cx
$LN54@LoadMGG:

; 2987 : 				}
; 2988 : 
; 2989 : 				vbdt[l].num_elements=0;

	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	xor	ecx, ecx
	mov	edx, DWORD PTR _vbdt
	mov	WORD PTR [edx+eax+46], cx

; 2990 : 
; 2991 : 				glGenTextures(1,&vbdt[vbdt_num-1].texture);

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	lea	edx, DWORD PTR [ecx+eax+36]
	mov	esi, esp
	push	edx
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2992 : 
; 2993 : 				glBindTexture(GL_TEXTURE_2D,vbdt[l].texture);

	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+36]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2994 : 
; 2995 : 				glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,2048,2048,0,GL_BGRA,GL_UNSIGNED_BYTE,NULL);

	mov	esi, esp
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2996 : 
; 2997 : 				//glBindTexture(GL_TEXTURE_2D,mgg->frames[i].data);
; 2998 : 
; 2999 : 				//data=malloc(framesize[j]);
; 3000 : 				/*
; 3001 : 				if(data==NULL)
; 3002 : 				{
; 3003 : 					LogApp("Error allocating memory for texture %d, size %d, file %s during atlas creating",i,framesize[i],name);
; 3004 : 					continue;
; 3005 : 				}
; 3006 : 				*/
; 3007 : 				
; 3008 : 			
; 3009 : 				//if(i==0) fseek(file,mggf.textures_offset+1,SEEK_SET);
; 3010 : 				//else fseek(file,frameoffset[j-1]+1,SEEK_SET);
; 3011 : 
; 3012 : 				//fread(data,framesize[j],1,file);
; 3013 : 
; 3014 : 				//imgdata=SOIL_load_image_from_memory((unsigned char*) data,framesize[j],&width,&height,&channel,0);
; 3015 : 
; 3016 : 				if (mgg->frames[i].channel == 4)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+32], 4
	jne	SHORT $LN47@LoadMGG

; 3017 : 					channel2 = GL_RGBA;

	mov	eax, 6408				; 00001908H
	mov	WORD PTR _channel2$[ebp], ax

; 3018 : 				else

	jmp	SHORT $LN45@LoadMGG
$LN47@LoadMGG:

; 3019 : 				if (mgg->frames[i].channel == 3)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+32], 3
	jne	SHORT $LN45@LoadMGG

; 3020 : 					channel2 = GL_RGB;

	mov	eax, 6407				; 00001907H
	mov	WORD PTR _channel2$[ebp], ax
$LN45@LoadMGG:

; 3021 : 
; 3022 : 				imgdata = malloc(mgg->frames[i].w*mgg->frames[i].h*mgg->frames[i].channel);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _i$[ebp]
	imul	edx, edx, 40
	mov	esi, DWORD PTR _mgg$[ebp]
	mov	esi, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [eax+ecx+24]
	imul	eax, DWORD PTR [esi+edx+28]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	imul	eax, DWORD PTR [ecx+edx+32]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _imgdata$[ebp], eax

; 3023 : 				glBindTexture(GL_TEXTURE_2D, mgg->frames[i].data);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+ecx]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3024 : 				glGetTexImage(GL_TEXTURE_2D, 0, channel2, GL_UNSIGNED_BYTE, imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	movzx	ecx, WORD PTR _channel2$[ebp]
	push	ecx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glGetTexImage@20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3025 : 
; 3026 : 				glBindTexture(GL_TEXTURE_2D, vbdt[l].texture);

	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+36]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3027 : 
; 3028 : 				glTexSubImage2D(GL_TEXTURE_2D,0,w[l],currh[l],mgg->frames[i].w,mgg->frames[i].h,channel2,GL_UNSIGNED_BYTE,imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	movzx	ecx, WORD PTR _channel2$[ebp]
	push	ecx
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [edx+eax+28]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+edx+24]
	push	edx
	movzx	eax, WORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _currh$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	push	edx
	movzx	eax, WORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	push	edx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexSubImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3029 : 
; 3030 : 				mgg->frames[i].posx=(float)(w[l]*32768)/2048;

	movzx	eax, WORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	shl	edx, 15					; 0000000fH
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@45000000
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cvttss2si edx, xmm0
	mov	WORD PTR [eax+ecx+14], dx

; 3031 : 				mgg->frames[i].posy=(float)(currh[l]*32768)/2048;

	movzx	eax, WORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _currh$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	shl	edx, 15					; 0000000fH
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@45000000
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cvttss2si edx, xmm0
	mov	WORD PTR [eax+ecx+16], dx

; 3032 : 
; 3033 : 				w[l]=mgg->frames[i].w;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _l$[ebp]
	mov	esi, DWORD PTR _w$[ebp]
	mov	ax, WORD PTR [eax+ecx+24]
	mov	WORD PTR [esi+edx*2], ax

; 3034 : 				h[l]=mgg->frames[i].h;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _l$[ebp]
	mov	esi, DWORD PTR _h$[ebp]
	mov	ax, WORD PTR [eax+ecx+28]
	mov	WORD PTR [esi+edx*2], ax

; 3035 : 
; 3036 : 				mgg->frames[i].sizex=(float)(mgg->frames[i].w*32768)/2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+ecx+24]
	shl	ecx, 15					; 0000000fH
	cvtsi2ss xmm0, ecx
	divss	xmm0, DWORD PTR __real@45000000
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	cvttss2si ecx, xmm0
	mov	WORD PTR [edx+eax+18], cx

; 3037 : 				mgg->frames[i].sizey=(float)(mgg->frames[i].h*32768)/2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+ecx+28]
	shl	ecx, 15					; 0000000fH
	cvtsi2ss xmm0, ecx
	divss	xmm0, DWORD PTR __real@45000000
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	cvttss2si ecx, xmm0
	mov	WORD PTR [edx+eax+20], cx

; 3038 : 
; 3039 : 				glDeleteTextures(1,&mgg->frames[i].data);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	add	eax, ecx
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3040 : 
; 3041 : 				mgg->frames[i].data=vbdt[l].texture;

	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	esi, DWORD PTR _vbdt
	mov	eax, DWORD PTR [esi+eax+36]
	mov	DWORD PTR [ecx+edx], eax

; 3042 : 
; 3043 : 				mgg->frames[i].vb_id=l;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	dx, WORD PTR _l$[ebp]
	mov	WORD PTR [eax+ecx+10], dx

; 3044 : 
; 3045 : 				mgg->frames[i].w = 2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [eax+ecx+24], 2048		; 00000800H

; 3046 : 				mgg->frames[i].h = 2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [eax+ecx+28], 2048		; 00000800H

; 3047 : 
; 3048 : 				//free(data);
; 3049 : 				free(imgdata);

	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3050 : 
; 3051 : 				//SOIL_free_image_data(imgdata);
; 3052 : 			}
; 3053 : 			else

	jmp	$LN19@LoadMGG
$LN59@LoadMGG:

; 3054 : 			{
; 3055 : 				if((mgg->frames[i].w+w[l]<2048 && mgg->frames[i].h+currh[l]<2048) && (mgg->frames[i].w<1024 && mgg->frames[i].h<1024) && !mgg->frames[i].normal)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _l$[ebp]
	mov	esi, DWORD PTR _w$[ebp]
	movzx	edx, WORD PTR [esi+edx*2]
	add	edx, DWORD PTR [eax+ecx+24]
	cmp	edx, 2048				; 00000800H
	jge	$LN43@LoadMGG
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _l$[ebp]
	mov	esi, DWORD PTR _currh$[ebp]
	movzx	edx, WORD PTR [esi+edx*2]
	add	edx, DWORD PTR [eax+ecx+28]
	cmp	edx, 2048				; 00000800H
	jge	$LN43@LoadMGG
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+24], 1024		; 00000400H
	jge	$LN43@LoadMGG
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+28], 1024		; 00000400H
	jge	$LN43@LoadMGG
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	ecx, BYTE PTR [eax+ecx+8]
	test	ecx, ecx
	jne	$LN43@LoadMGG

; 3056 : 				{
; 3057 : 					//glBindTexture(GL_TEXTURE_2D,mgg->frames[i].data);
; 3058 : 
; 3059 : 					//data=malloc(framesize[j]);
; 3060 : 					/*
; 3061 : 					if(data==NULL)
; 3062 : 					{
; 3063 : 						LogApp("Error allocating memory for texture %d, size %d, file %s during atlas creating",i,framesize[i],name);
; 3064 : 						continue;
; 3065 : 					}
; 3066 : 					*/
; 3067 : 					//fseek(file,frameoffset[j-1]+1,SEEK_SET);
; 3068 : 
; 3069 : 					//fread(data,framesize[j],1,file);
; 3070 : 
; 3071 : 					//imgdata=SOIL_load_image_from_memory((unsigned char*) data,framesize[j],&width,&height,&channel,0);
; 3072 : 
; 3073 : 					if (mgg->frames[i].channel == 4)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+32], 4
	jne	SHORT $LN42@LoadMGG

; 3074 : 						channel2 = GL_RGBA;

	mov	eax, 6408				; 00001908H
	mov	WORD PTR _channel2$[ebp], ax

; 3075 : 					else

	jmp	SHORT $LN40@LoadMGG
$LN42@LoadMGG:

; 3076 : 						if (mgg->frames[i].channel == 3)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+32], 3
	jne	SHORT $LN40@LoadMGG

; 3077 : 							channel2 = GL_RGB;

	mov	eax, 6407				; 00001907H
	mov	WORD PTR _channel2$[ebp], ax
$LN40@LoadMGG:

; 3078 : 
; 3079 : 					imgdata = malloc(mgg->frames[i].w*mgg->frames[i].h*mgg->frames[i].channel);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _i$[ebp]
	imul	edx, edx, 40
	mov	esi, DWORD PTR _mgg$[ebp]
	mov	esi, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [eax+ecx+24]
	imul	eax, DWORD PTR [esi+edx+28]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	imul	eax, DWORD PTR [ecx+edx+32]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _imgdata$[ebp], eax

; 3080 : 					glBindTexture(GL_TEXTURE_2D, mgg->frames[i].data);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+ecx]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3081 : 					glGetTexImage(GL_TEXTURE_2D, 0, channel2, GL_UNSIGNED_BYTE, imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	movzx	ecx, WORD PTR _channel2$[ebp]
	push	ecx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glGetTexImage@20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3082 : 
; 3083 : 					glBindTexture(GL_TEXTURE_2D,vbdt[l].texture);

	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+36]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3084 : 
; 3085 : 					glTexSubImage2D(GL_TEXTURE_2D,0,w[l],currh[l],mgg->frames[i].w,mgg->frames[i].h,channel2,GL_UNSIGNED_BYTE,imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	movzx	ecx, WORD PTR _channel2$[ebp]
	push	ecx
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [edx+eax+28]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+edx+24]
	push	edx
	movzx	eax, WORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _currh$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	push	edx
	movzx	eax, WORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	push	edx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexSubImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3086 : 
; 3087 : 					mgg->frames[i].posx=(w[l]*32768)/2048;

	movzx	eax, WORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	movzx	eax, WORD PTR [ecx+eax*2]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	edx, WORD PTR _i$[ebp]
	imul	ecx, edx, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [edx+40]
	mov	WORD PTR [edx+ecx+14], ax

; 3088 : 					mgg->frames[i].posy=(currh[l]*32768)/2048;

	movzx	eax, WORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _currh$[ebp]
	movzx	eax, WORD PTR [ecx+eax*2]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	edx, WORD PTR _i$[ebp]
	imul	ecx, edx, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [edx+40]
	mov	WORD PTR [edx+ecx+16], ax

; 3089 : 
; 3090 : 					w[l]+=mgg->frames[i].w;

	movzx	eax, WORD PTR _l$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	esi, DWORD PTR _w$[ebp]
	movzx	eax, WORD PTR [esi+eax*2]
	add	eax, DWORD PTR [ecx+edx+24]
	movzx	ecx, WORD PTR _l$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 3091 : 
; 3092 : 					if(currh[l]+mgg->frames[i].h>h[l])

	movzx	eax, WORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _currh$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [eax+40]
	add	edx, DWORD PTR [eax+ecx+28]
	movzx	ecx, WORD PTR _l$[ebp]
	mov	eax, DWORD PTR _h$[ebp]
	movzx	ecx, WORD PTR [eax+ecx*2]
	cmp	edx, ecx
	jle	SHORT $LN39@LoadMGG

; 3093 : 						h[l]+=mgg->frames[i].h;

	movzx	eax, WORD PTR _l$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	esi, DWORD PTR _h$[ebp]
	movzx	eax, WORD PTR [esi+eax*2]
	add	eax, DWORD PTR [ecx+edx+28]
	movzx	ecx, WORD PTR _l$[ebp]
	mov	edx, DWORD PTR _h$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
$LN39@LoadMGG:

; 3094 : 
; 3095 : 					mgg->frames[i].sizex=(mgg->frames[i].w*32768)/2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	eax, DWORD PTR [eax+ecx+24]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	WORD PTR [ecx+edx+18], ax

; 3096 : 					mgg->frames[i].sizey=(mgg->frames[i].h*32768)/2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	eax, DWORD PTR [eax+ecx+28]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	WORD PTR [ecx+edx+20], ax

; 3097 : 
; 3098 : 					glDeleteTextures(1,&mgg->frames[i].data);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	add	eax, ecx
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3099 : 
; 3100 : 					mgg->frames[i].data=vbdt[l].texture;

	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	esi, DWORD PTR _vbdt
	mov	eax, DWORD PTR [esi+eax+36]
	mov	DWORD PTR [ecx+edx], eax

; 3101 : 
; 3102 : 					mgg->frames[i].vb_id=l;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	dx, WORD PTR _l$[ebp]
	mov	WORD PTR [eax+ecx+10], dx

; 3103 : 
; 3104 : 					mgg->frames[i].w = 2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [eax+ecx+24], 2048		; 00000800H

; 3105 : 					mgg->frames[i].h = 2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [eax+ecx+28], 2048		; 00000800H

; 3106 : 
; 3107 : 					//free(data);
; 3108 : 
; 3109 : 					free(imgdata);

	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3110 : 
; 3111 : 					if(2048-w[l]<128 && 2048-currh[l]>128)

	movzx	eax, WORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	mov	eax, 2048				; 00000800H
	sub	eax, edx
	cmp	eax, 128				; 00000080H
	jge	SHORT $LN38@LoadMGG
	movzx	eax, WORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _currh$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	mov	eax, 2048				; 00000800H
	sub	eax, edx
	cmp	eax, 128				; 00000080H
	jle	SHORT $LN38@LoadMGG

; 3112 : 					{
; 3113 : 						w[l]=0;

	movzx	eax, WORD PTR _l$[ebp]
	xor	ecx, ecx
	mov	edx, DWORD PTR _w$[ebp]
	mov	WORD PTR [edx+eax*2], cx

; 3114 : 						currh[l]=h[l];

	movzx	eax, WORD PTR _l$[ebp]
	movzx	ecx, WORD PTR _l$[ebp]
	mov	edx, DWORD PTR _currh$[ebp]
	mov	esi, DWORD PTR _h$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [edx+ecx*2], ax

; 3115 : 					}
; 3116 : 					else

	jmp	$LN31@LoadMGG
$LN38@LoadMGG:

; 3117 : 					if(2048-w[l]<128 && 2048-currh[l]<128)

	movzx	eax, WORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	mov	eax, 2048				; 00000800H
	sub	eax, edx
	cmp	eax, 128				; 00000080H
	jge	$LN31@LoadMGG
	movzx	eax, WORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _currh$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	mov	eax, 2048				; 00000800H
	sub	eax, edx
	cmp	eax, 128				; 00000080H
	jge	$LN31@LoadMGG

; 3118 : 					{
; 3119 : 						if(l==vbdt_num-1)

	movzx	eax, WORD PTR _l$[ebp]
	movzx	ecx, WORD PTR _vbdt_num
	sub	ecx, 1
	cmp	eax, ecx
	jne	$LN35@LoadMGG

; 3120 : 						{
; 3121 : 							vbdt_num++;

	mov	ax, WORD PTR _vbdt_num
	add	ax, 1
	mov	WORD PTR _vbdt_num, ax

; 3122 : 							vbdt=(VB_DATAT*) realloc(vbdt,vbdt_num*sizeof(VB_DATAT));

	movzx	eax, WORD PTR _vbdt_num
	shl	eax, 6
	push	eax
	mov	ecx, DWORD PTR _vbdt
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _vbdt, eax

; 3123 : 
; 3124 : 							vbdt[vbdt_num-1].normal=0;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	BYTE PTR [ecx+eax+44], 0

; 3125 : 
; 3126 : 							w=(int16*) realloc(w,vbdt_num*sizeof(int16));

	movzx	eax, WORD PTR _vbdt_num
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _w$[ebp], eax

; 3127 : 							h=(int16*) realloc(h,vbdt_num*sizeof(int16));

	movzx	eax, WORD PTR _vbdt_num
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _h$[ebp]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _h$[ebp], eax

; 3128 : 
; 3129 : 							vbdt[vbdt_num-1].num_elements=0;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	xor	ecx, ecx
	mov	edx, DWORD PTR _vbdt
	mov	WORD PTR [edx+eax+46], cx

; 3130 : 
; 3131 : 							currh=(int16*) realloc(currh,vbdt_num*sizeof(int16));

	movzx	eax, WORD PTR _vbdt_num
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _currh$[ebp]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _currh$[ebp], eax

; 3132 : 
; 3133 : 							currh[vbdt_num-1]=w[vbdt_num-1]=h[vbdt_num-1]=0;

	movzx	eax, WORD PTR _vbdt_num
	xor	ecx, ecx
	mov	edx, DWORD PTR _h$[ebp]
	mov	WORD PTR [edx+eax*2-2], cx
	movzx	eax, WORD PTR _vbdt_num
	xor	ecx, ecx
	mov	edx, DWORD PTR _w$[ebp]
	mov	WORD PTR [edx+eax*2-2], cx
	movzx	eax, WORD PTR _vbdt_num
	xor	ecx, ecx
	mov	edx, DWORD PTR _currh$[ebp]
	mov	WORD PTR [edx+eax*2-2], cx

; 3134 : 
; 3135 : 							l=vbdt_num-1;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	mov	WORD PTR _l$[ebp], ax

; 3136 : 						}
; 3137 : 						else

	jmp	SHORT $LN31@LoadMGG
$LN35@LoadMGG:

; 3138 : 						{
; 3139 : 							for(n=0;n<vbdt_num;n++)

	xor	eax, eax
	mov	WORD PTR _n$[ebp], ax
	jmp	SHORT $LN33@LoadMGG
$LN32@LoadMGG:
	mov	ax, WORD PTR _n$[ebp]
	add	ax, 1
	mov	WORD PTR _n$[ebp], ax
$LN33@LoadMGG:
	movzx	eax, WORD PTR _n$[ebp]
	movzx	ecx, WORD PTR _vbdt_num
	cmp	eax, ecx
	jge	SHORT $LN31@LoadMGG

; 3140 : 							{
; 3141 : 								if(2048-w[n]>128 || 2048-currh[n]>128)

	movzx	eax, WORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	mov	eax, 2048				; 00000800H
	sub	eax, edx
	cmp	eax, 128				; 00000080H
	jg	SHORT $LN29@LoadMGG
	movzx	eax, WORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _currh$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	mov	eax, 2048				; 00000800H
	sub	eax, edx
	cmp	eax, 128				; 00000080H
	jle	SHORT $LN30@LoadMGG
$LN29@LoadMGG:

; 3142 : 								{
; 3143 : 									l=n;

	mov	ax, WORD PTR _n$[ebp]
	mov	WORD PTR _l$[ebp], ax

; 3144 : 									break;

	jmp	SHORT $LN31@LoadMGG
$LN30@LoadMGG:

; 3145 : 								}
; 3146 : 							}

	jmp	SHORT $LN32@LoadMGG
$LN31@LoadMGG:

; 3147 : 						}
; 3148 : 					}
; 3149 : 				}
; 3150 : 				else

	jmp	$LN19@LoadMGG
$LN43@LoadMGG:

; 3151 : 				if((mgg->frames[i].w<1024 && mgg->frames[i].h<1024) && (mgg->frames[i].w+w[l]>2048 && mgg->frames[i].h+currh[l]>2048) && !mgg->frames[i].normal)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+24], 1024		; 00000400H
	jge	$LN19@LoadMGG
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+28], 1024		; 00000400H
	jge	$LN19@LoadMGG
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _l$[ebp]
	mov	esi, DWORD PTR _w$[ebp]
	movzx	edx, WORD PTR [esi+edx*2]
	add	edx, DWORD PTR [eax+ecx+24]
	cmp	edx, 2048				; 00000800H
	jle	$LN19@LoadMGG
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _l$[ebp]
	mov	esi, DWORD PTR _currh$[ebp]
	movzx	edx, WORD PTR [esi+edx*2]
	add	edx, DWORD PTR [eax+ecx+28]
	cmp	edx, 2048				; 00000800H
	jle	$LN19@LoadMGG
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	ecx, BYTE PTR [eax+ecx+8]
	test	ecx, ecx
	jne	$LN19@LoadMGG

; 3152 : 				{
; 3153 : 					if(l==vbdt_num-1)

	movzx	eax, WORD PTR _l$[ebp]
	movzx	ecx, WORD PTR _vbdt_num
	sub	ecx, 1
	cmp	eax, ecx
	jne	$LN26@LoadMGG

; 3154 : 					{
; 3155 : 						vbdt_num++;

	mov	ax, WORD PTR _vbdt_num
	add	ax, 1
	mov	WORD PTR _vbdt_num, ax

; 3156 : 						vbdt=(VB_DATAT*) realloc(vbdt,vbdt_num*sizeof(VB_DATAT));

	movzx	eax, WORD PTR _vbdt_num
	shl	eax, 6
	push	eax
	mov	ecx, DWORD PTR _vbdt
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _vbdt, eax

; 3157 : 
; 3158 : 						vbdt[vbdt_num-1].normal=0;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	BYTE PTR [ecx+eax+44], 0

; 3159 : 
; 3160 : 						w=(int16*) realloc(w,vbdt_num*sizeof(int16));

	movzx	eax, WORD PTR _vbdt_num
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _w$[ebp], eax

; 3161 : 						h=(int16*) realloc(h,vbdt_num*sizeof(int16));

	movzx	eax, WORD PTR _vbdt_num
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _h$[ebp]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _h$[ebp], eax

; 3162 : 
; 3163 : 						currh=(int16*) realloc(currh,vbdt_num*sizeof(int16));

	movzx	eax, WORD PTR _vbdt_num
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _currh$[ebp]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _currh$[ebp], eax

; 3164 : 
; 3165 : 						currh[vbdt_num-1]=w[vbdt_num-1]=h[vbdt_num-1]=0;

	movzx	eax, WORD PTR _vbdt_num
	xor	ecx, ecx
	mov	edx, DWORD PTR _h$[ebp]
	mov	WORD PTR [edx+eax*2-2], cx
	movzx	eax, WORD PTR _vbdt_num
	xor	ecx, ecx
	mov	edx, DWORD PTR _w$[ebp]
	mov	WORD PTR [edx+eax*2-2], cx
	movzx	eax, WORD PTR _vbdt_num
	xor	ecx, ecx
	mov	edx, DWORD PTR _currh$[ebp]
	mov	WORD PTR [edx+eax*2-2], cx

; 3166 : 
; 3167 : 						vbdt[vbdt_num-1].num_elements=0;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	xor	ecx, ecx
	mov	edx, DWORD PTR _vbdt
	mov	WORD PTR [edx+eax+46], cx

; 3168 : 
; 3169 : 						glGenTextures(1,&vbdt[vbdt_num-1].texture);

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	lea	edx, DWORD PTR [ecx+eax+36]
	mov	esi, esp
	push	edx
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3170 : 
; 3171 : 						glBindTexture(GL_TEXTURE_2D,vbdt[vbdt_num-1].texture);

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+36]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3172 : 
; 3173 : 						glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,2048,2048,0,GL_BGRA,GL_UNSIGNED_BYTE,NULL);

	mov	esi, esp
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3174 : 
; 3175 : 						//glBindTexture(GL_TEXTURE_2D,mgg->frames[i].data);
; 3176 : 
; 3177 : 						//data=malloc(framesize[j]);
; 3178 : 						/*
; 3179 : 						if(data==NULL)
; 3180 : 						{
; 3181 : 							LogApp("Error allocating memory for texture %d, size %d, file %s during atlas creating",i,framesize[i],name);
; 3182 : 							continue;
; 3183 : 						}
; 3184 : 						*/
; 3185 : 						//fseek(file,frameoffset[j-1]+1,SEEK_SET);
; 3186 : 
; 3187 : 						//fread(data,framesize[j],1,file);
; 3188 : 
; 3189 : 						//imgdata=SOIL_load_image_from_memory((unsigned char*) data,framesize[j],&width,&height,&channel,0);
; 3190 : 
; 3191 : 						if (mgg->frames[i].channel == 4)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+32], 4
	jne	SHORT $LN25@LoadMGG

; 3192 : 							channel2 = GL_RGBA;

	mov	eax, 6408				; 00001908H
	mov	WORD PTR _channel2$[ebp], ax

; 3193 : 						else

	jmp	SHORT $LN23@LoadMGG
$LN25@LoadMGG:

; 3194 : 						if (mgg->frames[i].channel == 3)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+32], 3
	jne	SHORT $LN23@LoadMGG

; 3195 : 							channel2 = GL_RGB;

	mov	eax, 6407				; 00001907H
	mov	WORD PTR _channel2$[ebp], ax
$LN23@LoadMGG:

; 3196 : 
; 3197 : 						imgdata = malloc(mgg->frames[i].w*mgg->frames[i].h*mgg->frames[i].channel);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _i$[ebp]
	imul	edx, edx, 40
	mov	esi, DWORD PTR _mgg$[ebp]
	mov	esi, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [eax+ecx+24]
	imul	eax, DWORD PTR [esi+edx+28]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	imul	eax, DWORD PTR [ecx+edx+32]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _imgdata$[ebp], eax

; 3198 : 						glBindTexture(GL_TEXTURE_2D, mgg->frames[i].data);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+ecx]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3199 : 						glGetTexImage(GL_TEXTURE_2D, 0, channel2, GL_UNSIGNED_BYTE, imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	movzx	ecx, WORD PTR _channel2$[ebp]
	push	ecx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glGetTexImage@20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3200 : 
; 3201 : 						glBindTexture(GL_TEXTURE_2D, vbdt[l].texture);

	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+36]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3202 : 				
; 3203 : 						glTexSubImage2D(GL_TEXTURE_2D,0,w[vbdt_num-1],currh[vbdt_num-1],mgg->frames[i].w,mgg->frames[i].h,channel2,GL_UNSIGNED_BYTE,imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	movzx	ecx, WORD PTR _channel2$[ebp]
	push	ecx
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [edx+eax+28]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+edx+24]
	push	edx
	movzx	eax, WORD PTR _vbdt_num
	mov	ecx, DWORD PTR _currh$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2-2]
	push	edx
	movzx	eax, WORD PTR _vbdt_num
	mov	ecx, DWORD PTR _w$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2-2]
	push	edx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexSubImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3204 : 
; 3205 : 						mgg->frames[i].posx=(w[vbdt_num-1]*32768)/2048;

	movzx	eax, WORD PTR _vbdt_num
	mov	ecx, DWORD PTR _w$[ebp]
	movzx	eax, WORD PTR [ecx+eax*2-2]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	edx, WORD PTR _i$[ebp]
	imul	ecx, edx, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [edx+40]
	mov	WORD PTR [edx+ecx+14], ax

; 3206 : 						mgg->frames[i].posy=(currh[vbdt_num-1]*32768)/2048;

	movzx	eax, WORD PTR _vbdt_num
	mov	ecx, DWORD PTR _currh$[ebp]
	movzx	eax, WORD PTR [ecx+eax*2-2]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	edx, WORD PTR _i$[ebp]
	imul	ecx, edx, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [edx+40]
	mov	WORD PTR [edx+ecx+16], ax

; 3207 : 
; 3208 : 						w[vbdt_num-1]=mgg->frames[i].w;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _vbdt_num
	mov	esi, DWORD PTR _w$[ebp]
	mov	ax, WORD PTR [eax+ecx+24]
	mov	WORD PTR [esi+edx*2-2], ax

; 3209 : 						h[vbdt_num-1]=mgg->frames[i].h;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _vbdt_num
	mov	esi, DWORD PTR _h$[ebp]
	mov	ax, WORD PTR [eax+ecx+28]
	mov	WORD PTR [esi+edx*2-2], ax

; 3210 : 
; 3211 : 						mgg->frames[i].sizex=(mgg->frames[i].w*32768)/2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	eax, DWORD PTR [eax+ecx+24]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	WORD PTR [ecx+edx+18], ax

; 3212 : 						mgg->frames[i].sizey=(mgg->frames[i].h*32768)/2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	eax, DWORD PTR [eax+ecx+28]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	WORD PTR [ecx+edx+20], ax

; 3213 : 
; 3214 : 						glDeleteTextures(1,&mgg->frames[i].data);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	add	eax, ecx
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3215 : 
; 3216 : 						mgg->frames[i].data=vbdt[vbdt_num-1].texture;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	esi, DWORD PTR _vbdt
	mov	eax, DWORD PTR [esi+eax+36]
	mov	DWORD PTR [ecx+edx], eax

; 3217 : 
; 3218 : 						mgg->frames[i].vb_id=vbdt_num-1;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	WORD PTR [ecx+edx+10], ax

; 3219 : 
; 3220 : 						mgg->frames[i].w = 2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [eax+ecx+24], 2048		; 00000800H

; 3221 : 						mgg->frames[i].h = 2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [eax+ecx+28], 2048		; 00000800H

; 3222 : 
; 3223 : 						//free(data);
; 3224 : 
; 3225 : 						free(imgdata);

	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3226 : 					}
; 3227 : 					else

	jmp	$LN19@LoadMGG
$LN26@LoadMGG:

; 3228 : 					{
; 3229 : 						for(n=l;n<vbdt_num;n++)

	mov	ax, WORD PTR _l$[ebp]
	mov	WORD PTR _n$[ebp], ax
	jmp	SHORT $LN21@LoadMGG
$LN20@LoadMGG:
	mov	ax, WORD PTR _n$[ebp]
	add	ax, 1
	mov	WORD PTR _n$[ebp], ax
$LN21@LoadMGG:
	movzx	eax, WORD PTR _n$[ebp]
	movzx	ecx, WORD PTR _vbdt_num
	cmp	eax, ecx
	jge	$LN19@LoadMGG

; 3230 : 						{
; 3231 : 							if(mgg->frames[i].w+w[n]<2048 || mgg->frames[i].h+currh[n]<2048)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _n$[ebp]
	mov	esi, DWORD PTR _w$[ebp]
	movzx	edx, WORD PTR [esi+edx*2]
	add	edx, DWORD PTR [eax+ecx+24]
	cmp	edx, 2048				; 00000800H
	jl	SHORT $LN17@LoadMGG
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _n$[ebp]
	mov	esi, DWORD PTR _currh$[ebp]
	movzx	edx, WORD PTR [esi+edx*2]
	add	edx, DWORD PTR [eax+ecx+28]
	cmp	edx, 2048				; 00000800H
	jge	$LN18@LoadMGG
$LN17@LoadMGG:

; 3232 : 							{
; 3233 : 								//glBindTexture(GL_TEXTURE_2D,mgg->frames[i].data);
; 3234 : 
; 3235 : 								/*
; 3236 : 								data=malloc(framesize[j]);
; 3237 : 
; 3238 : 								if(data==NULL)
; 3239 : 								{
; 3240 : 									LogApp("Error allocating memory for texture %d, size %d, file %s during atlas creating",i,framesize[i],name);
; 3241 : 									continue;
; 3242 : 								}
; 3243 : 
; 3244 : 								fseek(file,frameoffset[j-1]+1,SEEK_SET);
; 3245 : 
; 3246 : 								fread(data,framesize[j],1,file);
; 3247 : 
; 3248 : 								imgdata=SOIL_load_image_from_memory((unsigned char*) data,framesize[j],&width,&height,&channel,0);
; 3249 : 								*/
; 3250 : 
; 3251 : 								if (mgg->frames[i].channel == 4)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+32], 4
	jne	SHORT $LN16@LoadMGG

; 3252 : 									channel2 = GL_RGBA;

	mov	eax, 6408				; 00001908H
	mov	WORD PTR _channel2$[ebp], ax

; 3253 : 								else

	jmp	SHORT $LN14@LoadMGG
$LN16@LoadMGG:

; 3254 : 									if (mgg->frames[i].channel == 3)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+32], 3
	jne	SHORT $LN14@LoadMGG

; 3255 : 										channel2 = GL_RGB;

	mov	eax, 6407				; 00001907H
	mov	WORD PTR _channel2$[ebp], ax
$LN14@LoadMGG:

; 3256 : 
; 3257 : 								imgdata = malloc(mgg->frames[i].w*mgg->frames[i].h*mgg->frames[i].channel);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _i$[ebp]
	imul	edx, edx, 40
	mov	esi, DWORD PTR _mgg$[ebp]
	mov	esi, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [eax+ecx+24]
	imul	eax, DWORD PTR [esi+edx+28]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	imul	eax, DWORD PTR [ecx+edx+32]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _imgdata$[ebp], eax

; 3258 : 								glBindTexture(GL_TEXTURE_2D, mgg->frames[i].data);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+ecx]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3259 : 								glGetTexImage(GL_TEXTURE_2D, 0, channel2, GL_UNSIGNED_BYTE, imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	movzx	ecx, WORD PTR _channel2$[ebp]
	push	ecx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glGetTexImage@20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3260 : 
; 3261 : 								glBindTexture(GL_TEXTURE_2D, vbdt[l].texture);

	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+36]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3262 : 				
; 3263 : 								glTexSubImage2D(GL_TEXTURE_2D,0,w[n],h[n],mgg->frames[i].w,mgg->frames[i].h,channel2,GL_UNSIGNED_BYTE,imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	movzx	ecx, WORD PTR _channel2$[ebp]
	push	ecx
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [edx+eax+28]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+edx+24]
	push	edx
	movzx	eax, WORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	push	edx
	movzx	eax, WORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	push	edx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexSubImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3264 : 	
; 3265 : 								mgg->frames[i].posx=(w[n]*32768)/2048;

	movzx	eax, WORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	movzx	eax, WORD PTR [ecx+eax*2]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	edx, WORD PTR _i$[ebp]
	imul	ecx, edx, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [edx+40]
	mov	WORD PTR [edx+ecx+14], ax

; 3266 : 								mgg->frames[i].posy=(currh[n]*32768)/2048;

	movzx	eax, WORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _currh$[ebp]
	movzx	eax, WORD PTR [ecx+eax*2]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	edx, WORD PTR _i$[ebp]
	imul	ecx, edx, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [edx+40]
	mov	WORD PTR [edx+ecx+16], ax

; 3267 : 
; 3268 : 								w[n]+=mgg->frames[i].w;

	movzx	eax, WORD PTR _n$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	esi, DWORD PTR _w$[ebp]
	movzx	eax, WORD PTR [esi+eax*2]
	add	eax, DWORD PTR [ecx+edx+24]
	movzx	ecx, WORD PTR _n$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 3269 : 
; 3270 : 								if(currh[n]+mgg->frames[i].h>h[n])

	movzx	eax, WORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _currh$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [eax+40]
	add	edx, DWORD PTR [eax+ecx+28]
	movzx	ecx, WORD PTR _n$[ebp]
	mov	eax, DWORD PTR _h$[ebp]
	movzx	ecx, WORD PTR [eax+ecx*2]
	cmp	edx, ecx
	jle	SHORT $LN13@LoadMGG

; 3271 : 									h[n]+=mgg->frames[i].h;

	movzx	eax, WORD PTR _n$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	esi, DWORD PTR _h$[ebp]
	movzx	eax, WORD PTR [esi+eax*2]
	add	eax, DWORD PTR [ecx+edx+28]
	movzx	ecx, WORD PTR _n$[ebp]
	mov	edx, DWORD PTR _h$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
$LN13@LoadMGG:

; 3272 : 
; 3273 : 								mgg->frames[i].sizex=(mgg->frames[i].w*32768)/2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	eax, DWORD PTR [eax+ecx+24]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	WORD PTR [ecx+edx+18], ax

; 3274 : 								mgg->frames[i].sizey=(mgg->frames[i].h*32768)/2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	eax, DWORD PTR [eax+ecx+28]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	WORD PTR [ecx+edx+20], ax

; 3275 : 
; 3276 : 								glDeleteTextures(1,&mgg->frames[i].data);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	add	eax, ecx
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3277 : 
; 3278 : 								mgg->frames[i].data=vbdt[n].texture;

	movzx	eax, WORD PTR _n$[ebp]
	shl	eax, 6
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	esi, DWORD PTR _vbdt
	mov	eax, DWORD PTR [esi+eax+36]
	mov	DWORD PTR [ecx+edx], eax

; 3279 : 
; 3280 : 								mgg->frames[i].vb_id=n;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	dx, WORD PTR _n$[ebp]
	mov	WORD PTR [eax+ecx+10], dx

; 3281 : 
; 3282 : 								mgg->frames[i].w = 2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [eax+ecx+24], 2048		; 00000800H

; 3283 : 								mgg->frames[i].h = 2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [eax+ecx+28], 2048		; 00000800H

; 3284 : 
; 3285 : 							//	free(data);
; 3286 : 
; 3287 : 								free(imgdata);

	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3288 : 
; 3289 : 								if(2048-w[n]<128 && 2048-currh[n]>128)

	movzx	eax, WORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	mov	eax, 2048				; 00000800H
	sub	eax, edx
	cmp	eax, 128				; 00000080H
	jge	SHORT $LN12@LoadMGG
	movzx	eax, WORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _currh$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	mov	eax, 2048				; 00000800H
	sub	eax, edx
	cmp	eax, 128				; 00000080H
	jle	SHORT $LN12@LoadMGG

; 3290 : 								{
; 3291 : 									w[n]=0;

	movzx	eax, WORD PTR _n$[ebp]
	xor	ecx, ecx
	mov	edx, DWORD PTR _w$[ebp]
	mov	WORD PTR [edx+eax*2], cx

; 3292 : 									currh[n]=h[n];

	movzx	eax, WORD PTR _n$[ebp]
	movzx	ecx, WORD PTR _n$[ebp]
	mov	edx, DWORD PTR _currh$[ebp]
	mov	esi, DWORD PTR _h$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [edx+ecx*2], ax
$LN12@LoadMGG:

; 3293 : 								}
; 3294 : 
; 3295 : 								free(w);

	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3296 : 								free(h);

	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3297 : 								free(currh);

	mov	eax, DWORD PTR _currh$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3298 : 
; 3299 : 								break;

	jmp	$LN19@LoadMGG

; 3300 : 							}
; 3301 : 							else

	jmp	$LN10@LoadMGG
$LN18@LoadMGG:

; 3302 : 							if(n==vbdt_num-1)

	movzx	eax, WORD PTR _n$[ebp]
	movzx	ecx, WORD PTR _vbdt_num
	sub	ecx, 1
	cmp	eax, ecx
	jne	$LN10@LoadMGG

; 3303 : 							{
; 3304 : 								vbdt_num++;

	mov	ax, WORD PTR _vbdt_num
	add	ax, 1
	mov	WORD PTR _vbdt_num, ax

; 3305 : 								vbdt=(VB_DATAT*) realloc(vbdt,vbdt_num*sizeof(VB_DATAT));

	movzx	eax, WORD PTR _vbdt_num
	shl	eax, 6
	push	eax
	mov	ecx, DWORD PTR _vbdt
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _vbdt, eax

; 3306 : 
; 3307 : 								w=(int16*) realloc(w,vbdt_num*sizeof(int16));

	movzx	eax, WORD PTR _vbdt_num
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _w$[ebp], eax

; 3308 : 								h=(int16*) realloc(h,vbdt_num*sizeof(int16));

	movzx	eax, WORD PTR _vbdt_num
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _h$[ebp]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _h$[ebp], eax

; 3309 : 
; 3310 : 								vbdt[vbdt_num-1].normal=0;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	mov	BYTE PTR [ecx+eax+44], 0

; 3311 : 
; 3312 : 								currh=(int16*) realloc(currh,vbdt_num*sizeof(int16));

	movzx	eax, WORD PTR _vbdt_num
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _currh$[ebp]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _currh$[ebp], eax

; 3313 : 
; 3314 : 								currh[vbdt_num-1]=w[vbdt_num-1]=h[vbdt_num-1]=0;

	movzx	eax, WORD PTR _vbdt_num
	xor	ecx, ecx
	mov	edx, DWORD PTR _h$[ebp]
	mov	WORD PTR [edx+eax*2-2], cx
	movzx	eax, WORD PTR _vbdt_num
	xor	ecx, ecx
	mov	edx, DWORD PTR _w$[ebp]
	mov	WORD PTR [edx+eax*2-2], cx
	movzx	eax, WORD PTR _vbdt_num
	xor	ecx, ecx
	mov	edx, DWORD PTR _currh$[ebp]
	mov	WORD PTR [edx+eax*2-2], cx

; 3315 : 
; 3316 : 								vbdt[vbdt_num-1].num_elements=0;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	xor	ecx, ecx
	mov	edx, DWORD PTR _vbdt
	mov	WORD PTR [edx+eax+46], cx

; 3317 : 
; 3318 : 								glGenTextures(1,&vbdt[vbdt_num-1].texture);

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	mov	ecx, DWORD PTR _vbdt
	lea	edx, DWORD PTR [ecx+eax+36]
	mov	esi, esp
	push	edx
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3319 : 
; 3320 : 								glBindTexture(GL_TEXTURE_2D,vbdt[vbdt_num-1].texture);

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+36]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3321 : 
; 3322 : 								glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,2048,2048,0,GL_BGRA,GL_UNSIGNED_BYTE,NULL);

	mov	esi, esp
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3323 : 
; 3324 : 								//glBindTexture(GL_TEXTURE_2D,mgg->frames[i].data);
; 3325 : 
; 3326 : 								/*
; 3327 : 								data=malloc(framesize[j]);
; 3328 : 
; 3329 : 								if(data==NULL)
; 3330 : 								{
; 3331 : 									LogApp("Error allocating memory for texture %d, size %d, file %s during atlas creating",i,framesize[i],name);
; 3332 : 									continue;
; 3333 : 								}
; 3334 : 
; 3335 : 								fseek(file,frameoffset[j-1]+1,SEEK_SET);
; 3336 : 
; 3337 : 								fread(data,framesize[j],1,file);
; 3338 : 
; 3339 : 								imgdata=SOIL_load_image_from_memory((unsigned char*) data,framesize[j],&width,&height,&channel,0);
; 3340 : 								*/
; 3341 : 
; 3342 : 								if (mgg->frames[i].channel == 4)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+32], 4
	jne	SHORT $LN9@LoadMGG

; 3343 : 									channel2 = GL_RGBA;

	mov	eax, 6408				; 00001908H
	mov	WORD PTR _channel2$[ebp], ax

; 3344 : 								else

	jmp	SHORT $LN7@LoadMGG
$LN9@LoadMGG:

; 3345 : 									if (mgg->frames[i].channel == 3)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	DWORD PTR [eax+ecx+32], 3
	jne	SHORT $LN7@LoadMGG

; 3346 : 										channel2 = GL_RGB;

	mov	eax, 6407				; 00001907H
	mov	WORD PTR _channel2$[ebp], ax
$LN7@LoadMGG:

; 3347 : 
; 3348 : 								imgdata = malloc(mgg->frames[i].w*mgg->frames[i].h*mgg->frames[i].channel);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _i$[ebp]
	imul	edx, edx, 40
	mov	esi, DWORD PTR _mgg$[ebp]
	mov	esi, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [eax+ecx+24]
	imul	eax, DWORD PTR [esi+edx+28]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	imul	eax, DWORD PTR [ecx+edx+32]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _imgdata$[ebp], eax

; 3349 : 								glBindTexture(GL_TEXTURE_2D, mgg->frames[i].data);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+ecx]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3350 : 								glGetTexImage(GL_TEXTURE_2D, 0, channel2, GL_UNSIGNED_BYTE, imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	movzx	ecx, WORD PTR _channel2$[ebp]
	push	ecx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glGetTexImage@20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3351 : 
; 3352 : 								glBindTexture(GL_TEXTURE_2D, vbdt[l].texture);

	movzx	eax, WORD PTR _l$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+36]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3353 : 				
; 3354 : 								glTexSubImage2D(GL_TEXTURE_2D,0,w[vbdt_num-1],h[vbdt_num-1],mgg->frames[i].w,mgg->frames[i].h,channel2,GL_UNSIGNED_BYTE,imgdata);

	mov	esi, esp
	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	push	5121					; 00001401H
	movzx	ecx, WORD PTR _channel2$[ebp]
	push	ecx
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [edx+eax+28]
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	eax, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+edx+24]
	push	edx
	movzx	eax, WORD PTR _vbdt_num
	mov	ecx, DWORD PTR _h$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2-2]
	push	edx
	movzx	eax, WORD PTR _vbdt_num
	mov	ecx, DWORD PTR _w$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2-2]
	push	edx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexSubImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3355 : 
; 3356 : 								mgg->frames[i].posx=(w[vbdt_num-1]*32768)/2048;

	movzx	eax, WORD PTR _vbdt_num
	mov	ecx, DWORD PTR _w$[ebp]
	movzx	eax, WORD PTR [ecx+eax*2-2]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	edx, WORD PTR _i$[ebp]
	imul	ecx, edx, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [edx+40]
	mov	WORD PTR [edx+ecx+14], ax

; 3357 : 								mgg->frames[i].posy=(currh[vbdt_num-1]*32768)/2048;

	movzx	eax, WORD PTR _vbdt_num
	mov	ecx, DWORD PTR _currh$[ebp]
	movzx	eax, WORD PTR [ecx+eax*2-2]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	edx, WORD PTR _i$[ebp]
	imul	ecx, edx, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	edx, DWORD PTR [edx+40]
	mov	WORD PTR [edx+ecx+16], ax

; 3358 : 
; 3359 : 								w[vbdt_num-1]=mgg->frames[i].w;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _vbdt_num
	mov	esi, DWORD PTR _w$[ebp]
	mov	ax, WORD PTR [eax+ecx+24]
	mov	WORD PTR [esi+edx*2-2], ax

; 3360 : 								h[vbdt_num-1]=mgg->frames[i].h;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, WORD PTR _vbdt_num
	mov	esi, DWORD PTR _h$[ebp]
	mov	ax, WORD PTR [eax+ecx+28]
	mov	WORD PTR [esi+edx*2-2], ax

; 3361 : 
; 3362 : 								mgg->frames[i].sizex=(mgg->frames[i].w*32768)/2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	eax, DWORD PTR [eax+ecx+24]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	WORD PTR [ecx+edx+18], ax

; 3363 : 								mgg->frames[i].sizey=(mgg->frames[i].h*32768)/2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	eax, DWORD PTR [eax+ecx+28]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	WORD PTR [ecx+edx+20], ax

; 3364 : 
; 3365 : 								glDeleteTextures(1,&mgg->frames[i].data);

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	add	eax, ecx
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3366 : 
; 3367 : 								mgg->frames[i].data=vbdt[vbdt_num-1].texture;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	shl	eax, 6
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	esi, DWORD PTR _vbdt
	mov	eax, DWORD PTR [esi+eax+36]
	mov	DWORD PTR [ecx+edx], eax

; 3368 : 
; 3369 : 								mgg->frames[i].vb_id=vbdt_num-1;

	movzx	eax, WORD PTR _vbdt_num
	sub	eax, 1
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _mgg$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	WORD PTR [ecx+edx+10], ax

; 3370 : 
; 3371 : 								mgg->frames[i].w = 2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [eax+ecx+24], 2048		; 00000800H

; 3372 : 								mgg->frames[i].h = 2048;

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _mgg$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [eax+ecx+28], 2048		; 00000800H

; 3373 : 
; 3374 : 							//	free(data);
; 3375 : 
; 3376 : 								free(imgdata);

	mov	eax, DWORD PTR _imgdata$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3377 : 
; 3378 : 								free(w);

	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3379 : 								free(h);

	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3380 : 								free(currh);

	mov	eax, DWORD PTR _currh$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3381 : 
; 3382 : 								break;

	jmp	SHORT $LN19@LoadMGG
$LN10@LoadMGG:

; 3383 : 							}
; 3384 : 						}

	jmp	$LN20@LoadMGG
$LN19@LoadMGG:

; 3385 : 					}
; 3386 : 				}
; 3387 : 			}
; 3388 : 
; 3389 : 			if(i==mggf.num_frames-1)

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _mggf$[ebp+32]
	sub	ecx, 1
	cmp	eax, ecx
	jne	$LN3@LoadMGG

; 3390 : 			{
; 3391 : 				for(n=k;n<vbdt_num;n++)

	mov	ax, WORD PTR _k$[ebp]
	mov	WORD PTR _n$[ebp], ax
	jmp	SHORT $LN5@LoadMGG
$LN4@LoadMGG:
	mov	ax, WORD PTR _n$[ebp]
	add	ax, 1
	mov	WORD PTR _n$[ebp], ax
$LN5@LoadMGG:
	movzx	eax, WORD PTR _n$[ebp]
	movzx	ecx, WORD PTR _vbdt_num
	cmp	eax, ecx
	jge	$LN3@LoadMGG

; 3392 : 				{
; 3393 : 					glBindTexture(GL_TEXTURE_2D,vbdt[n].texture);

	movzx	eax, WORD PTR _n$[ebp]
	shl	eax, 6
	mov	esi, esp
	mov	ecx, DWORD PTR _vbdt
	mov	edx, DWORD PTR [ecx+eax+36]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3394 : 					//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
; 3395 : 					//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
; 3396 : 
; 3397 : 					if(mggf.mipmap)

	movsx	eax, BYTE PTR _mggf$[ebp+72]
	test	eax, eax
	je	SHORT $LN2@LoadMGG

; 3398 : 					{
; 3399 : 						glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);

	mov	esi, esp
	push	9728					; 00002600H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3400 : 						glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);

	mov	esi, esp
	push	9728					; 00002600H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3401 : 					}
; 3402 : 					else

	jmp	SHORT $LN1@LoadMGG
$LN2@LoadMGG:

; 3403 : 						glGenerateMipmap(GL_TEXTURE_2D);

	mov	esi, esp
	push	3553					; 00000de1H
	call	DWORD PTR _GLeeFuncPtr_glGenerateMipmap
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@LoadMGG:

; 3404 : 				}

	jmp	$LN4@LoadMGG
$LN3@LoadMGG:

; 3405 : 			}
; 3406 : 		}

	jmp	$LN63@LoadMGG
$LN62@LoadMGG:

; 3407 : 	}
; 3408 : 
; 3409 : #endif
; 3410 : 	
; 3411 : 	free(posx);

	mov	eax, DWORD PTR _posx$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3412 : 	free(posy);

	mov	eax, DWORD PTR _posy$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3413 : 	free(sizex);

	mov	eax, DWORD PTR _sizex$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3414 : 	free(sizey);

	mov	eax, DWORD PTR _sizey$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3415 : 	
; 3416 : 	//if(imgatlas!=0)
; 3417 : 		free(imgatlas);

	mov	eax, DWORD PTR _imgatlas$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3418 : 
; 3419 : 	//if(framealone!=0)
; 3420 : 		free(framealone);

	mov	eax, DWORD PTR _framealone$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 3421 : 
; 3422 : 	fclose(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 3423 : 
; 3424 : 	return 1;

	mov	eax, 1
$LN144@LoadMGG:

; 3425 : 		
; 3426 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN154@LoadMGG
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 107272				; 0001a308H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN154@LoadMGG:
	DD	7
	DD	$LN153@LoadMGG
$LN153@LoadMGG:
	DD	-120					; ffffff88H
	DD	76					; 0000004cH
	DD	$LN146@LoadMGG
	DD	-152					; ffffff68H
	DD	21					; 00000015H
	DD	$LN147@LoadMGG
	DD	-33012					; ffff7f0cH
	DD	32768					; 00008000H
	DD	$LN148@LoadMGG
	DD	-65788					; fffeff04H
	DD	32768					; 00008000H
	DD	$LN149@LoadMGG
	DD	-74204					; fffede24H
	DD	8192					; 00002000H
	DD	$LN150@LoadMGG
	DD	-106980					; fffe5e1cH
	DD	32768					; 00008000H
	DD	$LN151@LoadMGG
	DD	-107016					; fffe5df8H
	DD	3
	DD	$LN152@LoadMGG
$LN152@LoadMGG:
	DB	109					; 0000006dH
	DB	103					; 00000067H
	DB	105					; 00000069H
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN151@LoadMGG:
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$LN150@LoadMGG:
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	115					; 00000073H
	DB	0
$LN149@LoadMGG:
	DB	102					; 00000066H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN148@LoadMGG:
	DB	102					; 00000066H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$LN147@LoadMGG:
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN146@LoadMGG:
	DB	109					; 0000006dH
	DB	103					; 00000067H
	DB	103					; 00000067H
	DB	102					; 00000066H
	DB	0
_LoadMGG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CheckMGGFile
_TEXT	SEGMENT
_mggf$ = -128						; size = 76
_header$ = -44						; size = 21
_file$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_CheckMGGFile PROC					; COMDAT

; 2396 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-324]
	mov	ecx, 81					; 00000051H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2397 : 	FILE *file;
; 2398 : 	char header[21];
; 2399 : 
; 2400 : 	_MGGFORMAT mggf;
; 2401 : 
; 2402 : 	/*
; 2403 : 	if((file=DecompressFile(name))==NULL)
; 2404 : 	{
; 2405 : 		LogApp("Error reading MGG file %s",name);
; 2406 : 			return 0;
; 2407 : 	}
; 2408 : 	*/
; 2409 : 
; 2410 : 	
; 2411 : 	if((file=fopen(name,"rb"))==NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _file$[ebp], eax
	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN6@CheckMGGFi

; 2412 : 	{
; 2413 : 		LogApp("Error reading MGG file %s",name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BK@JNFOJKPO@Error?5reading?5MGG?5file?5?$CFs?$AA@
	call	_SDL_Log
	add	esp, 8

; 2414 : 			return -2;

	mov	eax, -2					; fffffffeH
	jmp	$LN7@CheckMGGFi
$LN6@CheckMGGFi:

; 2415 : 	}
; 2416 : 
; 2417 : 	rewind(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_rewind
	add	esp, 4

; 2418 : 
; 2419 : 	fread(header,21,1,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	21					; 00000015H
	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 2420 : 
; 2421 : 	if(strcmp(header,"MGG File Version 1")!=NULL)

	push	OFFSET ??_C@_0BD@IGEJGLBO@MGG?5File?5Version?51?$AA@
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@CheckMGGFi

; 2422 : 	{
; 2423 : 		LogApp("Invalid MGG file header %s",name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BL@HGJNDNHB@Invalid?5MGG?5file?5header?5?$CFs?$AA@
	call	_SDL_Log
	add	esp, 8

; 2424 : 		fclose(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 2425 : 		return 0;

	xor	eax, eax
	jmp	$LN7@CheckMGGFi
$LN5@CheckMGGFi:

; 2426 : 	}
; 2427 : 
; 2428 : 	rewind(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_rewind
	add	esp, 4

; 2429 : 
; 2430 : 	fread(&mggf,sizeof(_MGGFORMAT),1,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	76					; 0000004cH
	lea	ecx, DWORD PTR _mggf$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 2431 : 
; 2432 : 	if((mggf.type!=SPRITEM && mggf.type!=TEXTUREM && mggf.type!=NONE) || (mggf.num_animations<0 || mggf.num_animations>MAX_ANIMATIONS) || (mggf.num_frames<0 || mggf.num_frames>MAX_FRAMES))

	cmp	DWORD PTR _mggf$[ebp+36], 0
	je	SHORT $LN2@CheckMGGFi
	cmp	DWORD PTR _mggf$[ebp+36], 1
	je	SHORT $LN2@CheckMGGFi
	cmp	DWORD PTR _mggf$[ebp+36], 2
	jne	SHORT $LN3@CheckMGGFi
$LN2@CheckMGGFi:
	cmp	DWORD PTR _mggf$[ebp+48], 0
	jb	SHORT $LN3@CheckMGGFi
	cmp	DWORD PTR _mggf$[ebp+48], 64		; 00000040H
	ja	SHORT $LN3@CheckMGGFi
	movzx	eax, WORD PTR _mggf$[ebp+32]
	test	eax, eax
	jl	SHORT $LN3@CheckMGGFi
	movzx	eax, WORD PTR _mggf$[ebp+32]
	cmp	eax, 8192				; 00002000H
	jle	SHORT $LN4@CheckMGGFi
$LN3@CheckMGGFi:

; 2433 : 	{
; 2434 : 		fclose(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 2435 : 		LogApp("Invalid MGG file %s",name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BE@GOCIOEKA@Invalid?5MGG?5file?5?$CFs?$AA@
	call	_SDL_Log
	add	esp, 8

; 2436 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN7@CheckMGGFi
$LN4@CheckMGGFi:

; 2437 : 	}
; 2438 : 
; 2439 : 	fclose(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 2440 : 	return 1;

	mov	eax, 1
$LN7@CheckMGGFi:

; 2441 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@CheckMGGFi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 324				; 00000144H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@CheckMGGFi:
	DD	2
	DD	$LN11@CheckMGGFi
$LN11@CheckMGGFi:
	DD	-44					; ffffffd4H
	DD	21					; 00000015H
	DD	$LN9@CheckMGGFi
	DD	-128					; ffffff80H
	DD	76					; 0000004cH
	DD	$LN10@CheckMGGFi
$LN10@CheckMGGFi:
	DB	109					; 0000006dH
	DB	103					; 00000067H
	DB	103					; 00000067H
	DB	102					; 00000066H
	DB	0
$LN9@CheckMGGFi:
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_CheckMGGFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CheckMGGInSystem
_TEXT	SEGMENT
_mggf$ = -140						; size = 76
_i$ = -53						; size = 1
_header$ = -44						; size = 21
_file$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_CheckMGGInSystem PROC					; COMDAT

; 2330 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-336]
	mov	ecx, 84					; 00000054H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2331 : 	FILE *file;
; 2332 : 	char header[21];
; 2333 : 	int8 i;
; 2334 : 
; 2335 : 	_MGGFORMAT mggf;
; 2336 : 	/*
; 2337 : 	if((file=DecompressFile(name))==NULL)
; 2338 : 	{
; 2339 : 		LogApp("Error reading MGG file %s",name);
; 2340 : 			return -2;
; 2341 : 	}
; 2342 : 	*/
; 2343 : 
; 2344 : 	if((file=fopen(name,"rb"))==NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _file$[ebp], eax
	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN14@CheckMGGIn

; 2345 : 	{
; 2346 : 		LogApp("Error reading MGG file %s",name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BK@JNFOJKPO@Error?5reading?5MGG?5file?5?$CFs?$AA@
	call	_SDL_Log
	add	esp, 8

; 2347 : 			return -2;

	mov	eax, -2					; fffffffeH
	jmp	$LN15@CheckMGGIn
$LN14@CheckMGGIn:

; 2348 : 	}
; 2349 : 
; 2350 : 	rewind(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_rewind
	add	esp, 4

; 2351 : 
; 2352 : 	fread(header,21,1,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	21					; 00000015H
	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 2353 : 
; 2354 : 	if(strcmp(header,"MGG File Version 1")!=NULL)

	push	OFFSET ??_C@_0BD@IGEJGLBO@MGG?5File?5Version?51?$AA@
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@CheckMGGIn

; 2355 : 	{
; 2356 : 		LogApp("Invalid MGG file header %s",header);

	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	push	OFFSET ??_C@_0BL@HGJNDNHB@Invalid?5MGG?5file?5header?5?$CFs?$AA@
	call	_SDL_Log
	add	esp, 8

; 2357 : 		fclose(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 2358 : 		return -2;

	mov	eax, -2					; fffffffeH
	jmp	$LN15@CheckMGGIn
$LN13@CheckMGGIn:

; 2359 : 	}
; 2360 : 
; 2361 : 	fread(&mggf,sizeof(_MGGFORMAT),1,file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	76					; 0000004cH
	lea	ecx, DWORD PTR _mggf$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 2362 : 
; 2363 : 	for(i=0;i<st.num_mgg_basic;i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $LN12@CheckMGGIn
$LN11@CheckMGGIn:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$LN12@CheckMGGIn:
	movsx	eax, BYTE PTR _i$[ebp]
	movzx	ecx, BYTE PTR _st+266
	cmp	eax, ecx
	jge	SHORT $LN10@CheckMGGIn

; 2364 : 	{
; 2365 : 		if(strcmp(mggf.name,mgg_sys[i].name)==NULL)

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 60
	add	ecx, OFFSET _mgg_sys
	push	ecx
	lea	edx, DWORD PTR _mggf$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@CheckMGGIn

; 2366 : 		{
; 2367 : 			fclose(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 2368 : 			return i+1000;

	movsx	eax, BYTE PTR _i$[ebp]
	add	eax, 1000				; 000003e8H
	jmp	$LN15@CheckMGGIn
$LN9@CheckMGGIn:

; 2369 : 		}
; 2370 : 	}

	jmp	SHORT $LN11@CheckMGGIn
$LN10@CheckMGGIn:

; 2371 : 
; 2372 : 	for(i=0;i<st.num_mgg;i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $LN8@CheckMGGIn
$LN7@CheckMGGIn:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$LN8@CheckMGGIn:
	movsx	eax, BYTE PTR _i$[ebp]
	movzx	ecx, BYTE PTR _st+265
	cmp	eax, ecx
	jge	SHORT $LN6@CheckMGGIn

; 2373 : 	{
; 2374 : 		if(strcmp(mggf.name,mgg_game[i].name)==NULL)

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 60
	add	ecx, OFFSET _mgg_game
	push	ecx
	lea	edx, DWORD PTR _mggf$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@CheckMGGIn

; 2375 : 		{
; 2376 : 			fclose(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 2377 : 			return i+10000;

	movsx	eax, BYTE PTR _i$[ebp]
	add	eax, 10000				; 00002710H
	jmp	SHORT $LN15@CheckMGGIn
$LN5@CheckMGGIn:

; 2378 : 		}
; 2379 : 	}

	jmp	SHORT $LN7@CheckMGGIn
$LN6@CheckMGGIn:

; 2380 : 
; 2381 : 	for(i=0;i<st.Current_Map.num_mgg;i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $LN4@CheckMGGIn
$LN3@CheckMGGIn:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$LN4@CheckMGGIn:
	movsx	eax, BYTE PTR _i$[ebp]
	movzx	ecx, BYTE PTR _st+66848
	cmp	eax, ecx
	jge	SHORT $LN2@CheckMGGIn

; 2382 : 	{
; 2383 : 		if(strcmp(mggf.name,mgg_map[i].name)==NULL)

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 60
	add	ecx, OFFSET _mgg_map
	push	ecx
	lea	edx, DWORD PTR _mggf$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@CheckMGGIn

; 2384 : 		{
; 2385 : 			fclose(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 2386 : 			return i+100000;

	movsx	eax, BYTE PTR _i$[ebp]
	add	eax, 100000				; 000186a0H
	jmp	SHORT $LN15@CheckMGGIn
$LN1@CheckMGGIn:

; 2387 : 		}
; 2388 : 	}

	jmp	SHORT $LN3@CheckMGGIn
$LN2@CheckMGGIn:

; 2389 : 
; 2390 : 	fclose(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 2391 : 
; 2392 : 	return -1;

	or	eax, -1
$LN15@CheckMGGIn:

; 2393 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@CheckMGGIn
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 336				; 00000150H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN20@CheckMGGIn:
	DD	2
	DD	$LN19@CheckMGGIn
$LN19@CheckMGGIn:
	DD	-44					; ffffffd4H
	DD	21					; 00000015H
	DD	$LN17@CheckMGGIn
	DD	-140					; ffffff74H
	DD	76					; 0000004cH
	DD	$LN18@CheckMGGIn
$LN18@CheckMGGIn:
	DB	109					; 0000006dH
	DB	103					; 00000067H
	DB	103					; 00000067H
	DB	102					; 00000066H
	DB	0
$LN17@CheckMGGIn:
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_CheckMGGInSystem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _Quit
_TEXT	SEGMENT
_Quit	PROC						; COMDAT

; 537  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 538  : 	//ResetVB();
; 539  : 	InputClose();

	call	_InputClose

; 540  : 	SDL_DestroyWindow(wn);

	mov	eax, DWORD PTR _wn
	push	eax
	call	_SDL_DestroyWindow
	add	esp, 4

; 541  : 	SDL_Quit();

	call	_SDL_Quit

; 542  : #ifndef MGEAR_CLEAN_VERSION
; 543  : 	FMOD_System_Close(st.sound_sys.Sound_System);
; 544  : 	FMOD_System_Release(st.sound_sys.Sound_System);
; 545  : #endif
; 546  : 	TTF_Quit();

	call	_TTF_Quit

; 547  : 	exit(1);

	push	1
	call	_exit
$LN2@Quit:

; 548  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_Quit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _OpenFont
_TEXT	SEGMENT
tv68 = -196						; size = 4
_file$ = 8						; size = 4
_name$ = 12						; size = 4
_index$ = 16						; size = 1
_font_size$ = 20					; size = 4
_OpenFont PROC						; COMDAT

; 2186 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2187 : 	if((st.fonts[index].font=TTF_OpenFont(file,font_size))==NULL)

	mov	eax, DWORD PTR _font_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_TTF_OpenFont
	add	esp, 8
	mov	DWORD PTR tv68[ebp], eax
	movzx	edx, BYTE PTR _index$[ebp]
	imul	eax, edx, 84
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _st[eax+64344], ecx
	cmp	DWORD PTR tv68[ebp], 0
	jne	SHORT $LN1@OpenFont

; 2188 : 	{
; 2189 : 		LogApp("Error while opening TTF font : %s",TTF_GetError());

	call	_SDL_GetError
	push	eax
	push	OFFSET ??_C@_0CC@HAGAANID@Error?5while?5opening?5TTF?5font?5?3?5?$CF@
	call	_SDL_Log
	add	esp, 8

; 2190 : 		return 0;

	xor	al, al
	jmp	SHORT $LN2@OpenFont
$LN1@OpenFont:

; 2191 : 	}
; 2192 : 
; 2193 : 	st.fonts[index].size_h_px=font_size;

	movzx	eax, BYTE PTR _index$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _font_size$[ebp]
	mov	DWORD PTR _st[ecx+64352], edx

; 2194 : 	st.fonts[index].size_w_px=font_size/2;

	mov	eax, DWORD PTR _font_size$[ebp]
	shr	eax, 1
	movzx	ecx, BYTE PTR _index$[ebp]
	imul	edx, ecx, 84
	mov	DWORD PTR _st[edx+64348], eax

; 2195 : 	st.fonts[index].size_w_gm=font_size;

	movzx	eax, BYTE PTR _index$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _font_size$[ebp]
	mov	DWORD PTR _st[ecx+64356], edx

; 2196 : 	st.fonts[index].size_h_gm=font_size;

	movzx	eax, BYTE PTR _index$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _font_size$[ebp]
	mov	DWORD PTR _st[ecx+64360], edx

; 2197 : 	
; 2198 : 	strcpy(st.fonts[index].name,name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _index$[ebp]
	imul	edx, ecx, 84
	add	edx, OFFSET _st+64280
	push	edx
	call	_strcpy
	add	esp, 8

; 2199 : 
; 2200 : 	return 1;

	mov	al, 1
$LN2@OpenFont:

; 2201 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_OpenFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _Init
_TEXT	SEGMENT
_logs$ = -33120						; size = 32768
_statusLK$ = -344					; size = 128
_statusCM$ = -208					; size = 128
_k$ = -48						; size = 4
_l$ = -36						; size = 2
_j$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_Init	PROC						; COMDAT

; 1412 : {	

	push	ebp
	mov	ebp, esp
	mov	eax, 33316				; 00008224H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-33316]
	mov	ecx, 8329				; 00002089H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1413 : 	 uint16 i=0, j=0, l=0;

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	xor	eax, eax
	mov	WORD PTR _l$[ebp], ax

; 1414 : 	 float k=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _k$[ebp], xmm0

; 1415 : 
; 1416 : 	int check;
; 1417 : #ifndef MGEAR_CLEAN_VERSION
; 1418 : 	FMOD_RESULT result;
; 1419 : #endif
; 1420 : 
; 1421 : 	GLenum checkfb;
; 1422 : 
; 1423 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 1424 : 
; 1425 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER)
; 1426 : 	GLint statusCM[32], statusLK[32];
; 1427 : 	GLchar logs[32][1024];
; 1428 : 
; 1429 : #ifdef _DEBUG
; 1430 : 	//printf("Waiting...\n");
; 1431 : 	//system("pause");
; 1432 : #endif
; 1433 : 
; 1434 : 	CreateLog();

	call	_CreateLog

; 1435 : 
; 1436 : 	vbd.vertex=(float*) malloc(12*sizeof(float));

	push	48					; 00000030H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _vbd+12, eax

; 1437 : 	vbd.texcoord=(float*) malloc(8*sizeof(float));

	push	32					; 00000020H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _vbd+16, eax

; 1438 : #endif
; 1439 : 	vbd.color=(GLubyte*) malloc(16*sizeof(GLubyte));

	push	16					; 00000010H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _vbd+28, eax

; 1440 : 	vbd.index=(GLushort*) malloc(6*sizeof(GLushort));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _vbd+32, eax

; 1441 : 	
; 1442 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER)
; 1443 : 
; 1444 : 	vbd.vertex[0]=-1.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _vbd+12
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+ecx], xmm0

; 1445 : 	vbd.vertex[1]=-1.0f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _vbd+12
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+eax], xmm0

; 1446 : 	vbd.vertex[2]=0.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _vbd+12
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax], xmm0

; 1447 : 	vbd.vertex[3]=1.0f;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _vbd+12
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx], xmm0

; 1448 : 	vbd.vertex[4]=-1.0f;

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _vbd+12
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+eax], xmm0

; 1449 : 	vbd.vertex[5]=0.0f;

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _vbd+12
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx], xmm0

; 1450 : 	vbd.vertex[6]=1.0f;

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _vbd+12
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx], xmm0

; 1451 : 	vbd.vertex[7]=1.0f;

	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _vbd+12
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx], xmm0

; 1452 : 	vbd.vertex[8]=0.0f;

	mov	eax, 4
	shl	eax, 3
	mov	ecx, DWORD PTR _vbd+12
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax], xmm0

; 1453 : 	vbd.vertex[9]=-1.0f;

	mov	eax, 4
	imul	ecx, eax, 9
	mov	edx, DWORD PTR _vbd+12
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+ecx], xmm0

; 1454 : 	vbd.vertex[10]=1.0f;

	mov	eax, 4
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _vbd+12
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx], xmm0

; 1455 : 	vbd.vertex[11]=0.0f;

	mov	eax, 4
	imul	ecx, eax, 11
	mov	edx, DWORD PTR _vbd+12
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx], xmm0

; 1456 : 
; 1457 : 	vbd.texcoord[0]=0.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _vbd+16
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx], xmm0

; 1458 : 	vbd.texcoord[1]=0.0f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _vbd+16
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax], xmm0

; 1459 : 	vbd.texcoord[2]=1.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _vbd+16
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+eax], xmm0

; 1460 : 	vbd.texcoord[3]=0.0f;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _vbd+16
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx], xmm0

; 1461 : 	vbd.texcoord[4]=1.0f;

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _vbd+16
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+eax], xmm0

; 1462 : 	vbd.texcoord[5]=1.0f;

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _vbd+16
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx], xmm0

; 1463 : 	vbd.texcoord[6]=0.0f;

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _vbd+16
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx], xmm0

; 1464 : 	vbd.texcoord[7]=1.0f;

	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _vbd+16
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx], xmm0

; 1465 : 
; 1466 : #endif
; 1467 : 
; 1468 : 	vbd.color[0]=255;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _vbd+28
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 1469 : 	vbd.color[1]=255;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _vbd+28
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 1470 : 	vbd.color[2]=255;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _vbd+28
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 1471 : 	vbd.color[3]=255;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _vbd+28
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 1472 : 	vbd.color[4]=255;

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _vbd+28
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 1473 : 	vbd.color[5]=255;

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _vbd+28
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 1474 : 	vbd.color[6]=255;

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _vbd+28
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 1475 : 	vbd.color[7]=255;

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _vbd+28
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 1476 : 	vbd.color[8]=255;

	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _vbd+28
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 1477 : 	vbd.color[9]=255;

	mov	eax, 1
	imul	ecx, eax, 9
	mov	edx, DWORD PTR _vbd+28
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 1478 : 	vbd.color[10]=255;

	mov	eax, 1
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _vbd+28
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 1479 : 	vbd.color[11]=255;

	mov	eax, 1
	imul	ecx, eax, 11
	mov	edx, DWORD PTR _vbd+28
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 1480 : 	vbd.color[12]=255;

	mov	eax, 1
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _vbd+28
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 1481 : 	vbd.color[13]=255;

	mov	eax, 1
	imul	ecx, eax, 13
	mov	edx, DWORD PTR _vbd+28
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 1482 : 	vbd.color[14]=255;

	mov	eax, 1
	imul	ecx, eax, 14
	mov	edx, DWORD PTR _vbd+28
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 1483 : 	vbd.color[15]=255;

	mov	eax, 1
	imul	ecx, eax, 15
	mov	edx, DWORD PTR _vbd+28
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 1484 : 
; 1485 : 	vbd.index[0]=0;

	mov	eax, 2
	imul	ecx, eax, 0
	xor	edx, edx
	mov	eax, DWORD PTR _vbd+32
	mov	WORD PTR [eax+ecx], dx

; 1486 : 	vbd.index[1]=1;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 1
	mov	edx, DWORD PTR _vbd+32
	mov	WORD PTR [edx+eax], cx

; 1487 : 	vbd.index[2]=2;

	mov	eax, 2
	shl	eax, 1
	mov	ecx, 2
	mov	edx, DWORD PTR _vbd+32
	mov	WORD PTR [edx+eax], cx

; 1488 : 	vbd.index[3]=2;

	mov	eax, 2
	imul	ecx, eax, 3
	mov	edx, 2
	mov	eax, DWORD PTR _vbd+32
	mov	WORD PTR [eax+ecx], dx

; 1489 : 	vbd.index[4]=3;

	mov	eax, 2
	shl	eax, 2
	mov	ecx, 3
	mov	edx, DWORD PTR _vbd+32
	mov	WORD PTR [edx+eax], cx

; 1490 : 	vbd.index[5]=0;

	mov	eax, 2
	imul	ecx, eax, 5
	xor	edx, edx
	mov	eax, DWORD PTR _vbd+32
	mov	WORD PTR [eax+ecx], dx

; 1491 : 	
; 1492 : 	vbdt_num=0;

	xor	eax, eax
	mov	WORD PTR _vbdt_num, ax

; 1493 : 
; 1494 : #endif
; 1495 : 
; 1496 : 	//Initialize SDL
; 1497 : 	if((SDL_Init(SDL_INIT_EVERYTHING))!=NULL)

	push	29233					; 00007231H
	call	_SDL_Init
	add	esp, 4
	test	eax, eax
	je	SHORT $LN71@Init

; 1498 : 	{
; 1499 : 		LogApp("SDL Initilization failed %s",SDL_GetError());

	call	_SDL_GetError
	push	eax
	push	OFFSET ??_C@_0BM@HCNBMJIE@SDL?5Initilization?5failed?5?$CFs?$AA@
	call	_SDL_Log
	add	esp, 8

; 1500 : 			Quit();

	call	_Quit
$LN71@Init:

; 1501 : 	}
; 1502 : 
; 1503 : 	LogApp("SDL 2.0 initialzed");

	push	OFFSET ??_C@_0BD@DNBPCBJE@SDL?52?40?5initialzed?$AA@
	call	_SDL_Log
	add	esp, 4

; 1504 : 		
; 1505 : #if !defined (MGEAR_CLEAN_VERSION) || defined (ENABLE_SOUND_SYS) 
; 1506 : 
; 1507 : 	if((result=FMOD_System_Create(&st.sound_sys.Sound_System))!=FMOD_OK)
; 1508 : 	{
; 1509 : 		LogApp("Error while initializing FMOD, Creating System : %s",FMOD_ErrorString(result));
; 1510 : 			Quit();
; 1511 : 	}
; 1512 : 	LogApp("FMOD system created");
; 1513 : 	
; 1514 : 	if((result=FMOD_System_Init(st.sound_sys.Sound_System,MAX_CHANNELS,FMOD_INIT_NORMAL,NULL))!=FMOD_OK)
; 1515 : 	{
; 1516 : 		LogApp("Error while initializing FMOD : %s",FMOD_ErrorString(result));
; 1517 : 			Quit();
; 1518 : 	}
; 1519 : 
; 1520 : 	LogApp("FMOD system initialzed, %d channels",MAX_CHANNELS);
; 1521 : 	/*
; 1522 : 	for(i=0;i<MAX_SOUNDS;i++)
; 1523 : 		st.sound_sys.slot_ID[i]=-1;
; 1524 : 
; 1525 : 	for(i=0;i<MAX_CHANNELS;i++)
; 1526 : 		st.sound_sys.slotch_ID[i]=-1;
; 1527 : 		*/
; 1528 : #endif
; 1529 : 
; 1530 : 	if(TTF_Init()==-1)

	call	_TTF_Init
	cmp	eax, -1
	jne	SHORT $LN70@Init

; 1531 : 	{
; 1532 : 		LogApp("Error while initializing SDL TTF : %s",TTF_GetError());

	call	_SDL_GetError
	push	eax
	push	OFFSET ??_C@_0CG@LLIBEPGC@Error?5while?5initializing?5SDL?5TTF@
	call	_SDL_Log
	add	esp, 8

; 1533 : 			Quit();

	call	_Quit
$LN70@Init:

; 1534 : 	}
; 1535 : 
; 1536 : 	LogApp("SDL TTF initialized");

	push	OFFSET ??_C@_0BE@MBBIJNFJ@SDL?5TTF?5initialized?$AA@
	call	_SDL_Log
	add	esp, 4

; 1537 : 
; 1538 : //#ifndef MGEAR_MFC
; 1539 : 	
; 1540 : 	SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER,1);

	push	1
	push	5
	call	_SDL_GL_SetAttribute
	add	esp, 8

; 1541 : 	SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL,1);

	push	1
	push	15					; 0000000fH
	call	_SDL_GL_SetAttribute
	add	esp, 8

; 1542 : 
; 1543 : 	//Set video mode
; 1544 : 	if(st.fullscreen)

	movzx	eax, BYTE PTR _st+233
	test	eax, eax
	je	SHORT $LN69@Init

; 1545 : 	{
; 1546 : 		if((wn=SDL_CreateWindow(st.WINDOW_NAME, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, st.screenx, st.screeny, SDL_WINDOW_FULLSCREEN | SDL_WINDOW_OPENGL ))==NULL)

	push	3
	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	ecx, WORD PTR _st+228
	push	ecx
	push	805240832				; 2fff0000H
	push	805240832				; 2fff0000H
	push	OFFSET _st+132
	call	_SDL_CreateWindow
	add	esp, 24					; 00000018H
	mov	DWORD PTR _wn, eax
	cmp	DWORD PTR _wn, 0
	jne	SHORT $LN68@Init

; 1547 : 		{
; 1548 : 			LogApp("Error setting fullscreen video mode %d x %d %d bits - %s",st.screenx,st.screeny,st.bpp,SDL_GetError());

	call	_SDL_GetError
	push	eax
	movzx	eax, BYTE PTR _st+232
	push	eax
	movzx	ecx, WORD PTR _st+230
	push	ecx
	movzx	edx, WORD PTR _st+228
	push	edx
	push	OFFSET ??_C@_0DJ@GHPNMNEC@Error?5setting?5fullscreen?5video?5m@
	call	_SDL_Log
	add	esp, 20					; 00000014H

; 1549 : 				Quit();

	call	_Quit
$LN68@Init:

; 1550 : 		}
; 1551 : 	}
; 1552 : 	else

	jmp	SHORT $LN65@Init
$LN69@Init:

; 1553 : 	if(!st.fullscreen)

	movzx	eax, BYTE PTR _st+233
	test	eax, eax
	jne	SHORT $LN65@Init

; 1554 : 	{
; 1555 : 		if((wn=SDL_CreateWindow(st.WINDOW_NAME, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, st.screenx, st.screeny, SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE))==NULL)

	push	34					; 00000022H
	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	ecx, WORD PTR _st+228
	push	ecx
	push	805240832				; 2fff0000H
	push	805240832				; 2fff0000H
	push	OFFSET _st+132
	call	_SDL_CreateWindow
	add	esp, 24					; 00000018H
	mov	DWORD PTR _wn, eax
	cmp	DWORD PTR _wn, 0
	jne	SHORT $LN65@Init

; 1556 : 		{
; 1557 : 			LogApp("Error setting widowed video mode %d x %d %d bits - %s",st.screenx,st.screeny,st.bpp,SDL_GetError());

	call	_SDL_GetError
	push	eax
	movzx	eax, BYTE PTR _st+232
	push	eax
	movzx	ecx, WORD PTR _st+230
	push	ecx
	movzx	edx, WORD PTR _st+228
	push	edx
	push	OFFSET ??_C@_0DG@HINKMIAE@Error?5setting?5widowed?5video?5mode@
	call	_SDL_Log
	add	esp, 20					; 00000014H

; 1558 : 				Quit();

	call	_Quit
$LN65@Init:

; 1559 : 		}
; 1560 : 	}
; 1561 : 
; 1562 : 	LogApp("Window created, %d x %d, %d bits",st.screenx,st.screeny,st.bpp);

	movzx	eax, BYTE PTR _st+232
	push	eax
	movzx	ecx, WORD PTR _st+230
	push	ecx
	movzx	edx, WORD PTR _st+228
	push	edx
	push	OFFSET ??_C@_0CB@CJINDJOG@Window?5created?0?5?$CFd?5x?5?$CFd?0?5?$CFd?5bits@
	call	_SDL_Log
	add	esp, 16					; 00000010H

; 1563 : 
; 1564 : 	if((st.glc=SDL_GL_CreateContext(wn))==NULL)

	mov	eax, DWORD PTR _wn
	push	eax
	call	_SDL_GL_CreateContext
	add	esp, 4
	mov	DWORD PTR _st+2335412, eax
	cmp	DWORD PTR _st+2335412, 0
	jne	SHORT $LN64@Init

; 1565 : 	{
; 1566 : 		LogApp("Error setting renderer: %s",SDL_GetError());

	call	_SDL_GetError
	push	eax
	push	OFFSET ??_C@_0BL@JKBAOCCM@Error?5setting?5renderer?3?5?$CFs?$AA@
	call	_SDL_Log
	add	esp, 8

; 1567 : 				Quit();

	call	_Quit
$LN64@Init:

; 1568 : 	}
; 1569 : 
; 1570 : 	LogApp("Opengl context created");

	push	OFFSET ??_C@_0BH@PJDJGOFF@Opengl?5context?5created?$AA@
	call	_SDL_Log
	add	esp, 4

; 1571 : 
; 1572 : //#endif
; 1573 : 
; 1574 : #ifdef _VAO_RENDER
; 1575 : 	st.renderer.VAO_ON=0;

	mov	BYTE PTR _st+2336440, 0

; 1576 : #endif
; 1577 : 
; 1578 : #ifdef _VBO_RENDER
; 1579 : 	st.renderer.VBO_ON=0;

	mov	BYTE PTR _st+2336452, 0

; 1580 : #endif
; 1581 : 
; 1582 : #ifdef _VA_RENDER
; 1583 : 	st.renderer.VA_ON=0;

	mov	BYTE PTR _st+2336453, 0

; 1584 : #endif
; 1585 : 
; 1586 : #ifdef _VAO_RENDER
; 1587 : 	if(!GLEE_VERSION_3_0 || strstr((char const*) glGetString(GL_EXTENSIONS),"GL_ARB_vertex_array_object")==NULL)

	push	OFFSET __GLEE_VERSION_3_0
	call	_GLeeEnabled
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN62@Init
	push	OFFSET ??_C@_0BL@PNJKGHIL@GL_ARB_vertex_array_object?$AA@
	mov	esi, esp
	push	7939					; 00001f03H
	call	DWORD PTR __imp__glGetString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	$LN63@Init
$LN62@Init:

; 1588 : 	{
; 1589 : 		LogApp("VAO not supported, check your video's card driver for updates... Using VBO instead");

	push	OFFSET ??_C@_0FD@HGLPPOCA@VAO?5not?5supported?0?5check?5your?5vi@
	call	_SDL_Log
	add	esp, 4

; 1590 : 		st.renderer.VAO_ON=0;

	mov	BYTE PTR _st+2336440, 0

; 1591 : 
; 1592 : #ifdef _VBO_RENDER
; 1593 : 
; 1594 : 		if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_ARB_vertex_buffer_object")==NULL)

	push	OFFSET ??_C@_0BM@OOMEFFAE@GL_ARB_vertex_buffer_object?$AA@
	mov	esi, esp
	push	7939					; 00001f03H
	call	DWORD PTR __imp__glGetString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN61@Init

; 1595 : 		{
; 1596 : #ifdef _VA_RENDER
; 1597 : 			st.renderer.VA_ON=1;

	mov	BYTE PTR _st+2336453, 1

; 1598 : 			LogApp("VBOs not supported, check your video's card driver for updates... Using VA instead!!");

	push	OFFSET ??_C@_0FF@HDHKLDIO@VBOs?5not?5supported?0?5check?5your?5v@
	call	_SDL_Log
	add	esp, 4

; 1599 : #else 
; 1600 : 			LogApp("Your video card is not adequate to play this game... Goodbye!!");
; 1601 : 			Quit();
; 1602 : #endif
; 1603 : 		}
; 1604 : 		else

	jmp	SHORT $LN60@Init
$LN61@Init:

; 1605 : 			st.renderer.VBO_ON=1;

	mov	BYTE PTR _st+2336452, 1
$LN60@Init:

; 1606 : #endif
; 1607 : 
; 1608 : #ifdef _VA_RENDER
; 1609 : 		if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_EXT_vertex_array")==NULL)

	push	OFFSET ??_C@_0BE@PFGKPDCP@GL_EXT_vertex_array?$AA@
	mov	esi, esp
	push	7939					; 00001f03H
	call	DWORD PTR __imp__glGetString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN59@Init

; 1610 : 		{
; 1611 : 			LogApp("Your video card is not adequate to play this game... Goodbye!!");

	push	OFFSET ??_C@_0DP@GKIFJBKD@Your?5video?5card?5is?5not?5adequate?5@
	call	_SDL_Log
	add	esp, 4

; 1612 : 			Quit();

	call	_Quit
$LN59@Init:

; 1613 : 		}
; 1614 : #endif
; 1615 : 	}
; 1616 : 	else

	jmp	SHORT $LN58@Init
$LN63@Init:

; 1617 : 		st.renderer.VAO_ON=1;

	mov	BYTE PTR _st+2336440, 1
$LN58@Init:

; 1618 : #endif
; 1619 : 
; 1620 : #if !defined (_VAO_RENDER) && defined (_VBO_RENDER)
; 1621 : 	if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_ARB_vertex_buffer_object")==NULL)
; 1622 : 	{
; 1623 : #ifdef _VA_RENDER
; 1624 : 		st.renderer.VA_ON=1;
; 1625 : 		LogApp("VBOs not supported, check your video's card driver for updates... Using VA instead!!");
; 1626 : #else
; 1627 : 		LogApp("Your video card is not adequate to play this game... Goodbye!!");
; 1628 : 		Quit();
; 1629 : #endif
; 1630 : 
; 1631 : 	}
; 1632 : 	else
; 1633 : 		st.renderer.VBO_ON=1;
; 1634 : #endif
; 1635 : 
; 1636 : #if !defined (_VAO_RENDER) && !defined (_VBO_RENDER) && defined (_VA_RENDER)
; 1637 : 	if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_EXT_vertex_array")==NULL)
; 1638 : 	{
; 1639 : 		LogApp("Your video card is not adequate to play this game... Goodbye!!");
; 1640 : 		Quit();
; 1641 : 	}
; 1642 : 	else
; 1643 : 		st.renderer.VA_ON=1;
; 1644 : #endif
; 1645 : 
; 1646 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER)
; 1647 : 	if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_EXT_framebuffer")==NULL)

	push	OFFSET ??_C@_0BD@HLIFEONF@GL_EXT_framebuffer?$AA@
	mov	esi, esp
	push	7939					; 00001f03H
	call	DWORD PTR __imp__glGetString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN57@Init

; 1648 : 	{
; 1649 : #ifdef _VA_RENDER
; 1650 : 		st.renderer.VA_ON=1;

	mov	BYTE PTR _st+2336453, 1

; 1651 : 		LogApp("Framebuffer object not support, check your video's card driver for updates... Usign VA instead!");

	push	OFFSET ??_C@_0GA@BFFFOFBB@Framebuffer?5object?5not?5support?0?5@
	call	_SDL_Log
	add	esp, 4
$LN57@Init:

; 1652 : #else
; 1653 : 		LogApp("Your video card is not adequate to play this game... Goodbye!!");
; 1654 : 		Quit();
; 1655 : #endif
; 1656 : 	}
; 1657 : #endif
; 1658 : 
; 1659 : 	//Initialize OpenGL
; 1660 : 	glClearColor(0,0,0,0);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR __imp__glClearColor@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1661 : 	glMatrixMode(GL_MODELVIEW);

	mov	esi, esp
	push	5888					; 00001700H
	call	DWORD PTR __imp__glMatrixMode@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1662 : 	glLoadIdentity();

	mov	esi, esp
	call	DWORD PTR __imp__glLoadIdentity@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1663 : 	glViewport(0,0,st.screenx,st.screeny);

	movzx	eax, WORD PTR _st+230
	mov	esi, esp
	push	eax
	movzx	ecx, WORD PTR _st+228
	push	ecx
	push	0
	push	0
	call	DWORD PTR __imp__glViewport@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1664 : 	glEnable(GL_TEXTURE_2D);

	mov	esi, esp
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glEnable@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1665 : 	glDepthFunc(GL_LEQUAL);

	mov	esi, esp
	push	515					; 00000203H
	call	DWORD PTR __imp__glDepthFunc@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1666 : 	glEnable(GL_DEPTH_TEST);

	mov	esi, esp
	push	2929					; 00000b71H
	call	DWORD PTR __imp__glEnable@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1667 : 	glClearDepth(1.0);

	mov	esi, esp
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__glClearDepth@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1668 : 	glEnable(GL_BLEND);

	mov	esi, esp
	push	3042					; 00000be2H
	call	DWORD PTR __imp__glEnable@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1669 : 	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	mov	esi, esp
	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR __imp__glBlendFunc@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1670 : 
; 1671 : #ifndef MGEAR_MFC
; 1672 : 	SDL_GL_SetSwapInterval(st.vsync);

	movzx	eax, BYTE PTR _st+241
	push	eax
	call	_SDL_GL_SetSwapInterval
	add	esp, 4

; 1673 : #endif
; 1674 : 
; 1675 : 	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

	mov	esi, esp
	push	1
	push	3317					; 00000cf5H
	call	DWORD PTR __imp__glPixelStorei@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1676 : 	glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);

	mov	esi, esp
	push	0
	push	3314					; 00000cf2H
	call	DWORD PTR __imp__glPixelStorei@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1677 : 	glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);

	mov	esi, esp
	push	0
	push	3316					; 00000cf4H
	call	DWORD PTR __imp__glPixelStorei@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1678 : 	glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);

	mov	esi, esp
	push	0
	push	3315					; 00000cf3H
	call	DWORD PTR __imp__glPixelStorei@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1679 : 
; 1680 : 	//glHint(GL_GENERATE_MIPMAP_HINT,GL_FASTEST);
; 1681 : 
; 1682 : 	if(st.renderer.VAO_ON)

	movzx	eax, BYTE PTR _st+2336440
	test	eax, eax
	je	SHORT $LN56@Init

; 1683 : 		st.renderer.shader_version=130;

	mov	eax, 130				; 00000082H
	mov	WORD PTR _st+2336872, ax

; 1684 : 	else

	jmp	SHORT $LN53@Init
$LN56@Init:

; 1685 : 	if(st.renderer.VBO_ON)

	movzx	eax, BYTE PTR _st+2336452
	test	eax, eax
	je	SHORT $LN54@Init

; 1686 : 		st.renderer.shader_version=110;

	mov	eax, 110				; 0000006eH
	mov	WORD PTR _st+2336872, ax

; 1687 : 	else

	jmp	SHORT $LN53@Init
$LN54@Init:

; 1688 : 		st.renderer.shader_version=0;

	xor	eax, eax
	mov	WORD PTR _st+2336872, ax
$LN53@Init:

; 1689 : 
; 1690 : 	//Initialize with 32 slots
; 1691 : 	//Reallocation is done if necessary
; 1692 : 	//z_slots keeps track of the current number of slots available
; 1693 : 
; 1694 : 	//z_buffer=(int16**) calloc((3*8)*32,sizeof(int16));
; 1695 : 	//z_slots=32;
; 1696 : 
; 1697 : 	memset(z_buffer,0,((7*8)*2048)*sizeof(int16));

	push	229376					; 00038000H
	push	0
	push	OFFSET _z_buffer
	call	_memset
	add	esp, 12					; 0000000cH

; 1698 : 	memset(z_slot,0,(7*8)*sizeof(int16));

	push	112					; 00000070H
	push	0
	push	OFFSET _z_slot
	call	_memset
	add	esp, 12					; 0000000cH

; 1699 : 
; 1700 : 	z_used=0;

	mov	BYTE PTR _z_used, 0

; 1701 : 
; 1702 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER)
; 1703 : 	if(st.renderer.VAO_ON || st.renderer.VBO_ON)

	movzx	eax, BYTE PTR _st+2336440
	test	eax, eax
	jne	SHORT $LN51@Init
	movzx	eax, BYTE PTR _st+2336452
	test	eax, eax
	je	$LN13@Init
$LN51@Init:

; 1704 : 	{
; 1705 : 		glGenFramebuffers(1,&st.renderer.FBO[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	add	ecx, OFFSET _st+2336776
	mov	esi, esp
	push	ecx
	push	1
	call	DWORD PTR _GLeeFuncPtr_glGenFramebuffers
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1706 : 		glBindFramebuffer(GL_FRAMEBUFFER,st.renderer.FBO[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336776]
	push	edx
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glBindFramebuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1707 : 
; 1708 : 		glGenRenderbuffers(1,&st.renderer.RBO[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	add	ecx, OFFSET _st+2336824
	mov	esi, esp
	push	ecx
	push	1
	call	DWORD PTR _GLeeFuncPtr_glGenRenderbuffers
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1709 : 		glBindRenderbuffer(GL_RENDERBUFFER,st.renderer.RBO[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336824]
	push	edx
	push	36161					; 00008d41H
	call	DWORD PTR _GLeeFuncPtr_glBindRenderbuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1710 : 		glRenderbufferStorage(GL_RENDERBUFFER,GL_DEPTH_COMPONENT,st.screenx,st.screeny);

	movzx	eax, WORD PTR _st+230
	mov	esi, esp
	push	eax
	movzx	ecx, WORD PTR _st+228
	push	ecx
	push	6402					; 00001902H
	push	36161					; 00008d41H
	call	DWORD PTR _GLeeFuncPtr_glRenderbufferStorage
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1711 : 
; 1712 : 		glBindRenderbuffer(GL_RENDERBUFFER,0);

	mov	esi, esp
	push	0
	push	36161					; 00008d41H
	call	DWORD PTR _GLeeFuncPtr_glBindRenderbuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1713 : 
; 1714 : 		glGenTextures(1,&st.renderer.FBTex[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	add	ecx, OFFSET _st+2336792
	mov	esi, esp
	push	ecx
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1715 : 		glBindTexture(GL_TEXTURE_2D,st.renderer.FBTex[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336792]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1716 : 		glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,st.screenx,st.screeny,0,GL_BGRA,GL_UNSIGNED_BYTE,NULL);

	mov	esi, esp
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	ecx, WORD PTR _st+228
	push	ecx
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1717 : 
; 1718 : 		glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D,st.renderer.FBTex[0],0);

	mov	esi, esp
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _st[ecx+2336792]
	push	edx
	push	3553					; 00000de1H
	push	36064					; 00008ce0H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1719 : 
; 1720 : 		glFramebufferRenderbuffer(GL_FRAMEBUFFER,GL_DEPTH_ATTACHMENT,GL_RENDERBUFFER,st.renderer.RBO[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336824]
	push	edx
	push	36161					; 00008d41H
	push	36096					; 00008d00H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferRenderbuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1721 : 
; 1722 : 		glGenTextures(1,&st.renderer.FBTex[1]);

	mov	eax, 4
	shl	eax, 0
	add	eax, OFFSET _st+2336792
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1723 : 		glBindTexture(GL_TEXTURE_2D,st.renderer.FBTex[1]);

	mov	eax, 4
	shl	eax, 0
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336792]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1724 : 		glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,st.screenx,st.screeny,0,GL_BGRA,GL_UNSIGNED_BYTE,NULL);

	mov	esi, esp
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	ecx, WORD PTR _st+228
	push	ecx
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1725 : 
; 1726 : 		glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT1,GL_TEXTURE_2D,st.renderer.FBTex[1],0);

	mov	esi, esp
	push	0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _st[eax+2336792]
	push	ecx
	push	3553					; 00000de1H
	push	36065					; 00008ce1H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1727 : 
; 1728 : 		glGenTextures(1,&st.renderer.FBTex[2]);

	mov	eax, 4
	shl	eax, 1
	add	eax, OFFSET _st+2336792
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1729 : 		glBindTexture(GL_TEXTURE_2D,st.renderer.FBTex[2]);

	mov	eax, 4
	shl	eax, 1
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336792]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1730 : 		glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,st.screenx,st.screeny,0,GL_BGRA,GL_UNSIGNED_BYTE,NULL);

	mov	esi, esp
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	ecx, WORD PTR _st+228
	push	ecx
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1731 : 
; 1732 : 		glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT2,GL_TEXTURE_2D,st.renderer.FBTex[2],0);

	mov	esi, esp
	push	0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _st[eax+2336792]
	push	ecx
	push	3553					; 00000de1H
	push	36066					; 00008ce2H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1733 : 
; 1734 : 		glGenTextures(1,&st.renderer.FBTex[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	add	ecx, OFFSET _st+2336792
	mov	esi, esp
	push	ecx
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1735 : 		glBindTexture(GL_TEXTURE_2D,st.renderer.FBTex[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336792]
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1736 : 		glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,st.screenx,st.screeny,0,GL_BGRA,GL_UNSIGNED_BYTE,NULL);

	mov	esi, esp
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	ecx, WORD PTR _st+228
	push	ecx
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1737 : 
; 1738 : 		glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT3,GL_TEXTURE_2D,st.renderer.FBTex[3],0);

	mov	esi, esp
	push	0
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336792]
	push	edx
	push	3553					; 00000de1H
	push	36067					; 00008ce3H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1739 : 
; 1740 : 		glBindFramebuffer(GL_FRAMEBUFFER,0);

	mov	esi, esp
	push	0
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glBindFramebuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1741 : 		
; 1742 : 		st.renderer.Buffers[0]=GL_COLOR_ATTACHMENT0;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	DWORD PTR _st[ecx+2336856], 36064	; 00008ce0H

; 1743 : 		st.renderer.Buffers[1]=GL_COLOR_ATTACHMENT1;

	mov	eax, 4
	shl	eax, 0
	mov	DWORD PTR _st[eax+2336856], 36065	; 00008ce1H

; 1744 : 		st.renderer.Buffers[2]=GL_COLOR_ATTACHMENT2;

	mov	eax, 4
	shl	eax, 1
	mov	DWORD PTR _st[eax+2336856], 36066	; 00008ce2H

; 1745 : 		st.renderer.Buffers[3]=GL_COLOR_ATTACHMENT3;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	DWORD PTR _st[ecx+2336856], 36067	; 00008ce3H
$SHADER_CREATION$79:

; 1746 : 
; 1747 : SHADER_CREATION:
; 1748 : 
; 1749 : 		st.renderer.VShader[0]=glCreateShader(GL_VERTEX_SHADER);

	mov	esi, esp
	push	35633					; 00008b31H
	call	DWORD PTR _GLeeFuncPtr_glCreateShader
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	DWORD PTR _st[edx+2336456], eax

; 1750 : 		//st.renderer.FShader[0]=glCreateShader(GL_FRAGMENT_SHADER);
; 1751 : 		//st.renderer.FShader[1]=glCreateShader(GL_FRAGMENT_SHADER);
; 1752 : 		st.renderer.FShader[2]=glCreateShader(GL_FRAGMENT_SHADER);

	mov	esi, esp
	push	35632					; 00008b30H
	call	DWORD PTR _GLeeFuncPtr_glCreateShader
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 1
	mov	DWORD PTR _st[ecx+2336520], eax

; 1753 : 		st.renderer.FShader[3]=glCreateShader(GL_FRAGMENT_SHADER);

	mov	esi, esp
	push	35632					; 00008b30H
	call	DWORD PTR _GLeeFuncPtr_glCreateShader
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	DWORD PTR _st[edx+2336520], eax

; 1754 : 		st.renderer.FShader[4]=glCreateShader(GL_FRAGMENT_SHADER);

	mov	esi, esp
	push	35632					; 00008b30H
	call	DWORD PTR _GLeeFuncPtr_glCreateShader
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 2
	mov	DWORD PTR _st[ecx+2336520], eax

; 1755 : 		st.renderer.FShader[5]=glCreateShader(GL_FRAGMENT_SHADER);

	mov	esi, esp
	push	35632					; 00008b30H
	call	DWORD PTR _GLeeFuncPtr_glCreateShader
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 5
	mov	DWORD PTR _st[edx+2336520], eax

; 1756 : 		st.renderer.FShader[6]=glCreateShader(GL_FRAGMENT_SHADER);

	mov	esi, esp
	push	35632					; 00008b30H
	call	DWORD PTR _GLeeFuncPtr_glCreateShader
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	DWORD PTR _st[edx+2336520], eax

; 1757 : 
; 1758 : #ifdef _VAO_RENDER
; 1759 : 
; 1760 : 		if(st.renderer.shader_version==130)

	movzx	eax, WORD PTR _st+2336872
	cmp	eax, 130				; 00000082H
	jne	$LN50@Init

; 1761 : 		{
; 1762 : 			glShaderSource(st.renderer.VShader[0],1,(const GLchar**) Texture_VShader,0);

	mov	esi, esp
	push	0
	push	OFFSET _Texture_VShader
	push	1
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glShaderSource
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1763 : 			//glShaderSource(st.renderer.FShader[0],1,(const GLchar**) Lighting_FShader,0);
; 1764 : 			//glShaderSource(st.renderer.FShader[1],1,(const GLchar**) Normal_FShader,0);
; 1765 : 			glShaderSource(st.renderer.FShader[2],1,(const GLchar**) Texture_FShader,0);

	mov	esi, esp
	push	0
	push	OFFSET _Texture_FShader
	push	1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _st[eax+2336520]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glShaderSource
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1766 : 			glShaderSource(st.renderer.FShader[3],1,(const GLchar**) Lightmap_FShader,0);

	mov	esi, esp
	push	0
	push	OFFSET _Lightmap_FShader
	push	1
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glShaderSource
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1767 : 			glShaderSource(st.renderer.FShader[4],1,(const GLchar**) TextureNoT_FShader,0);

	mov	esi, esp
	push	0
	push	OFFSET _TextureNoT_FShader
	push	1
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _st[eax+2336520]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glShaderSource
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1768 : 			glShaderSource(st.renderer.FShader[5],1,(const GLchar**) TextureT_FShader,0);

	mov	esi, esp
	push	0
	push	OFFSET _TextureT_FShader
	push	1
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glShaderSource
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1769 : 			glShaderSource(st.renderer.FShader[6],1,(const GLchar**) Blend_FShader,0);

	mov	esi, esp
	push	0
	push	OFFSET _Blend_FShader
	push	1
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glShaderSource
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN50@Init:

; 1770 : 		}
; 1771 : #endif
; 1772 : 		//else
; 1773 : #ifdef _VBO_RENDER
; 1774 : 		if(st.renderer.shader_version==110)

	movzx	eax, WORD PTR _st+2336872
	cmp	eax, 110				; 0000006eH
	jne	$LN49@Init

; 1775 : 		{
; 1776 : 			
; 1777 : 			glShaderSource(st.renderer.VShader[0],1,(const GLchar**) Texture_VShader110,0);

	mov	esi, esp
	push	0
	push	OFFSET _Texture_VShader110
	push	1
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glShaderSource
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1778 : 			glShaderSource(st.renderer.FShader[2],1,(const GLchar**) Texture_FShader110,0);

	mov	esi, esp
	push	0
	push	OFFSET _Texture_FShader110
	push	1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _st[eax+2336520]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glShaderSource
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1779 : 			glShaderSource(st.renderer.FShader[3],1,(const GLchar**) Lightmap_FShader110,0);

	mov	esi, esp
	push	0
	push	OFFSET _Lightmap_FShader110
	push	1
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glShaderSource
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1780 : 			glShaderSource(st.renderer.FShader[4],1,(const GLchar**) TextureNoT_FShader110,0);

	mov	esi, esp
	push	0
	push	OFFSET _TextureNoT_FShader110
	push	1
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _st[eax+2336520]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glShaderSource
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1781 : 			glShaderSource(st.renderer.FShader[5],1,(const GLchar**) TextureT_FShader110,0);

	mov	esi, esp
	push	0
	push	OFFSET _TextureT_FShader110
	push	1
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glShaderSource
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1782 : 			glShaderSource(st.renderer.FShader[6],1,(const GLchar**) Blend_FShader110,0);

	mov	esi, esp
	push	0
	push	OFFSET _Blend_FShader110
	push	1
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glShaderSource
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN49@Init:

; 1783 : 		}
; 1784 : #endif
; 1785 : 
; 1786 : 		glCompileShader(st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glCompileShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1787 : 		//glCompileShader(st.renderer.FShader[0]);
; 1788 : 		//glCompileShader(st.renderer.FShader[1]);
; 1789 : 		glCompileShader(st.renderer.FShader[2]);

	mov	eax, 4
	shl	eax, 1
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336520]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glCompileShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1790 : 		glCompileShader(st.renderer.FShader[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glCompileShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1791 : 		glCompileShader(st.renderer.FShader[4]);

	mov	eax, 4
	shl	eax, 2
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336520]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glCompileShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1792 : 		glCompileShader(st.renderer.FShader[5]);

	mov	eax, 4
	imul	ecx, eax, 5
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glCompileShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1793 : 		glCompileShader(st.renderer.FShader[6]);

	mov	eax, 4
	imul	ecx, eax, 6
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glCompileShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1794 : 
; 1795 : 		glGetShaderiv(st.renderer.VShader[0],GL_COMPILE_STATUS,&statusCM[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _statusCM$[ebp+ecx]
	mov	esi, esp
	push	edx
	push	35713					; 00008b81H
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetShaderiv
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1796 : 		//glGetShaderiv(st.renderer.FShader[0],GL_COMPILE_STATUS,&statusCM[1]);
; 1797 : 		//glGetShaderiv(st.renderer.FShader[1],GL_COMPILE_STATUS,&statusCM[2]);
; 1798 : 		glGetShaderiv(st.renderer.FShader[2],GL_COMPILE_STATUS,&statusCM[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _statusCM$[ebp+ecx]
	mov	esi, esp
	push	edx
	push	35713					; 00008b81H
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _st[eax+2336520]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetShaderiv
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1799 : 		glGetShaderiv(st.renderer.FShader[3],GL_COMPILE_STATUS,&statusCM[4]);

	mov	eax, 4
	shl	eax, 2
	lea	ecx, DWORD PTR _statusCM$[ebp+eax]
	mov	esi, esp
	push	ecx
	push	35713					; 00008b81H
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _st[eax+2336520]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetShaderiv
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1800 : 		glGetShaderiv(st.renderer.FShader[4],GL_COMPILE_STATUS,&statusCM[5]);

	mov	eax, 4
	imul	ecx, eax, 5
	lea	edx, DWORD PTR _statusCM$[ebp+ecx]
	mov	esi, esp
	push	edx
	push	35713					; 00008b81H
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _st[eax+2336520]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetShaderiv
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1801 : 		glGetShaderiv(st.renderer.FShader[5],GL_COMPILE_STATUS,&statusCM[6]);

	mov	eax, 4
	imul	ecx, eax, 6
	lea	edx, DWORD PTR _statusCM$[ebp+ecx]
	mov	esi, esp
	push	edx
	push	35713					; 00008b81H
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetShaderiv
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1802 : 		glGetShaderiv(st.renderer.FShader[6],GL_COMPILE_STATUS,&statusCM[7]);

	mov	eax, 4
	imul	ecx, eax, 7
	lea	edx, DWORD PTR _statusCM$[ebp+ecx]
	mov	esi, esp
	push	edx
	push	35713					; 00008b81H
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetShaderiv
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1803 : 
; 1804 : 		if(!statusCM[0] || !statusCM[3] || !statusCM[4] || !statusCM[5] || !statusCM[6] || !statusCM[7])

	mov	eax, 4
	imul	ecx, eax, 0
	cmp	DWORD PTR _statusCM$[ebp+ecx], 0
	je	SHORT $LN47@Init
	mov	eax, 4
	imul	ecx, eax, 3
	cmp	DWORD PTR _statusCM$[ebp+ecx], 0
	je	SHORT $LN47@Init
	mov	eax, 4
	shl	eax, 2
	cmp	DWORD PTR _statusCM$[ebp+eax], 0
	je	SHORT $LN47@Init
	mov	eax, 4
	imul	ecx, eax, 5
	cmp	DWORD PTR _statusCM$[ebp+ecx], 0
	je	SHORT $LN47@Init
	mov	eax, 4
	imul	ecx, eax, 6
	cmp	DWORD PTR _statusCM$[ebp+ecx], 0
	je	SHORT $LN47@Init
	mov	eax, 4
	imul	ecx, eax, 7
	cmp	DWORD PTR _statusCM$[ebp+ecx], 0
	jne	$LN48@Init
$LN47@Init:

; 1805 : 		{
; 1806 : 			
; 1807 : 			for(i=0;i<8;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN46@Init
$LN45@Init:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN46@Init:
	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN44@Init

; 1808 : 			{
; 1809 : 				if(i==1 || i==2) continue;

	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, 1
	je	SHORT $LN42@Init
	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, 2
	jne	SHORT $LN43@Init
$LN42@Init:
	jmp	SHORT $LN45@Init
$LN43@Init:

; 1810 : 
; 1811 : 				if(!statusCM[i])

	movzx	eax, WORD PTR _i$[ebp]
	cmp	DWORD PTR _statusCM$[ebp+eax*4], 0
	jne	$LN41@Init

; 1812 : 				{
; 1813 : 					if(i==1)

	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, 1
	jne	SHORT $LN40@Init

; 1814 : 						glGetShaderInfoLog(st.renderer.FShader[0],1024,NULL,logs[0]);

	mov	eax, 1024				; 00000400H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _logs$[ebp+ecx]
	mov	esi, esp
	push	edx
	push	0
	push	1024					; 00000400H
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetShaderInfoLog
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1815 : 					else

	jmp	SHORT $LN37@Init
$LN40@Init:

; 1816 : 					if(i==0)

	movzx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	jne	SHORT $LN38@Init

; 1817 : 						glGetShaderInfoLog(st.renderer.VShader[0],1024,NULL,logs[0]);

	mov	eax, 1024				; 00000400H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _logs$[ebp+ecx]
	mov	esi, esp
	push	edx
	push	0
	push	1024					; 00000400H
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetShaderInfoLog
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1818 : 					else

	jmp	SHORT $LN37@Init
$LN38@Init:

; 1819 : 						glGetShaderInfoLog(st.renderer.FShader[i-1],1024,NULL,logs[0]);

	mov	eax, 1024				; 00000400H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _logs$[ebp+ecx]
	mov	esi, esp
	push	edx
	push	0
	push	1024					; 00000400H
	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _st[eax*4+2336516]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetShaderInfoLog
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN37@Init:

; 1820 : 
; 1821 : 					LogApp("Shader %d: %s",i ,logs[0]);

	mov	eax, 1024				; 00000400H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _logs$[ebp+ecx]
	push	edx
	movzx	eax, WORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0O@BNBOBIPB@Shader?5?$CFd?3?5?$CFs?$AA@
	call	_SDL_Log
	add	esp, 12					; 0000000cH

; 1822 : 					LogApp("Counld not compile shader");

	push	OFFSET ??_C@_0BK@JJHKDBGE@Counld?5not?5compile?5shader?$AA@
	call	_SDL_Log
	add	esp, 4
$LN41@Init:

; 1823 : 				}
; 1824 : 			}

	jmp	$LN45@Init
$LN44@Init:

; 1825 : 
; 1826 : #ifdef _VBO_RENDER
; 1827 : 			if(st.renderer.shader_version==130)

	movzx	eax, WORD PTR _st+2336872
	cmp	eax, 130				; 00000082H
	jne	$LN36@Init

; 1828 : 			{
; 1829 : 				LogApp("Changing to VBO...");

	push	OFFSET ??_C@_0BD@CHEFDAHK@Changing?5to?5VBO?4?4?4?$AA@
	call	_SDL_Log
	add	esp, 4

; 1830 : 
; 1831 : 				if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_ARB_vertex_buffer_object")==NULL)

	push	OFFSET ??_C@_0BM@OOMEFFAE@GL_ARB_vertex_buffer_object?$AA@
	mov	esi, esp
	push	7939					; 00001f03H
	call	DWORD PTR __imp__glGetString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN35@Init

; 1832 : 				{
; 1833 : #ifdef _VA_RENDER
; 1834 : 					st.renderer.VA_ON=1;

	mov	BYTE PTR _st+2336453, 1

; 1835 : 					LogApp("VBOs not supported, check your video's card driver for updates... Using VA instead!!");

	push	OFFSET ??_C@_0FF@HDHKLDIO@VBOs?5not?5supported?0?5check?5your?5v@
	call	_SDL_Log
	add	esp, 4

; 1836 : #else
; 1837 : 					LogApp("Your video card is not adequate to play this game... Goodbye!!");
; 1838 : 					Quit();
; 1839 : #endif
; 1840 : 				}
; 1841 : 				else

	jmp	$LN34@Init
$LN35@Init:

; 1842 : 				{
; 1843 : 					st.renderer.VBO_ON=1;

	mov	BYTE PTR _st+2336452, 1

; 1844 : 					st.renderer.shader_version=110;

	mov	eax, 110				; 0000006eH
	mov	WORD PTR _st+2336872, ax

; 1845 : 
; 1846 : 					glDeleteShader(st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1847 : 					glDeleteShader(st.renderer.VShader[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1848 : 					glDeleteShader(st.renderer.VShader[4]);

	mov	eax, 4
	shl	eax, 2
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336456]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1849 : 					glDeleteShader(st.renderer.VShader[5]);

	mov	eax, 4
	imul	ecx, eax, 5
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1850 : 					glDeleteShader(st.renderer.VShader[6]);

	mov	eax, 4
	imul	ecx, eax, 6
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1851 : 					glDeleteShader(st.renderer.VShader[7]);

	mov	eax, 4
	imul	ecx, eax, 7
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1852 : 
; 1853 : 					goto SHADER_CREATION;

	jmp	$SHADER_CREATION$79
$LN34@Init:

; 1854 : 				}
; 1855 : 			}
; 1856 : 			else

	jmp	$LN30@Init
$LN36@Init:

; 1857 : 			if(st.renderer.shader_version==110)

	movzx	eax, WORD PTR _st+2336872
	cmp	eax, 110				; 0000006eH
	jne	$LN30@Init

; 1858 : 			{
; 1859 : 
; 1860 : #ifdef _VA_RENDER
; 1861 : 
; 1862 : 				LogApp("Changing to VA...");

	push	OFFSET ??_C@_0BC@FPJNDHAI@Changing?5to?5VA?4?4?4?$AA@
	call	_SDL_Log
	add	esp, 4

; 1863 : 
; 1864 : 				if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_EXT_vertex_array")==NULL)

	push	OFFSET ??_C@_0BE@PFGKPDCP@GL_EXT_vertex_array?$AA@
	mov	esi, esp
	push	7939					; 00001f03H
	call	DWORD PTR __imp__glGetString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN31@Init

; 1865 : 				{
; 1866 : 					LogApp("Your video card is not adequate to play this game... Goodbye!!");

	push	OFFSET ??_C@_0DP@GKIFJBKD@Your?5video?5card?5is?5not?5adequate?5@
	call	_SDL_Log
	add	esp, 4

; 1867 : 					Quit();

	call	_Quit

; 1868 : 				}
; 1869 : 				else

	jmp	$LN30@Init
$LN31@Init:

; 1870 : 				{
; 1871 : 					st.renderer.VA_ON=1;

	mov	BYTE PTR _st+2336453, 1

; 1872 : 
; 1873 : 					glDeleteShader(st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1874 : 					glDeleteShader(st.renderer.VShader[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1875 : 					glDeleteShader(st.renderer.VShader[4]);

	mov	eax, 4
	shl	eax, 2
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336456]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1876 : 					glDeleteShader(st.renderer.VShader[5]);

	mov	eax, 4
	imul	ecx, eax, 5
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1877 : 					glDeleteShader(st.renderer.VShader[6]);

	mov	eax, 4
	imul	ecx, eax, 6
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1878 : 					glDeleteShader(st.renderer.VShader[7]);

	mov	eax, 4
	imul	ecx, eax, 7
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN30@Init:

; 1879 : 				}
; 1880 : 			}
; 1881 : #endif
; 1882 : 
; 1883 : #endif
; 1884 : 		}
; 1885 : 		else

	jmp	$LN13@Init
$LN48@Init:

; 1886 : 		if(statusCM[0] && statusCM[3] && statusCM[4] && statusCM[5] && statusCM[6] && statusCM[7])

	mov	eax, 4
	imul	ecx, eax, 0
	cmp	DWORD PTR _statusCM$[ebp+ecx], 0
	je	$LN13@Init
	mov	eax, 4
	imul	ecx, eax, 3
	cmp	DWORD PTR _statusCM$[ebp+ecx], 0
	je	$LN13@Init
	mov	eax, 4
	shl	eax, 2
	cmp	DWORD PTR _statusCM$[ebp+eax], 0
	je	$LN13@Init
	mov	eax, 4
	imul	ecx, eax, 5
	cmp	DWORD PTR _statusCM$[ebp+ecx], 0
	je	$LN13@Init
	mov	eax, 4
	imul	ecx, eax, 6
	cmp	DWORD PTR _statusCM$[ebp+ecx], 0
	je	$LN13@Init
	mov	eax, 4
	imul	ecx, eax, 7
	cmp	DWORD PTR _statusCM$[ebp+ecx], 0
	je	$LN13@Init

; 1887 : 		{
; 1888 : 			//st.renderer.Program[0]=glCreateProgram();
; 1889 : 			//st.renderer.Program[1]=glCreateProgram();
; 1890 : 			st.renderer.Program[2]=glCreateProgram();

	mov	esi, esp
	call	DWORD PTR _GLeeFuncPtr_glCreateProgram
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 1
	mov	DWORD PTR _st[ecx+2336648], eax

; 1891 : 			st.renderer.Program[3]=glCreateProgram();

	mov	esi, esp
	call	DWORD PTR _GLeeFuncPtr_glCreateProgram
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	DWORD PTR _st[edx+2336648], eax

; 1892 : 			st.renderer.Program[4]=glCreateProgram();

	mov	esi, esp
	call	DWORD PTR _GLeeFuncPtr_glCreateProgram
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 2
	mov	DWORD PTR _st[ecx+2336648], eax

; 1893 : 			st.renderer.Program[5]=glCreateProgram();

	mov	esi, esp
	call	DWORD PTR _GLeeFuncPtr_glCreateProgram
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 5
	mov	DWORD PTR _st[edx+2336648], eax

; 1894 : 			st.renderer.Program[6]=glCreateProgram();

	mov	esi, esp
	call	DWORD PTR _GLeeFuncPtr_glCreateProgram
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	DWORD PTR _st[edx+2336648], eax

; 1895 : 
; 1896 : 			//glAttachShader(st.renderer.Program[0],st.renderer.VShader[0]);
; 1897 : 			//glAttachShader(st.renderer.Program[0],st.renderer.FShader[0]);
; 1898 : 			
; 1899 : 			//glAttachShader(st.renderer.Program[1],st.renderer.VShader[0]);
; 1900 : 			//glAttachShader(st.renderer.Program[1],st.renderer.FShader[1]);
; 1901 : 
; 1902 : 			glAttachShader(st.renderer.Program[2],st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glAttachShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1903 : 			glAttachShader(st.renderer.Program[2],st.renderer.FShader[2]);

	mov	eax, 4
	shl	eax, 1
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336520]
	push	ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _st[edx+2336648]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glAttachShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1904 : 			
; 1905 : 			glAttachShader(st.renderer.Program[3],st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glAttachShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1906 : 			glAttachShader(st.renderer.Program[3],st.renderer.FShader[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glAttachShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1907 : 
; 1908 : 			glAttachShader(st.renderer.Program[4],st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glAttachShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1909 : 			glAttachShader(st.renderer.Program[4],st.renderer.FShader[4]);

	mov	eax, 4
	shl	eax, 2
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336520]
	push	ecx
	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _st[edx+2336648]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glAttachShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1910 : 
; 1911 : 			glAttachShader(st.renderer.Program[5],st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glAttachShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1912 : 			glAttachShader(st.renderer.Program[5],st.renderer.FShader[5]);

	mov	eax, 4
	imul	ecx, eax, 5
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glAttachShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1913 : 
; 1914 : 			glAttachShader(st.renderer.Program[6],st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glAttachShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1915 : 			glAttachShader(st.renderer.Program[6],st.renderer.FShader[6]);

	mov	eax, 4
	imul	ecx, eax, 6
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glAttachShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1916 : 
; 1917 : 			//glLinkProgram(st.renderer.Program[0]);
; 1918 : 			//glLinkProgram(st.renderer.Program[1]);
; 1919 : 			glLinkProgram(st.renderer.Program[2]);

	mov	eax, 4
	shl	eax, 1
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glLinkProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1920 : 			glLinkProgram(st.renderer.Program[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glLinkProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1921 : 			glLinkProgram(st.renderer.Program[4]);

	mov	eax, 4
	shl	eax, 2
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glLinkProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1922 : 			glLinkProgram(st.renderer.Program[5]);

	mov	eax, 4
	imul	ecx, eax, 5
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glLinkProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1923 : 			glLinkProgram(st.renderer.Program[6]);

	mov	eax, 4
	imul	ecx, eax, 6
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glLinkProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1924 : 
; 1925 : 			//glGetProgramiv(st.renderer.Program[0],GL_LINK_STATUS,&statusLK[0]);
; 1926 : 			//glGetProgramiv(st.renderer.Program[1],GL_LINK_STATUS,&statusLK[1]);
; 1927 : 			glGetProgramiv(st.renderer.Program[2],GL_LINK_STATUS,&statusLK[2]);

	mov	eax, 4
	shl	eax, 1
	lea	ecx, DWORD PTR _statusLK$[ebp+eax]
	mov	esi, esp
	push	ecx
	push	35714					; 00008b82H
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _st[edx+2336648]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glGetProgramiv
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1928 : 			glGetProgramiv(st.renderer.Program[3],GL_LINK_STATUS,&statusLK[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _statusLK$[ebp+ecx]
	mov	esi, esp
	push	edx
	push	35714					; 00008b82H
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetProgramiv
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1929 : 			glGetProgramiv(st.renderer.Program[4],GL_LINK_STATUS,&statusLK[4]);

	mov	eax, 4
	shl	eax, 2
	lea	ecx, DWORD PTR _statusLK$[ebp+eax]
	mov	esi, esp
	push	ecx
	push	35714					; 00008b82H
	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _st[edx+2336648]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glGetProgramiv
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1930 : 			glGetProgramiv(st.renderer.Program[5],GL_LINK_STATUS,&statusLK[5]);

	mov	eax, 4
	imul	ecx, eax, 5
	lea	edx, DWORD PTR _statusLK$[ebp+ecx]
	mov	esi, esp
	push	edx
	push	35714					; 00008b82H
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetProgramiv
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1931 : 			glGetProgramiv(st.renderer.Program[6],GL_LINK_STATUS,&statusLK[6]);

	mov	eax, 4
	imul	ecx, eax, 6
	lea	edx, DWORD PTR _statusLK$[ebp+ecx]
	mov	esi, esp
	push	edx
	push	35714					; 00008b82H
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetProgramiv
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1932 : 			/*
; 1933 : 			if(!statusLK[0])
; 1934 : 			{
; 1935 : 				glDeleteProgram(st.renderer.Program[0]);
; 1936 : 				glDeleteShader(st.renderer.VShader[0]);
; 1937 : 				glDeleteShader(st.renderer.FShader[0]);
; 1938 : 			}
; 1939 : 			else
; 1940 : 			{
; 1941 : 				glDetachShader(st.renderer.Program[0],st.renderer.VShader[0]);
; 1942 : 				glDetachShader(st.renderer.Program[0],st.renderer.FShader[0]);
; 1943 : 			}
; 1944 : 			
; 1945 : 			if(!statusLK[1])
; 1946 : 			{
; 1947 : 				glDeleteProgram(st.renderer.Program[1]);
; 1948 : 				glDeleteShader(st.renderer.VShader[0]);
; 1949 : 				glDeleteShader(st.renderer.FShader[1]);
; 1950 : 			}
; 1951 : 			else
; 1952 : 			{
; 1953 : 				glDetachShader(st.renderer.Program[1],st.renderer.VShader[0]);
; 1954 : 				glDetachShader(st.renderer.Program[1],st.renderer.FShader[1]);
; 1955 : 			}
; 1956 : 			*/
; 1957 : 			if(!statusLK[2])

	mov	eax, 4
	shl	eax, 1
	cmp	DWORD PTR _statusLK$[ebp+eax], 0
	jne	SHORT $LN27@Init

; 1958 : 			{
; 1959 : 				glDeleteProgram(st.renderer.Program[2]);

	mov	eax, 4
	shl	eax, 1
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glDeleteProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1960 : 				glDeleteShader(st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1961 : 				glDeleteShader(st.renderer.FShader[2]);

	mov	eax, 4
	shl	eax, 1
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336520]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1962 : 			}
; 1963 : 			else

	jmp	SHORT $LN26@Init
$LN27@Init:

; 1964 : 			{
; 1965 : 				glDetachShader(st.renderer.Program[2],st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glDetachShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1966 : 				glDetachShader(st.renderer.Program[2],st.renderer.FShader[2]);

	mov	eax, 4
	shl	eax, 1
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336520]
	push	ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _st[edx+2336648]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDetachShader
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN26@Init:

; 1967 : 			}
; 1968 : 			
; 1969 : 			if(!statusLK[3])

	mov	eax, 4
	imul	ecx, eax, 3
	cmp	DWORD PTR _statusLK$[ebp+ecx], 0
	jne	$LN25@Init

; 1970 : 			{
; 1971 : 				glGetProgramInfoLog(st.renderer.Program[3],1024,NULL,logs[0]);

	mov	eax, 1024				; 00000400H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _logs$[ebp+ecx]
	mov	esi, esp
	push	edx
	push	0
	push	1024					; 00000400H
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetProgramInfoLog
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1972 : 				glDeleteProgram(st.renderer.Program[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1973 : 				glDeleteShader(st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1974 : 				glDeleteShader(st.renderer.FShader[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1975 : 			}
; 1976 : 			else

	jmp	SHORT $LN24@Init
$LN25@Init:

; 1977 : 			{
; 1978 : 				glDetachShader(st.renderer.Program[3],st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDetachShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1979 : 				glDetachShader(st.renderer.Program[3],st.renderer.FShader[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDetachShader
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN24@Init:

; 1980 : 			}
; 1981 : 
; 1982 : 			if(!statusLK[4])

	mov	eax, 4
	shl	eax, 2
	cmp	DWORD PTR _statusLK$[ebp+eax], 0
	jne	$LN23@Init

; 1983 : 			{
; 1984 : 				glGetProgramInfoLog(st.renderer.Program[4],1024,NULL,logs[0]);

	mov	eax, 1024				; 00000400H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _logs$[ebp+ecx]
	mov	esi, esp
	push	edx
	push	0
	push	1024					; 00000400H
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetProgramInfoLog
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1985 : 				glDeleteProgram(st.renderer.Program[4]);

	mov	eax, 4
	shl	eax, 2
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glDeleteProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1986 : 				glDeleteShader(st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1987 : 				glDeleteShader(st.renderer.FShader[4]);

	mov	eax, 4
	shl	eax, 2
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336520]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1988 : 			}
; 1989 : 			else

	jmp	SHORT $LN22@Init
$LN23@Init:

; 1990 : 			{
; 1991 : 				glDetachShader(st.renderer.Program[4],st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glDetachShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1992 : 				glDetachShader(st.renderer.Program[4],st.renderer.FShader[4]);

	mov	eax, 4
	shl	eax, 2
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336520]
	push	ecx
	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _st[edx+2336648]
	push	eax
	call	DWORD PTR _GLeeFuncPtr_glDetachShader
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@Init:

; 1993 : 			}
; 1994 : 
; 1995 : 			if(!statusLK[5])

	mov	eax, 4
	imul	ecx, eax, 5
	cmp	DWORD PTR _statusLK$[ebp+ecx], 0
	jne	$LN21@Init

; 1996 : 			{
; 1997 : 				glGetProgramInfoLog(st.renderer.Program[5],1024,NULL,logs[0]);

	mov	eax, 1024				; 00000400H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _logs$[ebp+ecx]
	mov	esi, esp
	push	edx
	push	0
	push	1024					; 00000400H
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetProgramInfoLog
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1998 : 				glDeleteProgram(st.renderer.Program[5]);

	mov	eax, 4
	imul	ecx, eax, 5
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1999 : 				glDeleteShader(st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2000 : 				glDeleteShader(st.renderer.FShader[5]);

	mov	eax, 4
	imul	ecx, eax, 5
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2001 : 			}
; 2002 : 			else

	jmp	SHORT $LN20@Init
$LN21@Init:

; 2003 : 			{
; 2004 : 				glDetachShader(st.renderer.Program[5],st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDetachShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2005 : 				glDetachShader(st.renderer.Program[5],st.renderer.FShader[5]);

	mov	eax, 4
	imul	ecx, eax, 5
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDetachShader
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN20@Init:

; 2006 : 			}
; 2007 : 
; 2008 : 			if(!statusLK[6])

	mov	eax, 4
	imul	ecx, eax, 6
	cmp	DWORD PTR _statusLK$[ebp+ecx], 0
	jne	$LN19@Init

; 2009 : 			{
; 2010 : 				glGetProgramInfoLog(st.renderer.Program[6],1024,NULL,logs[0]);

	mov	eax, 1024				; 00000400H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _logs$[ebp+ecx]
	mov	esi, esp
	push	edx
	push	0
	push	1024					; 00000400H
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetProgramInfoLog
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2011 : 				glDeleteProgram(st.renderer.Program[6]);

	mov	eax, 4
	imul	ecx, eax, 6
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2012 : 				glDeleteShader(st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2013 : 				glDeleteShader(st.renderer.FShader[6]);

	mov	eax, 4
	imul	ecx, eax, 6
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2014 : 			}
; 2015 : 			else

	jmp	SHORT $LN18@Init
$LN19@Init:

; 2016 : 			{
; 2017 : 				glDetachShader(st.renderer.Program[6],st.renderer.VShader[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336456]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDetachShader
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2018 : 				glDetachShader(st.renderer.Program[6],st.renderer.FShader[6]);

	mov	eax, 4
	imul	ecx, eax, 6
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336520]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glDetachShader
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@Init:

; 2019 : 			}
; 2020 : 
; 2021 : 			if(!statusLK[2] || !statusLK[3] || !statusLK[4] || !statusLK[5] || !statusLK[6])

	mov	eax, 4
	shl	eax, 1
	cmp	DWORD PTR _statusLK$[ebp+eax], 0
	je	SHORT $LN16@Init
	mov	eax, 4
	imul	ecx, eax, 3
	cmp	DWORD PTR _statusLK$[ebp+ecx], 0
	je	SHORT $LN16@Init
	mov	eax, 4
	shl	eax, 2
	cmp	DWORD PTR _statusLK$[ebp+eax], 0
	je	SHORT $LN16@Init
	mov	eax, 4
	imul	ecx, eax, 5
	cmp	DWORD PTR _statusLK$[ebp+ecx], 0
	je	SHORT $LN16@Init
	mov	eax, 4
	imul	ecx, eax, 6
	cmp	DWORD PTR _statusLK$[ebp+ecx], 0
	jne	SHORT $LN14@Init
$LN16@Init:

; 2022 : 			{
; 2023 : #ifdef _VA_RENDER
; 2024 : 
; 2025 : 				LogApp("Changing to VA...");

	push	OFFSET ??_C@_0BC@FPJNDHAI@Changing?5to?5VA?4?4?4?$AA@
	call	_SDL_Log
	add	esp, 4

; 2026 : 
; 2027 : 				if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_EXT_vertex_array")==NULL)

	push	OFFSET ??_C@_0BE@PFGKPDCP@GL_EXT_vertex_array?$AA@
	mov	esi, esp
	push	7939					; 00001f03H
	call	DWORD PTR __imp__glGetString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@Init

; 2028 : 				{
; 2029 : 					LogApp("Your video card is not adequate to play this game... Goodbye!!");

	push	OFFSET ??_C@_0DP@GKIFJBKD@Your?5video?5card?5is?5not?5adequate?5@
	call	_SDL_Log
	add	esp, 4

; 2030 : 					Quit();

	call	_Quit

; 2031 : 				}
; 2032 : 				else

	jmp	SHORT $LN14@Init
$LN15@Init:

; 2033 : 					st.renderer.VA_ON=1;

	mov	BYTE PTR _st+2336453, 1
$LN14@Init:

; 2034 : #endif
; 2035 : 			}
; 2036 : 
; 2037 : 			//This is the main VAO/VBO, used for 1 Quad only objects
; 2038 : 
; 2039 : 			if(statusLK[0] || statusLK[3] || statusLK[4] || statusLK[5] || statusLK[6])

	mov	eax, 4
	imul	ecx, eax, 0
	cmp	DWORD PTR _statusLK$[ebp+ecx], 0
	jne	SHORT $LN12@Init
	mov	eax, 4
	imul	ecx, eax, 3
	cmp	DWORD PTR _statusLK$[ebp+ecx], 0
	jne	SHORT $LN12@Init
	mov	eax, 4
	shl	eax, 2
	cmp	DWORD PTR _statusLK$[ebp+eax], 0
	jne	SHORT $LN12@Init
	mov	eax, 4
	imul	ecx, eax, 5
	cmp	DWORD PTR _statusLK$[ebp+ecx], 0
	jne	SHORT $LN12@Init
	mov	eax, 4
	imul	ecx, eax, 6
	cmp	DWORD PTR _statusLK$[ebp+ecx], 0
	je	$LN13@Init
$LN12@Init:

; 2040 : 			{
; 2041 : 				glUseProgram(st.renderer.Program[2]);

	mov	eax, 4
	shl	eax, 1
	mov	esi, esp
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glUseProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2042 : 				st.renderer.unifs[0]=glGetUniformLocation(st.renderer.Program[2],"texu");

	mov	esi, esp
	push	OFFSET ??_C@_04DBNNPNIH@texu?$AA@
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, 4
	imul	ecx, edx, 0
	mov	DWORD PTR _st[ecx+2336712], eax

; 2043 : 				glUseProgram(st.renderer.Program[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	mov	esi, esp
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glUseProgram
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2044 : 				st.renderer.unifs[1]=glGetUniformLocation(st.renderer.Program[3],"texu");

	mov	esi, esp
	push	OFFSET ??_C@_04DBNNPNIH@texu?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 0
	mov	DWORD PTR _st[ecx+2336712], eax

; 2045 : 				st.renderer.unifs[2]=glGetUniformLocation(st.renderer.Program[3],"texu2");

	mov	esi, esp
	push	OFFSET ??_C@_05JOJNJPAP@texu2?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 1
	mov	DWORD PTR _st[ecx+2336712], eax

; 2046 : 				st.renderer.unifs[3]=glGetUniformLocation(st.renderer.Program[3],"texu3");

	mov	esi, esp
	push	OFFSET ??_C@_05IHIGKOEO@texu3?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	DWORD PTR _st[edx+2336712], eax

; 2047 : 				st.renderer.unifs[4]=glGetUniformLocation(st.renderer.Program[3],"normal");

	mov	esi, esp
	push	OFFSET ??_C@_06IKLLLDHL@normal?$AA@
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _st[ecx+2336648]
	push	edx
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	shl	ecx, 2
	mov	DWORD PTR _st[ecx+2336712], eax

; 2048 : 				st.renderer.unifs[5]=glGetUniformLocation(st.renderer.Program[2],"light_type");

	mov	esi, esp
	push	OFFSET ??_C@_0L@GLKJCCIE@light_type?$AA@
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _st[eax+2336648]
	push	ecx
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, 4
	imul	ecx, edx, 5
	mov	DWORD PTR _st[ecx+2336712], eax

; 2049 : 				//st.renderer.unifs[6]=glGetUniformLocation(st.renderer.Program[3],"Tile");
; 2050 : 				//st.renderer.unifs[7]=glGetUniformLocation(st.renderer.Program[3],"Tiles");
; 2051 : 
; 2052 : #ifdef _VAO_RENDER
; 2053 : 			CreateVAO(&vbd,1,3);

	push	3
	push	1
	push	OFFSET _vbd
	call	_CreateVAO
	add	esp, 12					; 0000000cH
$LN13@Init:

; 2054 : #elif _VBO_RENDER
; 2055 : 			CreateVBO(&vbd, 1);
; 2056 : #endif 
; 2057 : 			}
; 2058 : 		}
; 2059 : 	}
; 2060 : 
; 2061 : #endif
; 2062 : 
; 2063 : 	LogApp("Opengl initialized");

	push	OFFSET ??_C@_0BD@MFHDJABA@Opengl?5initialized?$AA@
	call	_SDL_Log
	add	esp, 4

; 2064 : 
; 2065 : 	if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_ARB_texture_non_power_of_two")==NULL)

	push	OFFSET ??_C@_0CA@IICOLDCN@GL_ARB_texture_non_power_of_two?$AA@
	mov	esi, esp
	push	7939					; 00001f03H
	call	DWORD PTR __imp__glGetString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@Init

; 2066 : 	{
; 2067 : 		st.LOWRES=1;

	mov	BYTE PTR _st+2335446, 1

; 2068 : 		LogApp("Non power of two textures not supported, loading times might increase and video's fps might decrease");

	push	OFFSET ??_C@_0GF@JPJDLJAN@Non?5power?5of?5two?5textures?5not?5su@
	call	_SDL_Log
	add	esp, 4
$LN11@Init:

; 2069 : 	}
; 2070 : 
; 2071 : 	if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_ARB_texture_rectangle")==NULL && strstr((char const*) glGetString(GL_EXTENSIONS),"GL_NV_texture_rectangle")==NULL && strstr((char const*) glGetString(GL_EXTENSIONS),"GL_NV_texture_rectangle")==NULL)

	push	OFFSET ??_C@_0BJ@NKHMPMDJ@GL_ARB_texture_rectangle?$AA@
	mov	esi, esp
	push	7939					; 00001f03H
	call	DWORD PTR __imp__glGetString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@Init
	push	OFFSET ??_C@_0BI@KIAKBMLM@GL_NV_texture_rectangle?$AA@
	mov	esi, esp
	push	7939					; 00001f03H
	call	DWORD PTR __imp__glGetString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@Init
	push	OFFSET ??_C@_0BI@KIAKBMLM@GL_NV_texture_rectangle?$AA@
	mov	esi, esp
	push	7939					; 00001f03H
	call	DWORD PTR __imp__glGetString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@Init

; 2072 : 		LogApp("Rectangle textures not supported, your video card is not supported or try updating your driver");

	push	OFFSET ??_C@_0FP@HOKOFLMI@Rectangle?5textures?5not?5supported@
	call	_SDL_Log
	add	esp, 4
$LN10@Init:

; 2073 : 
; 2074 : 	st.quit=0;

	mov	BYTE PTR _st+66668, 0

; 2075 : 
; 2076 : 	st.time=0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _st+64272, xmm0

; 2077 : 
; 2078 : 	st.PlayingVideo=0;

	mov	BYTE PTR _st+66669, 0

; 2079 : 
; 2080 : 	InputInit();

	call	_InputInit

; 2081 : 
; 2082 : 	LogApp("Input initialized");

	push	OFFSET ??_C@_0BC@DHDBMALK@Input?5initialized?$AA@
	call	_SDL_Log
	add	esp, 4

; 2083 : 
; 2084 : 	st.Camera.position.x=0;

	mov	DWORD PTR _st+2335380, 0

; 2085 : 	st.Camera.position.y=0;

	mov	DWORD PTR _st+2335384, 0

; 2086 : 	st.Camera.dimension.x=1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _st+2335396, xmm0

; 2087 : 	st.Camera.dimension.y=1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _st+2335400, xmm0

; 2088 : 	st.Camera.angle=0.0;

	xor	eax, eax
	mov	WORD PTR _st+2335392, ax

; 2089 : 
; 2090 : 	st.Current_Map.num_lights=0;

	mov	BYTE PTR _st+66849, 0

; 2091 : 	st.Current_Map.num_mgg=0;

	mov	BYTE PTR _st+66848, 0

; 2092 : 	st.Current_Map.num_obj=0;

	xor	eax, eax
	mov	WORD PTR _st+66846, ax

; 2093 : 	st.Current_Map.num_sector=0;

	xor	eax, eax
	mov	WORD PTR _st+66850, ax

; 2094 : 	st.Current_Map.num_sprites=0;

	xor	eax, eax
	mov	WORD PTR _st+66844, ax

; 2095 : 
; 2096 : 	st.num_hud=0;

	mov	DWORD PTR _st+252, 0

; 2097 : 	st.num_tex=0;

	mov	DWORD PTR _st+248, 0

; 2098 : 	st.num_ui=0;

	mov	DWORD PTR _st+256, 0

; 2099 : 
; 2100 : 	st.num_sprites=0;

	xor	eax, eax
	mov	WORD PTR _st+2335376, ax

; 2101 : 
; 2102 : 	st.num_uiwindow=0;

	mov	BYTE PTR _st+264, 0

; 2103 : 
; 2104 : 	st.cursor_type=0;

	mov	BYTE PTR _st+3307836, 0

; 2105 : 
; 2106 : 	memset(&ent,0,MAX_GRAPHICS*sizeof(_ENTITIES));

	push	540672					; 00084000H
	push	0
	push	OFFSET _ent
	call	_memset
	add	esp, 12					; 0000000cH

; 2107 : 
; 2108 : #ifndef MGEAR_CLEAN_VERSION
; 2109 : 	memset(&lmp,0,MAX_LIGHTMAPS*sizeof(_ENTITIES));
; 2110 : 	memset(&st.Game_Sprites,0,MAX_SPRITES*sizeof(_SPRITES));
; 2111 : #endif
; 2112 : 
; 2113 : 	memset(&st.strings,0,MAX_STRINGS*sizeof(StringsE));

	push	546816					; 00085800H
	push	0
	push	OFFSET _st+2761020
	call	_memset
	add	esp, 12					; 0000000cH

; 2114 : 
; 2115 : 	//Calculates Cos, Sin and Tan tables
; 2116 : 	for(k=0.0f;k<360.1f;k+=0.1f)

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _k$[ebp], xmm0
	jmp	SHORT $LN9@Init
$LN8@Init:
	movss	xmm0, DWORD PTR _k$[ebp]
	addss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _k$[ebp], xmm0
$LN9@Init:
	movss	xmm0, DWORD PTR __real@43b40ccd
	comiss	xmm0, DWORD PTR _k$[ebp]
	jbe	$LN7@Init

; 2117 : 	{
; 2118 : 		i=k*10;

	movss	xmm0, DWORD PTR _k$[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si eax, xmm0
	mov	WORD PTR _i$[ebp], ax

; 2119 : 		st.CosTable[i]=cos((k*pi)/180);

	cvtss2sd xmm0, DWORD PTR _k$[ebp]
	mulsd	xmm0, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm0, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	movzx	eax, WORD PTR _i$[ebp]
	fstp	DWORD PTR _st[eax*4+2717808]

; 2120 : 		st.SinTable[i]=sin((k*pi)/180);

	cvtss2sd xmm0, DWORD PTR _k$[ebp]
	mulsd	xmm0, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm0, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	movzx	eax, WORD PTR _i$[ebp]
	fstp	DWORD PTR _st[eax*4+2732212]

; 2121 : 		st.TanTable[i]=tan((k*pi)/180);

	cvtss2sd xmm0, DWORD PTR _k$[ebp]
	mulsd	xmm0, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm0, QWORD PTR __real@4066800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_tan
	add	esp, 8
	movzx	eax, WORD PTR _i$[ebp]
	fstp	DWORD PTR _st[eax*4+2746616]

; 2122 : 	}

	jmp	$LN8@Init
$LN7@Init:

; 2123 : 
; 2124 : #ifndef MGEAR_CLEAN_VERSION
; 2125 : 	memset(&st.game_lightmaps,0,MAX_LIGHTMAPS*sizeof(_GAME_LIGHTMAPS));
; 2126 : 
; 2127 : 	st.game_lightmaps[0].stat=1;
; 2128 : 
; 2129 : 	st.game_lightmaps[0].W_w=GAME_WIDTH;
; 2130 : 	st.game_lightmaps[0].W_h=GAME_HEIGHT;
; 2131 : 
; 2132 : 	st.game_lightmaps[0].T_w=4;
; 2133 : 	st.game_lightmaps[0].T_h=2;
; 2134 : 
; 2135 : 	st.game_lightmaps[0].num_lights=1;
; 2136 : 	st.game_lightmaps[0].w_pos.x=GAME_HEIGHT;
; 2137 : 	st.game_lightmaps[0].w_pos.y=4096;
; 2138 : 	st.game_lightmaps[0].w_pos.z=0;
; 2139 : 
; 2140 : 	st.game_lightmaps[0].t_pos[0].x=2;
; 2141 : 	st.game_lightmaps[0].t_pos[0].y=1;
; 2142 : 	st.game_lightmaps[0].t_pos[0].z=0;
; 2143 : 
; 2144 : 	st.game_lightmaps[0].t_pos[1].x=0;
; 2145 : 	st.game_lightmaps[0].t_pos[1].y=0;
; 2146 : 	st.game_lightmaps[0].t_pos[1].z=0;
; 2147 : 
; 2148 : 	st.game_lightmaps[0].t_pos[2].x=200;
; 2149 : 	st.game_lightmaps[0].t_pos[2].y=95;
; 2150 : 	st.game_lightmaps[0].t_pos[2].z=0;
; 2151 : 
; 2152 : 	st.game_lightmaps[0].data=GenerateLightmap(st.game_lightmaps[0].T_w, st.game_lightmaps[0].T_h);
; 2153 : 	AddLightToLightmap(st.game_lightmaps[0].data,st.game_lightmaps[0].T_w,st.game_lightmaps[0].T_h,255,255,255,0.1,st.game_lightmaps[0].t_pos[0].x,st.game_lightmaps[0].t_pos[0].y,st.game_lightmaps[0].t_pos[0].z,255,POINT_LIGHT_NORMAL);
; 2154 : 	//AddLightToLightmap(st.game_lightmaps[0].data,st.game_lightmaps[0].T_w,st.game_lightmaps[0].T_h,255,255,255,16,st.game_lightmaps[0].t_pos[1].x,st.game_lightmaps[0].t_pos[1].y,st.game_lightmaps[0].t_pos[1].z,128);
; 2155 : 	//AddLightToLightmap(st.game_lightmaps[0].data,st.game_lightmaps[0].T_w,st.game_lightmaps[0].T_h,255,255,255,16,st.game_lightmaps[0].t_pos[2].x,st.game_lightmaps[0].t_pos[2].y,st.game_lightmaps[0].t_pos[0].z,255);
; 2156 : 
; 2157 : 	st.game_lightmaps[0].tex=GenerateLightmapTexture(st.game_lightmaps[0].data,st.game_lightmaps[0].T_w,st.game_lightmaps[0].T_h);
; 2158 : 
; 2159 : #endif
; 2160 : 
; 2161 : 	DataN=(unsigned char*) calloc(64*64*3,sizeof(unsigned char));

	push	1
	push	12288					; 00003000H
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _DataN, eax

; 2162 : 
; 2163 : 	for(i=0;i<64;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN6@Init
$LN5@Init:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN6@Init:
	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN4@Init

; 2164 : 	{
; 2165 : 		for(j=0;j<64;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN3@Init
$LN2@Init:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN3@Init:
	movzx	eax, WORD PTR _j$[ebp]
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@Init

; 2166 : 		{
; 2167 : 			DataN[(i*64*3)+(j*3)]=255;

	movzx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	imul	ecx, eax, 3
	movzx	edx, WORD PTR _j$[ebp]
	imul	eax, edx, 3
	add	eax, DWORD PTR _DataN
	mov	BYTE PTR [eax+ecx], 255			; 000000ffH

; 2168 : 			DataN[(i*64*3)+(j*3)+1]=255;

	movzx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	imul	ecx, eax, 3
	movzx	edx, WORD PTR _j$[ebp]
	imul	eax, edx, 3
	add	eax, DWORD PTR _DataN
	mov	BYTE PTR [eax+ecx+1], 255		; 000000ffH

; 2169 : 			DataN[(i*64*3)+(j*3)+2]=255;

	movzx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	imul	ecx, eax, 3
	movzx	edx, WORD PTR _j$[ebp]
	imul	eax, edx, 3
	add	eax, DWORD PTR _DataN
	mov	BYTE PTR [eax+ecx+2], 255		; 000000ffH

; 2170 : 		}

	jmp	SHORT $LN2@Init
$LN1@Init:

; 2171 : 	}

	jmp	$LN5@Init
$LN4@Init:

; 2172 : 
; 2173 : 	glGenTextures(1,&DataNT);

	mov	esi, esp
	push	OFFSET _DataNT
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2174 : 	glBindTexture(GL_TEXTURE_2D,DataNT);

	mov	esi, esp
	mov	eax, DWORD PTR _DataNT
	push	eax
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2175 : 
; 2176 : 	glTexImage2D(GL_TEXTURE_2D,0,GL_RGB8,64,64,0,GL_BGR,GL_UNSIGNED_BYTE,DataN);

	mov	esi, esp
	mov	eax, DWORD PTR _DataN
	push	eax
	push	5121					; 00001401H
	push	32992					; 000080e0H
	push	0
	push	64					; 00000040H
	push	64					; 00000040H
	push	32849					; 00008051H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2177 : 
; 2178 : 	glGenerateMipmap(GL_TEXTURE_2D);

	mov	esi, esp
	push	3553					; 00000de1H
	call	DWORD PTR _GLeeFuncPtr_glGenerateMipmap
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2179 : 
; 2180 : 	//glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
; 2181 : 	//glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
; 2182 : 	
; 2183 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN78@Init
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 33316				; 00008224H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN78@Init:
	DD	3
	DD	$LN77@Init
$LN77@Init:
	DD	-208					; ffffff30H
	DD	128					; 00000080H
	DD	$LN74@Init
	DD	-344					; fffffea8H
	DD	128					; 00000080H
	DD	$LN75@Init
	DD	-33120					; ffff7ea0H
	DD	32768					; 00008000H
	DD	$LN76@Init
$LN76@Init:
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	0
$LN75@Init:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	76					; 0000004cH
	DB	75					; 0000004bH
	DB	0
$LN74@Init:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	67					; 00000043H
	DB	77					; 0000004dH
	DB	0
_Init	ENDP
_TEXT	ENDS
END
