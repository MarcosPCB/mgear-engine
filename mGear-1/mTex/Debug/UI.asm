; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	C:\Users\Marcos\Desktop\prj\mGear-1\mGear-1\UI.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
?time@?1??UISelectFile@@9@9 DD 01H DUP (?)		; `UISelectFile'::`2'::time
_BSS	ENDS
_DATA	SEGMENT
COMM	_UI_Sys:BYTE:040ca8H
_DATA	ENDS
_BSS	SEGMENT
?time@?1??UISavePath@@9@9 DD 01H DUP (?)		; `UISavePath'::`2'::time
_BSS	ENDS
_DATA	SEGMENT
COMM	_UI_Win:BYTE:01c0H
_DATA	ENDS
_BSS	SEGMENT
?time@?1??UIMakeList@@9@9 DD 01H DUP (?)		; `UIMakeList'::`2'::time
_BSS	ENDS
_DATA	SEGMENT
?m_sel@?1??UISelectFile@@9@9 DD 0ffffffffH		; `UISelectFile'::`2'::m_sel
?m_sel@?1??UISavePath@@9@9 DD 0ffffffffH		; `UISavePath'::`2'::m_sel
?m_sel@?1??UIMakeList@@9@9 DD 0ffffffffH		; `UIMakeList'::`2'::m_sel
_DATA	ENDS
PUBLIC	_UIMessageBox
PUBLIC	_UIOptionBox
PUBLIC	_UICreateWindow
PUBLIC	_UICreateWindow2
PUBLIC	_UIDestroyWindow
PUBLIC	_UIWin2_MarkBox
PUBLIC	_UIWin2_NumberBoxui8
PUBLIC	_UIWin2_NumberBoxi8
PUBLIC	_UIWin2_NumberBoxui16
PUBLIC	_UIWin2_NumberBoxi16
PUBLIC	_UIWin2_NumberBoxui32
PUBLIC	_UIWin2_NumberBoxi32
PUBLIC	_UIWin2_NumberBoxf
PUBLIC	_UIWin2_StringButton
PUBLIC	_UIWin2_TextBox
PUBLIC	_UIMain_DrawSystem
PUBLIC	_UILoadSystem
PUBLIC	_UIWin_Button
PUBLIC	_UIWin_ButtonIcon
PUBLIC	_UIStringButton
PUBLIC	_UIStringButtonWorld
PUBLIC	_Sys_ColorPicker
PUBLIC	_UITextBox
PUBLIC	_SetDirContent
PUBLIC	_UISelectFile
PUBLIC	_UISavePath
PUBLIC	_UIMakeList
PUBLIC	_UIButton
PUBLIC	_NumDirFile
PUBLIC	_UIBeginWidgetWindow
PUBLIC	_UIWindowLayoutRow
PUBLIC	??_C@_0BK@DEPFCNDH@Coulnd?5not?5open?5directory?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_02ILLPBGAO@?$DN?$CC?$AA@			; `string'
PUBLIC	??_C@_03PFIILPDO@?5?$DN?$CC?$AA@		; `string'
PUBLIC	??_C@_06PEKNBJMF@MGG?5ID?$AA@			; `string'
PUBLIC	??_C@_0O@PJPNPMCL@Window2?5Frame?$AA@		; `string'
PUBLIC	??_C@_0O@BEKHFMFK@Window?5Frame0?$AA@		; `string'
PUBLIC	??_C@_0O@NLMGNBL@Window?5Frame1?$AA@		; `string'
PUBLIC	??_C@_0O@CGJBDONI@Window?5Frame2?$AA@		; `string'
PUBLIC	??_C@_0O@JALBCEAG@Button?5Frame0?$AA@		; `string'
PUBLIC	??_C@_0O@IJKKBFEH@Button?5Frame1?$AA@		; `string'
PUBLIC	??_C@_0O@KCIHEGIE@Button?5Frame2?$AA@		; `string'
PUBLIC	??_C@_0BB@JHJNJBII@Subwindow?5Frame0?$AA@	; `string'
PUBLIC	??_C@_0BB@IOIGKAMJ@Subwindow?5Frame1?$AA@	; `string'
PUBLIC	??_C@_0BB@KFKLPDAK@Subwindow?5Frame2?$AA@	; `string'
PUBLIC	??_C@_09DLONLHCP@Tab?5Frame?$AA@		; `string'
PUBLIC	??_C@_0M@KGGBGCOI@Close?5Frame?$AA@		; `string'
PUBLIC	??_C@_0O@NIMFPFPB@Scroll?5Frame0?$AA@		; `string'
PUBLIC	??_C@_0O@MBNOMELA@Scroll?5Frame1?$AA@		; `string'
PUBLIC	??_C@_0BA@GBPLBIJP@Scroll?5Up?5Frame?$AA@	; `string'
PUBLIC	??_C@_0BC@PLHMGGMP@Scroll?5Down?5Frame?$AA@	; `string'
PUBLIC	??_C@_0BE@DIOJCMDC@Resize?5Cursor?5Frame?$AA@	; `string'
PUBLIC	??_C@_0BA@IPIPEMCB@Save?5Icon?5Frame?$AA@	; `string'
PUBLIC	??_C@_0BC@JKGLEFGA@Folder?5Icon?5Frame?$AA@	; `string'
PUBLIC	??_C@_0BB@MMJCIDDE@UI?5system?5loaded?$AA@	; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_02GIPFHKNO@OK?$AA@			; `string'
PUBLIC	??_C@_03CCLAEDDF@Yes?$AA@			; `string'
PUBLIC	??_C@_02JINPPBEP@No?$AA@			; `string'
PUBLIC	??_C@_06FMBNCPDL@Cancel?$AA@			; `string'
PUBLIC	??_C@_04IJKKPDFE@?5?$FLX?$FN?$AA@		; `string'
PUBLIC	??_C@_04NDEIMKLM@?5?$FL?5?$FN?$AA@		; `string'
PUBLIC	??_C@_06FFMNEPHE@?$CFs?3?5?$CFu?$AA@		; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu?$AA@			; `string'
PUBLIC	??_C@_06GBEGMGE@?$CFs?3?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_07BGICGNCG@?$CFs?3?5?$CFlu?$AA@		; `string'
PUBLIC	??_C@_03FKNCMABI@?$CFlu?$AA@			; `string'
PUBLIC	??_C@_07EFFLEODG@?$CFs?3?5?$CFld?$AA@		; `string'
PUBLIC	??_C@_03JALODAI@?$CFld?$AA@			; `string'
PUBLIC	??_C@_08KELGKKHF@?$CFs?3?5?$CF?43f?$AA@		; `string'
PUBLIC	??_C@_04GFJLOHHD@?$CF?43f?$AA@			; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_02CBLDBPFN@?1?1?$AA@			; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_04DNCDCIAE@Open?$AA@			; `string'
PUBLIC	??_C@_04INACKGJP@Save?$AA@			; `string'
PUBLIC	??_C@_06HJGPBJLE@Select?$AA@			; `string'
PUBLIC	?__LINE__Var@?1??UIWindowLayoutRow@@9@9		; `UIWindowLayoutRow'::`2'::__LINE__Var
PUBLIC	??_C@_1GC@LGLPIKNC@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@ ; `string'
PUBLIC	??_C@_1DE@LHFFAMPL@?$AAU?$AAI?$AA_?$AAW?$AAi?$AAn?$AA?$FL?$AAw?$AAi?$AAn?$AA_?$AAi?$AAd?$AA?$FN?$AA?4?$AAw?$AAg?$AA_?$AAp?$AAe?$AAr?$AA_?$AAr?$AAo?$AAw?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@KGBCOGGA@?$AAU?$AAI?$AA_?$AAW?$AAi?$AAn?$AA?$FL?$AAw?$AAi?$AAn?$AA_?$AAi?$AAd?$AA?$FN?$AA?4?$AAl?$AAa?$AAy?$AAo?$AAu?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@FFFHILIK@?$AAU?$AAI?$AA_?$AAW?$AAi?$AAn?$AA?$FL?$AAw?$AAi?$AAn?$AA_?$AAi?$AAd?$AA?$FN?$AA?4?$AAr?$AAo?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
EXTRN	_tolower:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_strtok:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindFirstFileW@8:PROC
EXTRN	__imp__FindNextFileW@8:PROC
EXTRN	__imp__GetFullPathNameW@16:PROC
EXTRN	__imp__glReadPixels@28:PROC
EXTRN	__set_errno:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_realloc:PROC
EXTRN	_SDL_ShowCursor:PROC
EXTRN	_SDL_Log:PROC
EXTRN	_fclose:PROC
EXTRN	_feof:PROC
EXTRN	_fgets:PROC
EXTRN	_fopen:PROC
EXTRN	_sprintf:PROC
EXTRN	_atof:PROC
EXTRN	_atoi:PROC
EXTRN	_mbstowcs_s:PROC
EXTRN	_wcstombs_s:PROC
EXTRN	@GetTimerM@0:PROC
EXTRN	_DrawUI:PROC
EXTRN	_CheckCollisionMouse:PROC
EXTRN	_CheckCollisionMouseWorld:PROC
EXTRN	_UIData:PROC
EXTRN	_StringUIData:PROC
EXTRN	_StringUIvData:PROC
EXTRN	_String2Data:PROC
EXTRN	_StartText:PROC
EXTRN	_StopText:PROC
EXTRN	__wassert:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	_st:BYTE
EXTRN	_mgg_sys:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1DA@FFFHILIK@?$AAU?$AAI?$AA_?$AAW?$AAi?$AAn?$AA?$FL?$AAw?$AAi?$AAn?$AA_?$AAi?$AAd?$AA?$FN?$AA?4?$AAr?$AAo?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@FFFHILIK@?$AAU?$AAI?$AA_?$AAW?$AAi?$AAn?$AA?$FL?$AAw?$AAi?$AAn?$AA_?$AAi?$AAd?$AA?$FN?$AA?4?$AAr?$AAo?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'U'
	DB	00H, 'I', 00H, '_', 00H, 'W', 00H, 'i', 00H, 'n', 00H, '[', 00H
	DB	'w', 00H, 'i', 00H, 'n', 00H, '_', 00H, 'i', 00H, 'd', 00H, ']'
	DB	00H, '.', 00H, 'r', 00H, 'o', 00H, 'w', 00H, '_', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@KGBCOGGA@?$AAU?$AAI?$AA_?$AAW?$AAi?$AAn?$AA?$FL?$AAw?$AAi?$AAn?$AA_?$AAi?$AAd?$AA?$FN?$AA?4?$AAl?$AAa?$AAy?$AAo?$AAu?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@KGBCOGGA@?$AAU?$AAI?$AA_?$AAW?$AAi?$AAn?$AA?$FL?$AAw?$AAi?$AAn?$AA_?$AAi?$AAd?$AA?$FN?$AA?4?$AAl?$AAa?$AAy?$AAo?$AAu?$AAt?$AA?$AA@ DB 'U'
	DB	00H, 'I', 00H, '_', 00H, 'W', 00H, 'i', 00H, 'n', 00H, '[', 00H
	DB	'w', 00H, 'i', 00H, 'n', 00H, '_', 00H, 'i', 00H, 'd', 00H, ']'
	DB	00H, '.', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@LHFFAMPL@?$AAU?$AAI?$AA_?$AAW?$AAi?$AAn?$AA?$FL?$AAw?$AAi?$AAn?$AA_?$AAi?$AAd?$AA?$FN?$AA?4?$AAw?$AAg?$AA_?$AAp?$AAe?$AAr?$AA_?$AAr?$AAo?$AAw?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@LHFFAMPL@?$AAU?$AAI?$AA_?$AAW?$AAi?$AAn?$AA?$FL?$AAw?$AAi?$AAn?$AA_?$AAi?$AAd?$AA?$FN?$AA?4?$AAw?$AAg?$AA_?$AAp?$AAe?$AAr?$AA_?$AAr?$AAo?$AAw?$AA?$AA@ DB 'U'
	DB	00H, 'I', 00H, '_', 00H, 'W', 00H, 'i', 00H, 'n', 00H, '[', 00H
	DB	'w', 00H, 'i', 00H, 'n', 00H, '_', 00H, 'i', 00H, 'd', 00H, ']'
	DB	00H, '.', 00H, 'w', 00H, 'g', 00H, '_', 00H, 'p', 00H, 'e', 00H
	DB	'r', 00H, '_', 00H, 'r', 00H, 'o', 00H, 'w', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GC@LGLPIKNC@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
CONST	SEGMENT
??_C@_1GC@LGLPIKNC@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'm', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 'd', 00H, 'e', 00H, 's', 00H, 'k', 00H
	DB	't', 00H, 'o', 00H, 'p', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'j'
	DB	00H, '\', 00H, 'm', 00H, 'g', 00H, 'e', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, '1', 00H, '\', 00H, 'm', 00H, 'g', 00H, 'e', 00H, 'a'
	DB	00H, 'r', 00H, '-', 00H, '1', 00H, '\', 00H, 'u', 00H, 'i', 00H
	DB	'.', 00H, 'c', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??UIWindowLayoutRow@@9@9
_DATA	SEGMENT
?__LINE__Var@?1??UIWindowLayoutRow@@9@9 DD 09caH	; `UIWindowLayoutRow'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_06HJGPBJLE@Select?$AA@
CONST	SEGMENT
??_C@_06HJGPBJLE@Select?$AA@ DB 'Select', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04INACKGJP@Save?$AA@
CONST	SEGMENT
??_C@_04INACKGJP@Save?$AA@ DB 'Save', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DNCDCIAE@Open?$AA@
CONST	SEGMENT
??_C@_04DNCDCIAE@Open?$AA@ DB 'Open', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CBLDBPFN@?1?1?$AA@
CONST	SEGMENT
??_C@_02CBLDBPFN@?1?1?$AA@ DB '//', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GFJLOHHD@?$CF?43f?$AA@
CONST	SEGMENT
??_C@_04GFJLOHHD@?$CF?43f?$AA@ DB '%.3f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KELGKKHF@?$CFs?3?5?$CF?43f?$AA@
CONST	SEGMENT
??_C@_08KELGKKHF@?$CFs?3?5?$CF?43f?$AA@ DB '%s: %.3f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JALODAI@?$CFld?$AA@
CONST	SEGMENT
??_C@_03JALODAI@?$CFld?$AA@ DB '%ld', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EFFLEODG@?$CFs?3?5?$CFld?$AA@
CONST	SEGMENT
??_C@_07EFFLEODG@?$CFs?3?5?$CFld?$AA@ DB '%s: %ld', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKNCMABI@?$CFlu?$AA@
CONST	SEGMENT
??_C@_03FKNCMABI@?$CFlu?$AA@ DB '%lu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BGICGNCG@?$CFs?3?5?$CFlu?$AA@
CONST	SEGMENT
??_C@_07BGICGNCG@?$CFs?3?5?$CFlu?$AA@ DB '%s: %lu', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GBEGMGE@?$CFs?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_06GBEGMGE@?$CFs?3?5?$CFd?$AA@ DB '%s: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu?$AA@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu?$AA@ DB '%u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFMNEPHE@?$CFs?3?5?$CFu?$AA@
CONST	SEGMENT
??_C@_06FFMNEPHE@?$CFs?3?5?$CFu?$AA@ DB '%s: %u', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04NDEIMKLM@?5?$FL?5?$FN?$AA@
CONST	SEGMENT
??_C@_04NDEIMKLM@?5?$FL?5?$FN?$AA@ DB ' [ ]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04IJKKPDFE@?5?$FLX?$FN?$AA@
CONST	SEGMENT
??_C@_04IJKKPDFE@?5?$FLX?$FN?$AA@ DB ' [X]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FMBNCPDL@Cancel?$AA@
CONST	SEGMENT
??_C@_06FMBNCPDL@Cancel?$AA@ DB 'Cancel', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02JINPPBEP@No?$AA@
CONST	SEGMENT
??_C@_02JINPPBEP@No?$AA@ DB 'No', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CCLAEDDF@Yes?$AA@
CONST	SEGMENT
??_C@_03CCLAEDDF@Yes?$AA@ DB 'Yes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GIPFHKNO@OK?$AA@
CONST	SEGMENT
??_C@_02GIPFHKNO@OK?$AA@ DB 'OK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MMJCIDDE@UI?5system?5loaded?$AA@
CONST	SEGMENT
??_C@_0BB@MMJCIDDE@UI?5system?5loaded?$AA@ DB 'UI system loaded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JKGLEFGA@Folder?5Icon?5Frame?$AA@
CONST	SEGMENT
??_C@_0BC@JKGLEFGA@Folder?5Icon?5Frame?$AA@ DB 'Folder Icon Frame', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IPIPEMCB@Save?5Icon?5Frame?$AA@
CONST	SEGMENT
??_C@_0BA@IPIPEMCB@Save?5Icon?5Frame?$AA@ DB 'Save Icon Frame', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DIOJCMDC@Resize?5Cursor?5Frame?$AA@
CONST	SEGMENT
??_C@_0BE@DIOJCMDC@Resize?5Cursor?5Frame?$AA@ DB 'Resize Cursor Frame', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PLHMGGMP@Scroll?5Down?5Frame?$AA@
CONST	SEGMENT
??_C@_0BC@PLHMGGMP@Scroll?5Down?5Frame?$AA@ DB 'Scroll Down Frame', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GBPLBIJP@Scroll?5Up?5Frame?$AA@
CONST	SEGMENT
??_C@_0BA@GBPLBIJP@Scroll?5Up?5Frame?$AA@ DB 'Scroll Up Frame', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MBNOMELA@Scroll?5Frame1?$AA@
CONST	SEGMENT
??_C@_0O@MBNOMELA@Scroll?5Frame1?$AA@ DB 'Scroll Frame1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NIMFPFPB@Scroll?5Frame0?$AA@
CONST	SEGMENT
??_C@_0O@NIMFPFPB@Scroll?5Frame0?$AA@ DB 'Scroll Frame0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KGGBGCOI@Close?5Frame?$AA@
CONST	SEGMENT
??_C@_0M@KGGBGCOI@Close?5Frame?$AA@ DB 'Close Frame', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DLONLHCP@Tab?5Frame?$AA@
CONST	SEGMENT
??_C@_09DLONLHCP@Tab?5Frame?$AA@ DB 'Tab Frame', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KFKLPDAK@Subwindow?5Frame2?$AA@
CONST	SEGMENT
??_C@_0BB@KFKLPDAK@Subwindow?5Frame2?$AA@ DB 'Subwindow Frame2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IOIGKAMJ@Subwindow?5Frame1?$AA@
CONST	SEGMENT
??_C@_0BB@IOIGKAMJ@Subwindow?5Frame1?$AA@ DB 'Subwindow Frame1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JHJNJBII@Subwindow?5Frame0?$AA@
CONST	SEGMENT
??_C@_0BB@JHJNJBII@Subwindow?5Frame0?$AA@ DB 'Subwindow Frame0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KCIHEGIE@Button?5Frame2?$AA@
CONST	SEGMENT
??_C@_0O@KCIHEGIE@Button?5Frame2?$AA@ DB 'Button Frame2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IJKKBFEH@Button?5Frame1?$AA@
CONST	SEGMENT
??_C@_0O@IJKKBFEH@Button?5Frame1?$AA@ DB 'Button Frame1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JALBCEAG@Button?5Frame0?$AA@
CONST	SEGMENT
??_C@_0O@JALBCEAG@Button?5Frame0?$AA@ DB 'Button Frame0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CGJBDONI@Window?5Frame2?$AA@
CONST	SEGMENT
??_C@_0O@CGJBDONI@Window?5Frame2?$AA@ DB 'Window Frame2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NLMGNBL@Window?5Frame1?$AA@
CONST	SEGMENT
??_C@_0O@NLMGNBL@Window?5Frame1?$AA@ DB 'Window Frame1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BEKHFMFK@Window?5Frame0?$AA@
CONST	SEGMENT
??_C@_0O@BEKHFMFK@Window?5Frame0?$AA@ DB 'Window Frame0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PJPNPMCL@Window2?5Frame?$AA@
CONST	SEGMENT
??_C@_0O@PJPNPMCL@Window2?5Frame?$AA@ DB 'Window2 Frame', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PEKNBJMF@MGG?5ID?$AA@
CONST	SEGMENT
??_C@_06PEKNBJMF@MGG?5ID?$AA@ DB 'MGG ID', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PFIILPDO@?5?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_03PFIILPDO@?5?$DN?$CC?$AA@ DB ' ="', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02ILLPBGAO@?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_02ILLPBGAO@?$DN?$CC?$AA@ DB '="', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DEPFCNDH@Coulnd?5not?5open?5directory?$AA@
CONST	SEGMENT
??_C@_0BK@DEPFCNDH@Coulnd?5not?5open?5directory?$AA@ DB 'Coulnd not open '
	DB	'directory', 00H				; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIWindowLayoutRow
_TEXT	SEGMENT
_win_id$ = 8						; size = 1
_w$ = 12						; size = 4
_h$ = 16						; size = 4
_num_wg$ = 20						; size = 1
_UIWindowLayoutRow PROC					; COMDAT

; 2506 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2507 : 	if (UI_Win[win_id].stat)

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx]
	test	edx, edx
	je	$LN4@UIWindowLa

; 2508 : 	{
; 2509 : 		UI_Win[win_id].rows++;

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _UI_Win[ecx+36]
	add	dl, 1
	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+36], dl

; 2510 : 		
; 2511 : 		if(UI_Win[win_id].rows == 1)

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+36]
	cmp	edx, 1
	jne	$LN3@UIWindowLa

; 2512 : 		{
; 2513 : 			UI_Win[win_id].wg_per_row = malloc(1);

	push	1
	call	_malloc
	add	esp, 4
	movsx	ecx, BYTE PTR _win_id$[ebp]
	imul	edx, ecx, 56
	mov	DWORD PTR _UI_Win[edx+40], eax

; 2514 : 			assert(UI_Win[win_id].wg_per_row);

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	cmp	DWORD PTR _UI_Win[ecx+40], 0
	jne	SHORT $LN7@UIWindowLa
	mov	edx, DWORD PTR ?__LINE__Var@?1??UIWindowLayoutRow@@9@9
	add	edx, 8
	push	edx
	push	OFFSET ??_C@_1GC@LGLPIKNC@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1DE@LHFFAMPL@?$AAU?$AAI?$AA_?$AAW?$AAi?$AAn?$AA?$FL?$AAw?$AAi?$AAn?$AA_?$AAi?$AAd?$AA?$FN?$AA?4?$AAw?$AAg?$AA_?$AAp?$AAe?$AAr?$AA_?$AAr?$AAo?$AAw?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN7@UIWindowLa:

; 2515 : 
; 2516 : 			UI_Win[win_id].wg_per_row[UI_Win[win_id].rows-1] = num_wg;

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _win_id$[ebp]
	imul	eax, edx, 56
	movzx	edx, BYTE PTR _UI_Win[eax+36]
	mov	eax, DWORD PTR _UI_Win[ecx+40]
	mov	cl, BYTE PTR _num_wg$[ebp]
	mov	BYTE PTR [eax+edx-1], cl

; 2517 : 
; 2518 : 			UI_Win[win_id].num_wg = num_wg;

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _num_wg$[ebp]
	mov	BYTE PTR _UI_Win[ecx+44], dl

; 2519 : 
; 2520 : 			UI_Win[win_id].layout = malloc(UI_Win[win_id].num_wg);

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+44]
	push	edx
	call	_malloc
	add	esp, 4
	movsx	ecx, BYTE PTR _win_id$[ebp]
	imul	edx, ecx, 56
	mov	DWORD PTR _UI_Win[edx+48], eax

; 2521 : 			assert(UI_Win[win_id].layout);

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	cmp	DWORD PTR _UI_Win[ecx+48], 0
	jne	SHORT $LN8@UIWindowLa
	mov	edx, DWORD PTR ?__LINE__Var@?1??UIWindowLayoutRow@@9@9
	add	edx, 15					; 0000000fH
	push	edx
	push	OFFSET ??_C@_1GC@LGLPIKNC@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1CM@KGBCOGGA@?$AAU?$AAI?$AA_?$AAW?$AAi?$AAn?$AA?$FL?$AAw?$AAi?$AAn?$AA_?$AAi?$AAd?$AA?$FN?$AA?4?$AAl?$AAa?$AAy?$AAo?$AAu?$AAt?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN8@UIWindowLa:

; 2522 : 			
; 2523 : 			memset(UI_Win[win_id].layout[0], 0, UI_Win[win_id].wg_per_row[UI_Win[win_id].rows - 1]);

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _win_id$[ebp]
	imul	eax, edx, 56
	movzx	edx, BYTE PTR _UI_Win[eax+36]
	mov	eax, DWORD PTR _UI_Win[ecx+40]
	movzx	ecx, BYTE PTR [eax+edx-1]
	push	ecx
	push	0
	movsx	edx, BYTE PTR _win_id$[ebp]
	imul	eax, edx, 56
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _UI_Win[eax+48]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2524 : 
; 2525 : 			UI_Win[win_id].row_size = malloc(sizeof(Pos));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	movsx	ecx, BYTE PTR _win_id$[ebp]
	imul	edx, ecx, 56
	mov	DWORD PTR _UI_Win[edx+52], eax

; 2526 : 			assert(UI_Win[win_id].row_size);

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	cmp	DWORD PTR _UI_Win[ecx+52], 0
	jne	SHORT $LN9@UIWindowLa
	mov	edx, DWORD PTR ?__LINE__Var@?1??UIWindowLayoutRow@@9@9
	add	edx, 20					; 00000014H
	push	edx
	push	OFFSET ??_C@_1GC@LGLPIKNC@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1DA@FFFHILIK@?$AAU?$AAI?$AA_?$AAW?$AAi?$AAn?$AA?$FL?$AAw?$AAi?$AAn?$AA_?$AAi?$AAd?$AA?$FN?$AA?4?$AAr?$AAo?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@UIWindowLa:

; 2527 : 			UI_Win[win_id].row_size[0].x = w;

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _UI_Win[ecx+52]
	mov	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 2528 : 			UI_Win[win_id].row_size[0].y = h;

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _UI_Win[ecx+52]
	mov	edx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [ecx+eax+4], edx

; 2529 : 
; 2530 : 		}
; 2531 : 		else

	jmp	$LN2@UIWindowLa
$LN3@UIWindowLa:

; 2532 : 		{	
; 2533 : 			UI_Win[win_id].wg_per_row = realloc(UI_Win[win_id].wg_per_row, UI_Win[win_id].rows);

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+36]
	push	edx
	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+40]
	push	edx
	call	_realloc
	add	esp, 8
	movsx	ecx, BYTE PTR _win_id$[ebp]
	imul	edx, ecx, 56
	mov	DWORD PTR _UI_Win[edx+40], eax

; 2534 : 			assert(UI_Win[win_id].wg_per_row);

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	cmp	DWORD PTR _UI_Win[ecx+40], 0
	jne	SHORT $LN10@UIWindowLa
	mov	edx, DWORD PTR ?__LINE__Var@?1??UIWindowLayoutRow@@9@9
	add	edx, 28					; 0000001cH
	push	edx
	push	OFFSET ??_C@_1GC@LGLPIKNC@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1DE@LHFFAMPL@?$AAU?$AAI?$AA_?$AAW?$AAi?$AAn?$AA?$FL?$AAw?$AAi?$AAn?$AA_?$AAi?$AAd?$AA?$FN?$AA?4?$AAw?$AAg?$AA_?$AAp?$AAe?$AAr?$AA_?$AAr?$AAo?$AAw?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@UIWindowLa:

; 2535 : 
; 2536 : 			UI_Win[win_id].wg_per_row[UI_Win[win_id].rows-1] = num_wg;

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _win_id$[ebp]
	imul	eax, edx, 56
	movzx	edx, BYTE PTR _UI_Win[eax+36]
	mov	eax, DWORD PTR _UI_Win[ecx+40]
	mov	cl, BYTE PTR _num_wg$[ebp]
	mov	BYTE PTR [eax+edx-1], cl

; 2537 : 	
; 2538 : 			UI_Win[win_id].num_wg += num_wg;

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _num_wg$[ebp]
	movzx	eax, BYTE PTR _UI_Win[ecx+44]
	add	eax, edx
	movsx	ecx, BYTE PTR _win_id$[ebp]
	imul	edx, ecx, 56
	mov	BYTE PTR _UI_Win[edx+44], al

; 2539 : 
; 2540 : 			UI_Win[win_id].layout = realloc(UI_Win[win_id].layout, UI_Win[win_id].rows * UI_Win[win_id].num_wg);

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+36]
	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	movzx	eax, BYTE PTR _UI_Win[ecx+44]
	imul	edx, eax
	push	edx
	movsx	ecx, BYTE PTR _win_id$[ebp]
	imul	edx, ecx, 56
	mov	eax, DWORD PTR _UI_Win[edx+48]
	push	eax
	call	_realloc
	add	esp, 8
	movsx	ecx, BYTE PTR _win_id$[ebp]
	imul	edx, ecx, 56
	mov	DWORD PTR _UI_Win[edx+48], eax

; 2541 : 			assert(UI_Win[win_id].layout);

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	cmp	DWORD PTR _UI_Win[ecx+48], 0
	jne	SHORT $LN11@UIWindowLa
	mov	edx, DWORD PTR ?__LINE__Var@?1??UIWindowLayoutRow@@9@9
	add	edx, 35					; 00000023H
	push	edx
	push	OFFSET ??_C@_1GC@LGLPIKNC@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAc?$AAo?$AAs?$AA?2?$AAd?$AAe?$AAs?$AAk?$AAt?$AAo?$AAp?$AA?2?$AAp?$AAr?$AAj?$AA?2?$AAm?$AAg?$AAe?$AAa@
	push	OFFSET ??_C@_1CM@KGBCOGGA@?$AAU?$AAI?$AA_?$AAW?$AAi?$AAn?$AA?$FL?$AAw?$AAi?$AAn?$AA_?$AAi?$AAd?$AA?$FN?$AA?4?$AAl?$AAa?$AAy?$AAo?$AAu?$AAt?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN11@UIWindowLa:

; 2542 : 
; 2543 : 			memset(UI_Win[win_id].layout[UI_Win[win_id].rows-1], 0, UI_Win[win_id].wg_per_row[UI_Win[win_id].rows-1]);

	movsx	eax, BYTE PTR _win_id$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _win_id$[ebp]
	imul	eax, edx, 56
	movzx	edx, BYTE PTR _UI_Win[eax+36]
	mov	eax, DWORD PTR _UI_Win[ecx+40]
	movzx	ecx, BYTE PTR [eax+edx-1]
	push	ecx
	push	0
	movsx	edx, BYTE PTR _win_id$[ebp]
	imul	eax, edx, 56
	movsx	ecx, BYTE PTR _win_id$[ebp]
	imul	edx, ecx, 56
	movzx	ecx, BYTE PTR _UI_Win[edx+36]
	mov	edx, DWORD PTR _UI_Win[eax+48]
	mov	eax, DWORD PTR [edx+ecx*4-4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN2@UIWindowLa:

; 2544 : 		}
; 2545 : 
; 2546 : 		return 1;

	mov	al, 1
	jmp	SHORT $LN5@UIWindowLa

; 2547 : 	}
; 2548 : 	else

	jmp	SHORT $LN5@UIWindowLa
$LN4@UIWindowLa:

; 2549 : 		return NULL;

	xor	al, al
$LN5@UIWindowLa:

; 2550 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UIWindowLayoutRow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIBeginWidgetWindow
_TEXT	SEGMENT
$T1 = -221						; size = 1
_i$ = -17						; size = 1
_ID$ = -5						; size = 1
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xsize$ = 16						; size = 4
_ysize$ = 20						; size = 4
_bpos$ = 24						; size = 4
_layer$ = 28						; size = 1
_UIBeginWidgetWindow PROC				; COMDAT

; 2466 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T1[ebp], 0

; 2467 : 	int8 ID, i;
; 2468 : 
; 2469 : 	if (bpos == CENTER)

	cmp	DWORD PTR _bpos$[ebp], 0
	jne	SHORT $LN7@UIBeginWid

; 2470 : 	{
; 2471 : 		x = 8192;

	mov	DWORD PTR _x$[ebp], 8192		; 00002000H

; 2472 : 		y = GAME_HEIGHT / 2;

	mov	DWORD PTR _y$[ebp], 4608		; 00001200H
$LN7@UIBeginWid:

; 2473 : 	}
; 2474 : 
; 2475 : 	if (st.num_uiwindow<MAX_UIWINDOWS)

	movzx	eax, BYTE PTR _st+264
	cmp	eax, 8
	jge	$LN6@UIBeginWid

; 2476 : 	{
; 2477 : 		for (i = 0; i<MAX_UIWINDOWS; i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $LN5@UIBeginWid
$LN4@UIBeginWid:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$LN5@UIBeginWid:
	movsx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN3@UIBeginWid

; 2478 : 		{
; 2479 : 			if (!UI_Win[i].stat)

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx]
	test	edx, edx
	jne	$LN2@UIBeginWid

; 2480 : 			{
; 2481 : 				UI_Win[i].stat = 1;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx], 1

; 2482 : 				UI_Win[i].pos.x = x;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _UI_Win[ecx+4], edx

; 2483 : 				UI_Win[i].pos.y = y;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _UI_Win[ecx+8], edx

; 2484 : 				UI_Win[i].size.x = xsize;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _UI_Win[ecx+16], edx

; 2485 : 				UI_Win[i].size.y = ysize;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _ysize$[ebp]
	mov	DWORD PTR _UI_Win[ecx+20], edx

; 2486 : 				UI_Win[i].layer = layer;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _layer$[ebp]
	mov	BYTE PTR _UI_Win[ecx+28], dl

; 2487 : 				UI_Win[i].num_options = 0;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+29], 0

; 2488 : 				UI_Win[i].current = -1;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+34], -1

; 2489 : 
; 2490 : 				UI_Win[i].rows = 0;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+36], 0

; 2491 : 				UI_Win[i].num_wg = 0;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+44], 0

; 2492 : 
; 2493 : 				ID = st.num_uiwindow;

	mov	BYTE PTR $T1[ebp], 1
	mov	al, BYTE PTR _st+264
	mov	BYTE PTR _ID$[ebp], al

; 2494 : 				st.num_uiwindow++;

	mov	al, BYTE PTR _st+264
	add	al, 1
	mov	BYTE PTR _st+264, al

; 2495 : 				break;

	jmp	SHORT $LN3@UIBeginWid
$LN2@UIBeginWid:

; 2496 : 			}
; 2497 : 		}

	jmp	$LN4@UIBeginWid
$LN3@UIBeginWid:

; 2498 : 	}
; 2499 : 	else

	jmp	SHORT $LN1@UIBeginWid
$LN6@UIBeginWid:

; 2500 : 		return -1;

	or	al, -1
	jmp	SHORT $LN8@UIBeginWid
$LN1@UIBeginWid:

; 2501 : 
; 2502 : 	return ID;

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN10@UIBeginWid
	push	OFFSET $LN11@UIBeginWid
	call	__RTC_UninitUse
	add	esp, 4
$LN10@UIBeginWid:
	mov	al, BYTE PTR _ID$[ebp]
$LN8@UIBeginWid:

; 2503 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@UIBeginWid:
$LN11@UIBeginWid:
	DB	73					; 00000049H
	DB	68					; 00000044H
	DB	0
_UIBeginWidgetWindow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _NumDirFile
_TEXT	SEGMENT
_filenum$ = -44						; size = 2
_i$ = -32						; size = 2
_ent$ = -20						; size = 4
_dir$ = -8						; size = 4
_path$ = 8						; size = 4
_content$ = 12						; size = 4
_NumDirFile PROC					; COMDAT

; 10   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 11   : 	DIR *dir;
; 12   : 	dirent *ent;
; 13   : 	uint16 i=0;

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax

; 14   : 	int16 filenum=0;

	xor	eax, eax
	mov	WORD PTR _filenum$[ebp], ax

; 15   : 
; 16   : 	if((dir=opendir(path))!=NULL)

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_opendir
	add	esp, 4
	mov	DWORD PTR _dir$[ebp], eax
	cmp	DWORD PTR _dir$[ebp], 0
	je	SHORT $LN4@NumDirFile
$LN3@NumDirFile:

; 17   : 	{
; 18   : 		while((ent=readdir(dir))!=NULL)

	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	_readdir
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax
	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN2@NumDirFile

; 19   : 		{
; 20   : 			strcpy(content[i],ent->d_name);

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	movzx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 9
	add	ecx, DWORD PTR _content$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 21   : 			i++;

	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax

; 22   : 			filenum++;

	mov	ax, WORD PTR _filenum$[ebp]
	add	ax, 1
	mov	WORD PTR _filenum$[ebp], ax

; 23   : 		}

	jmp	SHORT $LN3@NumDirFile
$LN2@NumDirFile:

; 24   : 
; 25   : 		closedir(dir);

	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	_closedir
	add	esp, 4

; 26   : 	}
; 27   : 	else

	jmp	SHORT $LN1@NumDirFile
$LN4@NumDirFile:

; 28   : 	{
; 29   : 		LogApp("Coulnd not open directory");

	push	OFFSET ??_C@_0BK@DEPFCNDH@Coulnd?5not?5open?5directory?$AA@
	call	_SDL_Log
	add	esp, 4

; 30   : 		return -1;

	or	eax, -1
	jmp	SHORT $LN5@NumDirFile
$LN1@NumDirFile:

; 31   : 	}
; 32   : 
; 33   : 	return filenum;

	mov	ax, WORD PTR _filenum$[ebp]
$LN5@NumDirFile:

; 34   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_NumDirFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\dirent.h
;	COMDAT _dirent_set_errno
_TEXT	SEGMENT
_error$ = 8						; size = 4
_dirent_set_errno PROC					; COMDAT

; 819  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 820  : #if defined(_MSC_VER)  &&  _MSC_VER >= 1400
; 821  : 
; 822  :     /* Microsoft Visual Studio 2005 and later */
; 823  :     _set_errno (error);

	mov	eax, DWORD PTR _error$[ebp]
	push	eax
	call	__set_errno
	add	esp, 4

; 824  : 
; 825  : #else
; 826  : 
; 827  :     /* Non-Microsoft compiler or older Microsoft compiler */
; 828  :     errno = error;
; 829  : 
; 830  : #endif
; 831  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_dirent_set_errno ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\dirent.h
;	COMDAT _dirent_wcstombs_s
_TEXT	SEGMENT
_error$ = -8						; size = 4
_pReturnValue$ = 8					; size = 4
_mbstr$ = 12						; size = 4
_sizeInBytes$ = 16					; size = 4
_wcstr$ = 20						; size = 4
_count$ = 24						; size = 4
_dirent_wcstombs_s PROC					; COMDAT

; 770  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 771  :     int error;
; 772  : 
; 773  : #if defined(_MSC_VER)  &&  _MSC_VER >= 1400
; 774  : 
; 775  :     /* Microsoft Visual Studio 2005 or later */
; 776  :     error = wcstombs_s (pReturnValue, mbstr, sizeInBytes, wcstr, count);

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wcstr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sizeInBytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _mbstr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pReturnValue$[ebp]
	push	ecx
	call	_wcstombs_s
	add	esp, 20					; 00000014H
	mov	DWORD PTR _error$[ebp], eax

; 777  : 
; 778  : #else
; 779  : 
; 780  :     /* Older Visual Studio or non-Microsoft compiler */
; 781  :     size_t n;
; 782  : 
; 783  :     /* Convert to multi-byte string (or count the number of bytes needed) */
; 784  :     n = wcstombs (mbstr, wcstr, sizeInBytes);
; 785  :     if (!mbstr  ||  n < count) {
; 786  : 
; 787  :         /* Zero-terminate output buffer */
; 788  :         if (mbstr  &&  sizeInBytes) {
; 789  :             if (n >= sizeInBytes) {
; 790  :                 n = sizeInBytes - 1;
; 791  :             }
; 792  :             mbstr[n] = '\0';
; 793  :         }
; 794  : 
; 795  :         /* Lenght of resulting multi-bytes string WITH zero-terminator */
; 796  :         if (pReturnValue) {
; 797  :             *pReturnValue = n + 1;
; 798  :         }
; 799  : 
; 800  :         /* Success */
; 801  :         error = 0;
; 802  : 
; 803  :     } else {
; 804  : 
; 805  :         /* Cannot convert string */
; 806  :         error = 1;
; 807  : 
; 808  :     }
; 809  : 
; 810  : #endif
; 811  : 
; 812  :     return error;

	mov	eax, DWORD PTR _error$[ebp]

; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_dirent_wcstombs_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\dirent.h
;	COMDAT _dirent_mbstowcs_s
_TEXT	SEGMENT
_error$ = -8						; size = 4
_pReturnValue$ = 8					; size = 4
_wcstr$ = 12						; size = 4
_sizeInWords$ = 16					; size = 4
_mbstr$ = 20						; size = 4
_count$ = 24						; size = 4
_dirent_mbstowcs_s PROC					; COMDAT

; 717  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 718  :     int error;
; 719  : 
; 720  : #if defined(_MSC_VER)  &&  _MSC_VER >= 1400
; 721  : 
; 722  :     /* Microsoft Visual Studio 2005 or later */
; 723  :     error = mbstowcs_s (pReturnValue, wcstr, sizeInWords, mbstr, count);

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mbstr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sizeInWords$[ebp]
	push	edx
	mov	eax, DWORD PTR _wcstr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pReturnValue$[ebp]
	push	ecx
	call	_mbstowcs_s
	add	esp, 20					; 00000014H
	mov	DWORD PTR _error$[ebp], eax

; 724  : 
; 725  : #else
; 726  : 
; 727  :     /* Older Visual Studio or non-Microsoft compiler */
; 728  :     size_t n;
; 729  : 
; 730  :     /* Convert to wide-character string (or count characters) */
; 731  :     n = mbstowcs (wcstr, mbstr, sizeInWords);
; 732  :     if (!wcstr  ||  n < count) {
; 733  : 
; 734  :         /* Zero-terminate output buffer */
; 735  :         if (wcstr  &&  sizeInWords) {
; 736  :             if (n >= sizeInWords) {
; 737  :                 n = sizeInWords - 1;
; 738  :             }
; 739  :             wcstr[n] = 0;
; 740  :         }
; 741  : 
; 742  :         /* Length of resuting multi-byte string WITH zero terminator */
; 743  :         if (pReturnValue) {
; 744  :             *pReturnValue = n + 1;
; 745  :         }
; 746  : 
; 747  :         /* Success */
; 748  :         error = 0;
; 749  : 
; 750  :     } else {
; 751  : 
; 752  :         /* Could not convert string */
; 753  :         error = 1;
; 754  : 
; 755  :     }
; 756  : 
; 757  : #endif
; 758  : 
; 759  :     return error;

	mov	eax, DWORD PTR _error$[ebp]

; 760  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_dirent_mbstowcs_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\dirent.h
;	COMDAT _dirent_next
_TEXT	SEGMENT
_p$ = -8						; size = 4
_dirp$ = 8						; size = 4
_dirent_next PROC					; COMDAT

; 485  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 486  :     WIN32_FIND_DATAW *p;
; 487  : 
; 488  :     /* Get next directory entry */
; 489  :     if (dirp->cached != 0) {

	mov	eax, DWORD PTR _dirp$[ebp]
	cmp	DWORD PTR [eax+1128], 0
	je	SHORT $LN6@dirent_nex

; 490  : 
; 491  :         /* A valid directory entry already in memory */
; 492  :         p = &dirp->data;

	mov	eax, DWORD PTR _dirp$[ebp]
	add	eax, 536				; 00000218H
	mov	DWORD PTR _p$[ebp], eax

; 493  :         dirp->cached = 0;

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	DWORD PTR [eax+1128], 0
	jmp	SHORT $LN5@dirent_nex
$LN6@dirent_nex:

; 494  : 
; 495  :     } else if (dirp->handle != INVALID_HANDLE_VALUE) {

	mov	eax, DWORD PTR _dirp$[ebp]
	cmp	DWORD PTR [eax+1132], -1
	je	SHORT $LN4@dirent_nex

; 496  : 
; 497  :         /* Get the next directory entry from stream */
; 498  :         if (FindNextFileW (dirp->handle, &dirp->data) != FALSE) {

	mov	eax, DWORD PTR _dirp$[ebp]
	add	eax, 536				; 00000218H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _dirp$[ebp]
	mov	edx, DWORD PTR [ecx+1132]
	push	edx
	call	DWORD PTR __imp__FindNextFileW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN3@dirent_nex

; 499  :             /* Got a file */
; 500  :             p = &dirp->data;

	mov	eax, DWORD PTR _dirp$[ebp]
	add	eax, 536				; 00000218H
	mov	DWORD PTR _p$[ebp], eax

; 501  :         } else {

	jmp	SHORT $LN2@dirent_nex
$LN3@dirent_nex:

; 502  :             /* The very last entry has been processed or an error occured */
; 503  :             FindClose (dirp->handle);

	mov	esi, esp
	mov	eax, DWORD PTR _dirp$[ebp]
	mov	ecx, DWORD PTR [eax+1132]
	push	ecx
	call	DWORD PTR __imp__FindClose@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 504  :             dirp->handle = INVALID_HANDLE_VALUE;

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	DWORD PTR [eax+1132], -1

; 505  :             p = NULL;

	mov	DWORD PTR _p$[ebp], 0
$LN2@dirent_nex:

; 506  :         }
; 507  : 
; 508  :     } else {

	jmp	SHORT $LN5@dirent_nex
$LN4@dirent_nex:

; 509  : 
; 510  :         /* End of directory stream reached */
; 511  :         p = NULL;

	mov	DWORD PTR _p$[ebp], 0
$LN5@dirent_nex:

; 512  : 
; 513  :     }
; 514  : 
; 515  :     return p;

	mov	eax, DWORD PTR _p$[ebp]

; 516  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_dirent_next ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\dirent.h
;	COMDAT _dirent_first
_TEXT	SEGMENT
_datap$ = -8						; size = 4
_dirp$ = 8						; size = 4
_dirent_first PROC					; COMDAT

; 460  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 461  :     WIN32_FIND_DATAW *datap;
; 462  : 
; 463  :     /* Open directory and retrieve the first entry */
; 464  :     dirp->handle = FindFirstFileW (dirp->patt, &dirp->data);

	mov	eax, DWORD PTR _dirp$[ebp]
	add	eax, 536				; 00000218H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _dirp$[ebp]
	mov	edx, DWORD PTR [ecx+1136]
	push	edx
	call	DWORD PTR __imp__FindFirstFileW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _dirp$[ebp]
	mov	DWORD PTR [ecx+1132], eax

; 465  :     if (dirp->handle != INVALID_HANDLE_VALUE) {

	mov	eax, DWORD PTR _dirp$[ebp]
	cmp	DWORD PTR [eax+1132], -1
	je	SHORT $LN2@dirent_fir

; 466  : 
; 467  :         /* a directory entry is now waiting in memory */
; 468  :         datap = &dirp->data;

	mov	eax, DWORD PTR _dirp$[ebp]
	add	eax, 536				; 00000218H
	mov	DWORD PTR _datap$[ebp], eax

; 469  :         dirp->cached = 1;

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	DWORD PTR [eax+1128], 1

; 470  : 
; 471  :     } else {

	jmp	SHORT $LN1@dirent_fir
$LN2@dirent_fir:

; 472  : 
; 473  :         /* Failed to re-open directory: no directory entry in memory */
; 474  :         dirp->cached = 0;

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	DWORD PTR [eax+1128], 0

; 475  :         datap = NULL;

	mov	DWORD PTR _datap$[ebp], 0
$LN1@dirent_fir:

; 476  : 
; 477  :     }
; 478  :     return datap;

	mov	eax, DWORD PTR _datap$[ebp]

; 479  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_dirent_first ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\dirent.h
;	COMDAT _closedir
_TEXT	SEGMENT
_ok$ = -8						; size = 4
_dirp$ = 8						; size = 4
_closedir PROC						; COMDAT

; 677  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 678  :     int ok;
; 679  :     if (dirp) {

	cmp	DWORD PTR _dirp$[ebp], 0
	je	SHORT $LN2@closedir

; 680  : 
; 681  :         /* Close wide-character directory stream */
; 682  :         ok = _wclosedir (dirp->wdirp);

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	ecx, DWORD PTR [eax+276]
	push	ecx
	call	__wclosedir
	add	esp, 4
	mov	DWORD PTR _ok$[ebp], eax

; 683  :         dirp->wdirp = NULL;

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	DWORD PTR [eax+276], 0

; 684  : 
; 685  :         /* Release multi-byte character version */
; 686  :         free (dirp);

	mov	eax, DWORD PTR _dirp$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 687  : 
; 688  :     } else {

	jmp	SHORT $LN1@closedir
$LN2@closedir:

; 689  : 
; 690  :         /* Invalid directory stream */
; 691  :         dirent_set_errno (EBADF);

	push	9
	call	_dirent_set_errno
	add	esp, 4

; 692  :         ok = /*failure*/-1;

	mov	DWORD PTR _ok$[ebp], -1
$LN1@closedir:

; 693  : 
; 694  :     }
; 695  :     return ok;

	mov	eax, DWORD PTR _ok$[ebp]

; 696  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_closedir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\dirent.h
;	COMDAT _readdir
_TEXT	SEGMENT
_attr$1 = -56						; size = 4
_error$2 = -44						; size = 4
_n$3 = -32						; size = 4
_entp$ = -20						; size = 4
_datap$ = -8						; size = 4
_dirp$ = 8						; size = 4
_readdir PROC						; COMDAT

; 594  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 595  :     WIN32_FIND_DATAW *datap;
; 596  :     struct dirent *entp;
; 597  : 
; 598  :     /* Read next directory entry */
; 599  :     datap = dirent_next (dirp->wdirp);

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	ecx, DWORD PTR [eax+276]
	push	ecx
	call	_dirent_next
	add	esp, 4
	mov	DWORD PTR _datap$[ebp], eax

; 600  :     if (datap) {

	cmp	DWORD PTR _datap$[ebp], 0
	je	$LN9@readdir

; 601  :         size_t n;
; 602  :         int error;
; 603  : 
; 604  :         /* Attempt to convert file name to multi-byte string */
; 605  :         error = dirent_wcstombs_s(
; 606  :             &n, dirp->ent.d_name, PATH_MAX, datap->cFileName, PATH_MAX);

	push	260					; 00000104H
	mov	eax, DWORD PTR _datap$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	push	260					; 00000104H
	mov	ecx, DWORD PTR _dirp$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	lea	edx, DWORD PTR _n$3[ebp]
	push	edx
	call	_dirent_wcstombs_s
	add	esp, 20					; 00000014H
	mov	DWORD PTR _error$2[ebp], eax

; 607  : 
; 608  :         /* 
; 609  :          * If the file name cannot be represented by a multi-byte string,
; 610  :          * then attempt to use old 8+3 file name.  This allows traditional
; 611  :          * Unix-code to access some file names despite of unicode
; 612  :          * characters, although file names may seem unfamiliar to the user.
; 613  :          *
; 614  :          * Be ware that the code below cannot come up with a short file
; 615  :          * name unless the file system provides one.  At least
; 616  :          * VirtualBox shared folders fail to do this.
; 617  :          */
; 618  :         if (error  &&  datap->cAlternateFileName[0] != '\0') {

	cmp	DWORD PTR _error$2[ebp], 0
	je	SHORT $LN8@readdir
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _datap$[ebp]
	movzx	eax, WORD PTR [edx+ecx+564]
	test	eax, eax
	je	SHORT $LN8@readdir

; 619  :             error = dirent_wcstombs_s(
; 620  :                 &n, dirp->ent.d_name, PATH_MAX, 
; 621  :                 datap->cAlternateFileName, PATH_MAX);

	push	260					; 00000104H
	mov	eax, DWORD PTR _datap$[ebp]
	add	eax, 564				; 00000234H
	push	eax
	push	260					; 00000104H
	mov	ecx, DWORD PTR _dirp$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	lea	edx, DWORD PTR _n$3[ebp]
	push	edx
	call	_dirent_wcstombs_s
	add	esp, 20					; 00000014H
	mov	DWORD PTR _error$2[ebp], eax
$LN8@readdir:

; 622  :         }
; 623  : 
; 624  :         if (!error) {

	cmp	DWORD PTR _error$2[ebp], 0
	jne	SHORT $LN7@readdir

; 625  :             DWORD attr;
; 626  : 
; 627  :             /* Initialize directory entry for return */
; 628  :             entp = &dirp->ent;

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	DWORD PTR _entp$[ebp], eax

; 629  : 
; 630  :             /* Length of file name excluding zero terminator */
; 631  :             entp->d_namlen = n - 1;

	mov	eax, DWORD PTR _n$3[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _entp$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 632  : 
; 633  :             /* File attributes */
; 634  :             attr = datap->dwFileAttributes;

	mov	eax, DWORD PTR _datap$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _attr$1[ebp], ecx

; 635  :             if ((attr & FILE_ATTRIBUTE_DEVICE) != 0) {

	mov	eax, DWORD PTR _attr$1[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN6@readdir

; 636  :                 entp->d_type = DT_CHR;

	mov	eax, DWORD PTR _entp$[ebp]
	mov	DWORD PTR [eax+12], 8192		; 00002000H
	jmp	SHORT $LN5@readdir
$LN6@readdir:

; 637  :             } else if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0) {

	mov	eax, DWORD PTR _attr$1[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN4@readdir

; 638  :                 entp->d_type = DT_DIR;

	mov	eax, DWORD PTR _entp$[ebp]
	mov	DWORD PTR [eax+12], 16384		; 00004000H

; 639  :             } else {

	jmp	SHORT $LN5@readdir
$LN4@readdir:

; 640  :                 entp->d_type = DT_REG;

	mov	eax, DWORD PTR _entp$[ebp]
	mov	DWORD PTR [eax+12], 32768		; 00008000H
$LN5@readdir:

; 641  :             }
; 642  : 
; 643  :             /* Reset dummy fields */
; 644  :             entp->d_ino = 0;

	mov	eax, DWORD PTR _entp$[ebp]
	mov	DWORD PTR [eax], 0

; 645  :             entp->d_reclen = sizeof (struct dirent);

	mov	eax, 276				; 00000114H
	mov	ecx, DWORD PTR _entp$[ebp]
	mov	WORD PTR [ecx+4], ax

; 646  : 
; 647  :         } else {

	jmp	SHORT $LN2@readdir
$LN7@readdir:

; 648  :             /* 
; 649  :              * Cannot convert file name to multi-byte string so construct
; 650  :              * an errornous directory entry and return that.  Note that
; 651  :              * we cannot return NULL as that would stop the processing
; 652  :              * of directory entries completely.
; 653  :              */
; 654  :             entp = &dirp->ent;

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	DWORD PTR _entp$[ebp], eax

; 655  :             entp->d_name[0] = '?';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _entp$[ebp]
	mov	BYTE PTR [edx+ecx+16], 63		; 0000003fH

; 656  :             entp->d_name[1] = '\0';

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _entp$[ebp]
	mov	BYTE PTR [ecx+eax+16], 0

; 657  :             entp->d_namlen = 1;

	mov	eax, DWORD PTR _entp$[ebp]
	mov	DWORD PTR [eax+8], 1

; 658  :             entp->d_type = DT_UNKNOWN;

	mov	eax, DWORD PTR _entp$[ebp]
	mov	DWORD PTR [eax+12], 0

; 659  :             entp->d_ino = 0;

	mov	eax, DWORD PTR _entp$[ebp]
	mov	DWORD PTR [eax], 0

; 660  :             entp->d_reclen = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _entp$[ebp]
	mov	WORD PTR [ecx+4], ax
$LN2@readdir:

; 661  :         }
; 662  : 
; 663  :     } else {

	jmp	SHORT $LN1@readdir
$LN9@readdir:

; 664  :         /* No more directory entries */
; 665  :         entp = NULL;

	mov	DWORD PTR _entp$[ebp], 0
$LN1@readdir:

; 666  :     }
; 667  : 
; 668  :     return entp;

	mov	eax, DWORD PTR _entp$[ebp]

; 669  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@readdir
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@readdir:
	DD	1
	DD	$LN13@readdir
$LN13@readdir:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN12@readdir
$LN12@readdir:
	DB	110					; 0000006eH
	DB	0
_readdir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\dirent.h
;	COMDAT _opendir
_TEXT	SEGMENT
_n$1 = -564						; size = 4
_wname$2 = -552						; size = 520
_error$ = -24						; size = 4
_dirp$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_dirname$ = 8						; size = 4
_opendir PROC						; COMDAT

; 524  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 760				; 000002f8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-760]
	mov	ecx, 190				; 000000beH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 525  :     struct DIR *dirp;
; 526  :     int error;
; 527  : 
; 528  :     /* Must have directory name */
; 529  :     if (dirname == NULL  ||  dirname[0] == '\0') {

	cmp	DWORD PTR _dirname$[ebp], 0
	je	SHORT $LN8@opendir
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dirname$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN9@opendir
$LN8@opendir:

; 530  :         dirent_set_errno (ENOENT);

	push	2
	call	_dirent_set_errno
	add	esp, 4

; 531  :         return NULL;

	xor	eax, eax
	jmp	$LN10@opendir
$LN9@opendir:

; 532  :     }
; 533  : 
; 534  :     /* Allocate memory for DIR structure */
; 535  :     dirp = (DIR*) malloc (sizeof (struct DIR));

	push	280					; 00000118H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _dirp$[ebp], eax

; 536  :     if (dirp) {

	cmp	DWORD PTR _dirp$[ebp], 0
	je	SHORT $LN7@opendir

; 537  :         wchar_t wname[PATH_MAX];
; 538  :         size_t n;
; 539  : 
; 540  :         /* Convert directory name to wide-character string */
; 541  :         error = dirent_mbstowcs_s (&n, wname, PATH_MAX, dirname, PATH_MAX);

	push	260					; 00000104H
	mov	eax, DWORD PTR _dirname$[ebp]
	push	eax
	push	260					; 00000104H
	lea	ecx, DWORD PTR _wname$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _n$1[ebp]
	push	edx
	call	_dirent_mbstowcs_s
	add	esp, 20					; 00000014H
	mov	DWORD PTR _error$[ebp], eax

; 542  :         if (!error) {

	cmp	DWORD PTR _error$[ebp], 0
	jne	SHORT $LN6@opendir

; 543  : 
; 544  :             /* Open directory stream using wide-character name */
; 545  :             dirp->wdirp = _wopendir (wname);

	lea	eax, DWORD PTR _wname$2[ebp]
	push	eax
	call	__wopendir
	add	esp, 4
	mov	ecx, DWORD PTR _dirp$[ebp]
	mov	DWORD PTR [ecx+276], eax

; 546  :             if (dirp->wdirp) {

	mov	eax, DWORD PTR _dirp$[ebp]
	cmp	DWORD PTR [eax+276], 0
	je	SHORT $LN5@opendir

; 547  :                 /* Directory stream opened */
; 548  :                 error = 0;

	mov	DWORD PTR _error$[ebp], 0

; 549  :             } else {

	jmp	SHORT $LN4@opendir
$LN5@opendir:

; 550  :                 /* Failed to open directory stream */
; 551  :                 error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN4@opendir:

; 552  :             }
; 553  : 
; 554  :         } else {

	jmp	SHORT $LN3@opendir
$LN6@opendir:

; 555  :             /* 
; 556  :              * Cannot convert file name to wide-character string.  This
; 557  :              * occurs if the string contains invalid multi-byte sequences or
; 558  :              * the output buffer is too small to contain the resulting
; 559  :              * string.
; 560  :              */
; 561  :             error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN3@opendir:

; 562  :         }
; 563  : 
; 564  :     } else {

	jmp	SHORT $LN2@opendir
$LN7@opendir:

; 565  :         /* Cannot allocate DIR structure */
; 566  :         error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN2@opendir:

; 567  :     }
; 568  : 
; 569  :     /* Clean up in case of error */
; 570  :     if (error  &&  dirp) {

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN1@opendir
	cmp	DWORD PTR _dirp$[ebp], 0
	je	SHORT $LN1@opendir

; 571  :         free (dirp);

	mov	eax, DWORD PTR _dirp$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 572  :         dirp = NULL;

	mov	DWORD PTR _dirp$[ebp], 0
$LN1@opendir:

; 573  :     }
; 574  : 
; 575  :     return dirp;

	mov	eax, DWORD PTR _dirp$[ebp]
$LN10@opendir:

; 576  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@opendir
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 760				; 000002f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@opendir:
	DD	2
	DD	$LN14@opendir
$LN14@opendir:
	DD	-552					; fffffdd8H
	DD	520					; 00000208H
	DD	$LN12@opendir
	DD	-564					; fffffdccH
	DD	4
	DD	$LN13@opendir
$LN13@opendir:
	DB	110					; 0000006eH
	DB	0
$LN12@opendir:
	DB	119					; 00000077H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_opendir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\dirent.h
;	COMDAT __wclosedir
_TEXT	SEGMENT
_ok$ = -8						; size = 4
_dirp$ = 8						; size = 4
__wclosedir PROC					; COMDAT

; 409  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 410  :     int ok;
; 411  :     if (dirp) {

	cmp	DWORD PTR _dirp$[ebp], 0
	je	SHORT $LN4@wclosedir

; 412  : 
; 413  :         /* Release search handle */
; 414  :         if (dirp->handle != INVALID_HANDLE_VALUE) {

	mov	eax, DWORD PTR _dirp$[ebp]
	cmp	DWORD PTR [eax+1132], -1
	je	SHORT $LN3@wclosedir

; 415  :             FindClose (dirp->handle);

	mov	esi, esp
	mov	eax, DWORD PTR _dirp$[ebp]
	mov	ecx, DWORD PTR [eax+1132]
	push	ecx
	call	DWORD PTR __imp__FindClose@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 416  :             dirp->handle = INVALID_HANDLE_VALUE;

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	DWORD PTR [eax+1132], -1
$LN3@wclosedir:

; 417  :         }
; 418  : 
; 419  :         /* Release search pattern */
; 420  :         if (dirp->patt) {

	mov	eax, DWORD PTR _dirp$[ebp]
	cmp	DWORD PTR [eax+1136], 0
	je	SHORT $LN2@wclosedir

; 421  :             free (dirp->patt);

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	ecx, DWORD PTR [eax+1136]
	push	ecx
	call	_free
	add	esp, 4

; 422  :             dirp->patt = NULL;

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	DWORD PTR [eax+1136], 0
$LN2@wclosedir:

; 423  :         }
; 424  : 
; 425  :         /* Release directory structure */
; 426  :         free (dirp);

	mov	eax, DWORD PTR _dirp$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 427  :         ok = /*success*/0;

	mov	DWORD PTR _ok$[ebp], 0

; 428  : 
; 429  :     } else {

	jmp	SHORT $LN1@wclosedir
$LN4@wclosedir:

; 430  :         /* Invalid directory stream */
; 431  :         dirent_set_errno (EBADF);

	push	9
	call	_dirent_set_errno
	add	esp, 4

; 432  :         ok = /*failure*/-1;

	mov	DWORD PTR _ok$[ebp], -1
$LN1@wclosedir:

; 433  :     }
; 434  :     return ok;

	mov	eax, DWORD PTR _ok$[ebp]

; 435  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__wclosedir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\dirent.h
;	COMDAT __wopendir
_TEXT	SEGMENT
tv135 = -244						; size = 4
_p$1 = -44						; size = 4
_n$2 = -32						; size = 4
_error$ = -20						; size = 4
_dirp$ = -8						; size = 4
_dirname$ = 8						; size = 4
__wopendir PROC						; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 251  :     _WDIR *dirp = NULL;

	mov	DWORD PTR _dirp$[ebp], 0

; 252  :     int error;
; 253  : 
; 254  :     /* Must have directory name */
; 255  :     if (dirname == NULL  ||  dirname[0] == '\0') {

	cmp	DWORD PTR _dirname$[ebp], 0
	je	SHORT $LN15@wopendir
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dirname$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN16@wopendir
$LN15@wopendir:

; 256  :         dirent_set_errno (ENOENT);

	push	2
	call	_dirent_set_errno
	add	esp, 4

; 257  :         return NULL;

	xor	eax, eax
	jmp	$LN17@wopendir
$LN16@wopendir:

; 258  :     }
; 259  : 
; 260  :     /* Allocate new _WDIR structure */
; 261  :     dirp = (_WDIR*) malloc (sizeof (struct _WDIR));

	push	1140					; 00000474H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _dirp$[ebp], eax

; 262  :     if (dirp != NULL) {

	cmp	DWORD PTR _dirp$[ebp], 0
	je	$LN14@wopendir

; 263  :         DWORD n;
; 264  : 
; 265  :         /* Reset _WDIR structure */
; 266  :         dirp->handle = INVALID_HANDLE_VALUE;

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	DWORD PTR [eax+1132], -1

; 267  :         dirp->patt = NULL;

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	DWORD PTR [eax+1136], 0

; 268  :         dirp->cached = 0;

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	DWORD PTR [eax+1128], 0

; 269  : 
; 270  :         /* Compute the length of full path plus zero terminator */
; 271  :         n = GetFullPathNameW (dirname, 0, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _dirname$[ebp]
	push	eax
	call	DWORD PTR __imp__GetFullPathNameW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _n$2[ebp], eax

; 272  : 
; 273  :         /* Allocate room for absolute directory name and search pattern */
; 274  :         dirp->patt = (wchar_t*) malloc (sizeof (wchar_t) * n + 16);

	mov	eax, DWORD PTR _n$2[ebp]
	lea	ecx, DWORD PTR [eax+eax+16]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _dirp$[ebp]
	mov	DWORD PTR [edx+1136], eax

; 275  :         if (dirp->patt) {

	mov	eax, DWORD PTR _dirp$[ebp]
	cmp	DWORD PTR [eax+1136], 0
	je	$LN13@wopendir

; 276  : 
; 277  :             /*
; 278  :              * Convert relative directory name to an absolute one.  This
; 279  :              * allows rewinddir() to function correctly even when current
; 280  :              * working directory is changed between opendir() and rewinddir().
; 281  :              */
; 282  :             n = GetFullPathNameW (dirname, n, dirp->patt, NULL);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _dirp$[ebp]
	mov	ecx, DWORD PTR [eax+1136]
	push	ecx
	mov	edx, DWORD PTR _n$2[ebp]
	push	edx
	mov	eax, DWORD PTR _dirname$[ebp]
	push	eax
	call	DWORD PTR __imp__GetFullPathNameW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _n$2[ebp], eax

; 283  :             if (n > 0) {

	cmp	DWORD PTR _n$2[ebp], 0
	jbe	$LN12@wopendir

; 284  :                 wchar_t *p;
; 285  : 
; 286  :                 /* Append search pattern \* to the directory name */
; 287  :                 p = dirp->patt + n;

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	ecx, DWORD PTR [eax+1136]
	mov	edx, DWORD PTR _n$2[ebp]
	lea	eax, DWORD PTR [ecx+edx*2]
	mov	DWORD PTR _p$1[ebp], eax

; 288  :                 if (dirp->patt < p) {

	mov	eax, DWORD PTR _dirp$[ebp]
	mov	ecx, DWORD PTR [eax+1136]
	cmp	ecx, DWORD PTR _p$1[ebp]
	jae	SHORT $LN11@wopendir

; 289  :                     switch (p[-1]) {

	mov	eax, 2
	imul	ecx, eax, -1
	mov	edx, DWORD PTR _p$1[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR tv135[ebp], eax
	cmp	DWORD PTR tv135[ebp], 47		; 0000002fH
	je	SHORT $LN8@wopendir
	cmp	DWORD PTR tv135[ebp], 58		; 0000003aH
	je	SHORT $LN8@wopendir
	cmp	DWORD PTR tv135[ebp], 92		; 0000005cH
	je	SHORT $LN8@wopendir
	jmp	SHORT $LN7@wopendir
$LN8@wopendir:

; 290  :                     case '\\':
; 291  :                     case '/':
; 292  :                     case ':':
; 293  :                         /* Directory ends in path separator, e.g. c:\temp\ */
; 294  :                         /*NOP*/;
; 295  :                         break;

	jmp	SHORT $LN11@wopendir
$LN7@wopendir:

; 296  : 
; 297  :                     default:
; 298  :                         /* Directory name doesn't end in path separator */
; 299  :                         *p++ = '\\';

	mov	eax, 92					; 0000005cH
	mov	ecx, DWORD PTR _p$1[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _p$1[ebp]
	add	edx, 2
	mov	DWORD PTR _p$1[ebp], edx
$LN11@wopendir:

; 300  :                     }
; 301  :                 }
; 302  :                 *p++ = '*';

	mov	eax, 42					; 0000002aH
	mov	ecx, DWORD PTR _p$1[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _p$1[ebp]
	add	edx, 2
	mov	DWORD PTR _p$1[ebp], edx

; 303  :                 *p = '\0';

	xor	eax, eax
	mov	ecx, DWORD PTR _p$1[ebp]
	mov	WORD PTR [ecx], ax

; 304  : 
; 305  :                 /* Open directory stream and retrieve the first entry */
; 306  :                 if (dirent_first (dirp)) {

	mov	eax, DWORD PTR _dirp$[ebp]
	push	eax
	call	_dirent_first
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@wopendir

; 307  :                     /* Directory stream opened successfully */
; 308  :                     error = 0;

	mov	DWORD PTR _error$[ebp], 0

; 309  :                 } else {

	jmp	SHORT $LN5@wopendir
$LN6@wopendir:

; 310  :                     /* Cannot retrieve first entry */
; 311  :                     error = 1;

	mov	DWORD PTR _error$[ebp], 1

; 312  :                     dirent_set_errno (ENOENT);

	push	2
	call	_dirent_set_errno
	add	esp, 4
$LN5@wopendir:

; 313  :                 }
; 314  : 
; 315  :             } else {

	jmp	SHORT $LN4@wopendir
$LN12@wopendir:

; 316  :                 /* Cannot retrieve full path name */
; 317  :                 dirent_set_errno (ENOENT);

	push	2
	call	_dirent_set_errno
	add	esp, 4

; 318  :                 error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN4@wopendir:

; 319  :             }
; 320  : 
; 321  :         } else {

	jmp	SHORT $LN3@wopendir
$LN13@wopendir:

; 322  :             /* Cannot allocate memory for search pattern */
; 323  :             error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN3@wopendir:

; 324  :         }
; 325  : 
; 326  :     } else {

	jmp	SHORT $LN2@wopendir
$LN14@wopendir:

; 327  :         /* Cannot allocate _WDIR structure */
; 328  :         error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN2@wopendir:

; 329  :     }
; 330  : 
; 331  :     /* Clean up in case of error */
; 332  :     if (error  &&  dirp) {

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN1@wopendir
	cmp	DWORD PTR _dirp$[ebp], 0
	je	SHORT $LN1@wopendir

; 333  :         _wclosedir (dirp);

	mov	eax, DWORD PTR _dirp$[ebp]
	push	eax
	call	__wclosedir
	add	esp, 4

; 334  :         dirp = NULL;

	mov	DWORD PTR _dirp$[ebp], 0
$LN1@wopendir:

; 335  :     }
; 336  : 
; 337  :     return dirp;

	mov	eax, DWORD PTR _dirp$[ebp]
$LN17@wopendir:

; 338  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__wopendir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIButton
_TEXT	SEGMENT
_gsizew$ = -32						; size = 2
_gsize$ = -20						; size = 2
_text_size$ = -8					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_text$ = 16						; size = 4
_font$ = 20						; size = 1
_font_size$ = 24					; size = 2
_layer$ = 28						; size = 1
_select_mode$ = 32					; size = 1
_UIButton PROC						; COMDAT

; 478  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 479  : 	int32 text_size;
; 480  : 	int16 gsize, gsizew;
; 481  : 
; 482  : 	gsize = (st.fonts[font].size_h_gm*font_size) / FONT_SIZE;

	movsx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	movsx	edx, WORD PTR _font_size$[ebp]
	imul	edx, DWORD PTR _st[ecx+64360]
	shr	edx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], dx

; 483  : 	gsizew = (st.fonts[font].size_w_gm*font_size) / FONT_SIZE;

	movsx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	movsx	edx, WORD PTR _font_size$[ebp]
	imul	edx, DWORD PTR _st[ecx+64356]
	shr	edx, 10					; 0000000aH
	mov	WORD PTR _gsizew$[ebp], dx

; 484  : 
; 485  : 	text_size = gsizew*strlen(text);

	movsx	esi, WORD PTR _gsizew$[ebp]
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	imul	esi, eax
	mov	DWORD PTR _text_size$[ebp], esi

; 486  : 
; 487  : 	if (CheckCollisionMouse(x, y, text_size, gsize, 0))

	push	0
	movsx	eax, WORD PTR _gsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@UIButton

; 488  : 	{
; 489  : 		if (st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN6@UIButton

; 490  : 		{
; 491  : 			st.mouse1 = 0;

	mov	BYTE PTR _st+65636, 0

; 492  : 
; 493  : 			if (select_mode==1) select_mode = 0;

	movzx	eax, BYTE PTR _select_mode$[ebp]
	cmp	eax, 1
	jne	SHORT $LN4@UIButton
	mov	BYTE PTR _select_mode$[ebp], 0
	jmp	SHORT $LN6@UIButton
$LN4@UIButton:

; 494  : 			else select_mode = 1;

	mov	BYTE PTR _select_mode$[ebp], 1
$LN6@UIButton:

; 495  : 		}
; 496  : 	}
; 497  : 
; 498  : 	if (select_mode)

	movzx	eax, BYTE PTR _select_mode$[ebp]
	test	eax, eax
	je	$LN2@UIButton

; 499  : 	{
; 500  : 		UIData(x, y, text_size + 512, gsize + 512, 0, 255, 255, 255, 0, 0, TEX_PAN_RANGE, TEX_PAN_RANGE, mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.button_frame2], 255, layer);

	movzx	eax, BYTE PTR _layer$[ebp]
	push	eax
	push	255					; 000000ffH
	movsx	ecx, BYTE PTR _UI_Sys
	imul	edx, ecx, 60
	movsx	eax, BYTE PTR _UI_Sys+7
	imul	ecx, eax, 40
	mov	esi, DWORD PTR _mgg_sys[edx+40]
	add	esi, ecx
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	movsx	edx, WORD PTR _gsize$[ebp]
	add	edx, 512				; 00000200H
	push	edx
	mov	eax, DWORD PTR _text_size$[ebp]
	add	eax, 512				; 00000200H
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_UIData
	add	esp, 96					; 00000060H

; 501  : 		StringUIData(text, x, y, text_size, gsize, 0, 255, 255, 255, 255, font, font_size, font_size, layer);

	movzx	eax, BYTE PTR _layer$[ebp]
	push	eax
	movsx	ecx, WORD PTR _font_size$[ebp]
	push	ecx
	movsx	edx, WORD PTR _font_size$[ebp]
	push	edx
	movzx	eax, BYTE PTR _font$[ebp]
	push	eax
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	movsx	ecx, WORD PTR _gsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	call	_StringUIData
	add	esp, 56					; 00000038H

; 502  : 		return UI_SEL;

	mov	al, 100					; 00000064H
	jmp	$LN7@UIButton

; 503  : 	}
; 504  : 	else

	jmp	$LN7@UIButton
$LN2@UIButton:

; 505  : 	{
; 506  : 		UIData(x, y, text_size + 512, gsize + 512, 0, 255, 255, 255, 0, 0, TEX_PAN_RANGE, TEX_PAN_RANGE, mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.button_frame0], 255, layer);

	movzx	eax, BYTE PTR _layer$[ebp]
	push	eax
	push	255					; 000000ffH
	movsx	ecx, BYTE PTR _UI_Sys
	imul	edx, ecx, 60
	movsx	eax, BYTE PTR _UI_Sys+5
	imul	ecx, eax, 40
	mov	esi, DWORD PTR _mgg_sys[edx+40]
	add	esi, ecx
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	movsx	edx, WORD PTR _gsize$[ebp]
	add	edx, 512				; 00000200H
	push	edx
	mov	eax, DWORD PTR _text_size$[ebp]
	add	eax, 512				; 00000200H
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_UIData
	add	esp, 96					; 00000060H

; 507  : 		StringUIData(text, x, y, text_size, gsize, 0, 0, 0, 0, 255, font, font_size, font_size, layer);

	movzx	eax, BYTE PTR _layer$[ebp]
	push	eax
	movsx	ecx, WORD PTR _font_size$[ebp]
	push	ecx
	movsx	edx, WORD PTR _font_size$[ebp]
	push	edx
	movzx	eax, BYTE PTR _font$[ebp]
	push	eax
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	push	0
	movsx	ecx, WORD PTR _gsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	call	_StringUIData
	add	esp, 56					; 00000038H

; 508  : 		return UI_NULLOP;

	or	al, -1
$LN7@UIButton:

; 509  : 	}
; 510  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UIButton ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIMakeList
_TEXT	SEGMENT
tv521 = -2388						; size = 8
tv459 = -2388						; size = 8
_loop_c$ = -2169					; size = 1
_j$ = -2076						; size = 4
_i$ = -2064						; size = 4
_list$ = 8						; size = 4
_sizel$ = 12						; size = 2
_UIMakeList PROC					; COMDAT

; 2338 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2388				; 00000954H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2388]
	mov	ecx, 597				; 00000255H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2339 : 	char path[2048];
; 2340 : 	int32 i, j, k, l, m, n, o, p;
; 2341 : 	static int32 m_sel=-1, time=0;
; 2342 : 	size_t size;
; 2343 : 	uint8 loop_c=0;

	mov	BYTE PTR _loop_c$[ebp], 0

; 2344 : 
; 2345 : 	UI_Sys.sys_freeze=1;

	mov	BYTE PTR _UI_Sys+2162, 1

; 2346 : 
; 2347 : 	UIData(8192,4608,8192,4608,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.window2_frame],255,1);

	push	1
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+1
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	4608					; 00001200H
	push	8192					; 00002000H
	push	4608					; 00001200H
	push	8192					; 00002000H
	call	_UIData
	add	esp, 96					; 00000060H

; 2348 : 	UIData(8192,4608,8192-512,4608-512,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.window_frame2],255,1);

	push	1
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+4
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	4096					; 00001000H
	push	7680					; 00001e00H
	push	4608					; 00001200H
	push	8192					; 00002000H
	call	_UIData
	add	esp, 96					; 00000060H

; 2349 : 
; 2350 : 	if(sizel>13)

	movsx	eax, WORD PTR _sizel$[ebp]
	cmp	eax, 13					; 0000000dH
	jle	$LN24@UIMakeList

; 2351 : 	{
; 2352 : 		for(i=UI_Sys.mouse_scroll, j=0;i<UI_Sys.mouse_scroll+13;i++)

	mov	eax, DWORD PTR _UI_Sys+2092
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN23@UIMakeList
$LN22@UIMakeList:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN23@UIMakeList:
	mov	eax, DWORD PTR _UI_Sys+2092
	add	eax, 13					; 0000000dH
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN21@UIMakeList

; 2353 : 		{
; 2354 : 			if(i>sizel-1)

	movsx	eax, WORD PTR _sizel$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jle	SHORT $LN20@UIMakeList

; 2355 : 				break;

	jmp	$LN21@UIMakeList
$LN20@UIMakeList:

; 2356 : 
; 2357 : 			if(CheckCollisionMouse(8192,4608-((4608-512)/2)+256+(j*256),8192-512,256,0) && st.mouse1)

	push	0
	push	256					; 00000100H
	push	7680					; 00001e00H
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	8192					; 00002000H
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	ecx, al
	test	ecx, ecx
	je	$LN19@UIMakeList
	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN19@UIMakeList

; 2358 : 			{
; 2359 : 				if((GetTimerM()-time)<50)

	call	@GetTimerM@0
	mov	ecx, eax
	mov	esi, edx
	mov	eax, DWORD PTR ?time@?1??UIMakeList@@9@9
	cdq
	sub	ecx, eax
	sbb	esi, edx
	mov	DWORD PTR tv459[ebp], ecx
	mov	DWORD PTR tv459[ebp+4], esi
	cmp	DWORD PTR tv459[ebp+4], 0
	ja	SHORT $LN18@UIMakeList
	jb	SHORT $LN27@UIMakeList
	cmp	DWORD PTR tv459[ebp], 50		; 00000032H
	jae	SHORT $LN18@UIMakeList
$LN27@UIMakeList:

; 2360 : 				{
; 2361 : 					UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 2362 : 
; 2363 : 					m_sel=-1;

	mov	DWORD PTR ?m_sel@?1??UIMakeList@@9@9, -1

; 2364 : 
; 2365 : 					st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 2366 : 					time=0;

	mov	DWORD PTR ?time@?1??UIMakeList@@9@9, 0

; 2367 : 					
; 2368 : 					return i;

	mov	ax, WORD PTR _i$[ebp]
	jmp	$LN25@UIMakeList
$LN18@UIMakeList:

; 2369 : 				}
; 2370 : 
; 2371 : 				time=GetTimerM();

	call	@GetTimerM@0
	mov	DWORD PTR ?time@?1??UIMakeList@@9@9, eax

; 2372 : 
; 2373 : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0
$LN19@UIMakeList:

; 2374 : 			}
; 2375 : 
; 2376 : 			if (m_sel == i)

	mov	eax, DWORD PTR ?m_sel@?1??UIMakeList@@9@9
	cmp	eax, DWORD PTR _i$[ebp]
	jne	$LN17@UIMakeList

; 2377 : 			{
; 2378 : 				UIData(8192, 4608 - ((4608 - 512) / 2) + 256 + (j * 256), 8192 - 512, 256, 0, 0, 0, 0, 0, 0, TEX_PAN_RANGE, TEX_PAN_RANGE, mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame1], 255, 0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+14
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	256					; 00000100H
	push	7680					; 00001e00H
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 8
	add	ecx, 2816				; 00000b00H
	push	ecx
	push	8192					; 00002000H
	call	_UIData
	add	esp, 96					; 00000060H

; 2379 : 				StringUIvData(list[i], 8192 - ((8192 - 512) / 2) + 256, 4608 - ((4608 - 512) / 2) + 256 + (j * 256), 0, 0, 0, 255, 255, 255, 255, 0, 2048, 2048, 0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _list$[ebp]
	push	ecx
	call	_StringUIvData
	add	esp, 56					; 00000038H

; 2380 : 			}
; 2381 : 			else

	jmp	SHORT $LN16@UIMakeList
$LN17@UIMakeList:

; 2382 : 				StringUIvData(list[i],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(j*256),0,0,0,0,0,0,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _list$[ebp]
	push	ecx
	call	_StringUIvData
	add	esp, 56					; 00000038H
$LN16@UIMakeList:

; 2383 : 
; 2384 : 			j++;

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax

; 2385 : 
; 2386 : 		}

	jmp	$LN22@UIMakeList
$LN21@UIMakeList:

; 2387 : 
; 2388 : 		UIData(8192+((8192-512)/2)-128,4608,256,4608-512,0,128,128,128,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame1],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+14
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	128					; 00000080H
	push	128					; 00000080H
	push	128					; 00000080H
	push	0
	push	4096					; 00001000H
	push	256					; 00000100H
	push	4608					; 00001200H
	push	11904					; 00002e80H
	call	_UIData
	add	esp, 96					; 00000060H

; 2389 : 		UIData(8192+((8192-512)/2)-128,4608-((4608-512)/2)+128,256,128,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame0],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+13
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	128					; 00000080H
	push	256					; 00000100H
	push	2688					; 00000a80H
	push	11904					; 00002e80H
	call	_UIData
	add	esp, 96					; 00000060H

; 2390 : 		UIData(8192+((8192-512)/2)-128,4608+((4608-512)/2)-128,256,128,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame0],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+13
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	128					; 00000080H
	push	256					; 00000100H
	push	6528					; 00001980H
	push	11904					; 00002e80H
	call	_UIData
	add	esp, 96					; 00000060H

; 2391 : 
; 2392 : 		UIData(8192+((8192-512)/2)-128,4608-((4608-1024)/2)+(UI_Sys.mouse_scroll*((4608-1024)/(UI_Sys.num_files-13))),256,256,
; 2393 : 			0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame1],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+14
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	256					; 00000100H
	push	256					; 00000100H
	movsx	ecx, WORD PTR _UI_Sys+265332
	sub	ecx, 13					; 0000000dH
	mov	eax, 3584				; 00000e00H
	cdq
	idiv	ecx
	imul	eax, DWORD PTR _UI_Sys+2092
	add	eax, 2816				; 00000b00H
	push	eax
	push	11904					; 00002e80H
	call	_UIData
	add	esp, 96					; 00000060H

; 2394 : 
; 2395 : 		if(st.mouse_wheel>0)

	cmp	DWORD PTR _st+65640, 0
	jle	SHORT $LN15@UIMakeList

; 2396 : 		{
; 2397 : 			UI_Sys.mouse_scroll--;

	mov	eax, DWORD PTR _UI_Sys+2092
	sub	eax, 1
	mov	DWORD PTR _UI_Sys+2092, eax

; 2398 : 			st.mouse_wheel=0;

	mov	DWORD PTR _st+65640, 0

; 2399 : 		}
; 2400 : 		else

	jmp	SHORT $LN14@UIMakeList
$LN15@UIMakeList:

; 2401 : 		if(st.mouse_wheel<0)

	cmp	DWORD PTR _st+65640, 0
	jge	SHORT $LN14@UIMakeList

; 2402 : 		{
; 2403 : 			UI_Sys.mouse_scroll++;

	mov	eax, DWORD PTR _UI_Sys+2092
	add	eax, 1
	mov	DWORD PTR _UI_Sys+2092, eax

; 2404 : 			st.mouse_wheel=0;

	mov	DWORD PTR _st+65640, 0
$LN14@UIMakeList:

; 2405 : 		}
; 2406 : 
; 2407 : 		if(UI_Sys.mouse_scroll<0)

	cmp	DWORD PTR _UI_Sys+2092, 0
	jge	SHORT $LN12@UIMakeList

; 2408 : 			UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 2409 : 		else

	jmp	SHORT $LN11@UIMakeList
$LN12@UIMakeList:

; 2410 : 		if(UI_Sys.mouse_scroll>sizel-13)

	movsx	eax, WORD PTR _sizel$[ebp]
	sub	eax, 13					; 0000000dH
	cmp	DWORD PTR _UI_Sys+2092, eax
	jle	SHORT $LN11@UIMakeList

; 2411 : 			UI_Sys.mouse_scroll=sizel-13;

	movsx	eax, WORD PTR _sizel$[ebp]
	sub	eax, 13					; 0000000dH
	mov	DWORD PTR _UI_Sys+2092, eax
$LN11@UIMakeList:

; 2412 : 	}
; 2413 : 	else

	jmp	$LN9@UIMakeList
$LN24@UIMakeList:

; 2414 : 	{
; 2415 : 		for(i=0;i<sizel;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@UIMakeList
$LN7@UIMakeList:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@UIMakeList:
	movsx	eax, WORD PTR _sizel$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN9@UIMakeList

; 2416 : 		{
; 2417 : 
; 2418 : 			if(CheckCollisionMouse(8192,4608-((4608-512)/2)+256+(i*256),8192-512,256,0) && st.mouse1)

	push	0
	push	256					; 00000100H
	push	7680					; 00001e00H
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	8192					; 00002000H
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@UIMakeList
	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	$LN5@UIMakeList

; 2419 : 			{
; 2420 : 				if((GetTimerM()-time)<50)

	call	@GetTimerM@0
	mov	ecx, eax
	mov	esi, edx
	mov	eax, DWORD PTR ?time@?1??UIMakeList@@9@9
	cdq
	sub	ecx, eax
	sbb	esi, edx
	mov	DWORD PTR tv521[ebp], ecx
	mov	DWORD PTR tv521[ebp+4], esi
	cmp	DWORD PTR tv521[ebp+4], 0
	ja	SHORT $LN4@UIMakeList
	jb	SHORT $LN28@UIMakeList
	cmp	DWORD PTR tv521[ebp], 50		; 00000032H
	jae	SHORT $LN4@UIMakeList
$LN28@UIMakeList:

; 2421 : 				{
; 2422 : 					UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 2423 : 
; 2424 : 					m_sel=-1;

	mov	DWORD PTR ?m_sel@?1??UIMakeList@@9@9, -1

; 2425 : 
; 2426 : 					st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 2427 : 					time=0;

	mov	DWORD PTR ?time@?1??UIMakeList@@9@9, 0

; 2428 : 
; 2429 : 					return i;

	mov	ax, WORD PTR _i$[ebp]
	jmp	$LN25@UIMakeList
$LN4@UIMakeList:

; 2430 : 				}
; 2431 : 
; 2432 : 				time=GetTimerM();

	call	@GetTimerM@0
	mov	DWORD PTR ?time@?1??UIMakeList@@9@9, eax

; 2433 : 
; 2434 : 				m_sel = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR ?m_sel@?1??UIMakeList@@9@9, eax

; 2435 : 				
; 2436 : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0
$LN5@UIMakeList:

; 2437 : 			}
; 2438 : 
; 2439 : 			if (m_sel == i)

	mov	eax, DWORD PTR ?m_sel@?1??UIMakeList@@9@9
	cmp	eax, DWORD PTR _i$[ebp]
	jne	$LN3@UIMakeList

; 2440 : 			{
; 2441 : 				UIData(8192, 4608 - ((4608 - 512) / 2) + 256 + (i * 256), 8192 - 512, 256, 0, 0, 0, 0, 0, 0, TEX_PAN_RANGE, TEX_PAN_RANGE, mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame1], 255, 0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+14
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	256					; 00000100H
	push	7680					; 00001e00H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 8
	add	ecx, 2816				; 00000b00H
	push	ecx
	push	8192					; 00002000H
	call	_UIData
	add	esp, 96					; 00000060H

; 2442 : 				StringUIvData(list[i], 8192 - ((8192 - 512) / 2) + 256, 4608 - ((4608 - 512) / 2) + 256 + (i * 256), 0, 0, 0, 255, 255, 255, 255, 0, 2048, 2048, 0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _list$[ebp]
	push	ecx
	call	_StringUIvData
	add	esp, 56					; 00000038H

; 2443 : 			}
; 2444 : 			else

	jmp	SHORT $LN2@UIMakeList
$LN3@UIMakeList:

; 2445 : 				StringUIvData(list[i],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(i*256),0,0,0,0,0,0,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _list$[ebp]
	push	ecx
	call	_StringUIvData
	add	esp, 56					; 00000038H
$LN2@UIMakeList:

; 2446 : 		}

	jmp	$LN7@UIMakeList
$LN9@UIMakeList:

; 2447 : 	}
; 2448 : 
; 2449 : 	if(UIStringButton(8192+2048+1024,4608+2048+64+32+16,"Select",0,1536,0,UI_COL_NORMAL,UI_COL_SELECTED)==UI_SEL)

	push	16744480				; 00ff8020H
	push	16777215				; 00ffffffH
	push	0
	push	1536					; 00000600H
	push	0
	push	OFFSET ??_C@_06HJGPBJLE@Select?$AA@
	push	6768					; 00001a70H
	push	11264					; 00002c00H
	call	_UIStringButton
	add	esp, 32					; 00000020H
	movsx	eax, al
	cmp	eax, 100				; 00000064H
	jne	SHORT $LN1@UIMakeList

; 2450 : 	{
; 2451 : 		UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 2452 : 
; 2453 : 		j = m_sel;

	mov	eax, DWORD PTR ?m_sel@?1??UIMakeList@@9@9
	mov	DWORD PTR _j$[ebp], eax

; 2454 : 
; 2455 : 		m_sel=-1;

	mov	DWORD PTR ?m_sel@?1??UIMakeList@@9@9, -1

; 2456 : 
; 2457 : 		st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 2458 : 		return j;

	mov	ax, WORD PTR _j$[ebp]
	jmp	SHORT $LN25@UIMakeList
$LN1@UIMakeList:

; 2459 : 	}
; 2460 : 
; 2461 : 	return -1;

	or	eax, -1
$LN25@UIMakeList:

; 2462 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@UIMakeList
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 2388				; 00000954H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN32@UIMakeList:
	DD	2
	DD	$LN31@UIMakeList
$LN31@UIMakeList:
	DD	-2052					; fffff7fcH
	DD	2048					; 00000800H
	DD	$LN29@UIMakeList
	DD	-2184					; fffff778H
	DD	4
	DD	$LN30@UIMakeList
$LN30@UIMakeList:
	DB	95					; 0000005fH
	DB	36					; 00000024H
	DB	65					; 00000041H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	0
$LN29@UIMakeList:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
_UIMakeList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UISavePath
_TEXT	SEGMENT
tv1016 = -2416						; size = 8
tv903 = -2416						; size = 8
_loop_c$ = -2209					; size = 1
_size$ = -2200						; size = 4
_f$ = -2188						; size = 4
_dir$ = -2176						; size = 4
_o$ = -2152						; size = 4
_n$ = -2140						; size = 4
_m$ = -2128						; size = 4
_j$ = -2092						; size = 4
_i$ = -2080						; size = 4
_catext$ = -2068					; size = 2
_path$ = -2056						; size = 2048
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_UISavePath PROC					; COMDAT

; 2016 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2416				; 00000970H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2416]
	mov	ecx, 604				; 0000025cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2017 : 	char path[2048];
; 2018 : 	int16 catext=1;

	mov	eax, 1
	mov	WORD PTR _catext$[ebp], ax

; 2019 : 	int32 i, j, k, l, m, n, o, p;
; 2020 : 	DIR *dir;
; 2021 : 	static int32 m_sel=-1, time=0;
; 2022 : 	FILE *f;
; 2023 : 	size_t size;
; 2024 : 	uint8 loop_c=0;

	mov	BYTE PTR _loop_c$[ebp], 0

; 2025 : 
; 2026 : 	UI_Sys.sys_freeze=1;

	mov	BYTE PTR _UI_Sys+2162, 1

; 2027 : 
; 2028 : 	UIData(8192,4608,8192,4608+1024,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.window2_frame],255,1);

	push	1
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+1
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	5632					; 00001600H
	push	8192					; 00002000H
	push	4608					; 00001200H
	push	8192					; 00002000H
	call	_UIData
	add	esp, 96					; 00000060H

; 2029 : 	UIData(8192,4608,8192-512,4608-512,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.window_frame2],255,1);

	push	1
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+4
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	4096					; 00001000H
	push	7680					; 00001e00H
	push	4608					; 00001200H
	push	8192					; 00002000H
	call	_UIData
	add	esp, 96					; 00000060H

; 2030 : 
; 2031 : 	if(UI_Sys.num_files>13)

	movsx	eax, WORD PTR _UI_Sys+265332
	cmp	eax, 13					; 0000000dH
	jle	$LN70@UISavePath

; 2032 : 	{
; 2033 : 		for(i=UI_Sys.mouse_scroll, j=0;i<UI_Sys.mouse_scroll+13;i++)

	mov	eax, DWORD PTR _UI_Sys+2092
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN69@UISavePath
$LN68@UISavePath:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN69@UISavePath:
	mov	eax, DWORD PTR _UI_Sys+2092
	add	eax, 13					; 0000000dH
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN67@UISavePath

; 2034 : 		{
; 2035 : 			if(i>UI_Sys.num_files-1)

	movsx	eax, WORD PTR _UI_Sys+265332
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jle	SHORT $LN66@UISavePath

; 2036 : 				break;

	jmp	$LN67@UISavePath
$LN66@UISavePath:

; 2037 : 
; 2038 : 			if(CheckCollisionMouse(8192,4608-((4608-512)/2)+256+(j*256),8192-512,256,0) && st.mouse1)

	push	0
	push	256					; 00000100H
	push	7680					; 00001e00H
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	8192					; 00002000H
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	ecx, al
	test	ecx, ecx
	je	$LN65@UISavePath
	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	$LN65@UISavePath

; 2039 : 			{
; 2040 : 				if((GetTimerM()-time)<50)

	call	@GetTimerM@0
	mov	ecx, eax
	mov	esi, edx
	mov	eax, DWORD PTR ?time@?1??UISavePath@@9@9
	cdq
	sub	ecx, eax
	sbb	esi, edx
	mov	DWORD PTR tv903[ebp], ecx
	mov	DWORD PTR tv903[ebp+4], esi
	cmp	DWORD PTR tv903[ebp+4], 0
	ja	$LN64@UISavePath
	jb	SHORT $LN73@UISavePath
	cmp	DWORD PTR tv903[ebp], 50		; 00000032H
	jae	$LN64@UISavePath
$LN73@UISavePath:

; 2041 : 				{
; 2042 : 					UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 2043 : 
; 2044 : 					strcpy(path,UI_Sys.current_path);

	push	OFFSET _UI_Sys+43
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2045 : 
; 2046 : 					strcat(path,"//");

	push	OFFSET ??_C@_02CBLDBPFN@?1?1?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2047 : 					strcat(path,UI_Sys.files[m_sel]);

	mov	eax, DWORD PTR ?m_sel@?1??UISavePath@@9@9
	shl	eax, 9
	add	eax, OFFSET _UI_Sys+2164
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2048 : 
; 2049 : 
; 2050 : 					if((f=fopen(path,"rb"))==NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax
	cmp	DWORD PTR _f$[ebp], 0
	jne	$LN63@UISavePath

; 2051 : 					{
; 2052 : 						if((dir=opendir(path))!=NULL)

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_opendir
	add	esp, 4
	mov	DWORD PTR _dir$[ebp], eax
	cmp	DWORD PTR _dir$[ebp], 0
	je	SHORT $LN63@UISavePath

; 2053 : 						{
; 2054 : 							strcpy(UI_Sys.current_path,path);

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET _UI_Sys+43
	call	_strcpy
	add	esp, 8

; 2055 : 							memset(path,0,2048);

	push	2048					; 00000800H
	push	0
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2056 : 							closedir(dir);

	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	_closedir
	add	esp, 4

; 2057 : 							UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 2058 : 							m_sel=-1;

	mov	DWORD PTR ?m_sel@?1??UISavePath@@9@9, -1

; 2059 : 							st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 2060 : 							time=0;

	mov	DWORD PTR ?time@?1??UISavePath@@9@9, 0

; 2061 : 							SetDirContent(UI_Sys.extension);

	push	OFFSET _UI_Sys+265334
	call	_SetDirContent
	add	esp, 4

; 2062 : 
; 2063 : 							break;

	jmp	$LN67@UISavePath
$LN63@UISavePath:

; 2064 : 						}
; 2065 : 					}
; 2066 : 
; 2067 : 					fclose(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 2068 : 					memset(path,0,2048);

	push	2048					; 00000800H
	push	0
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2069 : 					//UI_Sys.mouse_scroll=0;
; 2070 : 					//m_sel=-1;
; 2071 : 
; 2072 : 					//strcpy(path,UI_Sys.current_path);
; 2073 : 
; 2074 : 					//strcpy(UI_Sys.current_path,".");
; 2075 : 
; 2076 : 					st.mouse1=0;

	mov	BYTE PTR _st+65636, 0
$LN64@UISavePath:

; 2077 : 					//time=0;
; 2078 : 
; 2079 : 					//strcpy(filename,path);
; 2080 : 					//return 1;
; 2081 : 				}
; 2082 : 
; 2083 : 				time=GetTimerM();

	call	@GetTimerM@0
	mov	DWORD PTR ?time@?1??UISavePath@@9@9, eax

; 2084 : 
; 2085 : 
; 2086 : 				if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN61@UISavePath

; 2087 : 					m_sel=UI_Sys.foldersp[i];

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264820]
	mov	DWORD PTR ?m_sel@?1??UISavePath@@9@9, ecx

; 2088 : 				else

	jmp	$LN60@UISavePath
$LN61@UISavePath:

; 2089 : 				{
; 2090 : 					m_sel=UI_Sys.filesp[i];

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	DWORD PTR ?m_sel@?1??UISavePath@@9@9, ecx

; 2091 : 
; 2092 : 					strcpy(UI_Sys.file_name,UI_Sys.files[m_sel]);

	mov	eax, DWORD PTR ?m_sel@?1??UISavePath@@9@9
	shl	eax, 9
	add	eax, OFFSET _UI_Sys+2164
	push	eax
	push	OFFSET _UI_Sys+2098
	call	_strcpy
	add	esp, 8

; 2093 : 
; 2094 : 					size=strlen(UI_Sys.file_name);

	push	OFFSET _UI_Sys+2098
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 2095 : 
; 2096 : 					for(m=size;m>-1;m--)

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _m$[ebp], eax
	jmp	SHORT $LN59@UISavePath
$LN58@UISavePath:
	mov	eax, DWORD PTR _m$[ebp]
	sub	eax, 1
	mov	DWORD PTR _m$[ebp], eax
$LN59@UISavePath:
	cmp	DWORD PTR _m$[ebp], -1
	jle	$LN57@UISavePath

; 2097 : 					{
; 2098 : 						if(UI_Sys.files[m_sel][m]=='.')

	mov	eax, DWORD PTR ?m_sel@?1??UISavePath@@9@9
	shl	eax, 9
	mov	ecx, DWORD PTR _m$[ebp]
	movsx	edx, BYTE PTR _UI_Sys[eax+ecx+2164]
	cmp	edx, 46					; 0000002eH
	jne	$LN56@UISavePath

; 2099 : 						{
; 2100 : 							memset(path,0,2048);

	push	2048					; 00000800H
	push	0
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2101 : 							for(n=m+1,o=0;n<size;n++,o++)

	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	mov	DWORD PTR _o$[ebp], 0
	jmp	SHORT $LN55@UISavePath
$LN54@UISavePath:
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	mov	ecx, DWORD PTR _o$[ebp]
	add	ecx, 1
	mov	DWORD PTR _o$[ebp], ecx
$LN55@UISavePath:
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jae	SHORT $LN53@UISavePath

; 2102 : 							{
; 2103 : 								path[o]=tolower(UI_Sys.files[m_sel][n]);

	mov	eax, DWORD PTR ?m_sel@?1??UISavePath@@9@9
	shl	eax, 9
	mov	ecx, DWORD PTR _n$[ebp]
	movsx	edx, BYTE PTR _UI_Sys[eax+ecx+2164]
	push	edx
	call	_tolower
	add	esp, 4
	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR _path$[ebp+ecx], al

; 2104 : 							}

	jmp	SHORT $LN54@UISavePath
$LN53@UISavePath:

; 2105 : 
; 2106 : 							if(strcmp(path,UI_Sys.extension2)==NULL)

	push	OFFSET _UI_Sys+265366
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN56@UISavePath

; 2107 : 							{
; 2108 : 								catext=0;

	xor	eax, eax
	mov	WORD PTR _catext$[ebp], ax

; 2109 : 								break;

	jmp	SHORT $LN57@UISavePath
$LN56@UISavePath:

; 2110 : 							}
; 2111 : 						}
; 2112 : 					}

	jmp	$LN58@UISavePath
$LN57@UISavePath:

; 2113 : 
; 2114 : 					if(catext)

	movsx	eax, WORD PTR _catext$[ebp]
	test	eax, eax
	je	SHORT $LN60@UISavePath

; 2115 : 					{
; 2116 : 						strcat(UI_Sys.file_name,".");

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	push	OFFSET _UI_Sys+2098
	call	_strcat
	add	esp, 8

; 2117 : 						strcat(UI_Sys.file_name,UI_Sys.extension);

	push	OFFSET _UI_Sys+265334
	push	OFFSET _UI_Sys+2098
	call	_strcat
	add	esp, 8
$LN60@UISavePath:

; 2118 : 					}
; 2119 : 				}
; 2120 : 
; 2121 : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0
$LN65@UISavePath:

; 2122 : 			}
; 2123 : 
; 2124 : 			if(m_sel==UI_Sys.filesp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	cmp	DWORD PTR ?m_sel@?1??UISavePath@@9@9, ecx
	jne	$LN50@UISavePath

; 2125 : 			{
; 2126 : 				UIData(8192,4608-((4608-512)/2)+256+(j*256),8192-512,256,0,0,0,0,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame1],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+14
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	256					; 00000100H
	push	7680					; 00001e00H
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 8
	add	ecx, 2816				; 00000b00H
	push	ecx
	push	8192					; 00002000H
	call	_UIData
	add	esp, 96					; 00000060H

; 2127 : 				if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN49@UISavePath

; 2128 : 					StringUIvData(UI_Sys.files[UI_Sys.foldersp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(j*256),0,0,0,255,255,255,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264820]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H

; 2129 : 				else

	jmp	SHORT $LN48@UISavePath
$LN49@UISavePath:

; 2130 : 					StringUIvData(UI_Sys.files[UI_Sys.filesp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(j*256),0,0,0,255,255,255,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264308]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H
$LN48@UISavePath:

; 2131 : 			}
; 2132 : 			else

	jmp	$LN47@UISavePath
$LN50@UISavePath:

; 2133 : 			{
; 2134 : 				if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN46@UISavePath

; 2135 : 					StringUIvData(UI_Sys.files[UI_Sys.foldersp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(j*256),0,0,0,0,0,0,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264820]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H

; 2136 : 				else

	jmp	SHORT $LN47@UISavePath
$LN46@UISavePath:

; 2137 : 					StringUIvData(UI_Sys.files[UI_Sys.filesp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(j*256),0,0,0,0,0,0,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264308]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H
$LN47@UISavePath:

; 2138 : 			}
; 2139 : 
; 2140 : 			if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN44@UISavePath

; 2141 : 				UIData(8192-((8192-512)/2)+128,4608-((4608-512)/2)+256+(j*256),256,256,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.folder_icon],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+21
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	256					; 00000100H
	push	256					; 00000100H
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 8
	add	ecx, 2816				; 00000b00H
	push	ecx
	push	4480					; 00001180H
	call	_UIData
	add	esp, 96					; 00000060H
$LN44@UISavePath:

; 2142 : 
; 2143 : 			j++;

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax

; 2144 : 
; 2145 : 		}

	jmp	$LN68@UISavePath
$LN67@UISavePath:

; 2146 : 
; 2147 : 		if (UI_Sys.num_files > 13)

	movsx	eax, WORD PTR _UI_Sys+265332
	cmp	eax, 13					; 0000000dH
	jle	$LN43@UISavePath

; 2148 : 		{
; 2149 : 
; 2150 : 			UIData(8192 + ((8192 - 512) / 2) - 128, 4608, 256, 4608 - 512, 0, 128, 128, 128, 0, 0, TEX_PAN_RANGE, TEX_PAN_RANGE, mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame1], 255, 0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+14
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	128					; 00000080H
	push	128					; 00000080H
	push	128					; 00000080H
	push	0
	push	4096					; 00001000H
	push	256					; 00000100H
	push	4608					; 00001200H
	push	11904					; 00002e80H
	call	_UIData
	add	esp, 96					; 00000060H

; 2151 : 			UIData(8192 + ((8192 - 512) / 2) - 128, 4608 - ((4608 - 512) / 2) + 128, 256, 128, 0, 255, 255, 255, 0, 0, TEX_PAN_RANGE, TEX_PAN_RANGE, mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame0], 255, 0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+13
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	128					; 00000080H
	push	256					; 00000100H
	push	2688					; 00000a80H
	push	11904					; 00002e80H
	call	_UIData
	add	esp, 96					; 00000060H

; 2152 : 			UIData(8192 + ((8192 - 512) / 2) - 128, 4608 + ((4608 - 512) / 2) - 128, 256, 128, 0, 255, 255, 255, 0, 0, TEX_PAN_RANGE, TEX_PAN_RANGE, mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame0], 255, 0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+13
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	128					; 00000080H
	push	256					; 00000100H
	push	6528					; 00001980H
	push	11904					; 00002e80H
	call	_UIData
	add	esp, 96					; 00000060H

; 2153 : 
; 2154 : 			UIData(8192 + ((8192 - 512) / 2) - 128, 4608 - ((4608 - 1024) / 2) + (UI_Sys.mouse_scroll*((4608 - 1024) / (UI_Sys.num_files - 13))), 256, 256,
; 2155 : 				0, 255, 255, 255, 0, 0, TEX_PAN_RANGE, TEX_PAN_RANGE, mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame1], 255, 0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+14
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	256					; 00000100H
	push	256					; 00000100H
	movsx	ecx, WORD PTR _UI_Sys+265332
	sub	ecx, 13					; 0000000dH
	mov	eax, 3584				; 00000e00H
	cdq
	idiv	ecx
	imul	eax, DWORD PTR _UI_Sys+2092
	add	eax, 2816				; 00000b00H
	push	eax
	push	11904					; 00002e80H
	call	_UIData
	add	esp, 96					; 00000060H

; 2156 : 
; 2157 : 			if (st.mouse_wheel > 0)

	cmp	DWORD PTR _st+65640, 0
	jle	SHORT $LN42@UISavePath

; 2158 : 			{
; 2159 : 				UI_Sys.mouse_scroll--;

	mov	eax, DWORD PTR _UI_Sys+2092
	sub	eax, 1
	mov	DWORD PTR _UI_Sys+2092, eax

; 2160 : 				st.mouse_wheel = 0;

	mov	DWORD PTR _st+65640, 0

; 2161 : 			}
; 2162 : 			else

	jmp	SHORT $LN41@UISavePath
$LN42@UISavePath:

; 2163 : 				if (st.mouse_wheel < 0)

	cmp	DWORD PTR _st+65640, 0
	jge	SHORT $LN41@UISavePath

; 2164 : 				{
; 2165 : 					UI_Sys.mouse_scroll++;

	mov	eax, DWORD PTR _UI_Sys+2092
	add	eax, 1
	mov	DWORD PTR _UI_Sys+2092, eax

; 2166 : 					st.mouse_wheel = 0;

	mov	DWORD PTR _st+65640, 0
$LN41@UISavePath:

; 2167 : 				}
; 2168 : 
; 2169 : 			if (UI_Sys.mouse_scroll<0)

	cmp	DWORD PTR _UI_Sys+2092, 0
	jge	SHORT $LN39@UISavePath

; 2170 : 				UI_Sys.mouse_scroll = 0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 2171 : 			else

	jmp	SHORT $LN43@UISavePath
$LN39@UISavePath:

; 2172 : 				if (UI_Sys.mouse_scroll>UI_Sys.num_files - 13)

	movsx	eax, WORD PTR _UI_Sys+265332
	sub	eax, 13					; 0000000dH
	cmp	DWORD PTR _UI_Sys+2092, eax
	jle	SHORT $LN43@UISavePath

; 2173 : 					UI_Sys.mouse_scroll = UI_Sys.num_files - 13;

	movsx	eax, WORD PTR _UI_Sys+265332
	sub	eax, 13					; 0000000dH
	mov	DWORD PTR _UI_Sys+2092, eax
$LN43@UISavePath:

; 2174 : 		}
; 2175 : 	}
; 2176 : 	else

	jmp	$LN36@UISavePath
$LN70@UISavePath:

; 2177 : 	{
; 2178 : 		for(i=0;i<UI_Sys.num_files;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN35@UISavePath
$LN34@UISavePath:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN35@UISavePath:
	movsx	eax, WORD PTR _UI_Sys+265332
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN36@UISavePath

; 2179 : 		{
; 2180 : 
; 2181 : 			if(CheckCollisionMouse(8192,4608-((4608-512)/2)+256+(i*256),8192-512,256,0) && st.mouse1)

	push	0
	push	256					; 00000100H
	push	7680					; 00001e00H
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	8192					; 00002000H
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	ecx, al
	test	ecx, ecx
	je	$LN32@UISavePath
	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	$LN32@UISavePath

; 2182 : 			{
; 2183 : 				if((GetTimerM()-time)<50)

	call	@GetTimerM@0
	mov	ecx, eax
	mov	esi, edx
	mov	eax, DWORD PTR ?time@?1??UISavePath@@9@9
	cdq
	sub	ecx, eax
	sbb	esi, edx
	mov	DWORD PTR tv1016[ebp], ecx
	mov	DWORD PTR tv1016[ebp+4], esi
	cmp	DWORD PTR tv1016[ebp+4], 0
	ja	$LN31@UISavePath
	jb	SHORT $LN74@UISavePath
	cmp	DWORD PTR tv1016[ebp], 50		; 00000032H
	jae	$LN31@UISavePath
$LN74@UISavePath:

; 2184 : 				{
; 2185 : 					UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 2186 : 
; 2187 : 					strcpy(path,UI_Sys.current_path);

	push	OFFSET _UI_Sys+43
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2188 : 
; 2189 : 					strcat(path,"//");

	push	OFFSET ??_C@_02CBLDBPFN@?1?1?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2190 : 					strcat(path,UI_Sys.files[m_sel]);

	mov	eax, DWORD PTR ?m_sel@?1??UISavePath@@9@9
	shl	eax, 9
	add	eax, OFFSET _UI_Sys+2164
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2191 : 
; 2192 : 
; 2193 : 					if((f=fopen(path,"rb"))==NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax
	cmp	DWORD PTR _f$[ebp], 0
	jne	$LN30@UISavePath

; 2194 : 					{
; 2195 : 						if((dir=opendir(path))!=NULL)

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_opendir
	add	esp, 4
	mov	DWORD PTR _dir$[ebp], eax
	cmp	DWORD PTR _dir$[ebp], 0
	je	SHORT $LN30@UISavePath

; 2196 : 						{
; 2197 : 							strcpy(UI_Sys.current_path,path);

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET _UI_Sys+43
	call	_strcpy
	add	esp, 8

; 2198 : 							memset(path,0,2048);

	push	2048					; 00000800H
	push	0
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2199 : 							closedir(dir);

	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	_closedir
	add	esp, 4

; 2200 : 							UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 2201 : 							m_sel=-1;

	mov	DWORD PTR ?m_sel@?1??UISavePath@@9@9, -1

; 2202 : 							st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 2203 : 							time=0;

	mov	DWORD PTR ?time@?1??UISavePath@@9@9, 0

; 2204 : 							SetDirContent(UI_Sys.extension);

	push	OFFSET _UI_Sys+265334
	call	_SetDirContent
	add	esp, 4

; 2205 : 
; 2206 : 							break;

	jmp	$LN36@UISavePath
$LN30@UISavePath:

; 2207 : 						}
; 2208 : 					}
; 2209 : 
; 2210 : 					fclose(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 2211 : 					memset(path,0,2048);

	push	2048					; 00000800H
	push	0
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2212 : 					//UI_Sys.mouse_scroll=0;
; 2213 : 					//m_sel=-1;
; 2214 : 
; 2215 : 					//strcpy(path,UI_Sys.current_path);
; 2216 : 
; 2217 : 					//strcpy(UI_Sys.current_path,".");
; 2218 : 
; 2219 : 					st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 2220 : 					time=0;

	mov	DWORD PTR ?time@?1??UISavePath@@9@9, 0
$LN31@UISavePath:

; 2221 : 
; 2222 : 					//strcpy(filename,path);
; 2223 : 					//return 1;
; 2224 : 				}
; 2225 : 
; 2226 : 				time=GetTimerM();

	call	@GetTimerM@0
	mov	DWORD PTR ?time@?1??UISavePath@@9@9, eax

; 2227 : 
; 2228 : 				if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN28@UISavePath

; 2229 : 					m_sel=UI_Sys.foldersp[i];

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264820]
	mov	DWORD PTR ?m_sel@?1??UISavePath@@9@9, ecx

; 2230 : 				else

	jmp	$LN27@UISavePath
$LN28@UISavePath:

; 2231 : 				{
; 2232 : 					m_sel=UI_Sys.filesp[i];

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	DWORD PTR ?m_sel@?1??UISavePath@@9@9, ecx

; 2233 : 
; 2234 : 					strcpy(UI_Sys.file_name,UI_Sys.files[m_sel]);

	mov	eax, DWORD PTR ?m_sel@?1??UISavePath@@9@9
	shl	eax, 9
	add	eax, OFFSET _UI_Sys+2164
	push	eax
	push	OFFSET _UI_Sys+2098
	call	_strcpy
	add	esp, 8

; 2235 : 
; 2236 : 					size=strlen(UI_Sys.file_name);

	push	OFFSET _UI_Sys+2098
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 2237 : 
; 2238 : 					for(m=size;m>-1;m--)

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _m$[ebp], eax
	jmp	SHORT $LN26@UISavePath
$LN25@UISavePath:
	mov	eax, DWORD PTR _m$[ebp]
	sub	eax, 1
	mov	DWORD PTR _m$[ebp], eax
$LN26@UISavePath:
	cmp	DWORD PTR _m$[ebp], -1
	jle	$LN24@UISavePath

; 2239 : 					{
; 2240 : 						if(UI_Sys.files[m_sel][m]=='.')

	mov	eax, DWORD PTR ?m_sel@?1??UISavePath@@9@9
	shl	eax, 9
	mov	ecx, DWORD PTR _m$[ebp]
	movsx	edx, BYTE PTR _UI_Sys[eax+ecx+2164]
	cmp	edx, 46					; 0000002eH
	jne	$LN23@UISavePath

; 2241 : 						{
; 2242 : 							memset(path,0,2048);

	push	2048					; 00000800H
	push	0
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2243 : 							for(n=m+1,o=0;n<size;n++,o++)

	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	mov	DWORD PTR _o$[ebp], 0
	jmp	SHORT $LN22@UISavePath
$LN21@UISavePath:
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	mov	ecx, DWORD PTR _o$[ebp]
	add	ecx, 1
	mov	DWORD PTR _o$[ebp], ecx
$LN22@UISavePath:
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jae	SHORT $LN20@UISavePath

; 2244 : 							{
; 2245 : 								path[o]=tolower(UI_Sys.files[m_sel][n]);

	mov	eax, DWORD PTR ?m_sel@?1??UISavePath@@9@9
	shl	eax, 9
	mov	ecx, DWORD PTR _n$[ebp]
	movsx	edx, BYTE PTR _UI_Sys[eax+ecx+2164]
	push	edx
	call	_tolower
	add	esp, 4
	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR _path$[ebp+ecx], al

; 2246 : 							}

	jmp	SHORT $LN21@UISavePath
$LN20@UISavePath:

; 2247 : 
; 2248 : 							if(strcmp(path,UI_Sys.extension2)==NULL)

	push	OFFSET _UI_Sys+265366
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN23@UISavePath

; 2249 : 							{
; 2250 : 								catext=0;

	xor	eax, eax
	mov	WORD PTR _catext$[ebp], ax

; 2251 : 								break;

	jmp	SHORT $LN24@UISavePath
$LN23@UISavePath:

; 2252 : 							}
; 2253 : 						}
; 2254 : 					}

	jmp	$LN25@UISavePath
$LN24@UISavePath:

; 2255 : 
; 2256 : 					if(catext)

	movsx	eax, WORD PTR _catext$[ebp]
	test	eax, eax
	je	SHORT $LN27@UISavePath

; 2257 : 					{
; 2258 : 						strcat(UI_Sys.file_name,".");

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	push	OFFSET _UI_Sys+2098
	call	_strcat
	add	esp, 8

; 2259 : 						strcat(UI_Sys.file_name,UI_Sys.extension);

	push	OFFSET _UI_Sys+265334
	push	OFFSET _UI_Sys+2098
	call	_strcat
	add	esp, 8
$LN27@UISavePath:

; 2260 : 					}
; 2261 : 				}
; 2262 : 
; 2263 : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0
$LN32@UISavePath:

; 2264 : 			}
; 2265 : 
; 2266 : 			if(m_sel==UI_Sys.filesp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	cmp	DWORD PTR ?m_sel@?1??UISavePath@@9@9, ecx
	jne	$LN17@UISavePath

; 2267 : 			{
; 2268 : 				UIData(8192,4608-((4608-512)/2)+256+(i*256),8192-512,256,0,0,0,0,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame1],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+14
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	256					; 00000100H
	push	7680					; 00001e00H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 8
	add	ecx, 2816				; 00000b00H
	push	ecx
	push	8192					; 00002000H
	call	_UIData
	add	esp, 96					; 00000060H

; 2269 : 				if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN16@UISavePath

; 2270 : 					StringUIvData(UI_Sys.files[UI_Sys.foldersp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(i*256),0,0,0,255,255,255,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264820]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H

; 2271 : 				else

	jmp	SHORT $LN15@UISavePath
$LN16@UISavePath:

; 2272 : 					StringUIvData(UI_Sys.files[UI_Sys.filesp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(i*256),0,0,0,255,255,255,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264308]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H
$LN15@UISavePath:

; 2273 : 			}
; 2274 : 			else

	jmp	$LN14@UISavePath
$LN17@UISavePath:

; 2275 : 			{
; 2276 : 				if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN13@UISavePath

; 2277 : 					StringUIvData(UI_Sys.files[UI_Sys.foldersp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(i*256),0,0,0,0,0,0,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264820]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H

; 2278 : 				else

	jmp	SHORT $LN14@UISavePath
$LN13@UISavePath:

; 2279 : 					StringUIvData(UI_Sys.files[UI_Sys.filesp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(i*256),0,0,0,0,0,0,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264308]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H
$LN14@UISavePath:

; 2280 : 			}
; 2281 : 
; 2282 : 			if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN11@UISavePath

; 2283 : 				UIData(8192-((8192-512)/2)+128,4608-((4608-512)/2)+256+(i*256),256,256,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.folder_icon],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+21
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	256					; 00000100H
	push	256					; 00000100H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 8
	add	ecx, 2816				; 00000b00H
	push	ecx
	push	4480					; 00001180H
	call	_UIData
	add	esp, 96					; 00000060H
$LN11@UISavePath:

; 2284 : 		}

	jmp	$LN34@UISavePath
$LN36@UISavePath:

; 2285 : 	}
; 2286 : 
; 2287 : 	UITextBox(8192,4608+2048-64-32,4608-256,UI_Sys.file_name,0,2048,0,UI_COL_SELECTED,UI_COL_CLICKED,0,1);

	push	1
	push	0
	push	16719904				; 00ff2020H
	push	16744480				; 00ff8020H
	push	0
	push	2048					; 00000800H
	push	0
	push	OFFSET _UI_Sys+2098
	push	4352					; 00001100H
	push	6560					; 000019a0H
	push	8192					; 00002000H
	call	_UITextBox
	add	esp, 44					; 0000002cH

; 2288 : 
; 2289 : 	if(UIStringButton(8192+2048+1024,4608+2048,"Save",0,1536,0,UI_COL_NORMAL,UI_COL_SELECTED)==UI_SEL)

	push	16744480				; 00ff8020H
	push	16777215				; 00ffffffH
	push	0
	push	1536					; 00000600H
	push	0
	push	OFFSET ??_C@_04INACKGJP@Save?$AA@
	push	6656					; 00001a00H
	push	11264					; 00002c00H
	call	_UIStringButton
	add	esp, 32					; 00000020H
	movsx	eax, al
	cmp	eax, 100				; 00000064H
	jne	$LN10@UISavePath

; 2290 : 	{
; 2291 : 		UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 2292 : 
; 2293 : 		size=strlen(UI_Sys.file_name);

	push	OFFSET _UI_Sys+2098
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 2294 : 
; 2295 : 		for(m=size;m>-1;m--)

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _m$[ebp], eax
	jmp	SHORT $LN9@UISavePath
$LN8@UISavePath:
	mov	eax, DWORD PTR _m$[ebp]
	sub	eax, 1
	mov	DWORD PTR _m$[ebp], eax
$LN9@UISavePath:
	cmp	DWORD PTR _m$[ebp], -1
	jle	$LN7@UISavePath

; 2296 : 		{
; 2297 : 			if(UI_Sys.file_name[m]=='.')

	mov	eax, DWORD PTR _m$[ebp]
	movsx	ecx, BYTE PTR _UI_Sys[eax+2098]
	cmp	ecx, 46					; 0000002eH
	jne	$LN6@UISavePath

; 2298 : 			{
; 2299 : 				memset(path,0,2048);

	push	2048					; 00000800H
	push	0
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2300 : 				for(n=m+1,o=0;n<size;n++,o++)

	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	mov	DWORD PTR _o$[ebp], 0
	jmp	SHORT $LN5@UISavePath
$LN4@UISavePath:
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	mov	ecx, DWORD PTR _o$[ebp]
	add	ecx, 1
	mov	DWORD PTR _o$[ebp], ecx
$LN5@UISavePath:
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jae	SHORT $LN3@UISavePath

; 2301 : 				{
; 2302 : 					path[o]=tolower(UI_Sys.file_name[n]);

	mov	eax, DWORD PTR _n$[ebp]
	movsx	ecx, BYTE PTR _UI_Sys[eax+2098]
	push	ecx
	call	_tolower
	add	esp, 4
	mov	edx, DWORD PTR _o$[ebp]
	mov	BYTE PTR _path$[ebp+edx], al

; 2303 : 				}

	jmp	SHORT $LN4@UISavePath
$LN3@UISavePath:

; 2304 : 
; 2305 : 				if(strcmp(path,UI_Sys.extension2)==NULL)

	push	OFFSET _UI_Sys+265366
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@UISavePath

; 2306 : 				{
; 2307 : 					catext=0;

	xor	eax, eax
	mov	WORD PTR _catext$[ebp], ax

; 2308 : 					break;

	jmp	SHORT $LN7@UISavePath
$LN6@UISavePath:

; 2309 : 				}
; 2310 : 			}
; 2311 : 		}

	jmp	$LN8@UISavePath
$LN7@UISavePath:

; 2312 : 
; 2313 : 		if(catext)

	movsx	eax, WORD PTR _catext$[ebp]
	test	eax, eax
	je	SHORT $LN1@UISavePath

; 2314 : 		{
; 2315 : 			strcat(UI_Sys.file_name,".");

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	push	OFFSET _UI_Sys+2098
	call	_strcat
	add	esp, 8

; 2316 : 			strcat(UI_Sys.file_name,UI_Sys.extension);

	push	OFFSET _UI_Sys+265334
	push	OFFSET _UI_Sys+2098
	call	_strcat
	add	esp, 8
$LN1@UISavePath:

; 2317 : 		}
; 2318 : 
; 2319 : 		strcat(UI_Sys.current_path,"//");

	push	OFFSET ??_C@_02CBLDBPFN@?1?1?$AA@
	push	OFFSET _UI_Sys+43
	call	_strcat
	add	esp, 8

; 2320 : 		strcat(UI_Sys.current_path,UI_Sys.file_name);

	push	OFFSET _UI_Sys+2098
	push	OFFSET _UI_Sys+43
	call	_strcat
	add	esp, 8

; 2321 : 		
; 2322 : 		UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 2323 : 		m_sel=-1;

	mov	DWORD PTR ?m_sel@?1??UISavePath@@9@9, -1

; 2324 : 
; 2325 : 		strcpy(path,UI_Sys.current_path);

	push	OFFSET _UI_Sys+43
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2326 : 
; 2327 : 		strcpy(UI_Sys.current_path,".");

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	push	OFFSET _UI_Sys+43
	call	_strcpy
	add	esp, 8

; 2328 : 
; 2329 : 		strcpy(filename,path);

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2330 : 		st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 2331 : 		return 1;

	mov	al, 1
	jmp	SHORT $LN71@UISavePath
$LN10@UISavePath:

; 2332 : 	}
; 2333 : 
; 2334 : 	return NULL;

	xor	al, al
$LN71@UISavePath:

; 2335 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN77@UISavePath
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 2416				; 00000970H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN77@UISavePath:
	DD	1
	DD	$LN76@UISavePath
$LN76@UISavePath:
	DD	-2056					; fffff7f8H
	DD	2048					; 00000800H
	DD	$LN75@UISavePath
$LN75@UISavePath:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
_UISavePath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UISelectFile
_TEXT	SEGMENT
tv868 = -2404						; size = 8
tv779 = -2404						; size = 8
_loop_c$ = -2197					; size = 1
_f$ = -2176						; size = 4
_dir$ = -2164						; size = 4
_j$ = -2080						; size = 4
_i$ = -2068						; size = 4
_path$ = -2056						; size = 2048
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_UISelectFile PROC					; COMDAT

; 1784 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2404				; 00000964H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2404]
	mov	ecx, 601				; 00000259H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1785 : 	char path[2048];
; 1786 : 	int32 i, j, k, l, m, n, o, p;
; 1787 : 	DIR *dir;
; 1788 : 	static int32 m_sel=-1, time=0;
; 1789 : 	FILE *f;
; 1790 : 	size_t size;
; 1791 : 	uint8 loop_c=0;

	mov	BYTE PTR _loop_c$[ebp], 0

; 1792 : 
; 1793 : 	UI_Sys.sys_freeze=1;

	mov	BYTE PTR _UI_Sys+2162, 1

; 1794 : 
; 1795 : 	UIData(8192,GAME_HEIGHT/2,8192,GAME_HEIGHT/2,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.window2_frame],255,1);

	push	1
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+1
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	4608					; 00001200H
	push	8192					; 00002000H
	push	4608					; 00001200H
	push	8192					; 00002000H
	call	_UIData
	add	esp, 96					; 00000060H

; 1796 : 	UIData(8192,GAME_HEIGHT/2,8192-512,GAME_HEIGHT/2-512,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.window_frame2],255,1);

	push	1
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+4
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	4096					; 00001000H
	push	7680					; 00001e00H
	push	4608					; 00001200H
	push	8192					; 00002000H
	call	_UIData
	add	esp, 96					; 00000060H

; 1797 : 
; 1798 : 	if(UI_Sys.num_files>13)

	movsx	eax, WORD PTR _UI_Sys+265332
	cmp	eax, 13					; 0000000dH
	jle	$LN45@UISelectFi

; 1799 : 	{
; 1800 : 		for(i=UI_Sys.mouse_scroll, j=0;i<UI_Sys.mouse_scroll+13;i++)

	mov	eax, DWORD PTR _UI_Sys+2092
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN44@UISelectFi
$LN43@UISelectFi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN44@UISelectFi:
	mov	eax, DWORD PTR _UI_Sys+2092
	add	eax, 13					; 0000000dH
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN42@UISelectFi

; 1801 : 		{
; 1802 : 			if(i>UI_Sys.num_files-1)

	movsx	eax, WORD PTR _UI_Sys+265332
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jle	SHORT $LN41@UISelectFi

; 1803 : 				break;

	jmp	$LN42@UISelectFi
$LN41@UISelectFi:

; 1804 : 
; 1805 : 			if(CheckCollisionMouse(8192,4608-((4608-512)/2)+256+(j*256),8192-512,256,0) && st.mouse1)

	push	0
	push	256					; 00000100H
	push	7680					; 00001e00H
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	8192					; 00002000H
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	ecx, al
	test	ecx, ecx
	je	$LN40@UISelectFi
	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	$LN40@UISelectFi

; 1806 : 			{
; 1807 : 				if((GetTimerM()-time)<50)

	call	@GetTimerM@0
	mov	ecx, eax
	mov	esi, edx
	mov	eax, DWORD PTR ?time@?1??UISelectFile@@9@9
	cdq
	sub	ecx, eax
	sbb	esi, edx
	mov	DWORD PTR tv779[ebp], ecx
	mov	DWORD PTR tv779[ebp+4], esi
	cmp	DWORD PTR tv779[ebp+4], 0
	ja	$LN39@UISelectFi
	jb	SHORT $LN48@UISelectFi
	cmp	DWORD PTR tv779[ebp], 50		; 00000032H
	jae	$LN39@UISelectFi
$LN48@UISelectFi:

; 1808 : 				{
; 1809 : 					UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 1810 : 
; 1811 : 					strcat(UI_Sys.current_path,"//");

	push	OFFSET ??_C@_02CBLDBPFN@?1?1?$AA@
	push	OFFSET _UI_Sys+43
	call	_strcat
	add	esp, 8

; 1812 : 					strcat(UI_Sys.current_path,UI_Sys.files[m_sel]);

	mov	eax, DWORD PTR ?m_sel@?1??UISelectFile@@9@9
	shl	eax, 9
	add	eax, OFFSET _UI_Sys+2164
	push	eax
	push	OFFSET _UI_Sys+43
	call	_strcat
	add	esp, 8

; 1813 : 
; 1814 : 
; 1815 : 					if((f=fopen(UI_Sys.current_path,"rb"))==NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET _UI_Sys+43
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax
	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN38@UISelectFi

; 1816 : 					{
; 1817 : 						if((dir=opendir(UI_Sys.current_path))!=NULL)

	push	OFFSET _UI_Sys+43
	call	_opendir
	add	esp, 4
	mov	DWORD PTR _dir$[ebp], eax
	cmp	DWORD PTR _dir$[ebp], 0
	je	SHORT $LN38@UISelectFi

; 1818 : 						{
; 1819 : 							closedir(dir);

	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	_closedir
	add	esp, 4

; 1820 : 							UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 1821 : 							m_sel=-1;

	mov	DWORD PTR ?m_sel@?1??UISelectFile@@9@9, -1

; 1822 : 							st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 1823 : 							time=0;

	mov	DWORD PTR ?time@?1??UISelectFile@@9@9, 0

; 1824 : 							SetDirContent(UI_Sys.extension);

	push	OFFSET _UI_Sys+265334
	call	_SetDirContent
	add	esp, 4

; 1825 : 
; 1826 : 							break;

	jmp	$LN42@UISelectFi
$LN38@UISelectFi:

; 1827 : 						}
; 1828 : 					}
; 1829 : 
; 1830 : 					fclose(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 1831 : 					UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 1832 : 					m_sel=-1;

	mov	DWORD PTR ?m_sel@?1??UISelectFile@@9@9, -1

; 1833 : 
; 1834 : 					strcpy(path,UI_Sys.current_path);

	push	OFFSET _UI_Sys+43
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1835 : 
; 1836 : 					strcpy(UI_Sys.current_path,".");

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	push	OFFSET _UI_Sys+43
	call	_strcpy
	add	esp, 8

; 1837 : 
; 1838 : 					st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 1839 : 					time=0;

	mov	DWORD PTR ?time@?1??UISelectFile@@9@9, 0

; 1840 : 
; 1841 : 					strcpy(filename,path);

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1842 : 					return 1;

	mov	al, 1
	jmp	$LN46@UISelectFi
$LN39@UISelectFi:

; 1843 : 				}
; 1844 : 
; 1845 : 				time=GetTimerM();

	call	@GetTimerM@0
	mov	DWORD PTR ?time@?1??UISelectFile@@9@9, eax

; 1846 : 				if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN36@UISelectFi

; 1847 : 					m_sel=UI_Sys.foldersp[i];

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264820]
	mov	DWORD PTR ?m_sel@?1??UISelectFile@@9@9, ecx

; 1848 : 				else

	jmp	SHORT $LN35@UISelectFi
$LN36@UISelectFi:

; 1849 : 					m_sel=UI_Sys.filesp[i];

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	DWORD PTR ?m_sel@?1??UISelectFile@@9@9, ecx
$LN35@UISelectFi:

; 1850 : 
; 1851 : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0
$LN40@UISelectFi:

; 1852 : 			}
; 1853 : 
; 1854 : 			if(m_sel==UI_Sys.filesp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	cmp	DWORD PTR ?m_sel@?1??UISelectFile@@9@9, ecx
	jne	$LN34@UISelectFi

; 1855 : 			{
; 1856 : 				UIData(8192,4608-((4608-512)/2)+256+(j*256),8192-512,256,0,0,0,0,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame1],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+14
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	256					; 00000100H
	push	7680					; 00001e00H
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 8
	add	ecx, 2816				; 00000b00H
	push	ecx
	push	8192					; 00002000H
	call	_UIData
	add	esp, 96					; 00000060H

; 1857 : 				if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN33@UISelectFi

; 1858 : 					StringUIvData(UI_Sys.files[UI_Sys.foldersp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(j*256),0,0,0,255,255,255,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264820]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H

; 1859 : 				else

	jmp	SHORT $LN32@UISelectFi
$LN33@UISelectFi:

; 1860 : 					StringUIvData(UI_Sys.files[UI_Sys.filesp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(j*256),0,0,0,255,255,255,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264308]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H
$LN32@UISelectFi:

; 1861 : 			}
; 1862 : 			else

	jmp	$LN31@UISelectFi
$LN34@UISelectFi:

; 1863 : 			{
; 1864 : 				if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN30@UISelectFi

; 1865 : 					StringUIvData(UI_Sys.files[UI_Sys.foldersp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(j*256),0,0,0,0,0,0,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264820]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H

; 1866 : 				else

	jmp	SHORT $LN31@UISelectFi
$LN30@UISelectFi:

; 1867 : 					StringUIvData(UI_Sys.files[UI_Sys.filesp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(j*256),0,0,0,0,0,0,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264308]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H
$LN31@UISelectFi:

; 1868 : 			}
; 1869 : 
; 1870 : 			if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN28@UISelectFi

; 1871 : 				UIData(8192-((8192-512)/2)+128,4608-((4608-512)/2)+256+(j*256),256,256,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.folder_icon],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+21
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	256					; 00000100H
	push	256					; 00000100H
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 8
	add	ecx, 2816				; 00000b00H
	push	ecx
	push	4480					; 00001180H
	call	_UIData
	add	esp, 96					; 00000060H
$LN28@UISelectFi:

; 1872 : 
; 1873 : 			j++;

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax

; 1874 : 
; 1875 : 		}

	jmp	$LN43@UISelectFi
$LN42@UISelectFi:

; 1876 : 
; 1877 : 		if (UI_Sys.num_files > 13)

	movsx	eax, WORD PTR _UI_Sys+265332
	cmp	eax, 13					; 0000000dH
	jle	$LN27@UISelectFi

; 1878 : 		{
; 1879 : 			UIData(8192 + ((8192 - 512) / 2) - 128, 4608, 256, 4608 - 512, 0, 128, 128, 128, 0, 0, TEX_PAN_RANGE, TEX_PAN_RANGE, mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame1], 255, 0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+14
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	128					; 00000080H
	push	128					; 00000080H
	push	128					; 00000080H
	push	0
	push	4096					; 00001000H
	push	256					; 00000100H
	push	4608					; 00001200H
	push	11904					; 00002e80H
	call	_UIData
	add	esp, 96					; 00000060H

; 1880 : 			UIData(8192 + ((8192 - 512) / 2) - 128, 4608 - ((4608 - 512) / 2) + 128, 256, 128, 0, 255, 255, 255, 0, 0, TEX_PAN_RANGE, TEX_PAN_RANGE, mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame0], 255, 0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+13
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	128					; 00000080H
	push	256					; 00000100H
	push	2688					; 00000a80H
	push	11904					; 00002e80H
	call	_UIData
	add	esp, 96					; 00000060H

; 1881 : 			UIData(8192 + ((8192 - 512) / 2) - 128, 4608 + ((4608 - 512) / 2) - 128, 256, 128, 0, 255, 255, 255, 0, 0, TEX_PAN_RANGE, TEX_PAN_RANGE, mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame0], 255, 0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+13
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	128					; 00000080H
	push	256					; 00000100H
	push	6528					; 00001980H
	push	11904					; 00002e80H
	call	_UIData
	add	esp, 96					; 00000060H

; 1882 : 
; 1883 : 			UIData(8192 + ((8192 - 512) / 2) - 128, 4608 - ((4608 - 1024) / 2) + (UI_Sys.mouse_scroll*((4608 - 1024) / (UI_Sys.num_files - 13))), 256, 256,
; 1884 : 				0, 255, 255, 255, 0, 0, TEX_PAN_RANGE, TEX_PAN_RANGE, mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame1], 255, 0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+14
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	256					; 00000100H
	push	256					; 00000100H
	movsx	ecx, WORD PTR _UI_Sys+265332
	sub	ecx, 13					; 0000000dH
	mov	eax, 3584				; 00000e00H
	cdq
	idiv	ecx
	imul	eax, DWORD PTR _UI_Sys+2092
	add	eax, 2816				; 00000b00H
	push	eax
	push	11904					; 00002e80H
	call	_UIData
	add	esp, 96					; 00000060H

; 1885 : 
; 1886 : 			if (st.mouse_wheel > 0)

	cmp	DWORD PTR _st+65640, 0
	jle	SHORT $LN26@UISelectFi

; 1887 : 			{
; 1888 : 				UI_Sys.mouse_scroll--;

	mov	eax, DWORD PTR _UI_Sys+2092
	sub	eax, 1
	mov	DWORD PTR _UI_Sys+2092, eax

; 1889 : 				st.mouse_wheel = 0;

	mov	DWORD PTR _st+65640, 0

; 1890 : 			}
; 1891 : 			else

	jmp	SHORT $LN25@UISelectFi
$LN26@UISelectFi:

; 1892 : 				if (st.mouse_wheel < 0)

	cmp	DWORD PTR _st+65640, 0
	jge	SHORT $LN25@UISelectFi

; 1893 : 				{
; 1894 : 					UI_Sys.mouse_scroll++;

	mov	eax, DWORD PTR _UI_Sys+2092
	add	eax, 1
	mov	DWORD PTR _UI_Sys+2092, eax

; 1895 : 					st.mouse_wheel = 0;

	mov	DWORD PTR _st+65640, 0
$LN25@UISelectFi:

; 1896 : 				}
; 1897 : 
; 1898 : 			if (UI_Sys.mouse_scroll<0)

	cmp	DWORD PTR _UI_Sys+2092, 0
	jge	SHORT $LN23@UISelectFi

; 1899 : 				UI_Sys.mouse_scroll = 0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 1900 : 			else

	jmp	SHORT $LN27@UISelectFi
$LN23@UISelectFi:

; 1901 : 				if (UI_Sys.mouse_scroll>UI_Sys.num_files - 13)

	movsx	eax, WORD PTR _UI_Sys+265332
	sub	eax, 13					; 0000000dH
	cmp	DWORD PTR _UI_Sys+2092, eax
	jle	SHORT $LN27@UISelectFi

; 1902 : 					UI_Sys.mouse_scroll = UI_Sys.num_files - 13;

	movsx	eax, WORD PTR _UI_Sys+265332
	sub	eax, 13					; 0000000dH
	mov	DWORD PTR _UI_Sys+2092, eax
$LN27@UISelectFi:

; 1903 : 		}
; 1904 : 	}
; 1905 : 	else

	jmp	$LN20@UISelectFi
$LN45@UISelectFi:

; 1906 : 	{
; 1907 : 		for(i=0;i<UI_Sys.num_files;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN19@UISelectFi
$LN18@UISelectFi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN19@UISelectFi:
	movsx	eax, WORD PTR _UI_Sys+265332
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN20@UISelectFi

; 1908 : 		{
; 1909 : 
; 1910 : 			if(CheckCollisionMouse(8192,4608-((4608-512)/2)+256+(i*256),8192-512,256,0) && st.mouse1)

	push	0
	push	256					; 00000100H
	push	7680					; 00001e00H
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	8192					; 00002000H
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	ecx, al
	test	ecx, ecx
	je	$LN16@UISelectFi
	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	$LN16@UISelectFi

; 1911 : 			{
; 1912 : 				if((GetTimerM()-time)<50)

	call	@GetTimerM@0
	mov	ecx, eax
	mov	esi, edx
	mov	eax, DWORD PTR ?time@?1??UISelectFile@@9@9
	cdq
	sub	ecx, eax
	sbb	esi, edx
	mov	DWORD PTR tv868[ebp], ecx
	mov	DWORD PTR tv868[ebp+4], esi
	cmp	DWORD PTR tv868[ebp+4], 0
	ja	$LN15@UISelectFi
	jb	SHORT $LN49@UISelectFi
	cmp	DWORD PTR tv868[ebp], 50		; 00000032H
	jae	$LN15@UISelectFi
$LN49@UISelectFi:

; 1913 : 				{
; 1914 : 					UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 1915 : 
; 1916 : 					strcat(UI_Sys.current_path,"//");

	push	OFFSET ??_C@_02CBLDBPFN@?1?1?$AA@
	push	OFFSET _UI_Sys+43
	call	_strcat
	add	esp, 8

; 1917 : 					strcat(UI_Sys.current_path,UI_Sys.files[m_sel]);

	mov	eax, DWORD PTR ?m_sel@?1??UISelectFile@@9@9
	shl	eax, 9
	add	eax, OFFSET _UI_Sys+2164
	push	eax
	push	OFFSET _UI_Sys+43
	call	_strcat
	add	esp, 8

; 1918 : 
; 1919 : 
; 1920 : 					if((f=fopen(UI_Sys.current_path,"rb"))==NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET _UI_Sys+43
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax
	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN14@UISelectFi

; 1921 : 					{
; 1922 : 						if((dir=opendir(UI_Sys.current_path))!=NULL)

	push	OFFSET _UI_Sys+43
	call	_opendir
	add	esp, 4
	mov	DWORD PTR _dir$[ebp], eax
	cmp	DWORD PTR _dir$[ebp], 0
	je	SHORT $LN14@UISelectFi

; 1923 : 						{
; 1924 : 							closedir(dir);

	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	_closedir
	add	esp, 4

; 1925 : 							UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 1926 : 							m_sel=-1;

	mov	DWORD PTR ?m_sel@?1??UISelectFile@@9@9, -1

; 1927 : 							st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 1928 : 							time=0;

	mov	DWORD PTR ?time@?1??UISelectFile@@9@9, 0

; 1929 : 							SetDirContent(UI_Sys.extension);

	push	OFFSET _UI_Sys+265334
	call	_SetDirContent
	add	esp, 4

; 1930 : 
; 1931 : 							break;

	jmp	$LN20@UISelectFi
$LN14@UISelectFi:

; 1932 : 						}
; 1933 : 					}
; 1934 : 
; 1935 : 					fclose(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 1936 : 					UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 1937 : 					m_sel=-1;

	mov	DWORD PTR ?m_sel@?1??UISelectFile@@9@9, -1

; 1938 : 
; 1939 : 					strcpy(path,UI_Sys.current_path);

	push	OFFSET _UI_Sys+43
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1940 : 
; 1941 : 					strcpy(UI_Sys.current_path,".");

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	push	OFFSET _UI_Sys+43
	call	_strcpy
	add	esp, 8

; 1942 : 
; 1943 : 					st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 1944 : 					time=0;

	mov	DWORD PTR ?time@?1??UISelectFile@@9@9, 0

; 1945 : 
; 1946 : 					strcpy(filename,path);

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1947 : 					return 1;

	mov	al, 1
	jmp	$LN46@UISelectFi
$LN15@UISelectFi:

; 1948 : 				}
; 1949 : 
; 1950 : 				time=GetTimerM();

	call	@GetTimerM@0
	mov	DWORD PTR ?time@?1??UISelectFile@@9@9, eax

; 1951 : 				if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN12@UISelectFi

; 1952 : 					m_sel=UI_Sys.foldersp[i];

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264820]
	mov	DWORD PTR ?m_sel@?1??UISelectFile@@9@9, ecx

; 1953 : 				else

	jmp	SHORT $LN11@UISelectFi
$LN12@UISelectFi:

; 1954 : 					m_sel=UI_Sys.filesp[i];

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	DWORD PTR ?m_sel@?1??UISelectFile@@9@9, ecx
$LN11@UISelectFi:

; 1955 : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0
$LN16@UISelectFi:

; 1956 : 			}
; 1957 : 
; 1958 : 			if(m_sel==UI_Sys.filesp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	cmp	DWORD PTR ?m_sel@?1??UISelectFile@@9@9, ecx
	jne	$LN10@UISelectFi

; 1959 : 			{
; 1960 : 				UIData(8192,4608-((4608-512)/2)+256+(i*256),8192-512,256,0,0,0,0,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.scroll_frame1],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+14
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	256					; 00000100H
	push	7680					; 00001e00H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 8
	add	ecx, 2816				; 00000b00H
	push	ecx
	push	8192					; 00002000H
	call	_UIData
	add	esp, 96					; 00000060H

; 1961 : 				if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN9@UISelectFi

; 1962 : 					StringUIvData(UI_Sys.files[UI_Sys.foldersp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(i*256),0,0,0,255,255,255,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264820]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H

; 1963 : 				else

	jmp	SHORT $LN8@UISelectFi
$LN9@UISelectFi:

; 1964 : 					StringUIvData(UI_Sys.files[UI_Sys.filesp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(i*256),0,0,0,255,255,255,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264308]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H
$LN8@UISelectFi:

; 1965 : 			}
; 1966 : 			else

	jmp	$LN7@UISelectFi
$LN10@UISelectFi:

; 1967 : 			{
; 1968 : 				if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN6@UISelectFi

; 1969 : 					StringUIvData(UI_Sys.files[UI_Sys.foldersp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(i*256),0,0,0,0,0,0,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264820]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H

; 1970 : 				else

	jmp	SHORT $LN7@UISelectFi
$LN6@UISelectFi:

; 1971 : 					StringUIvData(UI_Sys.files[UI_Sys.filesp[i]],8192-((8192-512)/2)+256,4608-((4608-512)/2)+256+(i*256),0,0,0,0,0,0,255,0,2048,2048,0);

	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 8
	add	eax, 2816				; 00000b00H
	push	eax
	push	4608					; 00001200H
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR _UI_Sys[ecx*2+264308]
	shl	edx, 9
	add	edx, OFFSET _UI_Sys+2164
	push	edx
	call	_StringUIvData
	add	esp, 56					; 00000038H
$LN7@UISelectFi:

; 1972 : 			}
; 1973 : 
; 1974 : 			if(UI_Sys.filesp[i]==UI_Sys.foldersp[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _UI_Sys[eax*2+264308]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _UI_Sys[edx*2+264820]
	cmp	ecx, eax
	jne	SHORT $LN4@UISelectFi

; 1975 : 				UIData(8192-((8192-512)/2)+128,4608-((4608-512)/2)+256+(i*256),256,256,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.folder_icon],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+21
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	256					; 00000100H
	push	256					; 00000100H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 8
	add	ecx, 2816				; 00000b00H
	push	ecx
	push	4480					; 00001180H
	call	_UIData
	add	esp, 96					; 00000060H
$LN4@UISelectFi:

; 1976 : 		}

	jmp	$LN18@UISelectFi
$LN20@UISelectFi:

; 1977 : 	}
; 1978 : 
; 1979 : 	if(UIStringButton(8192+2048+1024,4608+2048+64+32+16,"Open",0,1536,0,UI_COL_NORMAL,UI_COL_SELECTED)==UI_SEL)

	push	16744480				; 00ff8020H
	push	16777215				; 00ffffffH
	push	0
	push	1536					; 00000600H
	push	0
	push	OFFSET ??_C@_04DNCDCIAE@Open?$AA@
	push	6768					; 00001a70H
	push	11264					; 00002c00H
	call	_UIStringButton
	add	esp, 32					; 00000020H
	movsx	eax, al
	cmp	eax, 100				; 00000064H
	jne	$LN3@UISelectFi

; 1980 : 	{
; 1981 : 		UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 1982 : 
; 1983 : 		strcat(UI_Sys.current_path,"//");

	push	OFFSET ??_C@_02CBLDBPFN@?1?1?$AA@
	push	OFFSET _UI_Sys+43
	call	_strcat
	add	esp, 8

; 1984 : 		strcat(UI_Sys.current_path,UI_Sys.files[m_sel]);

	mov	eax, DWORD PTR ?m_sel@?1??UISelectFile@@9@9
	shl	eax, 9
	add	eax, OFFSET _UI_Sys+2164
	push	eax
	push	OFFSET _UI_Sys+43
	call	_strcat
	add	esp, 8

; 1985 : 
; 1986 : 
; 1987 : 		if((f=fopen(UI_Sys.current_path,"rb"))==NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET _UI_Sys+43
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax
	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@UISelectFi

; 1988 : 		{
; 1989 : 			if((dir=opendir(UI_Sys.current_path))!=NULL)

	push	OFFSET _UI_Sys+43
	call	_opendir
	add	esp, 4
	mov	DWORD PTR _dir$[ebp], eax
	cmp	DWORD PTR _dir$[ebp], 0
	je	SHORT $LN2@UISelectFi

; 1990 : 			{
; 1991 : 				closedir(dir);

	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	_closedir
	add	esp, 4

; 1992 : 				UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 1993 : 				m_sel=-1;

	mov	DWORD PTR ?m_sel@?1??UISelectFile@@9@9, -1

; 1994 : 				SetDirContent(UI_Sys.extension);

	push	OFFSET _UI_Sys+265334
	call	_SetDirContent
	add	esp, 4

; 1995 : 				return NULL;

	xor	al, al
	jmp	SHORT $LN46@UISelectFi
$LN2@UISelectFi:

; 1996 : 			}
; 1997 : 		}
; 1998 : 
; 1999 : 		fclose(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 2000 : 		UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 2001 : 		m_sel=-1;

	mov	DWORD PTR ?m_sel@?1??UISelectFile@@9@9, -1

; 2002 : 
; 2003 : 		strcpy(path,UI_Sys.current_path);

	push	OFFSET _UI_Sys+43
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2004 : 
; 2005 : 		strcpy(UI_Sys.current_path,".");

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	push	OFFSET _UI_Sys+43
	call	_strcpy
	add	esp, 8

; 2006 : 
; 2007 : 		strcpy(filename,path);

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2008 : 		st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 2009 : 		return 1;

	mov	al, 1
	jmp	SHORT $LN46@UISelectFi
$LN3@UISelectFi:

; 2010 : 	}
; 2011 : 
; 2012 : 	return NULL;

	xor	al, al
$LN46@UISelectFi:

; 2013 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN52@UISelectFi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 2404				; 00000964H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN52@UISelectFi:
	DD	1
	DD	$LN51@UISelectFi
$LN51@UISelectFi:
	DD	-2056					; fffff7f8H
	DD	2048					; 00000800H
	DD	$LN50@UISelectFi
$LN50@UISelectFi:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
_UISelectFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _SetDirContent
_TEXT	SEGMENT
_f$ = -2384						; size = 4
_dir$ = -2372						; size = 4
_size$ = -2360						; size = 4
_path$ = -2348						; size = 2048
_toks$ = -292						; size = 128
_tok$ = -156						; size = 4
_ext$ = -144						; size = 16
_num_ext$ = -120					; size = 2
_num_files$ = -108					; size = 2
_p$ = -96						; size = 2
_o$ = -84						; size = 2
_n$ = -72						; size = 2
_m$ = -60						; size = 2
_l$ = -48						; size = 2
_k$ = -36						; size = 2
_j$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_extension$ = 8						; size = 4
_SetDirContent PROC					; COMDAT

; 1674 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2580				; 00000a14H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2580]
	mov	ecx, 645				; 00000285H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1675 : 	register int16 i, j, k, l, m, n, o, p;
; 1676 : 	int16 num_files, num_ext;
; 1677 : 	char ext[16], *tok, toks[16][8], path[2048];
; 1678 : 	size_t size;
; 1679 : 	DIR *dir;
; 1680 : 	FILE *f;
; 1681 : 
; 1682 : 	if(extension)

	cmp	DWORD PTR _extension$[ebp], 0
	je	SHORT $LN27@SetDirCont

; 1683 : 		strcpy(UI_Sys.extension,extension);

	mov	eax, DWORD PTR _extension$[ebp]
	push	eax
	push	OFFSET _UI_Sys+265334
	call	_strcpy
	add	esp, 8
$LN27@SetDirCont:

; 1684 : 
; 1685 : 	UI_Sys.num_files=0;

	xor	eax, eax
	mov	WORD PTR _UI_Sys+265332, ax

; 1686 : 
; 1687 : 	num_files=NumDirFile(UI_Sys.current_path,UI_Sys.files);

	push	OFFSET _UI_Sys+2164
	push	OFFSET _UI_Sys+43
	call	_NumDirFile
	add	esp, 8
	mov	WORD PTR _num_files$[ebp], ax

; 1688 : 
; 1689 : 	if(extension)

	cmp	DWORD PTR _extension$[ebp], 0
	je	$LN26@SetDirCont

; 1690 : 	{
; 1691 : 		memset(ext,0,16);

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1692 : 		size=strlen(extension);

	mov	eax, DWORD PTR _extension$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 1693 : 
; 1694 : 		for(k=0;k<size;k++)

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN25@SetDirCont
$LN24@SetDirCont:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN25@SetDirCont:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jae	SHORT $LN23@SetDirCont

; 1695 : 			ext[k]=tolower(extension[k]);

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _extension$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	_tolower
	add	esp, 4
	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _ext$[ebp+ecx], al
	jmp	SHORT $LN24@SetDirCont
$LN23@SetDirCont:

; 1696 : 
; 1697 : 		strcpy(UI_Sys.extension2,ext);

	lea	eax, DWORD PTR _ext$[ebp]
	push	eax
	push	OFFSET _UI_Sys+265366
	call	_strcpy
	add	esp, 8

; 1698 : 
; 1699 : 		tok=strtok(ext,", ");

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_strtok
	add	esp, 8
	mov	DWORD PTR _tok$[ebp], eax

; 1700 : 
; 1701 : 		strcpy(toks[0],tok);

	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	mov	ecx, 8
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _toks$[ebp+edx]
	push	eax
	call	_strcpy
	add	esp, 8

; 1702 : 
; 1703 : 		num_ext=1;

	mov	eax, 1
	mov	WORD PTR _num_ext$[ebp], ax

; 1704 : 
; 1705 : 		k=1;

	mov	eax, 1
	mov	WORD PTR _k$[ebp], ax
$LN22@SetDirCont:

; 1706 : 
; 1707 : 		while(tok!=NULL)

	cmp	DWORD PTR _tok$[ebp], 0
	je	SHORT $LN26@SetDirCont

; 1708 : 		{
; 1709 : 			tok=strtok(NULL,", ");

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	push	0
	call	_strtok
	add	esp, 8
	mov	DWORD PTR _tok$[ebp], eax

; 1710 : 			if(tok!=NULL)

	cmp	DWORD PTR _tok$[ebp], 0
	je	SHORT $LN20@SetDirCont

; 1711 : 			{
; 1712 : 				strcpy(toks[k],tok);

	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	movsx	ecx, WORD PTR _k$[ebp]
	lea	edx, DWORD PTR _toks$[ebp+ecx*8]
	push	edx
	call	_strcpy
	add	esp, 8

; 1713 : 				num_ext++;

	mov	ax, WORD PTR _num_ext$[ebp]
	add	ax, 1
	mov	WORD PTR _num_ext$[ebp], ax

; 1714 : 				k++;

	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN20@SetDirCont:

; 1715 : 			}
; 1716 : 		}

	jmp	SHORT $LN22@SetDirCont
$LN26@SetDirCont:

; 1717 : 	}
; 1718 : 
; 1719 : 	for(i=0, j=0, l=0;i<num_files;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	xor	edx, edx
	mov	WORD PTR _l$[ebp], dx
	jmp	SHORT $LN19@SetDirCont
$LN18@SetDirCont:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN19@SetDirCont:
	movsx	eax, WORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _num_files$[ebp]
	cmp	eax, ecx
	jge	$LN28@SetDirCont

; 1720 : 	{
; 1721 : 			strcpy(path,UI_Sys.current_path);

	push	OFFSET _UI_Sys+43
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1722 : 			strcat(path,"//");

	push	OFFSET ??_C@_02CBLDBPFN@?1?1?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1723 : 			strcat(path,UI_Sys.files[i]);

	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 9
	add	eax, OFFSET _UI_Sys+2164
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1724 : 
; 1725 : 			if((f=fopen(path,"rb"))==NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax
	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN16@SetDirCont

; 1726 : 			{
; 1727 : 				if((dir=opendir(path))!=NULL)

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_opendir
	add	esp, 4
	mov	DWORD PTR _dir$[ebp], eax
	cmp	DWORD PTR _dir$[ebp], 0
	je	SHORT $LN15@SetDirCont

; 1728 : 				{
; 1729 : 					closedir(dir);

	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	_closedir
	add	esp, 4

; 1730 : 					
; 1731 : 					UI_Sys.foldersp[j]=i;

	movsx	eax, WORD PTR _j$[ebp]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _UI_Sys[eax*2+264820], cx

; 1732 : 					UI_Sys.filesp[j]=i;

	movsx	eax, WORD PTR _j$[ebp]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _UI_Sys[eax*2+264308], cx

; 1733 : 					j++;

	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax

; 1734 : 					//l++;
; 1735 : 					UI_Sys.num_files++;

	mov	ax, WORD PTR _UI_Sys+265332
	add	ax, 1
	mov	WORD PTR _UI_Sys+265332, ax
$LN15@SetDirCont:

; 1736 : 					//num3++;
; 1737 : 				}
; 1738 : 			}
; 1739 : 			else

	jmp	$LN14@SetDirCont
$LN16@SetDirCont:

; 1740 : 			{
; 1741 : 				fclose(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 1742 : 
; 1743 : 				//Check if the current extension is the one asked
; 1744 : 
; 1745 : 				if(extension)

	cmp	DWORD PTR _extension$[ebp], 0
	je	$LN13@SetDirCont

; 1746 : 				{
; 1747 : 
; 1748 : 					size=strlen(UI_Sys.files[i]);

	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 9
	add	eax, OFFSET _UI_Sys+2164
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 1749 : 
; 1750 : 					for(m=size;m>-1;m--)

	mov	ax, WORD PTR _size$[ebp]
	mov	WORD PTR _m$[ebp], ax
	jmp	SHORT $LN12@SetDirCont
$LN11@SetDirCont:
	mov	ax, WORD PTR _m$[ebp]
	sub	ax, 1
	mov	WORD PTR _m$[ebp], ax
$LN12@SetDirCont:
	movsx	eax, WORD PTR _m$[ebp]
	cmp	eax, -1
	jle	$LN10@SetDirCont

; 1751 : 					{
; 1752 : 						if(UI_Sys.files[i][m]=='.')

	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 9
	movsx	ecx, WORD PTR _m$[ebp]
	movsx	edx, BYTE PTR _UI_Sys[eax+ecx+2164]
	cmp	edx, 46					; 0000002eH
	jne	$LN9@SetDirCont

; 1753 : 						{
; 1754 : 							memset(path,0,2048);

	push	2048					; 00000800H
	push	0
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1755 : 							for(n=m+1,o=0;n<size;n++,o++)

	movsx	eax, WORD PTR _m$[ebp]
	add	eax, 1
	mov	WORD PTR _n$[ebp], ax
	xor	ecx, ecx
	mov	WORD PTR _o$[ebp], cx
	jmp	SHORT $LN8@SetDirCont
$LN7@SetDirCont:
	mov	ax, WORD PTR _n$[ebp]
	add	ax, 1
	mov	WORD PTR _n$[ebp], ax
	mov	cx, WORD PTR _o$[ebp]
	add	cx, 1
	mov	WORD PTR _o$[ebp], cx
$LN8@SetDirCont:
	movsx	eax, WORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jae	SHORT $LN6@SetDirCont

; 1756 : 							{
; 1757 : 								path[o]=tolower(UI_Sys.files[i][n]);

	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 9
	movsx	ecx, WORD PTR _n$[ebp]
	movsx	edx, BYTE PTR _UI_Sys[eax+ecx+2164]
	push	edx
	call	_tolower
	add	esp, 4
	movsx	ecx, WORD PTR _o$[ebp]
	mov	BYTE PTR _path$[ebp+ecx], al

; 1758 : 							}

	jmp	SHORT $LN7@SetDirCont
$LN6@SetDirCont:

; 1759 : 
; 1760 : 							for(p=0;p<num_ext;p++)

	xor	eax, eax
	mov	WORD PTR _p$[ebp], ax
	jmp	SHORT $LN5@SetDirCont
$LN4@SetDirCont:
	mov	ax, WORD PTR _p$[ebp]
	add	ax, 1
	mov	WORD PTR _p$[ebp], ax
$LN5@SetDirCont:
	movsx	eax, WORD PTR _p$[ebp]
	movsx	ecx, WORD PTR _num_ext$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN9@SetDirCont

; 1761 : 							{
; 1762 : 								if(strcmp(path,toks[p])==NULL)

	movsx	eax, WORD PTR _p$[ebp]
	lea	ecx, DWORD PTR _toks$[ebp+eax*8]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@SetDirCont

; 1763 : 								{
; 1764 : 									UI_Sys.filesp[j]=i;

	movsx	eax, WORD PTR _j$[ebp]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _UI_Sys[eax*2+264308], cx

; 1765 : 									j++;

	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax

; 1766 : 									UI_Sys.num_files++;

	mov	ax, WORD PTR _UI_Sys+265332
	add	ax, 1
	mov	WORD PTR _UI_Sys+265332, ax

; 1767 : 									break;

	jmp	SHORT $LN9@SetDirCont
$LN2@SetDirCont:

; 1768 : 								}
; 1769 : 							}

	jmp	SHORT $LN4@SetDirCont
$LN9@SetDirCont:

; 1770 : 						}
; 1771 : 					}

	jmp	$LN11@SetDirCont
$LN10@SetDirCont:

; 1772 : 				}
; 1773 : 				else

	jmp	SHORT $LN14@SetDirCont
$LN13@SetDirCont:

; 1774 : 				{
; 1775 : 					UI_Sys.filesp[j]=i;

	movsx	eax, WORD PTR _j$[ebp]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR _UI_Sys[eax*2+264308], cx

; 1776 : 					j++;

	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax

; 1777 : 					UI_Sys.num_files++;

	mov	ax, WORD PTR _UI_Sys+265332
	add	ax, 1
	mov	WORD PTR _UI_Sys+265332, ax
$LN14@SetDirCont:

; 1778 : 				}
; 1779 : 			}
; 1780 : 	}

	jmp	$LN18@SetDirCont
$LN28@SetDirCont:

; 1781 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN34@SetDirCont
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 2580				; 00000a14H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN34@SetDirCont:
	DD	3
	DD	$LN33@SetDirCont
$LN33@SetDirCont:
	DD	-144					; ffffff70H
	DD	16					; 00000010H
	DD	$LN30@SetDirCont
	DD	-292					; fffffedcH
	DD	128					; 00000080H
	DD	$LN31@SetDirCont
	DD	-2348					; fffff6d4H
	DD	2048					; 00000800H
	DD	$LN32@SetDirCont
$LN32@SetDirCont:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN31@SetDirCont:
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	107					; 0000006bH
	DB	115					; 00000073H
	DB	0
$LN30@SetDirCont:
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_SetDirContent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UITextBox
_TEXT	SEGMENT
_bc$ = -125						; size = 1
_gc$ = -113						; size = 1
_rc$ = -101						; size = 1
_bs$ = -89						; size = 1
_gs$ = -77						; size = 1
_rs$ = -65						; size = 1
_bn$ = -53						; size = 1
_gn$ = -41						; size = 1
_rn$ = -29						; size = 1
_gsize$ = -20						; size = 2
_lenght$ = -8						; size = 2
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_sizex$ = 16						; size = 4
_text$ = 20						; size = 4
_font$ = 24						; size = 1
_font_size$ = 28					; size = 2
_colorN$ = 32						; size = 4
_colorS$ = 36						; size = 4
_colorC$ = 40						; size = 4
_layer$ = 44						; size = 1
_option_number$ = 48					; size = 2
_UITextBox PROC						; COMDAT

; 1611 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-324]
	mov	ecx, 81					; 00000051H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1612 : 	int16 lenght, gsize;
; 1613 : 
; 1614 : 	uint8 rn, gn, bn, rs, gs, bs, rc, gc, bc;
; 1615 : 
; 1616 : 	//char text2[32];
; 1617 : 
; 1618 : 	rn=colorN>>16;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rn$[ebp], al

; 1619 : 	gn=(colorN>>8) & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gn$[ebp], al

; 1620 : 	bn=colorN & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bn$[ebp], al

; 1621 : 
; 1622 : 	rs=colorS>>16;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rs$[ebp], al

; 1623 : 	gs=(colorS>>8) & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gs$[ebp], al

; 1624 : 	bs=colorS & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bs$[ebp], al

; 1625 : 
; 1626 : 	rc=colorC>>16;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rc$[ebp], al

; 1627 : 	gc=(colorC>>8) & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gc$[ebp], al

; 1628 : 	bc=colorC & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bc$[ebp], al

; 1629 : 
; 1630 : 	gsize=(st.fonts[font].size_h_gm*font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	movsx	edx, WORD PTR _font_size$[ebp]
	imul	edx, DWORD PTR _st[ecx+64360]
	shr	edx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], dx

; 1631 : 
; 1632 : 	//sprintf(text2,"%s: %.3f",text, *value);
; 1633 : 
; 1634 : 	lenght=strlen(text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _lenght$[ebp], ax

; 1635 : 
; 1636 : 	UIData(x,y,sizex,gsize,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.window_frame2],255,layer);

	movzx	eax, BYTE PTR _layer$[ebp]
	push	eax
	push	255					; 000000ffH
	movsx	ecx, BYTE PTR _UI_Sys
	imul	edx, ecx, 60
	movsx	eax, BYTE PTR _UI_Sys+4
	imul	ecx, eax, 40
	mov	esi, DWORD PTR _mgg_sys[edx+40]
	add	esi, ecx
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	movsx	edx, WORD PTR _gsize$[ebp]
	push	edx
	mov	eax, DWORD PTR _sizex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_UIData
	add	esp, 96					; 00000060H

; 1637 : 
; 1638 : 	if(UI_Sys.current_option!=option_number)

	movsx	eax, WORD PTR _UI_Sys+2096
	movsx	ecx, WORD PTR _option_number$[ebp]
	cmp	eax, ecx
	je	$LN7@UITextBox

; 1639 : 	{
; 1640 : 		if(CheckCollisionMouse(x,y,sizex,gsize,0))

	push	0
	movsx	eax, WORD PTR _gsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sizex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@UITextBox

; 1641 : 		{
; 1642 : 			StringUIvData(text,x-(sizex/2),y,0,0,0,rs,gs,bs,255,font,font_size,font_size,layer);

	movzx	eax, BYTE PTR _layer$[ebp]
	push	eax
	movsx	ecx, WORD PTR _font_size$[ebp]
	push	ecx
	movsx	edx, WORD PTR _font_size$[ebp]
	push	edx
	movzx	eax, BYTE PTR _font$[ebp]
	push	eax
	push	255					; 000000ffH
	movzx	ecx, BYTE PTR _bs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _gs$[ebp]
	push	edx
	movzx	eax, BYTE PTR _rs$[ebp]
	push	eax
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _x$[ebp]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_StringUIvData
	add	esp, 56					; 00000038H

; 1643 : 
; 1644 : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN5@UITextBox

; 1645 : 			{
; 1646 : 				UI_Sys.current_option=option_number;

	mov	ax, WORD PTR _option_number$[ebp]
	mov	WORD PTR _UI_Sys+2096, ax

; 1647 : 				strcpy(st.TextInput,text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	push	OFFSET _st+66670
	call	_strcpy
	add	esp, 8

; 1648 : 				StartText();

	call	_StartText

; 1649 : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 1650 : 				UI_Sys.textinput=1;

	mov	BYTE PTR _UI_Sys+2163, 1
$LN5@UITextBox:

; 1651 : 			}
; 1652 : 		}
; 1653 : 		else

	jmp	SHORT $LN4@UITextBox
$LN6@UITextBox:

; 1654 : 			StringUIvData(text,x-(sizex/2),y,0,0,0,rn,gn,bn,255,font,font_size,font_size,layer);

	movzx	eax, BYTE PTR _layer$[ebp]
	push	eax
	movsx	ecx, WORD PTR _font_size$[ebp]
	push	ecx
	movsx	edx, WORD PTR _font_size$[ebp]
	push	edx
	movzx	eax, BYTE PTR _font$[ebp]
	push	eax
	push	255					; 000000ffH
	movzx	ecx, BYTE PTR _bn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _gn$[ebp]
	push	edx
	movzx	eax, BYTE PTR _rn$[ebp]
	push	eax
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _x$[ebp]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_StringUIvData
	add	esp, 56					; 00000038H
$LN4@UITextBox:

; 1655 : 	}
; 1656 : 	else

	jmp	$LN8@UITextBox
$LN7@UITextBox:

; 1657 : 	if(UI_Sys.current_option==option_number)

	movsx	eax, WORD PTR _UI_Sys+2096
	movsx	ecx, WORD PTR _option_number$[ebp]
	cmp	eax, ecx
	jne	$LN8@UITextBox

; 1658 : 	{
; 1659 : 		StringUIvData(text,x-(sizex/2),y,0,0,0,rc,gc,bc,255,font,font_size,font_size,layer);

	movzx	eax, BYTE PTR _layer$[ebp]
	push	eax
	movsx	ecx, WORD PTR _font_size$[ebp]
	push	ecx
	movsx	edx, WORD PTR _font_size$[ebp]
	push	edx
	movzx	eax, BYTE PTR _font$[ebp]
	push	eax
	push	255					; 000000ffH
	movzx	ecx, BYTE PTR _bc$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _gc$[ebp]
	push	edx
	movzx	eax, BYTE PTR _rc$[ebp]
	push	eax
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _x$[ebp]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_StringUIvData
	add	esp, 56					; 00000038H

; 1660 : 
; 1661 : 		strcpy(text,st.TextInput);

	push	OFFSET _st+66670
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1662 : 
; 1663 : 		if(st.keys[RETURN_KEY].state)

	mov	eax, 8
	shl	eax, 0
	movzx	ecx, BYTE PTR _st[eax+65648]
	test	ecx, ecx
	je	SHORT $LN8@UITextBox

; 1664 : 		{
; 1665 : 			StopText();

	call	_StopText

; 1666 : 			st.keys[RETURN_KEY].state=0;

	mov	eax, 8
	shl	eax, 0
	mov	BYTE PTR _st[eax+65648], 0

; 1667 : 			UI_Sys.current_option=-1;

	or	eax, -1
	mov	WORD PTR _UI_Sys+2096, ax

; 1668 : 			UI_Sys.textinput=0;

	mov	BYTE PTR _UI_Sys+2163, 0
$LN8@UITextBox:

; 1669 : 		}
; 1670 : 	}
; 1671 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 324				; 00000144H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UITextBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _Sys_ColorPicker
_TEXT	SEGMENT
_p$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_Sys_ColorPicker PROC					; COMDAT

; 1595 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1596 : 	Pos p;
; 1597 : 
; 1598 : 	UIData(14336,1536,GAME_HEIGHT/2,2048,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[0].frames[10],255,0);

	push	0
	push	255					; 000000ffH
	mov	eax, 60					; 0000003cH
	imul	ecx, eax, 0
	mov	edx, 40					; 00000028H
	imul	eax, edx, 10
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	2048					; 00000800H
	push	4608					; 00001200H
	push	1536					; 00000600H
	push	14336					; 00003800H
	call	_UIData
	add	esp, 96					; 00000060H

; 1599 : 
; 1600 : 	if(CheckCollisionMouse(14336,1536,GAME_HEIGHT/2,2048,0) && st.mouse1)

	push	0
	push	2048					; 00000800H
	push	4608					; 00001200H
	push	1536					; 00000600H
	push	14336					; 00003800H
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	je	$LN2@Sys_ColorP
	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	$LN2@Sys_ColorP

; 1601 : 	{
; 1602 : 		p=st.mouse;

	mov	eax, DWORD PTR _st+65624
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _st+65628
	mov	DWORD PTR _p$[ebp+4], ecx
	mov	edx, DWORD PTR _st+65632
	mov	DWORD PTR _p$[ebp+8], edx

; 1603 : 
; 1604 : 		glReadPixels(p.x,st.screeny-p.y-1,1,1,GL_RED,GL_UNSIGNED_BYTE,r);

	mov	esi, esp
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	push	5121					; 00001401H
	push	6403					; 00001903H
	push	1
	push	1
	movzx	ecx, WORD PTR _st+230
	sub	ecx, DWORD PTR _p$[ebp+4]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	DWORD PTR __imp__glReadPixels@28
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1605 : 		glReadPixels(p.x,st.screeny-p.y-1,1,1,GL_GREEN,GL_UNSIGNED_BYTE,g);

	mov	esi, esp
	mov	eax, DWORD PTR _g$[ebp]
	push	eax
	push	5121					; 00001401H
	push	6404					; 00001904H
	push	1
	push	1
	movzx	ecx, WORD PTR _st+230
	sub	ecx, DWORD PTR _p$[ebp+4]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	DWORD PTR __imp__glReadPixels@28
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1606 : 		glReadPixels(p.x,st.screeny-p.y-1,1,1,GL_BLUE,GL_UNSIGNED_BYTE,b);

	mov	esi, esp
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	push	5121					; 00001401H
	push	6405					; 00001905H
	push	1
	push	1
	movzx	ecx, WORD PTR _st+230
	sub	ecx, DWORD PTR _p$[ebp+4]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	DWORD PTR __imp__glReadPixels@28
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Sys_ColorP:

; 1607 : 	}
; 1608 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Sys_ColorP
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@Sys_ColorP:
	DD	1
	DD	$LN5@Sys_ColorP
$LN5@Sys_ColorP:
	DD	-20					; ffffffecH
	DD	12					; 0000000cH
	DD	$LN4@Sys_ColorP
$LN4@Sys_ColorP:
	DB	112					; 00000070H
	DB	0
_Sys_ColorPicker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIStringButtonWorld
_TEXT	SEGMENT
_bs$ = -101						; size = 1
_gs$ = -89						; size = 1
_rs$ = -77						; size = 1
_bn$ = -65						; size = 1
_gn$ = -53						; size = 1
_rn$ = -41						; size = 1
_gsizew$ = -32						; size = 2
_gsize$ = -20						; size = 2
_text_size$ = -8					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_text$ = 16						; size = 4
_font$ = 20						; size = 1
_font_size$ = 24					; size = 2
_layer$ = 28						; size = 1
_colorN$ = 32						; size = 4
_colorS$ = 36						; size = 4
_UIStringButtonWorld PROC				; COMDAT

; 513  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 514  : 	int32 text_size;
; 515  : 	int16 gsize, gsizew;
; 516  : 
; 517  : 	uint8 rn, gn, bn, rs, gs, bs;
; 518  : 
; 519  : 	rn=colorN>>16;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rn$[ebp], al

; 520  : 	gn=(colorN>>8) & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gn$[ebp], al

; 521  : 	bn=colorN & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bn$[ebp], al

; 522  : 
; 523  : 	rs=colorS>>16;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rs$[ebp], al

; 524  : 	gs=(colorS>>8) & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gs$[ebp], al

; 525  : 	bs=colorS & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bs$[ebp], al

; 526  : 
; 527  : 	gsize=(st.fonts[font].size_h_gm*font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	movsx	edx, WORD PTR _font_size$[ebp]
	imul	edx, DWORD PTR _st[ecx+64360]
	shr	edx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], dx

; 528  : 	gsizew=(st.fonts[font].size_w_gm*font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	movsx	edx, WORD PTR _font_size$[ebp]
	imul	edx, DWORD PTR _st[ecx+64356]
	shr	edx, 10					; 0000000aH
	mov	WORD PTR _gsizew$[ebp], dx

; 529  : 
; 530  : 	text_size=gsizew*strlen(text);

	movsx	esi, WORD PTR _gsizew$[ebp]
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	imul	esi, eax
	mov	DWORD PTR _text_size$[ebp], esi

; 531  : 
; 532  : 	if(CheckCollisionMouseWorld(x,y,text_size,gsize,0,layer))

	movzx	eax, BYTE PTR _layer$[ebp]
	push	eax
	push	0
	movsx	ecx, WORD PTR _gsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_CheckCollisionMouseWorld
	add	esp, 24					; 00000018H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@UIStringBu

; 533  : 	{
; 534  : 		String2Data(text,x,y,text_size,gsize,0,rs,gs,bs,255,font,font_size,font_size,layer);

	movzx	eax, BYTE PTR _layer$[ebp]
	push	eax
	movsx	ecx, WORD PTR _font_size$[ebp]
	push	ecx
	movsx	edx, WORD PTR _font_size$[ebp]
	push	edx
	movzx	eax, BYTE PTR _font$[ebp]
	push	eax
	push	255					; 000000ffH
	movzx	ecx, BYTE PTR _bs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _gs$[ebp]
	push	edx
	movzx	eax, BYTE PTR _rs$[ebp]
	push	eax
	push	0
	movsx	ecx, WORD PTR _gsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	call	_String2Data
	add	esp, 56					; 00000038H

; 535  : 
; 536  : 		if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN2@UIStringBu

; 537  : 		{
; 538  : 			st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 539  : 			return UI_SEL;

	mov	al, 100					; 00000064H
	jmp	SHORT $LN4@UIStringBu
$LN2@UIStringBu:

; 540  : 		}
; 541  : 	}
; 542  : 	else

	jmp	SHORT $LN1@UIStringBu
$LN3@UIStringBu:

; 543  : 		String2Data(text,x,y,text_size,gsize,0,rn,gn,bn,255,font,font_size,font_size,layer);

	movzx	eax, BYTE PTR _layer$[ebp]
	push	eax
	movsx	ecx, WORD PTR _font_size$[ebp]
	push	ecx
	movsx	edx, WORD PTR _font_size$[ebp]
	push	edx
	movzx	eax, BYTE PTR _font$[ebp]
	push	eax
	push	255					; 000000ffH
	movzx	ecx, BYTE PTR _bn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _gn$[ebp]
	push	edx
	movzx	eax, BYTE PTR _rn$[ebp]
	push	eax
	push	0
	movsx	ecx, WORD PTR _gsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	call	_String2Data
	add	esp, 56					; 00000038H
$LN1@UIStringBu:

; 544  : 
; 545  : 	return UI_NULLOP;

	or	al, -1
$LN4@UIStringBu:

; 546  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UIStringButtonWorld ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIStringButton
_TEXT	SEGMENT
_bs$ = -101						; size = 1
_gs$ = -89						; size = 1
_rs$ = -77						; size = 1
_bn$ = -65						; size = 1
_gn$ = -53						; size = 1
_rn$ = -41						; size = 1
_gsizew$ = -32						; size = 2
_gsize$ = -20						; size = 2
_text_size$ = -8					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_text$ = 16						; size = 4
_font$ = 20						; size = 1
_font_size$ = 24					; size = 2
_layer$ = 28						; size = 1
_colorN$ = 32						; size = 4
_colorS$ = 36						; size = 4
_UIStringButton PROC					; COMDAT

; 442  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 443  : 	int32 text_size;
; 444  : 	int16 gsize, gsizew;
; 445  : 
; 446  : 	uint8 rn, gn, bn, rs, gs, bs;
; 447  : 
; 448  : 	rn=colorN>>16;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rn$[ebp], al

; 449  : 	gn=(colorN>>8) & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gn$[ebp], al

; 450  : 	bn=colorN & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bn$[ebp], al

; 451  : 
; 452  : 	rs=colorS>>16;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rs$[ebp], al

; 453  : 	gs=(colorS>>8) & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gs$[ebp], al

; 454  : 	bs=colorS & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bs$[ebp], al

; 455  : 
; 456  : 	gsize=(st.fonts[font].size_h_gm*font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	movsx	edx, WORD PTR _font_size$[ebp]
	imul	edx, DWORD PTR _st[ecx+64360]
	shr	edx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], dx

; 457  : 	gsizew=(st.fonts[font].size_w_gm*font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	movsx	edx, WORD PTR _font_size$[ebp]
	imul	edx, DWORD PTR _st[ecx+64356]
	shr	edx, 10					; 0000000aH
	mov	WORD PTR _gsizew$[ebp], dx

; 458  : 
; 459  : 	text_size=gsizew*strlen(text);

	movsx	esi, WORD PTR _gsizew$[ebp]
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	imul	esi, eax
	mov	DWORD PTR _text_size$[ebp], esi

; 460  : 
; 461  : 	if(CheckCollisionMouse(x,y,text_size,gsize,0))

	push	0
	movsx	eax, WORD PTR _gsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@UIStringBu

; 462  : 	{
; 463  : 		StringUIData(text,x,y,text_size,gsize,0,rs,gs,bs,255,font,font_size,font_size,layer);

	movzx	eax, BYTE PTR _layer$[ebp]
	push	eax
	movsx	ecx, WORD PTR _font_size$[ebp]
	push	ecx
	movsx	edx, WORD PTR _font_size$[ebp]
	push	edx
	movzx	eax, BYTE PTR _font$[ebp]
	push	eax
	push	255					; 000000ffH
	movzx	ecx, BYTE PTR _bs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _gs$[ebp]
	push	edx
	movzx	eax, BYTE PTR _rs$[ebp]
	push	eax
	push	0
	movsx	ecx, WORD PTR _gsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	call	_StringUIData
	add	esp, 56					; 00000038H

; 464  : 
; 465  : 		if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN2@UIStringBu

; 466  : 		{
; 467  : 			st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 468  : 			return UI_SEL;

	mov	al, 100					; 00000064H
	jmp	SHORT $LN4@UIStringBu
$LN2@UIStringBu:

; 469  : 		}
; 470  : 	}
; 471  : 	else

	jmp	SHORT $LN1@UIStringBu
$LN3@UIStringBu:

; 472  : 		StringUIData(text,x,y,text_size,gsize,0,rn,gn,bn,255,font,font_size,font_size,layer);

	movzx	eax, BYTE PTR _layer$[ebp]
	push	eax
	movsx	ecx, WORD PTR _font_size$[ebp]
	push	ecx
	movsx	edx, WORD PTR _font_size$[ebp]
	push	edx
	movzx	eax, BYTE PTR _font$[ebp]
	push	eax
	push	255					; 000000ffH
	movzx	ecx, BYTE PTR _bn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _gn$[ebp]
	push	edx
	movzx	eax, BYTE PTR _rn$[ebp]
	push	eax
	push	0
	movsx	ecx, WORD PTR _gsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN1@UIStringBu:

; 473  : 
; 474  : 	return UI_NULLOP;

	or	al, -1
$LN4@UIStringBu:

; 475  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UIStringButton ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIWin_ButtonIcon
_TEXT	SEGMENT
tv69 = -232						; size = 4
_b$ = -29						; size = 1
_g$ = -17						; size = 1
_r$ = -5						; size = 1
_uiwinid$ = 8						; size = 1
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_sizex$ = 20						; size = 4
_sizey$ = 24						; size = 4
_frame$ = 28						; size = 1
_color$ = 32						; size = 4
_blocked$ = 36						; size = 1
_UIWin_ButtonIcon PROC					; COMDAT

; 1272 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1273 : 	uint8 r, g, b;
; 1274 : 
; 1275 : 	r=color>>16;

	mov	eax, DWORD PTR _color$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _r$[ebp], al

; 1276 : 	g=(color>>8) && 0xFF;

	mov	eax, DWORD PTR _color$[ebp]
	sar	eax, 8
	test	eax, eax
	je	SHORT $LN10@UIWin_Butt
	mov	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $LN10@UIWin_Butt
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN11@UIWin_Butt
$LN10@UIWin_Butt:
	mov	DWORD PTR tv69[ebp], 0
$LN11@UIWin_Butt:
	mov	dl, BYTE PTR tv69[ebp]
	mov	BYTE PTR _g$[ebp], dl

; 1277 : 	b=color & 0xFF;

	mov	eax, DWORD PTR _color$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _b$[ebp], al

; 1278 : 
; 1279 : 	if(!blocked)

	movsx	eax, BYTE PTR _blocked$[ebp]
	test	eax, eax
	jne	$LN7@UIWin_Butt

; 1280 : 	{
; 1281 : 		if(CheckCollisionMouse(x,y,sizex,sizey,0) && st.mouse1)

	push	0
	mov	eax, DWORD PTR _sizey$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sizex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@UIWin_Butt
	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	$LN6@UIWin_Butt

; 1282 : 		{
; 1283 : 			UIData(x,y,sizex,sizey,0,r,g,b,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id2].frames[UI_Sys.frames[frame]],255,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys+32
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _frame$[ebp]
	mov	eax, DWORD PTR _UI_Sys+36
	movsx	edx, BYTE PTR [eax+edx]
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _g$[ebp]
	push	edx
	movzx	eax, BYTE PTR _r$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _sizey$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sizex$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_UIData
	add	esp, 96					; 00000060H

; 1284 : 
; 1285 : 			st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 1286 : 
; 1287 : 			return UI_SEL;

	mov	al, 100					; 00000064H
	jmp	$LN8@UIWin_Butt

; 1288 : 		}
; 1289 : 		else

	jmp	SHORT $LN5@UIWin_Butt
$LN6@UIWin_Butt:

; 1290 : 			UIData(x,y,sizex,sizey,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id2].frames[UI_Sys.frames[frame]],255,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys+32
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _frame$[ebp]
	mov	eax, DWORD PTR _UI_Sys+36
	movsx	edx, BYTE PTR [eax+edx]
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	mov	ecx, DWORD PTR _sizey$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sizex$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_UIData
	add	esp, 96					; 00000060H
$LN5@UIWin_Butt:

; 1291 : 	}
; 1292 : 	else

	jmp	$LN4@UIWin_Butt
$LN7@UIWin_Butt:

; 1293 : 	if(blocked==1)

	movsx	eax, BYTE PTR _blocked$[ebp]
	cmp	eax, 1
	jne	$LN3@UIWin_Butt

; 1294 : 		UIData(x,y,sizex,sizey,0,128,128,128,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id2].frames[UI_Sys.frames[frame]],255,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys+32
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _frame$[ebp]
	mov	eax, DWORD PTR _UI_Sys+36
	movsx	edx, BYTE PTR [eax+edx]
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	128					; 00000080H
	push	128					; 00000080H
	push	128					; 00000080H
	push	0
	mov	ecx, DWORD PTR _sizey$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sizex$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_UIData
	add	esp, 96					; 00000060H

; 1295 : 	else

	jmp	$LN4@UIWin_Butt
$LN3@UIWin_Butt:

; 1296 : 	if(blocked==2)

	movsx	eax, BYTE PTR _blocked$[ebp]
	cmp	eax, 2
	jne	SHORT $LN4@UIWin_Butt

; 1297 : 		UIData(x,y,sizex,sizey,0,r,g,b,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id2].frames[UI_Sys.frames[frame]],255,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys+32
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _frame$[ebp]
	mov	eax, DWORD PTR _UI_Sys+36
	movsx	edx, BYTE PTR [eax+edx]
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _g$[ebp]
	push	edx
	movzx	eax, BYTE PTR _r$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _sizey$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sizex$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_UIData
	add	esp, 96					; 00000060H
$LN4@UIWin_Butt:

; 1298 : 
; 1299 : 	return UI_NULLOP;

	or	al, -1
$LN8@UIWin_Butt:

; 1300 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UIWin_ButtonIcon ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIWin_Button
_TEXT	SEGMENT
tv69 = -280						; size = 4
_gsizew$ = -80						; size = 2
_gsize$ = -68						; size = 2
_lenght$ = -56						; size = 2
_b$ = -29						; size = 1
_g$ = -17						; size = 1
_r$ = -5						; size = 1
_uiwinid$ = 8						; size = 1
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_text$ = 20						; size = 4
_font$ = 24						; size = 1
_font_size$ = 28					; size = 1
_color$ = 32						; size = 4
_blocked$ = 36						; size = 1
_UIWin_Button PROC					; COMDAT

; 1223 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1224 : 	uint8 r, g, b, frame;
; 1225 : 	int16 lenght, gsize, gsizew;
; 1226 : 
; 1227 : 	r=color>>16;

	mov	eax, DWORD PTR _color$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _r$[ebp], al

; 1228 : 	g=(color>>8) && 0xFF;

	mov	eax, DWORD PTR _color$[ebp]
	sar	eax, 8
	test	eax, eax
	je	SHORT $LN10@UIWin_Butt
	mov	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $LN10@UIWin_Butt
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN11@UIWin_Butt
$LN10@UIWin_Butt:
	mov	DWORD PTR tv69[ebp], 0
$LN11@UIWin_Butt:
	mov	dl, BYTE PTR tv69[ebp]
	mov	BYTE PTR _g$[ebp], dl

; 1229 : 	b=color & 0xFF;

	mov	eax, DWORD PTR _color$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _b$[ebp], al

; 1230 : 
; 1231 : 	gsize=(st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+30]
	imul	eax, edx, 84
	movsx	ecx, BYTE PTR _uiwinid$[ebp]
	imul	edx, ecx, 56
	movsx	ecx, WORD PTR _UI_Win[edx+32]
	imul	ecx, DWORD PTR _st[eax+64360]
	shr	ecx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], cx

; 1232 : 	gsizew=(st.fonts[UI_Win[uiwinid].font].size_w_gm*UI_Win[uiwinid].font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+30]
	imul	eax, edx, 84
	movsx	ecx, BYTE PTR _uiwinid$[ebp]
	imul	edx, ecx, 56
	movsx	ecx, WORD PTR _UI_Win[edx+32]
	imul	ecx, DWORD PTR _st[eax+64356]
	shr	ecx, 10					; 0000000aH
	mov	WORD PTR _gsizew$[ebp], cx

; 1233 : 
; 1234 : 
; 1235 : 	lenght=strlen(text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _lenght$[ebp], ax

; 1236 : 
; 1237 : 	if(!blocked)

	movsx	eax, BYTE PTR _blocked$[ebp]
	test	eax, eax
	jne	$LN7@UIWin_Butt

; 1238 : 	{
; 1239 : 		if(CheckCollisionMouse(x,y,lenght*gsizew,gsize,0) && st.mouse1)

	push	0
	movsx	eax, WORD PTR _gsize$[ebp]
	push	eax
	movsx	ecx, WORD PTR _lenght$[ebp]
	movsx	edx, WORD PTR _gsizew$[ebp]
	imul	ecx, edx
	push	ecx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	je	$LN6@UIWin_Butt
	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	$LN6@UIWin_Butt

; 1240 : 		{
; 1241 : 			UIData(x,y,lenght*gsizew,gsize,0,r,g,b,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.button_frame1],255,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+6
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _g$[ebp]
	push	edx
	movzx	eax, BYTE PTR _r$[ebp]
	push	eax
	push	0
	movsx	ecx, WORD PTR _gsize$[ebp]
	push	ecx
	movsx	edx, WORD PTR _lenght$[ebp]
	movsx	eax, WORD PTR _gsizew$[ebp]
	imul	edx, eax
	push	edx
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_UIData
	add	esp, 96					; 00000060H

; 1242 : 			StringUIData(text,x,y,0,0,0,255,255,255,255,UI_Win[uiwinid].font,UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	call	_StringUIData
	add	esp, 56					; 00000038H

; 1243 : 
; 1244 : 			st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 1245 : 
; 1246 : 			return UI_SEL;

	mov	al, 100					; 00000064H
	jmp	$LN8@UIWin_Butt

; 1247 : 		}
; 1248 : 		else

	jmp	$LN5@UIWin_Butt
$LN6@UIWin_Butt:

; 1249 : 		{
; 1250 : 			UIData(x,y,lenght*gsizew,gsize,0,r,g,b,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.button_frame0],255,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+5
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _g$[ebp]
	push	edx
	movzx	eax, BYTE PTR _r$[ebp]
	push	eax
	push	0
	movsx	ecx, WORD PTR _gsize$[ebp]
	push	ecx
	movsx	edx, WORD PTR _lenght$[ebp]
	movsx	eax, WORD PTR _gsizew$[ebp]
	imul	edx, eax
	push	edx
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_UIData
	add	esp, 96					; 00000060H

; 1251 : 			StringUIData(text,x,y,0,0,0,255,255,255,255,UI_Win[uiwinid].font,UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN5@UIWin_Butt:

; 1252 : 		}
; 1253 : 	}
; 1254 : 	else

	jmp	$LN4@UIWin_Butt
$LN7@UIWin_Butt:

; 1255 : 	if(blocked==1)

	movsx	eax, BYTE PTR _blocked$[ebp]
	cmp	eax, 1
	jne	$LN3@UIWin_Butt

; 1256 : 	{
; 1257 : 		UIData(x,y,lenght*gsizew,gsize,0,r,g,b,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.button_frame2],255,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+7
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _g$[ebp]
	push	edx
	movzx	eax, BYTE PTR _r$[ebp]
	push	eax
	push	0
	movsx	ecx, WORD PTR _gsize$[ebp]
	push	ecx
	movsx	edx, WORD PTR _lenght$[ebp]
	movsx	eax, WORD PTR _gsizew$[ebp]
	imul	edx, eax
	push	edx
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_UIData
	add	esp, 96					; 00000060H

; 1258 : 		StringUIData(text,x,y,0,0,0,128,128,128,255,UI_Win[uiwinid].font,UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	push	128					; 00000080H
	push	128					; 00000080H
	push	128					; 00000080H
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	call	_StringUIData
	add	esp, 56					; 00000038H

; 1259 : 	}
; 1260 : 	else

	jmp	$LN4@UIWin_Butt
$LN3@UIWin_Butt:

; 1261 : 	if(blocked==2)

	movsx	eax, BYTE PTR _blocked$[ebp]
	cmp	eax, 2
	jne	$LN4@UIWin_Butt

; 1262 : 	{
; 1263 : 		UIData(x,y,lenght*gsizew,gsize,0,r,g,b,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.button_frame2],255,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+7
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _g$[ebp]
	push	edx
	movzx	eax, BYTE PTR _r$[ebp]
	push	eax
	push	0
	movsx	ecx, WORD PTR _gsize$[ebp]
	push	ecx
	movsx	edx, WORD PTR _lenght$[ebp]
	movsx	eax, WORD PTR _gsizew$[ebp]
	imul	edx, eax
	push	edx
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_UIData
	add	esp, 96					; 00000060H

; 1264 : 		StringUIData(text,x,y,0,0,0,r,g,b,255,UI_Win[uiwinid].font,UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _g$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _r$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN4@UIWin_Butt:

; 1265 : 	}
; 1266 : 
; 1267 : 	return UI_NULLOP;

	or	al, -1
$LN8@UIWin_Butt:

; 1268 : 
; 1269 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UIWin_Button ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UILoadSystem
_TEXT	SEGMENT
$T1 = -597						; size = 1
_value$ = -384						; size = 2
_val$ = -312						; size = 4
_tok$ = -300						; size = 4
_buf$ = -288						; size = 256
_basic$ = -21						; size = 1
_file$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_UILoadSystem PROC					; COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 604				; 0000025cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-604]
	mov	ecx, 151				; 00000097H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	BYTE PTR $T1[ebp], 0

; 38   : 	FILE *file;
; 39   : 	int8 basic=1;

	mov	BYTE PTR _basic$[ebp], 1

; 40   : 	char buf[256], *tok, *val;
; 41   : 
; 42   : 	GLint pos, texc, col, texl, texr;
; 43   : 
; 44   : 	int16 value=0;

	xor	eax, eax
	mov	WORD PTR _value$[ebp], ax

; 45   : 
; 46   : 	register uint8 i;
; 47   : 
; 48   : 	if(filename==NULL)

	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN41@UILoadSyst

; 49   : 		basic=0;

	mov	BYTE PTR _basic$[ebp], 0

; 50   : 	else

	jmp	SHORT $LN40@UILoadSyst
$LN41@UILoadSyst:

; 51   : 	if((file=fopen(filename,"r"))==NULL)

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	BYTE PTR $T1[ebp], 1
	mov	DWORD PTR _file$[ebp], eax
	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN44@UILoadSyst
	push	OFFSET $LN45@UILoadSyst
	call	__RTC_UninitUse
	add	esp, 4
$LN44@UILoadSyst:
	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN40@UILoadSyst

; 52   : 		basic=0;

	mov	BYTE PTR _basic$[ebp], 0
$LN40@UILoadSyst:

; 53   : 
; 54   : 	if(basic)

	movsx	eax, BYTE PTR _basic$[ebp]
	test	eax, eax
	je	$LN38@UILoadSyst

; 55   : 	{
; 56   : 		memset(&UI_Sys,-1,sizeof(UI_SYSTEM));

	push	265384					; 00040ca8H
	push	-1
	push	OFFSET _UI_Sys
	call	_memset
	add	esp, 12					; 0000000cH
$LN37@UILoadSyst:

; 57   : 
; 58   : 		while(!feof(file))

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN46@UILoadSyst
	push	OFFSET $LN45@UILoadSyst
	call	__RTC_UninitUse
	add	esp, 4
$LN46@UILoadSyst:
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_feof
	add	esp, 4
	test	eax, eax
	jne	$LN36@UILoadSyst

; 59   : 		{
; 60   : 			fgets(buf,256,file);

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN47@UILoadSyst
	push	OFFSET $LN45@UILoadSyst
	call	__RTC_UninitUse
	add	esp, 4
$LN47@UILoadSyst:
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	256					; 00000100H
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_fgets
	add	esp, 12					; 0000000cH

; 61   : 
; 62   : 			tok=strtok(buf,"=\"");

	push	OFFSET ??_C@_02ILLPBGAO@?$DN?$CC?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_strtok
	add	esp, 8
	mov	DWORD PTR _tok$[ebp], eax

; 63   : 			val=strtok(NULL," =\"");

	push	OFFSET ??_C@_03PFIILPDO@?5?$DN?$CC?$AA@
	push	0
	call	_strtok
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 64   : 
; 65   : 			if(strcmp(tok,"MGG ID")==NULL)

	push	OFFSET ??_C@_06PEKNBJMF@MGG?5ID?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN35@UILoadSyst

; 66   : 				UI_Sys.mgg_id=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys, al
$LN35@UILoadSyst:

; 67   : 
; 68   : 			if(strcmp(tok,"Window2 Frame")==NULL)

	push	OFFSET ??_C@_0O@PJPNPMCL@Window2?5Frame?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN34@UILoadSyst

; 69   : 				UI_Sys.window2_frame=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+1, al
$LN34@UILoadSyst:

; 70   : 
; 71   : 			if(strcmp(tok,"Window Frame0")==NULL)

	push	OFFSET ??_C@_0O@BEKHFMFK@Window?5Frame0?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN33@UILoadSyst

; 72   : 				UI_Sys.window_frame0=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+2, al
$LN33@UILoadSyst:

; 73   : 			if(strcmp(tok,"Window Frame1")==NULL)

	push	OFFSET ??_C@_0O@NLMGNBL@Window?5Frame1?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@UILoadSyst

; 74   : 				UI_Sys.window_frame1=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+3, al
$LN32@UILoadSyst:

; 75   : 			if(strcmp(tok,"Window Frame2")==NULL)

	push	OFFSET ??_C@_0O@CGJBDONI@Window?5Frame2?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN31@UILoadSyst

; 76   : 				UI_Sys.window_frame2=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+4, al
$LN31@UILoadSyst:

; 77   : 
; 78   : 			if(strcmp(tok,"Button Frame0")==NULL)

	push	OFFSET ??_C@_0O@JALBCEAG@Button?5Frame0?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@UILoadSyst

; 79   : 				UI_Sys.button_frame0=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+5, al
$LN30@UILoadSyst:

; 80   : 			if(strcmp(tok,"Button Frame1")==NULL)

	push	OFFSET ??_C@_0O@IJKKBFEH@Button?5Frame1?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN29@UILoadSyst

; 81   : 				UI_Sys.button_frame1=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+6, al
$LN29@UILoadSyst:

; 82   : 			if(strcmp(tok,"Button Frame2")==NULL)

	push	OFFSET ??_C@_0O@KCIHEGIE@Button?5Frame2?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN28@UILoadSyst

; 83   : 				UI_Sys.button_frame2=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+7, al
$LN28@UILoadSyst:

; 84   : 
; 85   : 			if(strcmp(tok,"Subwindow Frame0")==NULL)

	push	OFFSET ??_C@_0BB@JHJNJBII@Subwindow?5Frame0?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@UILoadSyst

; 86   : 				UI_Sys.subwindow_frame0=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+10, al
$LN27@UILoadSyst:

; 87   : 			if(strcmp(tok,"Subwindow Frame1")==NULL)

	push	OFFSET ??_C@_0BB@IOIGKAMJ@Subwindow?5Frame1?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@UILoadSyst

; 88   : 				UI_Sys.subwindow_frame1=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+11, al
$LN26@UILoadSyst:

; 89   : 			if(strcmp(tok,"Subwindow Frame2")==NULL)

	push	OFFSET ??_C@_0BB@KFKLPDAK@Subwindow?5Frame2?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@UILoadSyst

; 90   : 				UI_Sys.subwindow_frame2=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+12, al
$LN25@UILoadSyst:

; 91   : 
; 92   : 			if(strcmp(tok,"Tab Frame")==NULL)

	push	OFFSET ??_C@_09DLONLHCP@Tab?5Frame?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN24@UILoadSyst

; 93   : 				UI_Sys.tab_frame=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+8, al
$LN24@UILoadSyst:

; 94   : 			if(strcmp(tok,"Close Frame")==NULL)

	push	OFFSET ??_C@_0M@KGGBGCOI@Close?5Frame?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN23@UILoadSyst

; 95   : 				UI_Sys.close_frame=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+9, al
$LN23@UILoadSyst:

; 96   : 
; 97   : 			if(strcmp(tok,"Scroll Frame0")==NULL)

	push	OFFSET ??_C@_0O@NIMFPFPB@Scroll?5Frame0?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@UILoadSyst

; 98   : 				UI_Sys.scroll_frame0=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+13, al
$LN22@UILoadSyst:

; 99   : 			if(strcmp(tok,"Scroll Frame1")==NULL)

	push	OFFSET ??_C@_0O@MBNOMELA@Scroll?5Frame1?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@UILoadSyst

; 100  : 				UI_Sys.scroll_frame1=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+14, al
$LN21@UILoadSyst:

; 101  : 			if(strcmp(tok,"Scroll Up Frame")==NULL)

	push	OFFSET ??_C@_0BA@GBPLBIJP@Scroll?5Up?5Frame?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@UILoadSyst

; 102  : 				UI_Sys.scroll_up_frame=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+15, al
$LN20@UILoadSyst:

; 103  : 			if(strcmp(tok,"Scroll Down Frame")==NULL)

	push	OFFSET ??_C@_0BC@PLHMGGMP@Scroll?5Down?5Frame?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@UILoadSyst

; 104  : 				UI_Sys.scroll_down_frame=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+16, al
$LN19@UILoadSyst:

; 105  : 
; 106  : 			if(strcmp(tok,"Resize Cursor Frame")==NULL)

	push	OFFSET ??_C@_0BE@DIOJCMDC@Resize?5Cursor?5Frame?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@UILoadSyst

; 107  : 				UI_Sys.resize_cursor=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+41, al
$LN18@UILoadSyst:

; 108  : 
; 109  : 			if(strcmp(tok,"Save Icon Frame")==NULL)

	push	OFFSET ??_C@_0BA@IPIPEMCB@Save?5Icon?5Frame?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@UILoadSyst

; 110  : 				UI_Sys.save_icon=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+19, al
$LN17@UILoadSyst:

; 111  : 
; 112  : 			if(strcmp(tok,"Folder Icon Frame")==NULL)

	push	OFFSET ??_C@_0BC@JKGLEFGA@Folder?5Icon?5Frame?$AA@
	mov	eax, DWORD PTR _tok$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@UILoadSyst

; 113  : 				UI_Sys.folder_icon=atoi(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	BYTE PTR _UI_Sys+21, al
$LN16@UILoadSyst:

; 114  : 
; 115  : 		}

	jmp	$LN37@UILoadSyst
$LN36@UILoadSyst:

; 116  : 
; 117  : 		if(UI_Sys.mgg_id==-1)

	movsx	eax, BYTE PTR _UI_Sys
	cmp	eax, -1
	jne	SHORT $LN15@UILoadSyst

; 118  : 			UI_Sys.mgg_id=0;

	mov	BYTE PTR _UI_Sys, 0
$LN15@UILoadSyst:

; 119  : 
; 120  : 		if(UI_Sys.window2_frame==-1)

	movsx	eax, BYTE PTR _UI_Sys+1
	cmp	eax, -1
	jne	SHORT $LN14@UILoadSyst

; 121  : 			UI_Sys.window2_frame=4;

	mov	BYTE PTR _UI_Sys+1, 4
$LN14@UILoadSyst:

; 122  : 
; 123  : 		if(UI_Sys.window_frame0==-1)

	movsx	eax, BYTE PTR _UI_Sys+2
	cmp	eax, -1
	jne	SHORT $LN13@UILoadSyst

; 124  : 			UI_Sys.window_frame0=6;

	mov	BYTE PTR _UI_Sys+2, 6
$LN13@UILoadSyst:

; 125  : 		if(UI_Sys.window_frame1==-1)

	movsx	eax, BYTE PTR _UI_Sys+3
	cmp	eax, -1
	jne	SHORT $LN12@UILoadSyst

; 126  : 			UI_Sys.window_frame1=7;

	mov	BYTE PTR _UI_Sys+3, 7
$LN12@UILoadSyst:

; 127  : 		if(UI_Sys.window_frame2==-1)

	movsx	eax, BYTE PTR _UI_Sys+4
	cmp	eax, -1
	jne	SHORT $LN11@UILoadSyst

; 128  : 			UI_Sys.window_frame2=8;

	mov	BYTE PTR _UI_Sys+4, 8
$LN11@UILoadSyst:

; 129  : 
; 130  : 		if(UI_Sys.button_frame0==-1)

	movsx	eax, BYTE PTR _UI_Sys+5
	cmp	eax, -1
	jne	SHORT $LN10@UILoadSyst

; 131  : 			UI_Sys.button_frame0=9;

	mov	BYTE PTR _UI_Sys+5, 9
$LN10@UILoadSyst:

; 132  : 		if(UI_Sys.button_frame1==-1)

	movsx	eax, BYTE PTR _UI_Sys+6
	cmp	eax, -1
	jne	SHORT $LN9@UILoadSyst

; 133  : 			UI_Sys.button_frame1=10;

	mov	BYTE PTR _UI_Sys+6, 10			; 0000000aH
$LN9@UILoadSyst:

; 134  : 		if(UI_Sys.button_frame2==-1)

	movsx	eax, BYTE PTR _UI_Sys+7
	cmp	eax, -1
	jne	SHORT $LN8@UILoadSyst

; 135  : 			UI_Sys.button_frame2=11;

	mov	BYTE PTR _UI_Sys+7, 11			; 0000000bH
$LN8@UILoadSyst:

; 136  : 
; 137  : 		if(UI_Sys.subwindow_frame0==-1)

	movsx	eax, BYTE PTR _UI_Sys+10
	cmp	eax, -1
	jne	SHORT $LN7@UILoadSyst

; 138  : 			UI_Sys.subwindow_frame0=14;

	mov	BYTE PTR _UI_Sys+10, 14			; 0000000eH
$LN7@UILoadSyst:

; 139  : 		if(UI_Sys.subwindow_frame1==-1)

	movsx	eax, BYTE PTR _UI_Sys+11
	cmp	eax, -1
	jne	SHORT $LN6@UILoadSyst

; 140  : 			UI_Sys.subwindow_frame1=15;

	mov	BYTE PTR _UI_Sys+11, 15			; 0000000fH
$LN6@UILoadSyst:

; 141  : 		if(UI_Sys.subwindow_frame2==-1)

	movsx	eax, BYTE PTR _UI_Sys+12
	cmp	eax, -1
	jne	SHORT $LN5@UILoadSyst

; 142  : 			UI_Sys.subwindow_frame2=16;

	mov	BYTE PTR _UI_Sys+12, 16			; 00000010H
$LN5@UILoadSyst:

; 143  : 
; 144  : 		if(UI_Sys.tab_frame==-1)

	movsx	eax, BYTE PTR _UI_Sys+8
	cmp	eax, -1
	jne	SHORT $LN4@UILoadSyst

; 145  : 			UI_Sys.tab_frame=12;

	mov	BYTE PTR _UI_Sys+8, 12			; 0000000cH
$LN4@UILoadSyst:

; 146  : 		if(UI_Sys.close_frame==-1)

	movsx	eax, BYTE PTR _UI_Sys+9
	cmp	eax, -1
	jne	SHORT $LN3@UILoadSyst

; 147  : 			UI_Sys.close_frame=13;

	mov	BYTE PTR _UI_Sys+9, 13			; 0000000dH
$LN3@UILoadSyst:

; 148  : 
; 149  : 		if(UI_Sys.resize_cursor==-1)

	movsx	eax, BYTE PTR _UI_Sys+41
	cmp	eax, -1
	jne	SHORT $LN2@UILoadSyst

; 150  : 			UI_Sys.resize_cursor=6;

	mov	BYTE PTR _UI_Sys+41, 6
$LN2@UILoadSyst:

; 151  : 
; 152  : 
; 153  : 		fclose(file);

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN48@UILoadSyst
	push	OFFSET $LN45@UILoadSyst
	call	__RTC_UninitUse
	add	esp, 4
$LN48@UILoadSyst:
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 154  : 
; 155  : 		LogApp("UI system loaded");

	push	OFFSET ??_C@_0BB@MMJCIDDE@UI?5system?5loaded?$AA@
	call	_SDL_Log
	add	esp, 4

; 156  : 	}
; 157  : 	else

	jmp	SHORT $LN1@UILoadSyst
$LN38@UILoadSyst:

; 158  : 	{
; 159  : 		UI_Sys.mgg_id=0;

	mov	BYTE PTR _UI_Sys, 0

; 160  : 		UI_Sys.window2_frame=4;

	mov	BYTE PTR _UI_Sys+1, 4

; 161  : 		UI_Sys.window_frame0=6;

	mov	BYTE PTR _UI_Sys+2, 6

; 162  : 		UI_Sys.window_frame1=7;

	mov	BYTE PTR _UI_Sys+3, 7

; 163  : 		UI_Sys.window_frame2=8;

	mov	BYTE PTR _UI_Sys+4, 8

; 164  : 		UI_Sys.button_frame0=15;

	mov	BYTE PTR _UI_Sys+5, 15			; 0000000fH

; 165  : 		UI_Sys.button_frame1=10;

	mov	BYTE PTR _UI_Sys+6, 10			; 0000000aH

; 166  : 		UI_Sys.button_frame2=9;

	mov	BYTE PTR _UI_Sys+7, 9

; 167  : 		UI_Sys.tab_frame=12;

	mov	BYTE PTR _UI_Sys+8, 12			; 0000000cH

; 168  : 		UI_Sys.close_frame=13;

	mov	BYTE PTR _UI_Sys+9, 13			; 0000000dH

; 169  : 		UI_Sys.subwindow_frame0=14;

	mov	BYTE PTR _UI_Sys+10, 14			; 0000000eH

; 170  : 		UI_Sys.subwindow_frame1=15;

	mov	BYTE PTR _UI_Sys+11, 15			; 0000000fH

; 171  : 		UI_Sys.subwindow_frame2=16;

	mov	BYTE PTR _UI_Sys+12, 16			; 00000010H

; 172  : 		UI_Sys.resize_cursor=6;

	mov	BYTE PTR _UI_Sys+41, 6

; 173  : 
; 174  : 		LogApp("UI system loaded");

	push	OFFSET ??_C@_0BB@MMJCIDDE@UI?5system?5loaded?$AA@
	call	_SDL_Log
	add	esp, 4
$LN1@UILoadSyst:

; 175  : 	}
; 176  : 
; 177  : 	strcpy(UI_Sys.current_path,".");

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	push	OFFSET _UI_Sys+43
	call	_strcpy
	add	esp, 8

; 178  : 	UI_Sys.mouse_scroll=0;

	mov	DWORD PTR _UI_Sys+2092, 0

; 179  : 
; 180  : 	UI_Sys.sys_freeze=0;

	mov	BYTE PTR _UI_Sys+2162, 0

; 181  : 
; 182  : 	UI_Sys.textinput=0;

	mov	BYTE PTR _UI_Sys+2163, 0

; 183  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN51@UILoadSyst
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 604				; 0000025cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN51@UILoadSyst:
	DD	1
	DD	$LN50@UILoadSyst
$LN50@UILoadSyst:
	DD	-288					; fffffee0H
	DD	256					; 00000100H
	DD	$LN49@UILoadSyst
$LN49@UILoadSyst:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN45@UILoadSyst:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
_UILoadSystem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIMain_DrawSystem
_TEXT	SEGMENT
_j$ = -41						; size = 1
_p$ = -32						; size = 12
_i$ = -9						; size = 1
__$ArrayPad$ = -4					; size = 4
_UIMain_DrawSystem PROC					; COMDAT

; 1303 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1304 : 	register uint8 i;
; 1305 : 	Pos p;
; 1306 : 	int8 j=0;

	mov	BYTE PTR _j$[ebp], 0

; 1307 : 
; 1308 : 	//if(UI_Sys.sys_freeze)
; 1309 : 		//UI_Sys.sys_freeze=0;
; 1310 : 
; 1311 : 	if(st.num_uiwindow!=0)

	movzx	eax, BYTE PTR _st+264
	test	eax, eax
	je	$LN21@UIMain_Dra

; 1312 : 	{
; 1313 : 		for(i=0;i<MAX_UIWINDOWS;i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $LN20@UIMain_Dra
$LN19@UIMain_Dra:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$LN20@UIMain_Dra:
	movzx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN18@UIMain_Dra

; 1314 : 		{
; 1315 : 			if(!UI_Win[i].stat)

	movzx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx]
	test	edx, edx
	jne	SHORT $LN17@UIMain_Dra

; 1316 : 				continue;

	jmp	SHORT $LN19@UIMain_Dra

; 1317 : 			else

	jmp	$LN16@UIMain_Dra
$LN17@UIMain_Dra:

; 1318 : 			if(UI_Win[i].stat==2)

	movzx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx]
	cmp	edx, 2
	jne	$LN15@UIMain_Dra

; 1319 : 				DrawUI(UI_Win[i].pos.x,UI_Win[i].pos.y,UI_Win[i].size.x,UI_Win[i].size.y,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.window2_frame],255,UI_Win[i].layer);

	movzx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+28]
	push	edx
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+1
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	movzx	ecx, BYTE PTR _i$[ebp]
	imul	edx, ecx, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	push	eax
	movzx	ecx, BYTE PTR _i$[ebp]
	imul	edx, ecx, 56
	mov	eax, DWORD PTR _UI_Win[edx+16]
	push	eax
	movzx	ecx, BYTE PTR _i$[ebp]
	imul	edx, ecx, 56
	mov	eax, DWORD PTR _UI_Win[edx+8]
	push	eax
	movzx	ecx, BYTE PTR _i$[ebp]
	imul	edx, ecx, 56
	mov	eax, DWORD PTR _UI_Win[edx+4]
	push	eax
	call	_DrawUI
	add	esp, 96					; 00000060H

; 1320 : 			else

	jmp	$LN16@UIMain_Dra
$LN15@UIMain_Dra:

; 1321 : 			if(UI_Win[i].stat==1)

	movzx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx]
	cmp	edx, 1
	jne	$LN16@UIMain_Dra

; 1322 : 				DrawUI(UI_Win[i].pos.x,UI_Win[i].pos.y,UI_Win[i].size.x,UI_Win[i].size.y,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Win[i].window_frame],255,UI_Win[i].layer);

	movzx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+28]
	push	edx
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movzx	edx, BYTE PTR _i$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+35]
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	movzx	ecx, BYTE PTR _i$[ebp]
	imul	edx, ecx, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	push	eax
	movzx	ecx, BYTE PTR _i$[ebp]
	imul	edx, ecx, 56
	mov	eax, DWORD PTR _UI_Win[edx+16]
	push	eax
	movzx	ecx, BYTE PTR _i$[ebp]
	imul	edx, ecx, 56
	mov	eax, DWORD PTR _UI_Win[edx+8]
	push	eax
	movzx	ecx, BYTE PTR _i$[ebp]
	imul	edx, ecx, 56
	mov	eax, DWORD PTR _UI_Win[edx+4]
	push	eax
	call	_DrawUI
	add	esp, 96					; 00000060H
$LN16@UIMain_Dra:

; 1323 : 		}

	jmp	$LN19@UIMain_Dra
$LN18@UIMain_Dra:

; 1324 : 	}
; 1325 : 	else

	jmp	SHORT $LN12@UIMain_Dra
$LN21@UIMain_Dra:

; 1326 : 	{
; 1327 : 		if(st.Text_Input && UI_Sys.textinput && UI_Sys.current_option==-1)

	movzx	eax, BYTE PTR _st+66798
	test	eax, eax
	je	SHORT $LN12@UIMain_Dra
	movsx	eax, BYTE PTR _UI_Sys+2163
	test	eax, eax
	je	SHORT $LN12@UIMain_Dra
	movsx	eax, WORD PTR _UI_Sys+2096
	cmp	eax, -1
	jne	SHORT $LN12@UIMain_Dra

; 1328 : 			st.Text_Input=UI_Sys.textinput=0;

	mov	BYTE PTR _UI_Sys+2163, 0
	mov	al, BYTE PTR _UI_Sys+2163
	mov	BYTE PTR _st+66798, al
$LN12@UIMain_Dra:

; 1329 : 	}
; 1330 : 
; 1331 : 	if(st.cursor_type!=0)

	movzx	eax, BYTE PTR _st+3307836
	test	eax, eax
	je	$LN10@UIMain_Dra

; 1332 : 	{
; 1333 : 		SDL_ShowCursor(SDL_DISABLE);

	push	0
	call	_SDL_ShowCursor
	add	esp, 4

; 1334 : 		
; 1335 : 		p=st.mouse;

	mov	eax, DWORD PTR _st+65624
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _st+65628
	mov	DWORD PTR _p$[ebp+4], ecx
	mov	edx, DWORD PTR _st+65632
	mov	DWORD PTR _p$[ebp+8], edx

; 1336 : 
; 1337 : 		p.x=(p.x*GAME_WIDTH)/st.screenx;

	mov	eax, DWORD PTR _p$[ebp]
	shl	eax, 14					; 0000000eH
	movzx	ecx, WORD PTR _st+228
	cdq
	idiv	ecx
	mov	DWORD PTR _p$[ebp], eax

; 1338 : 		p.y=(p.y*9216)/st.screeny;

	imul	eax, DWORD PTR _p$[ebp+4], 9216
	movzx	ecx, WORD PTR _st+230
	cdq
	idiv	ecx
	mov	DWORD PTR _p$[ebp+4], eax

; 1339 : 
; 1340 : 		if(st.cursor_type==1)

	movzx	eax, BYTE PTR _st+3307836
	cmp	eax, 1
	jne	SHORT $LN9@UIMain_Dra

; 1341 : 			DrawUI(p.x,p.y,512,512,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.resize_cursor],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+41
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	push	512					; 00000200H
	push	512					; 00000200H
	mov	ecx, DWORD PTR _p$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_DrawUI
	add	esp, 96					; 00000060H

; 1342 : 		else

	jmp	$LN8@UIMain_Dra
$LN9@UIMain_Dra:

; 1343 : 		if(st.cursor_type==2)

	movzx	eax, BYTE PTR _st+3307836
	cmp	eax, 2
	jne	SHORT $LN7@UIMain_Dra

; 1344 : 			DrawUI(p.x,p.y,512,512,900,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.resize_cursor],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+41
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	900					; 00000384H
	push	512					; 00000200H
	push	512					; 00000200H
	mov	ecx, DWORD PTR _p$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_DrawUI
	add	esp, 96					; 00000060H

; 1345 : 		else

	jmp	$LN8@UIMain_Dra
$LN7@UIMain_Dra:

; 1346 : 		if(st.cursor_type==3)

	movzx	eax, BYTE PTR _st+3307836
	cmp	eax, 3
	jne	SHORT $LN5@UIMain_Dra

; 1347 : 			DrawUI(p.x,p.y,512,512,450,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.resize_cursor],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+41
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	450					; 000001c2H
	push	512					; 00000200H
	push	512					; 00000200H
	mov	ecx, DWORD PTR _p$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_DrawUI
	add	esp, 96					; 00000060H

; 1348 : 		else

	jmp	SHORT $LN8@UIMain_Dra
$LN5@UIMain_Dra:

; 1349 : 		if(st.cursor_type==4)

	movzx	eax, BYTE PTR _st+3307836
	cmp	eax, 4
	jne	SHORT $LN8@UIMain_Dra

; 1350 : 			DrawUI(p.x,p.y,512,512,1350,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[UI_Sys.resize_cursor],255,0);

	push	0
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	movsx	edx, BYTE PTR _UI_Sys+41
	imul	eax, edx, 40
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, eax
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	1350					; 00000546H
	push	512					; 00000200H
	push	512					; 00000200H
	mov	ecx, DWORD PTR _p$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_DrawUI
	add	esp, 96					; 00000060H
$LN8@UIMain_Dra:

; 1351 : 	}
; 1352 : 	else

	jmp	SHORT $LN2@UIMain_Dra
$LN10@UIMain_Dra:

; 1353 : 		SDL_ShowCursor(SDL_ENABLE);

	push	1
	call	_SDL_ShowCursor
	add	esp, 4
$LN2@UIMain_Dra:

; 1354 : 
; 1355 : 	if(!st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	jne	SHORT $LN22@UIMain_Dra

; 1356 : 		UI_Sys.mouse_flag=0;

	mov	BYTE PTR _UI_Sys+42, 0
$LN22@UIMain_Dra:

; 1357 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN26@UIMain_Dra
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN26@UIMain_Dra:
	DD	1
	DD	$LN25@UIMain_Dra
$LN25@UIMain_Dra:
	DD	-32					; ffffffe0H
	DD	12					; 0000000cH
	DD	$LN24@UIMain_Dra
$LN24@UIMain_Dra:
	DB	112					; 00000070H
	DB	0
_UIMain_DrawSystem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIWin2_TextBox
_TEXT	SEGMENT
_bc$ = -125						; size = 1
_gc$ = -113						; size = 1
_rc$ = -101						; size = 1
_bs$ = -89						; size = 1
_gs$ = -77						; size = 1
_rs$ = -65						; size = 1
_bn$ = -53						; size = 1
_gn$ = -41						; size = 1
_rn$ = -29						; size = 1
_gsize$ = -20						; size = 2
_lenght$ = -8						; size = 2
_uiwinid$ = 8						; size = 1
_pos$ = 12						; size = 1
_text$ = 16						; size = 4
_colorN$ = 20						; size = 4
_colorS$ = 24						; size = 4
_colorC$ = 28						; size = 4
_UIWin2_TextBox PROC					; COMDAT

; 1158 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-324]
	mov	ecx, 81					; 00000051H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1159 : 	int16 lenght, gsize;
; 1160 : 
; 1161 : 	uint8 rn, gn, bn, rs, gs, bs, rc, gc, bc;
; 1162 : 
; 1163 : 	//char text2[32];
; 1164 : 
; 1165 : 	rn=colorN>>16;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rn$[ebp], al

; 1166 : 	gn=(colorN>>8) & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gn$[ebp], al

; 1167 : 	bn=colorN & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bn$[ebp], al

; 1168 : 
; 1169 : 	rs=colorS>>16;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rs$[ebp], al

; 1170 : 	gs=(colorS>>8) & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gs$[ebp], al

; 1171 : 	bs=colorS & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bs$[ebp], al

; 1172 : 
; 1173 : 	rc=colorC>>16;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rc$[ebp], al

; 1174 : 	gc=(colorC>>8) & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gc$[ebp], al

; 1175 : 	bc=colorC & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bc$[ebp], al

; 1176 : 
; 1177 : 	gsize=(st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+30]
	imul	eax, edx, 84
	movsx	ecx, BYTE PTR _uiwinid$[ebp]
	imul	edx, ecx, 56
	movsx	ecx, WORD PTR _UI_Win[edx+32]
	imul	ecx, DWORD PTR _st[eax+64360]
	shr	ecx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], cx

; 1178 : 
; 1179 : 	//sprintf(text2,"%s: %.3f",text, *value);
; 1180 : 
; 1181 : 	lenght=strlen(text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _lenght$[ebp], ax

; 1182 : 
; 1183 : 	if(UI_Win[uiwinid].current!=pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	je	$LN7@UIWin2_Tex

; 1184 : 	{
; 1185 : 		if(CheckCollisionMouse(UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),
; 1186 : 			lenght*((st.fonts[UI_Win[uiwinid].font].size_w_gm*UI_Win[uiwinid].font_size)/FONT_SIZE),gsize,0))

	push	0
	movsx	eax, WORD PTR _gsize$[ebp]
	push	eax
	movsx	ecx, WORD PTR _lenght$[ebp]
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+30]
	imul	eax, edx, 84
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	edx, edx, 56
	movsx	edx, WORD PTR _UI_Win[edx+32]
	imul	edx, DWORD PTR _st[eax+64356]
	shr	edx, 10					; 0000000aH
	imul	ecx, edx
	push	ecx
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	je	$LN6@UIWin2_Tex

; 1187 : 		{
; 1188 : 			StringUIData(text,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rs,gs,bs,255,UI_Win[uiwinid].font,
; 1189 : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rs$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 1190 : 
; 1191 : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN5@UIWin2_Tex

; 1192 : 			{
; 1193 : 				UI_Win[uiwinid].current=pos;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _pos$[ebp]
	mov	BYTE PTR _UI_Win[ecx+34], dl

; 1194 : 				strcpy(st.TextInput,text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	push	OFFSET _st+66670
	call	_strcpy
	add	esp, 8

; 1195 : 				StartText();

	call	_StartText

; 1196 : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 1197 : 				UI_Sys.textinput=1;

	mov	BYTE PTR _UI_Sys+2163, 1
$LN5@UIWin2_Tex:

; 1198 : 			}
; 1199 : 		}
; 1200 : 		else

	jmp	$LN4@UIWin2_Tex
$LN6@UIWin2_Tex:

; 1201 : 			StringUIData(text,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rn,gn,bn,255,UI_Win[uiwinid].font,
; 1202 : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN4@UIWin2_Tex:

; 1203 : 	}
; 1204 : 	else

	jmp	$LN8@UIWin2_Tex
$LN7@UIWin2_Tex:

; 1205 : 	if(UI_Win[uiwinid].current==pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	jne	$LN8@UIWin2_Tex

; 1206 : 	{
; 1207 : 		StringUIData(text,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rc,gc,bc,255,UI_Win[uiwinid].font,
; 1208 : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bc$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gc$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rc$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 1209 : 
; 1210 : 		strcpy(text,st.TextInput);

	push	OFFSET _st+66670
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1211 : 
; 1212 : 		if(st.keys[RETURN_KEY].state)

	mov	eax, 8
	shl	eax, 0
	movzx	ecx, BYTE PTR _st[eax+65648]
	test	ecx, ecx
	je	SHORT $LN8@UIWin2_Tex

; 1213 : 		{
; 1214 : 			StopText();

	call	_StopText

; 1215 : 			st.keys[RETURN_KEY].state=0;

	mov	eax, 8
	shl	eax, 0
	mov	BYTE PTR _st[eax+65648], 0

; 1216 : 			UI_Win[uiwinid].current=-1;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+34], -1

; 1217 : 			UI_Sys.textinput=0;

	mov	BYTE PTR _UI_Sys+2163, 0
$LN8@UIWin2_Tex:

; 1218 : 		}
; 1219 : 	}
; 1220 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 324				; 00000144H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UIWin2_TextBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIWin2_StringButton
_TEXT	SEGMENT
_text2$ = -104						; size = 4
_bs$ = -89						; size = 1
_gs$ = -77						; size = 1
_rs$ = -65						; size = 1
_bn$ = -53						; size = 1
_gn$ = -41						; size = 1
_rn$ = -29						; size = 1
_gsize$ = -20						; size = 2
_lenght$ = -8						; size = 2
_uiwinid$ = 8						; size = 1
_pos$ = 12						; size = 1
_text$ = 16						; size = 4
_colorN$ = 20						; size = 4
_colorS$ = 24						; size = 4
_UIWin2_StringButton PROC				; COMDAT

; 397  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 398  : 	int16 lenght, gsize;
; 399  : 
; 400  : 	uint8 rn, gn, bn, rs, gs, bs;
; 401  : 
; 402  : 	char *text2;
; 403  : 
; 404  : 	lenght=strlen(text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _lenght$[ebp], ax

; 405  : 
; 406  : 	text2=malloc(lenght+5);

	movsx	eax, WORD PTR _lenght$[ebp]
	add	eax, 5
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _text2$[ebp], eax

; 407  : 
; 408  : 	strcpy(text2,text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text2$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 409  : 
; 410  : 	rn=colorN>>16;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rn$[ebp], al

; 411  : 	gn=(colorN>>8) & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gn$[ebp], al

; 412  : 	bn=colorN & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bn$[ebp], al

; 413  : 
; 414  : 	rs=colorS>>16;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rs$[ebp], al

; 415  : 	gs=(colorS>>8) & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gs$[ebp], al

; 416  : 	bs=colorS & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bs$[ebp], al

; 417  : 
; 418  : 	gsize=(st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+30]
	imul	eax, edx, 84
	movsx	ecx, BYTE PTR _uiwinid$[ebp]
	imul	edx, ecx, 56
	movsx	ecx, WORD PTR _UI_Win[edx+32]
	imul	ecx, DWORD PTR _st[eax+64360]
	shr	ecx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], cx

; 419  : 
; 420  : 	lenght=strlen(text2);

	mov	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _lenght$[ebp], ax

; 421  : 
; 422  : 		if(CheckCollisionMouse(UI_Win[uiwinid].pos.x,(pos*((st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE))+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),
; 423  : 			lenght*((st.fonts[UI_Win[uiwinid].font].size_w_gm*UI_Win[uiwinid].font_size)/FONT_SIZE),(st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE,0))

	push	0
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+30]
	imul	eax, edx, 84
	movsx	ecx, BYTE PTR _uiwinid$[ebp]
	imul	edx, ecx, 56
	movsx	ecx, WORD PTR _UI_Win[edx+32]
	imul	ecx, DWORD PTR _st[eax+64360]
	shr	ecx, 10					; 0000000aH
	push	ecx
	movsx	edx, WORD PTR _lenght$[ebp]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	eax, BYTE PTR _UI_Win[ecx+30]
	imul	ecx, eax, 84
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	eax, eax, 56
	movsx	eax, WORD PTR _UI_Win[eax+32]
	imul	eax, DWORD PTR _st[ecx+64356]
	shr	eax, 10					; 0000000aH
	imul	edx, eax
	push	edx
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+30]
	imul	eax, edx, 84
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	edx, edx, 56
	movsx	edx, WORD PTR _UI_Win[edx+32]
	imul	edx, DWORD PTR _st[eax+64360]
	shr	edx, 10					; 0000000aH
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	je	$LN3@UIWin2_Str

; 424  : 		{
; 425  : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*((st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE))+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rs,gs,bs,255,
; 426  : 				UI_Win[uiwinid].font,UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rs$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+30]
	imul	eax, edx, 84
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	edx, edx, 56
	movsx	edx, WORD PTR _UI_Win[edx+32]
	imul	edx, DWORD PTR _st[eax+64360]
	shr	edx, 10					; 0000000aH
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	mov	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 427  : 
; 428  : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN2@UIWin2_Str

; 429  : 			{
; 430  : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 431  : 				return UI_SEL;

	mov	al, 100					; 00000064H
	jmp	$LN4@UIWin2_Str
$LN2@UIWin2_Str:

; 432  : 			}
; 433  : 		}
; 434  : 		else

	jmp	$LN1@UIWin2_Str
$LN3@UIWin2_Str:

; 435  : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*((st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE))+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rn,gn,bn,255,
; 436  : 				UI_Win[uiwinid].font,UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+30]
	imul	eax, edx, 84
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	edx, edx, 56
	movsx	edx, WORD PTR _UI_Win[edx+32]
	imul	edx, DWORD PTR _st[eax+64360]
	shr	edx, 10					; 0000000aH
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	mov	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN1@UIWin2_Str:

; 437  : 
; 438  : 	return UI_NULLOP;

	or	al, -1
$LN4@UIWin2_Str:

; 439  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UIWin2_StringButton ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIWin2_NumberBoxf
_TEXT	SEGMENT
_text2$ = -172						; size = 32
_bc$ = -129						; size = 1
_gc$ = -117						; size = 1
_rc$ = -105						; size = 1
_bs$ = -93						; size = 1
_gs$ = -81						; size = 1
_rs$ = -69						; size = 1
_bn$ = -57						; size = 1
_gn$ = -45						; size = 1
_rn$ = -33						; size = 1
_gsize$ = -24						; size = 2
_lenght$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_uiwinid$ = 8						; size = 1
_pos$ = 12						; size = 1
_value$ = 16						; size = 4
_text$ = 20						; size = 4
_colorN$ = 24						; size = 4
_colorS$ = 28						; size = 4
_colorC$ = 32						; size = 4
_UIWin2_NumberBoxf PROC					; COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-368]
	mov	ecx, 92					; 0000005cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1094 : 	int16 lenght, gsize;
; 1095 : 
; 1096 : 	uint8 rn, gn, bn, rs, gs, bs, rc, gc, bc;
; 1097 : 
; 1098 : 	char text2[32];
; 1099 : 
; 1100 : 	rn=colorN>>16;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rn$[ebp], al

; 1101 : 	gn=(colorN>>8) & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gn$[ebp], al

; 1102 : 	bn=colorN & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bn$[ebp], al

; 1103 : 
; 1104 : 	rs=colorS>>16;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rs$[ebp], al

; 1105 : 	gs=(colorS>>8) & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gs$[ebp], al

; 1106 : 	bs=colorS & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bs$[ebp], al

; 1107 : 
; 1108 : 	rc=colorC>>16;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rc$[ebp], al

; 1109 : 	gc=(colorC>>8) & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gc$[ebp], al

; 1110 : 	bc=colorC & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bc$[ebp], al

; 1111 : 
; 1112 : 	gsize=(st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+30]
	imul	eax, edx, 84
	movsx	ecx, BYTE PTR _uiwinid$[ebp]
	imul	edx, ecx, 56
	movsx	ecx, WORD PTR _UI_Win[edx+32]
	imul	ecx, DWORD PTR _st[eax+64360]
	shr	ecx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], cx

; 1113 : 
; 1114 : 	sprintf(text2,"%s: %.3f",text, *value);

	mov	eax, DWORD PTR _value$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	push	OFFSET ??_C@_08KELGKKHF@?$CFs?3?5?$CF?43f?$AA@
	lea	edx, DWORD PTR _text2$[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H

; 1115 : 
; 1116 : 	lenght=strlen(text2);

	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _lenght$[ebp], ax

; 1117 : 
; 1118 : 	if(UI_Win[uiwinid].current!=pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	je	$LN7@UIWin2_Num

; 1119 : 	{
; 1120 : 		if(CheckCollisionMouse(UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),
; 1121 : 			lenght*((st.fonts[UI_Win[uiwinid].font].size_w_gm*UI_Win[uiwinid].font_size)/FONT_SIZE),gsize,0))

	push	0
	movsx	eax, WORD PTR _gsize$[ebp]
	push	eax
	movsx	ecx, WORD PTR _lenght$[ebp]
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+30]
	imul	eax, edx, 84
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	edx, edx, 56
	movsx	edx, WORD PTR _UI_Win[edx+32]
	imul	edx, DWORD PTR _st[eax+64356]
	shr	edx, 10					; 0000000aH
	imul	ecx, edx
	push	ecx
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	je	$LN6@UIWin2_Num

; 1122 : 		{
; 1123 : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rs,gs,bs,255,UI_Win[uiwinid].font,
; 1124 : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rs$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 1125 : 
; 1126 : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN5@UIWin2_Num

; 1127 : 			{
; 1128 : 				UI_Win[uiwinid].current=pos;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _pos$[ebp]
	mov	BYTE PTR _UI_Win[ecx+34], dl

; 1129 : 				sprintf(st.TextInput,"%.3f",*value);

	mov	eax, DWORD PTR _value$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GFJLOHHD@?$CF?43f?$AA@
	push	OFFSET _st+66670
	call	_sprintf
	add	esp, 16					; 00000010H

; 1130 : 				StartText();

	call	_StartText

; 1131 : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 1132 : 				UI_Sys.textinput=1;

	mov	BYTE PTR _UI_Sys+2163, 1
$LN5@UIWin2_Num:

; 1133 : 			}
; 1134 : 		}
; 1135 : 		else

	jmp	$LN4@UIWin2_Num
$LN6@UIWin2_Num:

; 1136 : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rn,gn,bn,255,UI_Win[uiwinid].font,
; 1137 : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN4@UIWin2_Num:

; 1138 : 	}
; 1139 : 	else

	jmp	$LN1@UIWin2_Num
$LN7@UIWin2_Num:

; 1140 : 	if(UI_Win[uiwinid].current==pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	jne	$LN1@UIWin2_Num

; 1141 : 	{
; 1142 : 		StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rc,gc,bc,255,UI_Win[uiwinid].font,
; 1143 : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bc$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gc$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rc$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 1144 : 
; 1145 : 		*value=atof(st.TextInput);

	push	OFFSET _st+66670
	call	_atof
	add	esp, 4
	mov	eax, DWORD PTR _value$[ebp]
	fstp	DWORD PTR [eax]

; 1146 : 
; 1147 : 		if(st.keys[RETURN_KEY].state)

	mov	eax, 8
	shl	eax, 0
	movzx	ecx, BYTE PTR _st[eax+65648]
	test	ecx, ecx
	je	SHORT $LN1@UIWin2_Num

; 1148 : 		{
; 1149 : 			StopText();

	call	_StopText

; 1150 : 			st.keys[RETURN_KEY].state=0;

	mov	eax, 8
	shl	eax, 0
	mov	BYTE PTR _st[eax+65648], 0

; 1151 : 			UI_Win[uiwinid].current=-1;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+34], -1

; 1152 : 			UI_Sys.textinput=0;

	mov	BYTE PTR _UI_Sys+2163, 0
$LN1@UIWin2_Num:

; 1153 : 		}
; 1154 : 	}
; 1155 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@UIWin2_Num
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 368				; 00000170H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@UIWin2_Num:
	DD	1
	DD	$LN11@UIWin2_Num
$LN11@UIWin2_Num:
	DD	-172					; ffffff54H
	DD	32					; 00000020H
	DD	$LN10@UIWin2_Num
$LN10@UIWin2_Num:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
_UIWin2_NumberBoxf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIWin2_NumberBoxi32
_TEXT	SEGMENT
_text2$ = -172						; size = 32
_bc$ = -129						; size = 1
_gc$ = -117						; size = 1
_rc$ = -105						; size = 1
_bs$ = -93						; size = 1
_gs$ = -81						; size = 1
_rs$ = -69						; size = 1
_bn$ = -57						; size = 1
_gn$ = -45						; size = 1
_rn$ = -33						; size = 1
_gsize$ = -24						; size = 2
_lenght$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_uiwinid$ = 8						; size = 1
_pos$ = 12						; size = 1
_value$ = 16						; size = 4
_text$ = 20						; size = 4
_colorN$ = 24						; size = 4
_colorS$ = 28						; size = 4
_colorC$ = 32						; size = 4
_UIWin2_NumberBoxi32 PROC				; COMDAT

; 1028 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-368]
	mov	ecx, 92					; 0000005cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1029 : 	int16 lenght, gsize;
; 1030 : 
; 1031 : 	uint8 rn, gn, bn, rs, gs, bs, rc, gc, bc;
; 1032 : 
; 1033 : 	char text2[32];
; 1034 : 
; 1035 : 	rn=colorN>>16;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rn$[ebp], al

; 1036 : 	gn=(colorN>>8) & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gn$[ebp], al

; 1037 : 	bn=colorN & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bn$[ebp], al

; 1038 : 
; 1039 : 	rs=colorS>>16;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rs$[ebp], al

; 1040 : 	gs=(colorS>>8) & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gs$[ebp], al

; 1041 : 	bs=colorS & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bs$[ebp], al

; 1042 : 
; 1043 : 	rc=colorC>>16;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rc$[ebp], al

; 1044 : 	gc=(colorC>>8) & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gc$[ebp], al

; 1045 : 	bc=colorC & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bc$[ebp], al

; 1046 : 
; 1047 : 	gsize=(st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+30]
	imul	eax, edx, 84
	movsx	ecx, BYTE PTR _uiwinid$[ebp]
	imul	edx, ecx, 56
	movsx	ecx, WORD PTR _UI_Win[edx+32]
	imul	ecx, DWORD PTR _st[eax+64360]
	shr	ecx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], cx

; 1048 : 
; 1049 : 	sprintf(text2,"%s: %ld",text, *value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	push	OFFSET ??_C@_07EFFLEODG@?$CFs?3?5?$CFld?$AA@
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 1050 : 
; 1051 : 	lenght=strlen(text2);

	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _lenght$[ebp], ax

; 1052 : 
; 1053 : 	if(UI_Win[uiwinid].current!=pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	je	$LN7@UIWin2_Num

; 1054 : 	{
; 1055 : 		if(CheckCollisionMouse(UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),
; 1056 : 			lenght*((st.fonts[UI_Win[uiwinid].font].size_w_gm*UI_Win[uiwinid].font_size)/FONT_SIZE),gsize,0))

	push	0
	movsx	eax, WORD PTR _gsize$[ebp]
	push	eax
	movsx	ecx, WORD PTR _lenght$[ebp]
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+30]
	imul	eax, edx, 84
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	edx, edx, 56
	movsx	edx, WORD PTR _UI_Win[edx+32]
	imul	edx, DWORD PTR _st[eax+64356]
	shr	edx, 10					; 0000000aH
	imul	ecx, edx
	push	ecx
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	je	$LN6@UIWin2_Num

; 1057 : 		{
; 1058 : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rs,gs,bs,255,UI_Win[uiwinid].font,
; 1059 : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rs$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 1060 : 
; 1061 : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN5@UIWin2_Num

; 1062 : 			{
; 1063 : 				UI_Win[uiwinid].current=pos;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _pos$[ebp]
	mov	BYTE PTR _UI_Win[ecx+34], dl

; 1064 : 				sprintf(st.TextInput,"%ld",*value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_03JALODAI@?$CFld?$AA@
	push	OFFSET _st+66670
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1065 : 				StartText();

	call	_StartText

; 1066 : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 1067 : 				UI_Sys.textinput=1;

	mov	BYTE PTR _UI_Sys+2163, 1
$LN5@UIWin2_Num:

; 1068 : 			}
; 1069 : 		}
; 1070 : 		else

	jmp	$LN4@UIWin2_Num
$LN6@UIWin2_Num:

; 1071 : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rn,gn,bn,255,UI_Win[uiwinid].font,
; 1072 : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN4@UIWin2_Num:

; 1073 : 	}
; 1074 : 	else

	jmp	$LN8@UIWin2_Num
$LN7@UIWin2_Num:

; 1075 : 	if(UI_Win[uiwinid].current==pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	jne	$LN8@UIWin2_Num

; 1076 : 	{
; 1077 : 		StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rc,gc,bc,255,UI_Win[uiwinid].font,
; 1078 : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bc$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gc$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rc$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 1079 : 
; 1080 : 		*value=atoi(st.TextInput);

	push	OFFSET _st+66670
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax

; 1081 : 
; 1082 : 		if(st.keys[RETURN_KEY].state)

	mov	eax, 8
	shl	eax, 0
	movzx	ecx, BYTE PTR _st[eax+65648]
	test	ecx, ecx
	je	SHORT $LN8@UIWin2_Num

; 1083 : 		{
; 1084 : 			StopText();

	call	_StopText

; 1085 : 			st.keys[RETURN_KEY].state=0;

	mov	eax, 8
	shl	eax, 0
	mov	BYTE PTR _st[eax+65648], 0

; 1086 : 			UI_Win[uiwinid].current=-1;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+34], -1

; 1087 : 			UI_Sys.textinput=0;

	mov	BYTE PTR _UI_Sys+2163, 0
$LN8@UIWin2_Num:

; 1088 : 		}
; 1089 : 	}
; 1090 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@UIWin2_Num
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 368				; 00000170H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN12@UIWin2_Num:
	DD	1
	DD	$LN11@UIWin2_Num
$LN11@UIWin2_Num:
	DD	-172					; ffffff54H
	DD	32					; 00000020H
	DD	$LN10@UIWin2_Num
$LN10@UIWin2_Num:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
_UIWin2_NumberBoxi32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIWin2_NumberBoxui32
_TEXT	SEGMENT
_text2$ = -172						; size = 32
_bc$ = -129						; size = 1
_gc$ = -117						; size = 1
_rc$ = -105						; size = 1
_bs$ = -93						; size = 1
_gs$ = -81						; size = 1
_rs$ = -69						; size = 1
_bn$ = -57						; size = 1
_gn$ = -45						; size = 1
_rn$ = -33						; size = 1
_gsize$ = -24						; size = 2
_lenght$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_uiwinid$ = 8						; size = 1
_pos$ = 12						; size = 1
_value$ = 16						; size = 4
_text$ = 20						; size = 4
_colorN$ = 24						; size = 4
_colorS$ = 28						; size = 4
_colorC$ = 32						; size = 4
_UIWin2_NumberBoxui32 PROC				; COMDAT

; 963  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-368]
	mov	ecx, 92					; 0000005cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 964  : 	int16 lenght, gsize;
; 965  : 
; 966  : 	uint8 rn, gn, bn, rs, gs, bs, rc, gc, bc;
; 967  : 
; 968  : 	char text2[32];
; 969  : 
; 970  : 	rn=colorN>>16;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rn$[ebp], al

; 971  : 	gn=(colorN>>8) & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gn$[ebp], al

; 972  : 	bn=colorN & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bn$[ebp], al

; 973  : 
; 974  : 	rs=colorS>>16;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rs$[ebp], al

; 975  : 	gs=(colorS>>8) & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gs$[ebp], al

; 976  : 	bs=colorS & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bs$[ebp], al

; 977  : 
; 978  : 	rc=colorC>>16;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rc$[ebp], al

; 979  : 	gc=(colorC>>8) & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gc$[ebp], al

; 980  : 	bc=colorC & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bc$[ebp], al

; 981  : 
; 982  : 	gsize=(st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+30]
	imul	eax, edx, 84
	movsx	ecx, BYTE PTR _uiwinid$[ebp]
	imul	edx, ecx, 56
	movsx	ecx, WORD PTR _UI_Win[edx+32]
	imul	ecx, DWORD PTR _st[eax+64360]
	shr	ecx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], cx

; 983  : 
; 984  : 	sprintf(text2,"%s: %lu",text, *value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	push	OFFSET ??_C@_07BGICGNCG@?$CFs?3?5?$CFlu?$AA@
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 985  : 
; 986  : 	lenght=strlen(text2);

	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _lenght$[ebp], ax

; 987  : 
; 988  : 	if(UI_Win[uiwinid].current!=pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	je	$LN7@UIWin2_Num

; 989  : 	{
; 990  : 		if(CheckCollisionMouse(UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),
; 991  : 			lenght*((st.fonts[UI_Win[uiwinid].font].size_w_gm*UI_Win[uiwinid].font_size)/FONT_SIZE),gsize,0))

	push	0
	movsx	eax, WORD PTR _gsize$[ebp]
	push	eax
	movsx	ecx, WORD PTR _lenght$[ebp]
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+30]
	imul	eax, edx, 84
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	edx, edx, 56
	movsx	edx, WORD PTR _UI_Win[edx+32]
	imul	edx, DWORD PTR _st[eax+64356]
	shr	edx, 10					; 0000000aH
	imul	ecx, edx
	push	ecx
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	je	$LN6@UIWin2_Num

; 992  : 		{
; 993  : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rs,gs,bs,255,UI_Win[uiwinid].font,
; 994  : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rs$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 995  : 
; 996  : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN5@UIWin2_Num

; 997  : 			{
; 998  : 				UI_Win[uiwinid].current=pos;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _pos$[ebp]
	mov	BYTE PTR _UI_Win[ecx+34], dl

; 999  : 				sprintf(st.TextInput,"%lu",*value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu?$AA@
	push	OFFSET _st+66670
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1000 : 				StartText();

	call	_StartText

; 1001 : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 1002 : 				UI_Sys.textinput=1;

	mov	BYTE PTR _UI_Sys+2163, 1
$LN5@UIWin2_Num:

; 1003 : 			}
; 1004 : 		}
; 1005 : 		else

	jmp	$LN4@UIWin2_Num
$LN6@UIWin2_Num:

; 1006 : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rn,gn,bn,255,UI_Win[uiwinid].font,
; 1007 : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN4@UIWin2_Num:

; 1008 : 	}
; 1009 : 	else

	jmp	$LN8@UIWin2_Num
$LN7@UIWin2_Num:

; 1010 : 	if(UI_Win[uiwinid].current==pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	jne	$LN8@UIWin2_Num

; 1011 : 	{
; 1012 : 		StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rc,gc,bc,255,UI_Win[uiwinid].font,
; 1013 : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bc$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gc$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rc$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 1014 : 
; 1015 : 		*value=atoi(st.TextInput);

	push	OFFSET _st+66670
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax

; 1016 : 
; 1017 : 		if(st.keys[RETURN_KEY].state)

	mov	eax, 8
	shl	eax, 0
	movzx	ecx, BYTE PTR _st[eax+65648]
	test	ecx, ecx
	je	SHORT $LN8@UIWin2_Num

; 1018 : 		{
; 1019 : 			StopText();

	call	_StopText

; 1020 : 			st.keys[RETURN_KEY].state=0;

	mov	eax, 8
	shl	eax, 0
	mov	BYTE PTR _st[eax+65648], 0

; 1021 : 			UI_Win[uiwinid].current=-1;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+34], -1

; 1022 : 			UI_Sys.textinput=0;

	mov	BYTE PTR _UI_Sys+2163, 0
$LN8@UIWin2_Num:

; 1023 : 		}
; 1024 : 	}
; 1025 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@UIWin2_Num
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 368				; 00000170H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN12@UIWin2_Num:
	DD	1
	DD	$LN11@UIWin2_Num
$LN11@UIWin2_Num:
	DD	-172					; ffffff54H
	DD	32					; 00000020H
	DD	$LN10@UIWin2_Num
$LN10@UIWin2_Num:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
_UIWin2_NumberBoxui32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIWin2_NumberBoxi16
_TEXT	SEGMENT
_text2$ = -172						; size = 32
_bc$ = -129						; size = 1
_gc$ = -117						; size = 1
_rc$ = -105						; size = 1
_bs$ = -93						; size = 1
_gs$ = -81						; size = 1
_rs$ = -69						; size = 1
_bn$ = -57						; size = 1
_gn$ = -45						; size = 1
_rn$ = -33						; size = 1
_gsize$ = -24						; size = 2
_lenght$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_uiwinid$ = 8						; size = 1
_pos$ = 12						; size = 1
_value$ = 16						; size = 4
_text$ = 20						; size = 4
_colorN$ = 24						; size = 4
_colorS$ = 28						; size = 4
_colorC$ = 32						; size = 4
_UIWin2_NumberBoxi16 PROC				; COMDAT

; 899  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-368]
	mov	ecx, 92					; 0000005cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 900  : 	int16 lenght, gsize;
; 901  : 
; 902  : 	uint8 rn, gn, bn, rs, gs, bs, rc, gc, bc;
; 903  : 
; 904  : 	char text2[32];
; 905  : 
; 906  : 	rn=colorN>>16;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rn$[ebp], al

; 907  : 	gn=(colorN>>8) & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gn$[ebp], al

; 908  : 	bn=colorN & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bn$[ebp], al

; 909  : 
; 910  : 	rs=colorS>>16;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rs$[ebp], al

; 911  : 	gs=(colorS>>8) & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gs$[ebp], al

; 912  : 	bs=colorS & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bs$[ebp], al

; 913  : 
; 914  : 	rc=colorC>>16;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rc$[ebp], al

; 915  : 	gc=(colorC>>8) & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gc$[ebp], al

; 916  : 	bc=colorC & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bc$[ebp], al

; 917  : 
; 918  : 	gsize=(st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+30]
	imul	eax, edx, 84
	movsx	ecx, BYTE PTR _uiwinid$[ebp]
	imul	edx, ecx, 56
	movsx	ecx, WORD PTR _UI_Win[edx+32]
	imul	ecx, DWORD PTR _st[eax+64360]
	shr	ecx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], cx

; 919  : 
; 920  : 	sprintf(text2,"%s: %d",text, *value);

	mov	eax, DWORD PTR _value$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	push	OFFSET ??_C@_06GBEGMGE@?$CFs?3?5?$CFd?$AA@
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 921  : 
; 922  : 	lenght=strlen(text2);

	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _lenght$[ebp], ax

; 923  : 
; 924  : 	if(UI_Win[uiwinid].current!=pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	je	$LN6@UIWin2_Num

; 925  : 	{
; 926  : 		if(CheckCollisionMouse(UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),
; 927  : 			lenght*((st.fonts[UI_Win[uiwinid].font].size_w_gm*UI_Win[uiwinid].font_size)/FONT_SIZE),gsize,0))

	push	0
	movsx	eax, WORD PTR _gsize$[ebp]
	push	eax
	movsx	ecx, WORD PTR _lenght$[ebp]
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+30]
	imul	eax, edx, 84
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	edx, edx, 56
	movsx	edx, WORD PTR _UI_Win[edx+32]
	imul	edx, DWORD PTR _st[eax+64356]
	shr	edx, 10					; 0000000aH
	imul	ecx, edx
	push	ecx
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	je	$LN5@UIWin2_Num

; 928  : 		{
; 929  : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rs,gs,bs,255,UI_Win[uiwinid].font,
; 930  : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rs$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 931  : 
; 932  : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN4@UIWin2_Num

; 933  : 			{
; 934  : 				UI_Win[uiwinid].current=pos;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _pos$[ebp]
	mov	BYTE PTR _UI_Win[ecx+34], dl

; 935  : 				sprintf(st.TextInput,"%d",*value);

	mov	eax, DWORD PTR _value$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _st+66670
	call	_sprintf
	add	esp, 12					; 0000000cH

; 936  : 				StartText();

	call	_StartText

; 937  : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 938  : 				UI_Sys.textinput=1;

	mov	BYTE PTR _UI_Sys+2163, 1
$LN4@UIWin2_Num:

; 939  : 			}
; 940  : 		}
; 941  : 		else

	jmp	$LN6@UIWin2_Num
$LN5@UIWin2_Num:

; 942  : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rn,gn,bn,255,UI_Win[uiwinid].font,
; 943  : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN6@UIWin2_Num:

; 944  : 	}
; 945  : 	if(UI_Win[uiwinid].current==pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	jne	$LN7@UIWin2_Num

; 946  : 	{
; 947  : 		StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rc,gc,bc,255,UI_Win[uiwinid].font,
; 948  : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bc$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gc$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rc$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 949  : 
; 950  : 		*value=atoi(st.TextInput);

	push	OFFSET _st+66670
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _value$[ebp]
	mov	WORD PTR [ecx], ax

; 951  : 
; 952  : 		if(st.keys[RETURN_KEY].state)

	mov	eax, 8
	shl	eax, 0
	movzx	ecx, BYTE PTR _st[eax+65648]
	test	ecx, ecx
	je	SHORT $LN7@UIWin2_Num

; 953  : 		{
; 954  : 			UI_Win[uiwinid].current=-1;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+34], -1

; 955  : 			StopText();

	call	_StopText

; 956  : 			st.keys[RETURN_KEY].state=0;

	mov	eax, 8
	shl	eax, 0
	mov	BYTE PTR _st[eax+65648], 0

; 957  : 			UI_Sys.textinput=0;

	mov	BYTE PTR _UI_Sys+2163, 0
$LN7@UIWin2_Num:

; 958  : 		}
; 959  : 	}
; 960  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@UIWin2_Num
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 368				; 00000170H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@UIWin2_Num:
	DD	1
	DD	$LN10@UIWin2_Num
$LN10@UIWin2_Num:
	DD	-172					; ffffff54H
	DD	32					; 00000020H
	DD	$LN9@UIWin2_Num
$LN9@UIWin2_Num:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
_UIWin2_NumberBoxi16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIWin2_NumberBoxui16
_TEXT	SEGMENT
_text2$ = -172						; size = 32
_bc$ = -129						; size = 1
_gc$ = -117						; size = 1
_rc$ = -105						; size = 1
_bs$ = -93						; size = 1
_gs$ = -81						; size = 1
_rs$ = -69						; size = 1
_bn$ = -57						; size = 1
_gn$ = -45						; size = 1
_rn$ = -33						; size = 1
_gsize$ = -24						; size = 2
_lenght$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_uiwinid$ = 8						; size = 1
_pos$ = 12						; size = 1
_value$ = 16						; size = 4
_text$ = 20						; size = 4
_colorN$ = 24						; size = 4
_colorS$ = 28						; size = 4
_colorC$ = 32						; size = 4
_UIWin2_NumberBoxui16 PROC				; COMDAT

; 834  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-368]
	mov	ecx, 92					; 0000005cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 835  : 	int16 lenght, gsize;
; 836  : 
; 837  : 	uint8 rn, gn, bn, rs, gs, bs, rc, gc, bc;
; 838  : 
; 839  : 	char text2[32];
; 840  : 
; 841  : 	rn=colorN>>16;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rn$[ebp], al

; 842  : 	gn=(colorN>>8) & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gn$[ebp], al

; 843  : 	bn=colorN & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bn$[ebp], al

; 844  : 
; 845  : 	rs=colorS>>16;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rs$[ebp], al

; 846  : 	gs=(colorS>>8) & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gs$[ebp], al

; 847  : 	bs=colorS & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bs$[ebp], al

; 848  : 
; 849  : 	rc=colorC>>16;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rc$[ebp], al

; 850  : 	gc=(colorC>>8) & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gc$[ebp], al

; 851  : 	bc=colorC & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bc$[ebp], al

; 852  : 
; 853  : 	gsize=(st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+30]
	imul	eax, edx, 84
	movsx	ecx, BYTE PTR _uiwinid$[ebp]
	imul	edx, ecx, 56
	movsx	ecx, WORD PTR _UI_Win[edx+32]
	imul	ecx, DWORD PTR _st[eax+64360]
	shr	ecx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], cx

; 854  : 
; 855  : 	sprintf(text2,"%s: %u",text, *value);

	mov	eax, DWORD PTR _value$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	push	OFFSET ??_C@_06FFMNEPHE@?$CFs?3?5?$CFu?$AA@
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 856  : 
; 857  : 	lenght=strlen(text2);

	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _lenght$[ebp], ax

; 858  : 
; 859  : 	if(UI_Win[uiwinid].current!=pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	je	$LN7@UIWin2_Num

; 860  : 	{
; 861  : 		if(CheckCollisionMouse(UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),
; 862  : 			lenght*((st.fonts[UI_Win[uiwinid].font].size_w_gm*UI_Win[uiwinid].font_size)/FONT_SIZE),gsize,0))

	push	0
	movsx	eax, WORD PTR _gsize$[ebp]
	push	eax
	movsx	ecx, WORD PTR _lenght$[ebp]
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+30]
	imul	eax, edx, 84
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	edx, edx, 56
	movsx	edx, WORD PTR _UI_Win[edx+32]
	imul	edx, DWORD PTR _st[eax+64356]
	shr	edx, 10					; 0000000aH
	imul	ecx, edx
	push	ecx
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	je	$LN6@UIWin2_Num

; 863  : 		{
; 864  : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rs,gs,bs,255,UI_Win[uiwinid].font,
; 865  : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rs$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 866  : 
; 867  : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN5@UIWin2_Num

; 868  : 			{
; 869  : 				UI_Win[uiwinid].current=pos;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _pos$[ebp]
	mov	BYTE PTR _UI_Win[ecx+34], dl

; 870  : 				sprintf(st.TextInput,"%u",*value);

	mov	eax, DWORD PTR _value$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_02GMHACPFF@?$CFu?$AA@
	push	OFFSET _st+66670
	call	_sprintf
	add	esp, 12					; 0000000cH

; 871  : 				StartText();

	call	_StartText

; 872  : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 873  : 				UI_Sys.textinput=1;

	mov	BYTE PTR _UI_Sys+2163, 1
$LN5@UIWin2_Num:

; 874  : 			}
; 875  : 		}
; 876  : 		else

	jmp	$LN4@UIWin2_Num
$LN6@UIWin2_Num:

; 877  : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rn,gn,bn,255,UI_Win[uiwinid].font,
; 878  : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN4@UIWin2_Num:

; 879  : 	}
; 880  : 	else

	jmp	$LN8@UIWin2_Num
$LN7@UIWin2_Num:

; 881  : 	if(UI_Win[uiwinid].current==pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	jne	$LN8@UIWin2_Num

; 882  : 	{
; 883  : 		StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rc,gc,bc,255,UI_Win[uiwinid].font,
; 884  : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bc$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gc$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rc$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 885  : 
; 886  : 		*value=atoi(st.TextInput);

	push	OFFSET _st+66670
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _value$[ebp]
	mov	WORD PTR [ecx], ax

; 887  : 
; 888  : 		if(st.keys[RETURN_KEY].state)

	mov	eax, 8
	shl	eax, 0
	movzx	ecx, BYTE PTR _st[eax+65648]
	test	ecx, ecx
	je	SHORT $LN8@UIWin2_Num

; 889  : 		{
; 890  : 			StopText();

	call	_StopText

; 891  : 			st.keys[RETURN_KEY].state=0;

	mov	eax, 8
	shl	eax, 0
	mov	BYTE PTR _st[eax+65648], 0

; 892  : 			UI_Win[uiwinid].current=-1;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+34], -1

; 893  : 			UI_Sys.textinput=0;

	mov	BYTE PTR _UI_Sys+2163, 0
$LN8@UIWin2_Num:

; 894  : 		}
; 895  : 	}
; 896  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@UIWin2_Num
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 368				; 00000170H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN12@UIWin2_Num:
	DD	1
	DD	$LN11@UIWin2_Num
$LN11@UIWin2_Num:
	DD	-172					; ffffff54H
	DD	32					; 00000020H
	DD	$LN10@UIWin2_Num
$LN10@UIWin2_Num:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
_UIWin2_NumberBoxui16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIWin2_NumberBoxi8
_TEXT	SEGMENT
_text2$ = -172						; size = 32
_bc$ = -129						; size = 1
_gc$ = -117						; size = 1
_rc$ = -105						; size = 1
_bs$ = -93						; size = 1
_gs$ = -81						; size = 1
_rs$ = -69						; size = 1
_bn$ = -57						; size = 1
_gn$ = -45						; size = 1
_rn$ = -33						; size = 1
_gsize$ = -24						; size = 2
_lenght$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_uiwinid$ = 8						; size = 1
_pos$ = 12						; size = 1
_value$ = 16						; size = 4
_text$ = 20						; size = 4
_colorN$ = 24						; size = 4
_colorS$ = 28						; size = 4
_colorC$ = 32						; size = 4
_UIWin2_NumberBoxi8 PROC				; COMDAT

; 769  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-368]
	mov	ecx, 92					; 0000005cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 770  : 	int16 lenght, gsize;
; 771  : 
; 772  : 	uint8 rn, gn, bn, rs, gs, bs, rc, gc, bc;
; 773  : 
; 774  : 	char text2[32];
; 775  : 
; 776  : 	rn=colorN>>16;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rn$[ebp], al

; 777  : 	gn=(colorN>>8) & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gn$[ebp], al

; 778  : 	bn=colorN & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bn$[ebp], al

; 779  : 
; 780  : 	rs=colorS>>16;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rs$[ebp], al

; 781  : 	gs=(colorS>>8) & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gs$[ebp], al

; 782  : 	bs=colorS & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bs$[ebp], al

; 783  : 
; 784  : 	rc=colorC>>16;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rc$[ebp], al

; 785  : 	gc=(colorC>>8) & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gc$[ebp], al

; 786  : 	bc=colorC & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bc$[ebp], al

; 787  : 
; 788  : 	gsize=(st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+30]
	imul	eax, edx, 84
	movsx	ecx, BYTE PTR _uiwinid$[ebp]
	imul	edx, ecx, 56
	movsx	ecx, WORD PTR _UI_Win[edx+32]
	imul	ecx, DWORD PTR _st[eax+64360]
	shr	ecx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], cx

; 789  : 
; 790  : 	sprintf(text2,"%s: %d",text, *value);

	mov	eax, DWORD PTR _value$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	push	OFFSET ??_C@_06GBEGMGE@?$CFs?3?5?$CFd?$AA@
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 791  : 
; 792  : 	lenght=strlen(text2);

	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _lenght$[ebp], ax

; 793  : 
; 794  : 	if(UI_Win[uiwinid].current!=pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	je	$LN7@UIWin2_Num

; 795  : 	{
; 796  : 		if(CheckCollisionMouse(UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),
; 797  : 			lenght*((st.fonts[UI_Win[uiwinid].font].size_w_gm*UI_Win[uiwinid].font_size)/FONT_SIZE),gsize,0))

	push	0
	movsx	eax, WORD PTR _gsize$[ebp]
	push	eax
	movsx	ecx, WORD PTR _lenght$[ebp]
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+30]
	imul	eax, edx, 84
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	edx, edx, 56
	movsx	edx, WORD PTR _UI_Win[edx+32]
	imul	edx, DWORD PTR _st[eax+64356]
	shr	edx, 10					; 0000000aH
	imul	ecx, edx
	push	ecx
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	je	$LN6@UIWin2_Num

; 798  : 		{
; 799  : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rs,gs,bs,255,UI_Win[uiwinid].font,
; 800  : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rs$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 801  : 
; 802  : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN5@UIWin2_Num

; 803  : 			{
; 804  : 				UI_Win[uiwinid].current=pos;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _pos$[ebp]
	mov	BYTE PTR _UI_Win[ecx+34], dl

; 805  : 				sprintf(st.TextInput,"%d",*value);

	mov	eax, DWORD PTR _value$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _st+66670
	call	_sprintf
	add	esp, 12					; 0000000cH

; 806  : 				StartText();

	call	_StartText

; 807  : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 808  : 				UI_Sys.textinput=1;

	mov	BYTE PTR _UI_Sys+2163, 1
$LN5@UIWin2_Num:

; 809  : 			}
; 810  : 		}
; 811  : 		else

	jmp	$LN4@UIWin2_Num
$LN6@UIWin2_Num:

; 812  : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rn,gn,bn,255,UI_Win[uiwinid].font,
; 813  : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN4@UIWin2_Num:

; 814  : 	}
; 815  : 	else

	jmp	$LN8@UIWin2_Num
$LN7@UIWin2_Num:

; 816  : 	if(UI_Win[uiwinid].current==pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	jne	$LN8@UIWin2_Num

; 817  : 	{
; 818  : 		StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rc,gc,bc,255,UI_Win[uiwinid].font,
; 819  : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bc$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gc$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rc$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 820  : 
; 821  : 		*value=atoi(st.TextInput);

	push	OFFSET _st+66670
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _value$[ebp]
	mov	BYTE PTR [ecx], al

; 822  : 
; 823  : 		if(st.keys[RETURN_KEY].state)

	mov	eax, 8
	shl	eax, 0
	movzx	ecx, BYTE PTR _st[eax+65648]
	test	ecx, ecx
	je	SHORT $LN8@UIWin2_Num

; 824  : 		{
; 825  : 			StopText();

	call	_StopText

; 826  : 			st.keys[RETURN_KEY].state=0;

	mov	eax, 8
	shl	eax, 0
	mov	BYTE PTR _st[eax+65648], 0

; 827  : 			UI_Win[uiwinid].current=-1;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+34], -1

; 828  : 			UI_Sys.textinput=0;

	mov	BYTE PTR _UI_Sys+2163, 0
$LN8@UIWin2_Num:

; 829  : 		}
; 830  : 	}
; 831  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@UIWin2_Num
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 368				; 00000170H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@UIWin2_Num:
	DD	1
	DD	$LN11@UIWin2_Num
$LN11@UIWin2_Num:
	DD	-172					; ffffff54H
	DD	32					; 00000020H
	DD	$LN10@UIWin2_Num
$LN10@UIWin2_Num:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
_UIWin2_NumberBoxi8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIWin2_NumberBoxui8
_TEXT	SEGMENT
_text2$ = -172						; size = 32
_bc$ = -129						; size = 1
_gc$ = -117						; size = 1
_rc$ = -105						; size = 1
_bs$ = -93						; size = 1
_gs$ = -81						; size = 1
_rs$ = -69						; size = 1
_bn$ = -57						; size = 1
_gn$ = -45						; size = 1
_rn$ = -33						; size = 1
_gsize$ = -24						; size = 2
_lenght$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_uiwinid$ = 8						; size = 1
_pos$ = 12						; size = 1
_value$ = 16						; size = 4
_text$ = 20						; size = 4
_colorN$ = 24						; size = 4
_colorS$ = 28						; size = 4
_colorC$ = 32						; size = 4
_UIWin2_NumberBoxui8 PROC				; COMDAT

; 704  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-368]
	mov	ecx, 92					; 0000005cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 705  : 	int16 lenght, gsize;
; 706  : 
; 707  : 	uint8 rn, gn, bn, rs, gs, bs, rc, gc, bc;
; 708  : 
; 709  : 	char text2[32];
; 710  : 
; 711  : 	rn=colorN>>16;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rn$[ebp], al

; 712  : 	gn=(colorN>>8) & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gn$[ebp], al

; 713  : 	bn=colorN & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bn$[ebp], al

; 714  : 
; 715  : 	rs=colorS>>16;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rs$[ebp], al

; 716  : 	gs=(colorS>>8) & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gs$[ebp], al

; 717  : 	bs=colorS & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bs$[ebp], al

; 718  : 
; 719  : 	rc=colorC>>16;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rc$[ebp], al

; 720  : 	gc=(colorC>>8) & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gc$[ebp], al

; 721  : 	bc=colorC & 0xFF;

	mov	eax, DWORD PTR _colorC$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bc$[ebp], al

; 722  : 
; 723  : 	gsize=(st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+30]
	imul	eax, edx, 84
	movsx	ecx, BYTE PTR _uiwinid$[ebp]
	imul	edx, ecx, 56
	movsx	ecx, WORD PTR _UI_Win[edx+32]
	imul	ecx, DWORD PTR _st[eax+64360]
	shr	ecx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], cx

; 724  : 
; 725  : 	sprintf(text2,"%s: %u",text, *value);

	mov	eax, DWORD PTR _value$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	push	OFFSET ??_C@_06FFMNEPHE@?$CFs?3?5?$CFu?$AA@
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 726  : 
; 727  : 	lenght=strlen(text2);

	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _lenght$[ebp], ax

; 728  : 
; 729  : 	if(UI_Win[uiwinid].current!=pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	je	$LN7@UIWin2_Num

; 730  : 	{
; 731  : 		if(CheckCollisionMouse(UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),
; 732  : 			lenght*((st.fonts[UI_Win[uiwinid].font].size_w_gm*UI_Win[uiwinid].font_size)/FONT_SIZE),gsize,0))

	push	0
	movsx	eax, WORD PTR _gsize$[ebp]
	push	eax
	movsx	ecx, WORD PTR _lenght$[ebp]
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+30]
	imul	eax, edx, 84
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	edx, edx, 56
	movsx	edx, WORD PTR _UI_Win[edx+32]
	imul	edx, DWORD PTR _st[eax+64356]
	shr	edx, 10					; 0000000aH
	imul	ecx, edx
	push	ecx
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	je	$LN6@UIWin2_Num

; 733  : 		{
; 734  : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rs,gs,bs,255,UI_Win[uiwinid].font,
; 735  : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rs$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 736  : 
; 737  : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN5@UIWin2_Num

; 738  : 			{
; 739  : 				UI_Win[uiwinid].current=pos;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _pos$[ebp]
	mov	BYTE PTR _UI_Win[ecx+34], dl

; 740  : 				sprintf(st.TextInput,"%u",*value);

	mov	eax, DWORD PTR _value$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	push	OFFSET ??_C@_02GMHACPFF@?$CFu?$AA@
	push	OFFSET _st+66670
	call	_sprintf
	add	esp, 12					; 0000000cH

; 741  : 				StartText();

	call	_StartText

; 742  : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 743  : 				UI_Sys.textinput=1;

	mov	BYTE PTR _UI_Sys+2163, 1
$LN5@UIWin2_Num:

; 744  : 			}
; 745  : 		}
; 746  : 		else

	jmp	$LN4@UIWin2_Num
$LN6@UIWin2_Num:

; 747  : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rn,gn,bn,255,UI_Win[uiwinid].font,
; 748  : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN4@UIWin2_Num:

; 749  : 	}
; 750  : 	else

	jmp	$LN8@UIWin2_Num
$LN7@UIWin2_Num:

; 751  : 	if(UI_Win[uiwinid].current==pos)

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+34]
	movsx	eax, BYTE PTR _pos$[ebp]
	cmp	edx, eax
	jne	$LN8@UIWin2_Num

; 752  : 	{
; 753  : 		StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*gsize)+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rc,gc,bc,255,UI_Win[uiwinid].font,
; 754  : 				UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bc$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gc$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rc$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, WORD PTR _gsize$[ebp]
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	lea	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 755  : 
; 756  : 		*value=atoi(st.TextInput);

	push	OFFSET _st+66670
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _value$[ebp]
	mov	BYTE PTR [ecx], al

; 757  : 
; 758  : 		if(st.keys[RETURN_KEY].state)

	mov	eax, 8
	shl	eax, 0
	movzx	ecx, BYTE PTR _st[eax+65648]
	test	ecx, ecx
	je	SHORT $LN8@UIWin2_Num

; 759  : 		{
; 760  : 			StopText();

	call	_StopText

; 761  : 			st.keys[RETURN_KEY].state=0;

	mov	eax, 8
	shl	eax, 0
	mov	BYTE PTR _st[eax+65648], 0

; 762  : 			UI_Win[uiwinid].current=-1;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+34], -1

; 763  : 			UI_Sys.textinput=0;

	mov	BYTE PTR _UI_Sys+2163, 0
$LN8@UIWin2_Num:

; 764  : 		}
; 765  : 	}
; 766  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@UIWin2_Num
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 368				; 00000170H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@UIWin2_Num:
	DD	1
	DD	$LN11@UIWin2_Num
$LN11@UIWin2_Num:
	DD	-172					; ffffff54H
	DD	32					; 00000020H
	DD	$LN10@UIWin2_Num
$LN10@UIWin2_Num:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
_UIWin2_NumberBoxui8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIWin2_MarkBox
_TEXT	SEGMENT
_text2$ = -104						; size = 4
_bs$ = -89						; size = 1
_gs$ = -77						; size = 1
_rs$ = -65						; size = 1
_bn$ = -53						; size = 1
_gn$ = -41						; size = 1
_rn$ = -29						; size = 1
_gsize$ = -20						; size = 2
_lenght$ = -8						; size = 2
_uiwinid$ = 8						; size = 1
_pos$ = 12						; size = 1
_marked$ = 16						; size = 1
_text$ = 20						; size = 4
_colorN$ = 24						; size = 4
_colorS$ = 28						; size = 4
_UIWin2_MarkBox PROC					; COMDAT

; 640  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 641  : 	int16 lenght, gsize;
; 642  : 
; 643  : 	uint8 rn, gn, bn, rs, gs, bs;
; 644  : 
; 645  : 	char *text2;
; 646  : 
; 647  : 	lenght=strlen(text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _lenght$[ebp], ax

; 648  : 
; 649  : 	text2=malloc(lenght+5);

	movsx	eax, WORD PTR _lenght$[ebp]
	add	eax, 5
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _text2$[ebp], eax

; 650  : 
; 651  : 	strcpy(text2,text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text2$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 652  : 
; 653  : 	rn=colorN>>16;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rn$[ebp], al

; 654  : 	gn=(colorN>>8) & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gn$[ebp], al

; 655  : 	bn=colorN & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bn$[ebp], al

; 656  : 
; 657  : 	rs=colorS>>16;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 16					; 00000010H
	mov	BYTE PTR _rs$[ebp], al

; 658  : 	gs=(colorS>>8) & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gs$[ebp], al

; 659  : 	bs=colorS & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bs$[ebp], al

; 660  : 
; 661  : 	if(marked==1)

	movzx	eax, BYTE PTR _marked$[ebp]
	cmp	eax, 1
	jne	SHORT $LN13@UIWin2_Mar

; 662  : 		strcat(text2," [X]");

	push	OFFSET ??_C@_04IJKKPDFE@?5?$FLX?$FN?$AA@
	mov	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 663  : 	else

	jmp	SHORT $LN12@UIWin2_Mar
$LN13@UIWin2_Mar:

; 664  : 	if(!marked || marked==2)

	movzx	eax, BYTE PTR _marked$[ebp]
	test	eax, eax
	je	SHORT $LN10@UIWin2_Mar
	movzx	eax, BYTE PTR _marked$[ebp]
	cmp	eax, 2
	jne	SHORT $LN12@UIWin2_Mar
$LN10@UIWin2_Mar:

; 665  : 		strcat(text2," [ ]");

	push	OFFSET ??_C@_04NDEIMKLM@?5?$FL?5?$FN?$AA@
	mov	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN12@UIWin2_Mar:

; 666  : 
; 667  : 	gsize=(st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+30]
	imul	eax, edx, 84
	movsx	ecx, BYTE PTR _uiwinid$[ebp]
	imul	edx, ecx, 56
	movsx	ecx, WORD PTR _UI_Win[edx+32]
	imul	ecx, DWORD PTR _st[eax+64360]
	shr	ecx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], cx

; 668  : 
; 669  : 	lenght=strlen(text2);

	mov	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _lenght$[ebp], ax

; 670  : 
; 671  : 	if(!marked || marked==1)

	movzx	eax, BYTE PTR _marked$[ebp]
	test	eax, eax
	je	SHORT $LN8@UIWin2_Mar
	movzx	eax, BYTE PTR _marked$[ebp]
	cmp	eax, 1
	jne	$LN9@UIWin2_Mar
$LN8@UIWin2_Mar:

; 672  : 	{
; 673  : 		if(CheckCollisionMouse(UI_Win[uiwinid].pos.x,(pos*((st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE))+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),
; 674  : 			lenght*((st.fonts[UI_Win[uiwinid].font].size_w_gm*UI_Win[uiwinid].font_size)/FONT_SIZE),(st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE,0))

	push	0
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+30]
	imul	eax, edx, 84
	movsx	ecx, BYTE PTR _uiwinid$[ebp]
	imul	edx, ecx, 56
	movsx	ecx, WORD PTR _UI_Win[edx+32]
	imul	ecx, DWORD PTR _st[eax+64360]
	shr	ecx, 10					; 0000000aH
	push	ecx
	movsx	edx, WORD PTR _lenght$[ebp]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	eax, BYTE PTR _UI_Win[ecx+30]
	imul	ecx, eax, 84
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	eax, eax, 56
	movsx	eax, WORD PTR _UI_Win[eax+32]
	imul	eax, DWORD PTR _st[ecx+64356]
	shr	eax, 10					; 0000000aH
	imul	edx, eax
	push	edx
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+30]
	imul	eax, edx, 84
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	edx, edx, 56
	movsx	edx, WORD PTR _UI_Win[edx+32]
	imul	edx, DWORD PTR _st[eax+64360]
	shr	edx, 10					; 0000000aH
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	je	$LN7@UIWin2_Mar

; 675  : 		{
; 676  : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*((st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE))+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rs,gs,bs,255,
; 677  : 				UI_Win[uiwinid].font,UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rs$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+30]
	imul	eax, edx, 84
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	edx, edx, 56
	movsx	edx, WORD PTR _UI_Win[edx+32]
	imul	edx, DWORD PTR _st[eax+64360]
	shr	edx, 10					; 0000000aH
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	mov	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H

; 678  : 
; 679  : 			if(st.mouse1 && !marked)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN6@UIWin2_Mar
	movzx	eax, BYTE PTR _marked$[ebp]
	test	eax, eax
	jne	SHORT $LN6@UIWin2_Mar

; 680  : 			{
; 681  : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 682  : 				return 2;

	mov	al, 2
	jmp	$LN14@UIWin2_Mar

; 683  : 			}
; 684  : 			else

	jmp	SHORT $LN5@UIWin2_Mar
$LN6@UIWin2_Mar:

; 685  : 			if(st.mouse1 && marked==1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN5@UIWin2_Mar
	movzx	eax, BYTE PTR _marked$[ebp]
	cmp	eax, 1
	jne	SHORT $LN5@UIWin2_Mar

; 686  : 			{
; 687  : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 688  : 				return 1;

	mov	al, 1
	jmp	$LN14@UIWin2_Mar
$LN5@UIWin2_Mar:

; 689  : 			}
; 690  : 		}
; 691  : 		else

	jmp	$LN3@UIWin2_Mar
$LN7@UIWin2_Mar:

; 692  : 			StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*((st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE))+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rn,gn,bn,255,
; 693  : 				UI_Win[uiwinid].font,UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+30]
	imul	eax, edx, 84
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	edx, edx, 56
	movsx	edx, WORD PTR _UI_Win[edx+32]
	imul	edx, DWORD PTR _st[eax+64360]
	shr	edx, 10					; 0000000aH
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	mov	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN3@UIWin2_Mar:

; 694  : 	}
; 695  : 	else

	jmp	$LN2@UIWin2_Mar
$LN9@UIWin2_Mar:

; 696  : 	if(marked==2)

	movzx	eax, BYTE PTR _marked$[ebp]
	cmp	eax, 2
	jne	$LN2@UIWin2_Mar

; 697  : 		StringUIData(text2,UI_Win[uiwinid].pos.x,(pos*((st.fonts[UI_Win[uiwinid].font].size_h_gm*UI_Win[uiwinid].font_size)/FONT_SIZE))+UI_Win[uiwinid].pos.y-((UI_Win[uiwinid].size.y/2)-128-gsize),0,0,0,rn,gn,bn,128,
; 698  : 				UI_Win[uiwinid].font,UI_Win[uiwinid].font_size,UI_Win[uiwinid].font_size,UI_Win[uiwinid].layer-1);

	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, BYTE PTR _UI_Win[ecx+28]
	sub	edx, 1
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movsx	edx, WORD PTR _UI_Win[ecx+32]
	push	edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx+30]
	push	edx
	push	128					; 00000080H
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, BYTE PTR _pos$[ebp]
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	eax, edx, 56
	movsx	edx, BYTE PTR _UI_Win[eax+30]
	imul	eax, edx, 84
	movsx	edx, BYTE PTR _uiwinid$[ebp]
	imul	edx, edx, 56
	movsx	edx, WORD PTR _UI_Win[edx+32]
	imul	edx, DWORD PTR _st[eax+64360]
	shr	edx, 10					; 0000000aH
	imul	ecx, edx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	add	ecx, DWORD PTR _UI_Win[edx+8]
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	edx, eax, 56
	mov	eax, DWORD PTR _UI_Win[edx+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	sub	ecx, eax
	push	ecx
	movsx	eax, BYTE PTR _uiwinid$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _UI_Win[ecx+4]
	push	edx
	mov	eax, DWORD PTR _text2$[ebp]
	push	eax
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN2@UIWin2_Mar:

; 699  : 
; 700  : 	return 0;

	xor	al, al
$LN14@UIWin2_Mar:

; 701  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UIWin2_MarkBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIDestroyWindow
_TEXT	SEGMENT
_id$ = 8						; size = 1
_UIDestroyWindow PROC					; COMDAT

; 633  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 634  : 	UI_Win[id].stat=0;

	movsx	eax, BYTE PTR _id$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx], 0

; 635  : 	UI_Win[id].current=-1;

	movsx	eax, BYTE PTR _id$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+34], -1

; 636  : 	st.num_uiwindow--;

	mov	al, BYTE PTR _st+264
	sub	al, 1
	mov	BYTE PTR _st+264, al

; 637  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UIDestroyWindow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UICreateWindow2
_TEXT	SEGMENT
$T1 = -221						; size = 1
_i$ = -17						; size = 1
_ID$ = -5						; size = 1
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_bpos$ = 16						; size = 4
_layer$ = 20						; size = 1
_num_avail_options$ = 24				; size = 1
_font_size$ = 28					; size = 2
_num_charsperoption$ = 32				; size = 1
_font$ = 36						; size = 1
_UICreateWindow2 PROC					; COMDAT

; 595  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T1[ebp], 0

; 596  : 	int8 ID, i;
; 597  : 
; 598  : 	if(bpos==CENTER)

	cmp	DWORD PTR _bpos$[ebp], 0
	jne	SHORT $LN7@UICreateWi

; 599  : 	{
; 600  : 		x=8192;

	mov	DWORD PTR _x$[ebp], 8192		; 00002000H

; 601  : 		y=GAME_HEIGHT/2;

	mov	DWORD PTR _y$[ebp], 4608		; 00001200H
$LN7@UICreateWi:

; 602  : 	}
; 603  : 
; 604  : 	if(st.num_uiwindow<MAX_UIWINDOWS)

	movzx	eax, BYTE PTR _st+264
	cmp	eax, 8
	jge	$LN6@UICreateWi

; 605  : 	{
; 606  : 		for(i=0;i<MAX_UIWINDOWS;i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $LN5@UICreateWi
$LN4@UICreateWi:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$LN5@UICreateWi:
	movsx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN3@UICreateWi

; 607  : 		{
; 608  : 			if(!UI_Win[i].stat)

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx]
	test	edx, edx
	jne	$LN2@UICreateWi

; 609  : 			{
; 610  : 				UI_Win[i].stat=2;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx], 2

; 611  : 				UI_Win[i].pos.x=x;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _UI_Win[ecx+4], edx

; 612  : 				UI_Win[i].pos.y=y;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _UI_Win[ecx+8], edx

; 613  : 				UI_Win[i].size.x=(num_charsperoption*st.fonts[font].size_w_gm*font_size)/FONT_SIZE;

	movsx	eax, BYTE PTR _num_charsperoption$[ebp]
	movsx	ecx, BYTE PTR _font$[ebp]
	imul	edx, ecx, 84
	imul	eax, DWORD PTR _st[edx+64356]
	movsx	ecx, WORD PTR _font_size$[ebp]
	imul	eax, ecx
	shr	eax, 10					; 0000000aH
	movsx	edx, BYTE PTR _i$[ebp]
	imul	ecx, edx, 56
	mov	DWORD PTR _UI_Win[ecx+16], eax

; 614  : 				UI_Win[i].size.y=(num_avail_options*(st.fonts[font].size_h_gm*font_size)/FONT_SIZE)+256;

	movzx	eax, BYTE PTR _num_avail_options$[ebp]
	movsx	ecx, BYTE PTR _font$[ebp]
	imul	edx, ecx, 84
	movsx	ecx, WORD PTR _font_size$[ebp]
	imul	ecx, DWORD PTR _st[edx+64360]
	imul	eax, ecx
	shr	eax, 10					; 0000000aH
	add	eax, 256				; 00000100H
	movsx	edx, BYTE PTR _i$[ebp]
	imul	ecx, edx, 56
	mov	DWORD PTR _UI_Win[ecx+20], eax

; 615  : 				UI_Win[i].layer=layer;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _layer$[ebp]
	mov	BYTE PTR _UI_Win[ecx+28], dl

; 616  : 				UI_Win[i].num_options=0;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+29], 0

; 617  : 				UI_Win[i].font=font;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _font$[ebp]
	mov	BYTE PTR _UI_Win[ecx+30], dl

; 618  : 				UI_Win[i].font_size=font_size;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	dx, WORD PTR _font_size$[ebp]
	mov	WORD PTR _UI_Win[ecx+32], dx

; 619  : 				UI_Win[i].current=-1;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+34], -1

; 620  : 				ID=st.num_uiwindow;

	mov	BYTE PTR $T1[ebp], 1
	mov	al, BYTE PTR _st+264
	mov	BYTE PTR _ID$[ebp], al

; 621  : 				st.num_uiwindow++;

	mov	al, BYTE PTR _st+264
	add	al, 1
	mov	BYTE PTR _st+264, al

; 622  : 				break;

	jmp	SHORT $LN3@UICreateWi
$LN2@UICreateWi:

; 623  : 			}
; 624  : 		}

	jmp	$LN4@UICreateWi
$LN3@UICreateWi:

; 625  : 	}
; 626  : 	else

	jmp	SHORT $LN1@UICreateWi
$LN6@UICreateWi:

; 627  : 		return -1;

	or	al, -1
	jmp	SHORT $LN8@UICreateWi
$LN1@UICreateWi:

; 628  : 
; 629  : 	return ID;

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN10@UICreateWi
	push	OFFSET $LN11@UICreateWi
	call	__RTC_UninitUse
	add	esp, 4
$LN10@UICreateWi:
	mov	al, BYTE PTR _ID$[ebp]
$LN8@UICreateWi:

; 630  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@UICreateWi:
$LN11@UICreateWi:
	DB	73					; 00000049H
	DB	68					; 00000044H
	DB	0
_UICreateWindow2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UICreateWindow
_TEXT	SEGMENT
$T1 = -221						; size = 1
_i$ = -17						; size = 1
_ID$ = -5						; size = 1
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xsize$ = 16						; size = 4
_ysize$ = 20						; size = 4
_bpos$ = 24						; size = 4
_layer$ = 28						; size = 1
_window_frame$ = 32					; size = 1
_UICreateWindow PROC					; COMDAT

; 549  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T1[ebp], 0

; 550  : 	int8 ID, i;
; 551  : 
; 552  : 	if(bpos==CENTER)

	cmp	DWORD PTR _bpos$[ebp], 0
	jne	SHORT $LN13@UICreateWi

; 553  : 	{
; 554  : 		x=8192;

	mov	DWORD PTR _x$[ebp], 8192		; 00002000H

; 555  : 		y=GAME_HEIGHT/2;

	mov	DWORD PTR _y$[ebp], 4608		; 00001200H
$LN13@UICreateWi:

; 556  : 	}
; 557  : 
; 558  : 	if(st.num_uiwindow<MAX_UIWINDOWS)

	movzx	eax, BYTE PTR _st+264
	cmp	eax, 8
	jge	$LN12@UICreateWi

; 559  : 	{
; 560  : 		for(i=0;i<MAX_UIWINDOWS;i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $LN11@UICreateWi
$LN10@UICreateWi:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$LN11@UICreateWi:
	movsx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN9@UICreateWi

; 561  : 		{
; 562  : 			if(!UI_Win[i].stat)

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	movzx	edx, BYTE PTR _UI_Win[ecx]
	test	edx, edx
	jne	$LN8@UICreateWi

; 563  : 			{
; 564  : 				UI_Win[i].stat=1;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx], 1

; 565  : 				UI_Win[i].pos.x=x;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _UI_Win[ecx+4], edx

; 566  : 				UI_Win[i].pos.y=y;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _UI_Win[ecx+8], edx

; 567  : 				UI_Win[i].size.x=xsize;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _UI_Win[ecx+16], edx

; 568  : 				UI_Win[i].size.y=ysize;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _ysize$[ebp]
	mov	DWORD PTR _UI_Win[ecx+20], edx

; 569  : 				UI_Win[i].layer=layer;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _layer$[ebp]
	mov	BYTE PTR _UI_Win[ecx+28], dl

; 570  : 				UI_Win[i].num_options=0;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+29], 0

; 571  : 				UI_Win[i].current=-1;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	BYTE PTR _UI_Win[ecx+34], -1

; 572  : 
; 573  : 				if(window_frame==0 || window_frame==1)

	movzx	eax, BYTE PTR _window_frame$[ebp]
	test	eax, eax
	je	SHORT $LN6@UICreateWi
	movzx	eax, BYTE PTR _window_frame$[ebp]
	cmp	eax, 1
	jne	SHORT $LN7@UICreateWi
$LN6@UICreateWi:

; 574  : 					UI_Win[i].window_frame=UI_Sys.window_frame0;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _UI_Sys+2
	mov	BYTE PTR _UI_Win[ecx+35], dl

; 575  : 				else

	jmp	SHORT $LN5@UICreateWi
$LN7@UICreateWi:

; 576  : 				if(window_frame==2)

	movzx	eax, BYTE PTR _window_frame$[ebp]
	cmp	eax, 2
	jne	SHORT $LN4@UICreateWi

; 577  : 					UI_Win[i].window_frame=UI_Sys.window_frame1;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _UI_Sys+3
	mov	BYTE PTR _UI_Win[ecx+35], dl

; 578  : 				else

	jmp	SHORT $LN5@UICreateWi
$LN4@UICreateWi:

; 579  : 				if(window_frame==3)

	movzx	eax, BYTE PTR _window_frame$[ebp]
	cmp	eax, 3
	jne	SHORT $LN5@UICreateWi

; 580  : 					UI_Win[i].window_frame=UI_Sys.window_frame2;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	ecx, eax, 56
	mov	dl, BYTE PTR _UI_Sys+4
	mov	BYTE PTR _UI_Win[ecx+35], dl
$LN5@UICreateWi:

; 581  : 
; 582  : 				ID=st.num_uiwindow;

	mov	BYTE PTR $T1[ebp], 1
	mov	al, BYTE PTR _st+264
	mov	BYTE PTR _ID$[ebp], al

; 583  : 				st.num_uiwindow++;

	mov	al, BYTE PTR _st+264
	add	al, 1
	mov	BYTE PTR _st+264, al

; 584  : 				break;

	jmp	SHORT $LN9@UICreateWi
$LN8@UICreateWi:

; 585  : 			}
; 586  : 		}

	jmp	$LN10@UICreateWi
$LN9@UICreateWi:

; 587  : 	}
; 588  : 	else

	jmp	SHORT $LN1@UICreateWi
$LN12@UICreateWi:

; 589  : 		return -1;

	or	al, -1
	jmp	SHORT $LN14@UICreateWi
$LN1@UICreateWi:

; 590  : 
; 591  : 	return ID;

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN16@UICreateWi
	push	OFFSET $LN17@UICreateWi
	call	__RTC_UninitUse
	add	esp, 4
$LN16@UICreateWi:
	mov	al, BYTE PTR _ID$[ebp]
$LN14@UICreateWi:

; 592  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@UICreateWi:
$LN17@UICreateWi:
	DB	73					; 00000049H
	DB	68					; 00000044H
	DB	0
_UICreateWindow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIOptionBox
_TEXT	SEGMENT
$T1 = -365						; size = 1
_bs$ = -161						; size = 1
_gs$ = -149						; size = 1
_rs$ = -137						; size = 1
_bn$ = -125						; size = 1
_gn$ = -113						; size = 1
_rn$ = -101						; size = 1
_gsize$ = -92						; size = 2
_i$ = -68						; size = 2
_temp$ = -56						; size = 4
_height_size$ = -44					; size = 4
_text_size$ = -32					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_bpos$ = 16						; size = 4
_options$ = 20						; size = 4
_num_options$ = 24					; size = 1
_font$ = 28						; size = 1
_font_size$ = 32					; size = 4
_colorN$ = 36						; size = 4
_colorS$ = 40						; size = 4
_UIOptionBox PROC					; COMDAT

; 339  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 372				; 00000174H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-372]
	mov	ecx, 93					; 0000005dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T1[ebp], 0

; 340  : 	int32 xsize, ysize, text_size, height_size, temp;
; 341  : 	int16 i, j, gsize;
; 342  : 
; 343  : 	uint8 rn, gn, bn, rs, gs, bs;
; 344  : 
; 345  : 	rn=colorN>>16;

	mov	eax, DWORD PTR _colorN$[ebp]
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _rn$[ebp], al

; 346  : 	gn=(colorN>>8) & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gn$[ebp], al

; 347  : 	bn=colorN & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bn$[ebp], al

; 348  : 
; 349  : 	rs=colorS>>16;

	mov	eax, DWORD PTR _colorS$[ebp]
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _rs$[ebp], al

; 350  : 	gs=(colorS>>8) & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gs$[ebp], al

; 351  : 	bs=colorS & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bs$[ebp], al

; 352  : 
; 353  : 	if(bpos==CENTER)

	cmp	DWORD PTR _bpos$[ebp], 0
	jne	SHORT $LN13@UIOptionBo

; 354  : 	{
; 355  : 		x=8192;

	mov	DWORD PTR _x$[ebp], 8192		; 00002000H

; 356  : 		y=GAME_HEIGHT/2;

	mov	DWORD PTR _y$[ebp], 4608		; 00001200H
$LN13@UIOptionBo:

; 357  : 	}
; 358  : 
; 359  : 	height_size=(((st.fonts[font].size_h_gm*font_size)/FONT_SIZE)*num_options)+256;

	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64360]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	movzx	eax, BYTE PTR _num_options$[ebp]
	imul	edx, eax
	add	edx, 256				; 00000100H
	mov	DWORD PTR _height_size$[ebp], edx

; 360  : 	gsize=(st.fonts[font].size_h_gm*font_size)/FONT_SIZE;

	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64360]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	mov	WORD PTR _gsize$[ebp], dx

; 361  : 
; 362  : 	for(i=0;i<num_options;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN12@UIOptionBo
$LN11@UIOptionBo:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN12@UIOptionBo:
	movsx	eax, WORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _num_options$[ebp]
	cmp	eax, ecx
	jge	$LN10@UIOptionBo

; 363  : 	{
; 364  : 		if(i==0)

	movsx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	jne	SHORT $LN9@UIOptionBo

; 365  : 			text_size=strlen(options[i])*((st.fonts[font].size_w_gm*font_size)/FONT_SIZE); //text size in game units

	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _options$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	movzx	ecx, BYTE PTR _font$[ebp]
	imul	edx, ecx, 84
	mov	ecx, DWORD PTR _st[edx+64356]
	imul	ecx, DWORD PTR _font_size$[ebp]
	shr	ecx, 10					; 0000000aH
	imul	eax, ecx
	mov	BYTE PTR $T1[ebp], 1
	mov	DWORD PTR _text_size$[ebp], eax

; 366  : 		else

	jmp	SHORT $LN8@UIOptionBo
$LN9@UIOptionBo:

; 367  : 		{
; 368  : 			temp=strlen(options[i])*((st.fonts[font].size_w_gm*font_size)/FONT_SIZE);

	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _options$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	movzx	ecx, BYTE PTR _font$[ebp]
	imul	edx, ecx, 84
	mov	ecx, DWORD PTR _st[edx+64356]
	imul	ecx, DWORD PTR _font_size$[ebp]
	shr	ecx, 10					; 0000000aH
	imul	eax, ecx
	mov	DWORD PTR _temp$[ebp], eax

; 369  : 
; 370  : 			if(temp>text_size)

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN16@UIOptionBo
	push	OFFSET $LN17@UIOptionBo
	call	__RTC_UninitUse
	add	esp, 4
$LN16@UIOptionBo:
	mov	eax, DWORD PTR _temp$[ebp]
	cmp	eax, DWORD PTR _text_size$[ebp]
	jle	SHORT $LN8@UIOptionBo

; 371  : 				text_size=temp;

	mov	BYTE PTR $T1[ebp], 1
	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _text_size$[ebp], eax
$LN8@UIOptionBo:

; 372  : 		}
; 373  : 	}

	jmp	$LN11@UIOptionBo
$LN10@UIOptionBo:

; 374  : 
; 375  : 	UIData(x,y,text_size+128,height_size,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[SYS_BOX_TILE],255,7);

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN18@UIOptionBo
	push	OFFSET $LN17@UIOptionBo
	call	__RTC_UninitUse
	add	esp, 4
$LN18@UIOptionBo:
	push	7
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	mov	edx, 40					; 00000028H
	shl	edx, 2
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, edx
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	mov	eax, DWORD PTR _height_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text_size$[ebp]
	add	ecx, 128				; 00000080H
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_UIData
	add	esp, 96					; 00000060H

; 376  : 
; 377  : 	for(i=0;i<num_options;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN6@UIOptionBo
$LN5@UIOptionBo:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN6@UIOptionBo:
	movsx	eax, WORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _num_options$[ebp]
	cmp	eax, ecx
	jge	$LN4@UIOptionBo

; 378  : 	{
; 379  : 		if(CheckCollisionMouse(x,(y+(i*(st.fonts[font].size_h_gm*font_size)/FONT_SIZE))-((height_size-128-gsize)/2),text_size,(st.fonts[font].size_h_gm*font_size)/FONT_SIZE,0))

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN19@UIOptionBo
	push	OFFSET $LN17@UIOptionBo
	call	__RTC_UninitUse
	add	esp, 4
$LN19@UIOptionBo:
	push	0
	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64360]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _text_size$[ebp]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	movzx	edx, BYTE PTR _font$[ebp]
	imul	eax, edx, 84
	mov	edx, DWORD PTR _st[eax+64360]
	imul	edx, DWORD PTR _font_size$[ebp]
	imul	ecx, edx
	shr	ecx, 10					; 0000000aH
	add	ecx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	push	ecx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@UIOptionBo

; 380  : 		{
; 381  : 			StringUIData(options[i],x,(y+(i*(st.fonts[font].size_h_gm*font_size)/FONT_SIZE))-((height_size-128-gsize)/2),0,0,0,rs,gs,bs,255,font,font_size,font_size,5);

	push	5
	mov	eax, DWORD PTR _font_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _font_size$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _font$[ebp]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rs$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, WORD PTR _i$[ebp]
	movzx	edx, BYTE PTR _font$[ebp]
	imul	eax, edx, 84
	mov	edx, DWORD PTR _st[eax+64360]
	imul	edx, DWORD PTR _font_size$[ebp]
	imul	ecx, edx
	shr	ecx, 10					; 0000000aH
	add	ecx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	push	ecx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	_StringUIData
	add	esp, 56					; 00000038H

; 382  : 
; 383  : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN2@UIOptionBo

; 384  : 			{
; 385  : 				st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 386  : 				return 100+i;

	movsx	eax, WORD PTR _i$[ebp]
	add	eax, 100				; 00000064H
	jmp	SHORT $LN14@UIOptionBo
$LN2@UIOptionBo:

; 387  : 			}
; 388  : 		}
; 389  : 		else

	jmp	SHORT $LN1@UIOptionBo
$LN3@UIOptionBo:

; 390  : 			StringUIData(options[i],x,(y+(i*(st.fonts[font].size_h_gm*font_size)/FONT_SIZE))-((height_size-128-gsize)/2),0,0,0,rn,gn,bn,255,font,font_size,font_size,5);

	push	5
	mov	eax, DWORD PTR _font_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _font_size$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _font$[ebp]
	push	edx
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	movsx	ecx, WORD PTR _i$[ebp]
	movzx	edx, BYTE PTR _font$[ebp]
	imul	eax, edx, 84
	mov	edx, DWORD PTR _st[eax+64360]
	imul	edx, DWORD PTR _font_size$[ebp]
	imul	ecx, edx
	shr	ecx, 10					; 0000000aH
	add	ecx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 128				; 00000080H
	movsx	edx, WORD PTR _gsize$[ebp]
	sub	eax, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	push	ecx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN1@UIOptionBo:

; 391  : 	}

	jmp	$LN5@UIOptionBo
$LN4@UIOptionBo:

; 392  : 
; 393  : 	return UI_NULLOP;

	or	eax, -1
$LN14@UIOptionBo:

; 394  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 372				; 00000174H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@UIOptionBo:
$LN17@UIOptionBo:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
_UIOptionBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\ui.c
;	COMDAT _UIMessageBox
_TEXT	SEGMENT
_bt$ = -485						; size = 1
_gt$ = -473						; size = 1
_rt$ = -461						; size = 1
_bs$ = -449						; size = 1
_gs$ = -437						; size = 1
_rs$ = -425						; size = 1
_bn$ = -413						; size = 1
_gn$ = -401						; size = 1
_rn$ = -389						; size = 1
_ch_stop$ = -380					; size = 2
_j$ = -368						; size = 2
_i$ = -356						; size = 2
_lines$ = -344						; size = 2
_str_len$ = -332					; size = 2
_height_size$ = -320					; size = 4
_text_size$ = -308					; size = 4
_text_f$ = -272						; size = 264
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_bpos$ = 16						; size = 4
_text$ = 20						; size = 4
_num_options$ = 24					; size = 1
_font$ = 28						; size = 1
_font_size$ = 32					; size = 4
_colorN$ = 36						; size = 4
_colorS$ = 40						; size = 4
_colorT$ = 44						; size = 4
_UIMessageBox PROC					; COMDAT

; 186  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 684				; 000002acH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-684]
	mov	ecx, 171				; 000000abH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 187  : 	char text_f[8][33];
; 188  : 	int32 xsize, ysize, text_size, height_size;
; 189  : 	int16 str_len, lines=0, i, j, ch_stop=0;

	xor	eax, eax
	mov	WORD PTR _lines$[ebp], ax
	xor	eax, eax
	mov	WORD PTR _ch_stop$[ebp], ax

; 190  : 
; 191  : 	uint8 rn, gn, bn, rs, gs, bs, rt, gt, bt;
; 192  : 
; 193  : 	rn=colorN>>16;

	mov	eax, DWORD PTR _colorN$[ebp]
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _rn$[ebp], al

; 194  : 	gn=(colorN>>8) & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gn$[ebp], al

; 195  : 	bn=colorN & 0xFF;

	mov	eax, DWORD PTR _colorN$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bn$[ebp], al

; 196  : 
; 197  : 	rs=colorS>>16;

	mov	eax, DWORD PTR _colorS$[ebp]
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _rs$[ebp], al

; 198  : 	gs=(colorS>>8) & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gs$[ebp], al

; 199  : 	bs=colorS & 0xFF;

	mov	eax, DWORD PTR _colorS$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bs$[ebp], al

; 200  : 
; 201  : 	rt=colorT>>16;

	mov	eax, DWORD PTR _colorT$[ebp]
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _rt$[ebp], al

; 202  : 	gt=(colorT>>8) & 0xFF;

	mov	eax, DWORD PTR _colorT$[ebp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _gt$[ebp], al

; 203  : 	bt=colorT & 0xFF;

	mov	eax, DWORD PTR _colorT$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _bt$[ebp], al

; 204  : 
; 205  : 	//Forget x and y positions if bpos is not custom
; 206  : 	if(bpos==CENTER)

	cmp	DWORD PTR _bpos$[ebp], 0
	jne	SHORT $LN44@UIMessageB

; 207  : 	{
; 208  : 		x=8192;

	mov	DWORD PTR _x$[ebp], 8192		; 00002000H

; 209  : 		y=GAME_HEIGHT/2;

	mov	DWORD PTR _y$[ebp], 4608		; 00001200H
$LN44@UIMessageB:

; 210  : 	}
; 211  : 
; 212  : 	str_len=strlen(text);

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _str_len$[ebp], ax

; 213  : 
; 214  : 	if(str_len>32)

	movsx	eax, WORD PTR _str_len$[ebp]
	cmp	eax, 32					; 00000020H
	jle	$LN43@UIMessageB

; 215  : 	{
; 216  : 		lines=str_len/32;

	movsx	eax, WORD PTR _str_len$[ebp]
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	sar	eax, 5
	mov	WORD PTR _lines$[ebp], ax

; 217  : 
; 218  : 		for(i=0;i<lines;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN42@UIMessageB
$LN41@UIMessageB:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN42@UIMessageB:
	movsx	eax, WORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _lines$[ebp]
	cmp	eax, ecx
	jge	$LN40@UIMessageB

; 219  : 		{
; 220  : 			for(j=0;j<32;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN39@UIMessageB
$LN38@UIMessageB:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN39@UIMessageB:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 32					; 00000020H
	jge	$LN37@UIMessageB

; 221  : 			{
; 222  : 				if(text[j+ch_stop]=='\n' || j==31 || text[j+ch_stop]==0)

	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _ch_stop$[ebp]
	add	ecx, DWORD PTR _text$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN35@UIMessageB
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 31					; 0000001fH
	je	SHORT $LN35@UIMessageB
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _ch_stop$[ebp]
	add	ecx, DWORD PTR _text$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	$LN36@UIMessageB
$LN35@UIMessageB:

; 223  : 				{
; 224  : 					ch_stop=j+ch_stop+1;

	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _ch_stop$[ebp]
	lea	edx, DWORD PTR [eax+ecx+1]
	mov	WORD PTR _ch_stop$[ebp], dx

; 225  : 
; 226  : 					if(j==31)

	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 31					; 0000001fH
	jne	SHORT $LN34@UIMessageB

; 227  : 					{
; 228  : 						text_f[i][j+1]=0;

	movsx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 33
	lea	edx, DWORD PTR _text_f$[ebp+ecx]
	movsx	eax, WORD PTR _j$[ebp]
	mov	BYTE PTR [edx+eax+1], 0

; 229  : 						text_f[i][j]=text[j+ch_stop];

	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _ch_stop$[ebp]
	add	eax, ecx
	movsx	edx, WORD PTR _i$[ebp]
	imul	ecx, edx, 33
	lea	edx, DWORD PTR _text_f$[ebp+ecx]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	esi, DWORD PTR _text$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al

; 230  : 					}
; 231  : 					else

	jmp	SHORT $LN33@UIMessageB
$LN34@UIMessageB:

; 232  : 						text_f[i][j]=0;

	movsx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 33
	lea	edx, DWORD PTR _text_f$[ebp+ecx]
	movsx	eax, WORD PTR _j$[ebp]
	mov	BYTE PTR [edx+eax], 0
$LN33@UIMessageB:

; 233  : 
; 234  : 					if(i==lines-1 && ch_stop<str_len)

	movsx	eax, WORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _lines$[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jne	SHORT $LN32@UIMessageB
	movsx	eax, WORD PTR _ch_stop$[ebp]
	movsx	ecx, WORD PTR _str_len$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN32@UIMessageB

; 235  : 						lines++;

	mov	ax, WORD PTR _lines$[ebp]
	add	ax, 1
	mov	WORD PTR _lines$[ebp], ax
$LN32@UIMessageB:

; 236  : 
; 237  : 					break;

	jmp	SHORT $LN37@UIMessageB

; 238  : 				}
; 239  : 				else

	jmp	SHORT $LN31@UIMessageB
$LN36@UIMessageB:

; 240  : 					text_f[i][j]=text[j+ch_stop];

	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _ch_stop$[ebp]
	add	eax, ecx
	movsx	edx, WORD PTR _i$[ebp]
	imul	ecx, edx, 33
	lea	edx, DWORD PTR _text_f$[ebp+ecx]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	esi, DWORD PTR _text$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al
$LN31@UIMessageB:

; 241  : 			}

	jmp	$LN38@UIMessageB
$LN37@UIMessageB:

; 242  : 		}

	jmp	$LN41@UIMessageB
$LN40@UIMessageB:

; 243  : 
; 244  : 		text_size=32*((st.fonts[font].size_w_gm*font_size)/FONT_SIZE); //text size in game units

	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64356]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	shl	edx, 5
	mov	DWORD PTR _text_size$[ebp], edx

; 245  : 
; 246  : 		height_size=lines*((st.fonts[font].size_h_gm*font_size)/FONT_SIZE);

	movsx	eax, WORD PTR _lines$[ebp]
	movzx	ecx, BYTE PTR _font$[ebp]
	imul	edx, ecx, 84
	mov	ecx, DWORD PTR _st[edx+64360]
	imul	ecx, DWORD PTR _font_size$[ebp]
	shr	ecx, 10					; 0000000aH
	imul	eax, ecx
	mov	DWORD PTR _height_size$[ebp], eax

; 247  : 
; 248  : 		
; 249  : 	}
; 250  : 	else

	jmp	SHORT $LN30@UIMessageB
$LN43@UIMessageB:

; 251  : 	{
; 252  : 		text_size=str_len*((st.fonts[font].size_w_gm*font_size)/FONT_SIZE); //text size in game units

	movsx	eax, WORD PTR _str_len$[ebp]
	movzx	ecx, BYTE PTR _font$[ebp]
	imul	edx, ecx, 84
	mov	ecx, DWORD PTR _st[edx+64356]
	imul	ecx, DWORD PTR _font_size$[ebp]
	shr	ecx, 10					; 0000000aH
	imul	eax, ecx
	mov	DWORD PTR _text_size$[ebp], eax

; 253  : 
; 254  : 		height_size=((st.fonts[font].size_h_gm*font_size)/FONT_SIZE);

	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64360]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	mov	DWORD PTR _height_size$[ebp], edx
$LN30@UIMessageB:

; 255  : 	}
; 256  : 
; 257  : 	text_size+=128; //64 g.u of space between sides

	mov	eax, DWORD PTR _text_size$[ebp]
	add	eax, 128				; 00000080H
	mov	DWORD PTR _text_size$[ebp], eax

; 258  : 	height_size+=2*((st.fonts[font].size_h_gm*font_size)/FONT_SIZE);

	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64360]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _height_size$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _height_size$[ebp], ecx

; 259  : 
; 260  : 	UIData(x,y,text_size,height_size,0,255,255,255,0,0,TEX_PAN_RANGE,TEX_PAN_RANGE,mgg_sys[UI_Sys.mgg_id].frames[SYS_BOX_TILE],255,7);

	push	7
	push	255					; 000000ffH
	movsx	eax, BYTE PTR _UI_Sys
	imul	ecx, eax, 60
	mov	edx, 40					; 00000028H
	shl	edx, 2
	mov	esi, DWORD PTR _mgg_sys[ecx+40]
	add	esi, edx
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	32768					; 00008000H
	push	32768					; 00008000H
	push	0
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	0
	mov	eax, DWORD PTR _height_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_UIData
	add	esp, 96					; 00000060H

; 261  : 
; 262  : 	if(!lines)

	movsx	eax, WORD PTR _lines$[ebp]
	test	eax, eax
	jne	SHORT $LN29@UIMessageB

; 263  : 		StringUIData(text,x,y,0,0,0,rt,gt,bt,255,0,font_size,font_size,6);

	push	6
	mov	eax, DWORD PTR _font_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _font_size$[ebp]
	push	ecx
	push	0
	push	255					; 000000ffH
	movzx	edx, BYTE PTR _bt$[ebp]
	push	edx
	movzx	eax, BYTE PTR _gt$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _rt$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	_StringUIData
	add	esp, 56					; 00000038H

; 264  : 	else

	jmp	$LN28@UIMessageB
$LN29@UIMessageB:

; 265  : 	{
; 266  : 		for(i=0;i<lines;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN27@UIMessageB
$LN26@UIMessageB:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN27@UIMessageB:
	movsx	eax, WORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _lines$[ebp]
	cmp	eax, ecx
	jge	$LN28@UIMessageB

; 267  : 			StringUIData(text_f[i],x,(y-((height_size-512)/2))+(i*((st.fonts[font].size_h_gm*font_size)/FONT_SIZE)),0,0,0,rt,gt,bt,255,0,font_size,font_size,6);

	push	6
	mov	eax, DWORD PTR _font_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _font_size$[ebp]
	push	ecx
	push	0
	push	255					; 000000ffH
	movzx	edx, BYTE PTR _bt$[ebp]
	push	edx
	movzx	eax, BYTE PTR _gt$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _rt$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 512				; 00000200H
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _y$[ebp]
	sub	edx, eax
	movsx	eax, WORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _font$[ebp]
	imul	ecx, ecx, 84
	mov	ecx, DWORD PTR _st[ecx+64360]
	imul	ecx, DWORD PTR _font_size$[ebp]
	shr	ecx, 10					; 0000000aH
	imul	eax, ecx
	add	edx, eax
	push	edx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 33
	lea	edx, DWORD PTR _text_f$[ebp+ecx]
	push	edx
	call	_StringUIData
	add	esp, 56					; 00000038H
	jmp	$LN26@UIMessageB
$LN28@UIMessageB:

; 268  : 	}
; 269  : 
; 270  : 	if(num_options==1 || !num_options)

	movzx	eax, BYTE PTR _num_options$[ebp]
	cmp	eax, 1
	je	SHORT $LN23@UIMessageB
	movzx	eax, BYTE PTR _num_options$[ebp]
	test	eax, eax
	jne	$LN24@UIMessageB
$LN23@UIMessageB:

; 271  : 	{
; 272  : 		if(CheckCollisionMouse(x,y+((height_size-256)/2),2*((st.fonts[font].size_w_gm*font_size)/FONT_SIZE),((st.fonts[font].size_h_gm*font_size)/FONT_SIZE),0))

	push	0
	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64360]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	push	edx
	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64356]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	shl	edx, 1
	push	edx
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN22@UIMessageB

; 273  : 		{
; 274  : 			StringUIData("OK",x,y+((height_size-256)/2),0,0,0,rs,gs,bs,255,0,2048,2048,5);

	push	5
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rs$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	OFFSET ??_C@_02GIPFHKNO@OK?$AA@
	call	_StringUIData
	add	esp, 56					; 00000038H

; 275  : 
; 276  : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN21@UIMessageB

; 277  : 				return UI_OK;

	xor	eax, eax
	jmp	$LN45@UIMessageB
$LN21@UIMessageB:

; 278  : 		}
; 279  : 		else

	jmp	SHORT $LN20@UIMessageB
$LN22@UIMessageB:

; 280  : 			StringUIData("OK",x,y+((height_size-256)/2),0,0,0,rn,gn,bn,255,0,2048,2048,5);

	push	5
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	OFFSET ??_C@_02GIPFHKNO@OK?$AA@
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN20@UIMessageB:

; 281  : 	}
; 282  : 	else

	jmp	$LN19@UIMessageB
$LN24@UIMessageB:

; 283  : 	if(num_options==2)

	movzx	eax, BYTE PTR _num_options$[ebp]
	cmp	eax, 2
	jne	$LN18@UIMessageB

; 284  : 	{
; 285  : 		if(CheckCollisionMouse(x-((text_size-256)/2),y+((height_size-256)/2),2*((st.fonts[font].size_w_gm*font_size)/FONT_SIZE),((st.fonts[font].size_h_gm*font_size)/FONT_SIZE),0) && st.mouse1)

	push	0
	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64360]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	push	edx
	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64356]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	shl	edx, 1
	push	edx
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _text_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	push	ecx
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN17@UIMessageB
	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN17@UIMessageB

; 286  : 		{
; 287  : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN16@UIMessageB

; 288  : 				return UI_YES;

	mov	eax, 1
	jmp	$LN45@UIMessageB
$LN16@UIMessageB:

; 289  : 		}
; 290  : 		else

	jmp	SHORT $LN15@UIMessageB
$LN17@UIMessageB:

; 291  : 			StringUIData("Yes",x-((text_size-256)/2),y+((height_size-256)/2),0,0,0,rn,gn,bn,255,0,2048,2048,5);

	push	5
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _text_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	push	ecx
	push	OFFSET ??_C@_03CCLAEDDF@Yes?$AA@
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN15@UIMessageB:

; 292  : 
; 293  : 		if(CheckCollisionMouse(x+((text_size-256)/2),y+((height_size-256)/2),2*((st.fonts[font].size_w_gm*font_size)/FONT_SIZE),((st.fonts[font].size_h_gm*font_size)/FONT_SIZE),0) && st.mouse1)

	push	0
	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64360]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	push	edx
	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64356]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	shl	edx, 1
	push	edx
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _text_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@UIMessageB
	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN14@UIMessageB

; 294  : 		{
; 295  : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN13@UIMessageB

; 296  : 				return UI_NO;

	mov	eax, 2
	jmp	$LN45@UIMessageB
$LN13@UIMessageB:

; 297  : 		}
; 298  : 		else

	jmp	SHORT $LN12@UIMessageB
$LN14@UIMessageB:

; 299  : 			StringUIData("No",x+((text_size-256)/2),y+((height_size-256)/2),0,0,0,rn,gn,bn,255,0,2048,2048,5);

	push	5
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _text_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _x$[ebp]
	push	eax
	push	OFFSET ??_C@_02JINPPBEP@No?$AA@
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN12@UIMessageB:

; 300  : 	}
; 301  : 	else

	jmp	$LN19@UIMessageB
$LN18@UIMessageB:

; 302  : 	if(num_options==3)

	movzx	eax, BYTE PTR _num_options$[ebp]
	cmp	eax, 3
	jne	$LN19@UIMessageB

; 303  : 	{
; 304  : 		if(CheckCollisionMouse(x-((text_size-128)/2),y+((height_size-256)/2),2*((st.fonts[font].size_w_gm*font_size)/FONT_SIZE),((st.fonts[font].size_h_gm*font_size)/FONT_SIZE),0) && st.mouse1)

	push	0
	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64360]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	push	edx
	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64356]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	shl	edx, 1
	push	edx
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _text_size$[ebp]
	sub	eax, 128				; 00000080H
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	push	ecx
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	je	$LN9@UIMessageB
	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN9@UIMessageB

; 305  : 		{
; 306  : 			StringUIData("Yes",x-((text_size-128)/2),y+((height_size-256)/2),0,0,0,rs,gs,bs,255,0,2048,2048,5);

	push	5
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rs$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _text_size$[ebp]
	sub	eax, 128				; 00000080H
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	push	ecx
	push	OFFSET ??_C@_03CCLAEDDF@Yes?$AA@
	call	_StringUIData
	add	esp, 56					; 00000038H

; 307  : 
; 308  : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN8@UIMessageB

; 309  : 				return UI_YES;

	mov	eax, 1
	jmp	$LN45@UIMessageB
$LN8@UIMessageB:

; 310  : 		}
; 311  : 		else

	jmp	SHORT $LN7@UIMessageB
$LN9@UIMessageB:

; 312  : 			StringUIData("Yes",x-((text_size-128)/2),y+((height_size-256)/2),0,0,0,rn,gn,bn,255,0,2048,2048,5);

	push	5
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _text_size$[ebp]
	sub	eax, 128				; 00000080H
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	push	ecx
	push	OFFSET ??_C@_03CCLAEDDF@Yes?$AA@
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN7@UIMessageB:

; 313  : 
; 314  : 		if(CheckCollisionMouse(x+((text_size-128)/2),y+((height_size-256)/2),2*((st.fonts[font].size_w_gm*font_size)/FONT_SIZE),((st.fonts[font].size_h_gm*font_size)/FONT_SIZE),0) && st.mouse1)

	push	0
	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64360]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	push	edx
	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64356]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	shl	edx, 1
	push	edx
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _text_size$[ebp]
	sub	eax, 128				; 00000080H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	je	$LN6@UIMessageB
	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN6@UIMessageB

; 315  : 		{
; 316  : 			StringUIData("No",x+((text_size-128)/2),y+((height_size-256)/2),0,0,0,rs,gs,bs,255,0,2048,2048,5);

	push	5
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rs$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _text_size$[ebp]
	sub	eax, 128				; 00000080H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _x$[ebp]
	push	eax
	push	OFFSET ??_C@_02JINPPBEP@No?$AA@
	call	_StringUIData
	add	esp, 56					; 00000038H

; 317  : 
; 318  : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN5@UIMessageB

; 319  : 				return UI_NO;

	mov	eax, 2
	jmp	$LN45@UIMessageB
$LN5@UIMessageB:

; 320  : 		}
; 321  : 		else

	jmp	SHORT $LN4@UIMessageB
$LN6@UIMessageB:

; 322  : 			StringUIData("No",x+((text_size-128)/2),y+((height_size-256)/2),0,0,0,rn,gn,bn,255,0,2048,2048,5);

	push	5
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _text_size$[ebp]
	sub	eax, 128				; 00000080H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _x$[ebp]
	push	eax
	push	OFFSET ??_C@_02JINPPBEP@No?$AA@
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN4@UIMessageB:

; 323  : 
; 324  : 		if(CheckCollisionMouse(x,y+((height_size-256)/2),2*((st.fonts[font].size_w_gm*font_size)/FONT_SIZE),((st.fonts[font].size_h_gm*font_size)/FONT_SIZE),0) && st.mouse1)

	push	0
	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64360]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	push	edx
	movzx	eax, BYTE PTR _font$[ebp]
	imul	ecx, eax, 84
	mov	edx, DWORD PTR _st[ecx+64356]
	imul	edx, DWORD PTR _font_size$[ebp]
	shr	edx, 10					; 0000000aH
	shl	edx, 1
	push	edx
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_CheckCollisionMouse
	add	esp, 20					; 00000014H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@UIMessageB
	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN3@UIMessageB

; 325  : 		{
; 326  : 			StringUIData("Cancel",x,y+((height_size-256)/2),0,0,0,rs,gs,bs,255,0,2048,2048,5);

	push	5
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rs$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	OFFSET ??_C@_06FMBNCPDL@Cancel?$AA@
	call	_StringUIData
	add	esp, 56					; 00000038H

; 327  : 
; 328  : 			if(st.mouse1)

	movzx	eax, BYTE PTR _st+65636
	test	eax, eax
	je	SHORT $LN2@UIMessageB

; 329  : 				return UI_CANCEL;

	mov	eax, 4
	jmp	SHORT $LN45@UIMessageB
$LN2@UIMessageB:

; 330  : 		}
; 331  : 		else

	jmp	SHORT $LN19@UIMessageB
$LN3@UIMessageB:

; 332  : 			StringUIData("Cancel",x,y+((height_size-256)/2),0,0,0,rn,gn,bn,255,0,2048,2048,5);

	push	5
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	0
	push	255					; 000000ffH
	movzx	eax, BYTE PTR _bn$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _gn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _rn$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _height_size$[ebp]
	sub	eax, 256				; 00000100H
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	OFFSET ??_C@_06FMBNCPDL@Cancel?$AA@
	call	_StringUIData
	add	esp, 56					; 00000038H
$LN19@UIMessageB:

; 333  : 	}
; 334  : 
; 335  : 	return UI_NULLOP;

	or	eax, -1
$LN45@UIMessageB:

; 336  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN49@UIMessageB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 684				; 000002acH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@UIMessageB:
	DD	1
	DD	$LN48@UIMessageB
$LN48@UIMessageB:
	DD	-272					; fffffef0H
	DD	264					; 00000108H
	DD	$LN47@UIMessageB
$LN47@UIMessageB:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	102					; 00000066H
	DB	0
_UIMessageBox ENDP
_TEXT	ENDS
END
