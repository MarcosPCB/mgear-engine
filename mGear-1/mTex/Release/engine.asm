; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	C:\Users\Marcos\Desktop\prj\mGear-1\mGear-1\engine.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0PM@NPFOCGLD@?$CDversion?5130?6in?5vec3?5Position?$DL?6i@ ; `string'
PUBLIC	??_C@_0BDP@HLHOENOH@?$CDversion?5130?6uniform?5sampler2D?5t@ ; `string'
PUBLIC	??_C@_0NB@HNGLJMAI@?$CDversion?5130?6uniform?5sampler2D?5t@ ; `string'
PUBLIC	??_C@_0BFE@LHCNEGLH@?$CDversion?5130?6uniform?5sampler2D?5t@ ; `string'
PUBLIC	??_C@_0BAB@HLALIPKD@?$CDversion?5130?6uniform?5sampler2D?5t@ ; `string'
PUBLIC	??_C@_0CMF@PHINLJLD@?$CDversion?5130?6in?5vec2?5TexCoord2?$DL?6@ ; `string'
PUBLIC	??_C@_0BD@CBEDEJPH@unknown?5image?5type?$AA@	; `string'
PUBLIC	??_C@_08NOGIMCHF@outofmem?$AA@			; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0M@JPDHFAGK@can?8t?5fopen?$AA@		; `string'
PUBLIC	??_C@_0BB@FOKGPEKG@bad?5code?5lengths?$AA@	; `string'
PUBLIC	??_C@_0BB@IIMLINA@bad?5huffman?5code?$AA@	; `string'
PUBLIC	??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac?$AA@ ; `string'
PUBLIC	??_C@_0BA@KLNDOKJD@expected?5marker?$AA@	; `string'
PUBLIC	??_C@_0M@LPHNODCG@bad?5DRI?5len?$AA@		; `string'
PUBLIC	??_C@_0N@BOFJCHAP@bad?5DQT?5type?$AA@		; `string'
PUBLIC	??_C@_0O@CNHKKDIM@bad?5DQT?5table?$AA@		; `string'
PUBLIC	??_C@_0P@JLGKOCGN@bad?5DHT?5header?$AA@		; `string'
PUBLIC	??_C@_0M@CICAFFCH@bad?5COM?5len?$AA@		; `string'
PUBLIC	??_C@_0M@EENLKPDI@bad?5APP?5len?$AA@		; `string'
PUBLIC	??_C@_0P@NNGPHMMK@unknown?5marker?$AA@		; `string'
PUBLIC	??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count?$AA@ ; `string'
PUBLIC	??_C@_0M@GNEHAHOH@bad?5SOS?5len?$AA@		; `string'
PUBLIC	??_C@_0M@NOCCBFAC@bad?5DC?5huff?$AA@		; `string'
PUBLIC	??_C@_0M@JGMCBLGG@bad?5AC?5huff?$AA@		; `string'
PUBLIC	??_C@_07EEJOMGGP@bad?5SOS?$AA@			; `string'
PUBLIC	??_C@_0M@DOFMJEMP@bad?5SOF?5len?$AA@		; `string'
PUBLIC	??_C@_0L@BCINMEBJ@only?58?9bit?$AA@		; `string'
PUBLIC	??_C@_0BB@LNEGOMA@no?5header?5height?$AA@	; `string'
PUBLIC	??_C@_07BIDACDEF@0?5width?$AA@			; `string'
PUBLIC	??_C@_0BE@DAPHADHL@bad?5component?5count?$AA@	; `string'
PUBLIC	??_C@_05BLPKENEJ@bad?5H?$AA@			; `string'
PUBLIC	??_C@_05MPLLHCJG@bad?5V?$AA@			; `string'
PUBLIC	??_C@_06LJIHDFHI@bad?5TQ?$AA@			; `string'
PUBLIC	??_C@_09OJDLMMBJ@too?5large?$AA@		; `string'
PUBLIC	??_C@_06CLMBLEP@no?5SOI?$AA@			; `string'
PUBLIC	??_C@_06IFCEAHIA@no?5SOF?$AA@			; `string'
PUBLIC	??_C@_0M@EPMOIECP@bad?5DNL?5len?$AA@		; `string'
PUBLIC	??_C@_0P@PNCLKCLJ@bad?5DNL?5height?$AA@		; `string'
PUBLIC	??_C@_0N@KBPNPPBJ@bad?5req_comp?$AA@		; `string'
PUBLIC	??_C@_09EOHLEIKL@bad?5sizes?$AA@		; `string'
PUBLIC	??_C@_0BA@MDNKOBMC@bad?5codelengths?$AA@	; `string'
PUBLIC	??_C@_0BE@IBFIPFO@output?5buffer?5limit?$AA@	; `string'
PUBLIC	??_C@_08DIAPIMGJ@bad?5dist?$AA@			; `string'
PUBLIC	??_C@_0N@IECDHMDI@zlib?5corrupt?$AA@		; `string'
PUBLIC	??_C@_0BB@PIPBCKIA@read?5past?5buffer?$AA@	; `string'
PUBLIC	??_C@_0BA@OBKOPAFL@bad?5zlib?5header?$AA@	; `string'
PUBLIC	??_C@_0P@DOGMHEBI@no?5preset?5dict?$AA@		; `string'
PUBLIC	??_C@_0BA@MCNBDLPD@bad?5compression?$AA@	; `string'
PUBLIC	??_C@_0M@DMDNBACF@bad?5png?5sig?$AA@		; `string'
PUBLIC	??_C@_0BC@BHMPBBMG@not?5enough?5pixels?$AA@	; `string'
PUBLIC	??_C@_0P@FBBCPGMN@invalid?5filter?$AA@		; `string'
PUBLIC	??_C@_0O@KBHBNJOK@multiple?5IHDR?$AA@		; `string'
PUBLIC	??_C@_0N@POJLKMKK@bad?5IHDR?5len?$AA@		; `string'
PUBLIC	??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only?$AA@ ; `string'
PUBLIC	??_C@_09MBBNGCKB@bad?5ctype?$AA@		; `string'
PUBLIC	??_C@_0BA@MDMBDDFG@bad?5comp?5method?$AA@	; `string'
PUBLIC	??_C@_0BC@GHLIKKMD@bad?5filter?5method?$AA@	; `string'
PUBLIC	??_C@_0BF@JCGDPBAA@bad?5interlace?5method?$AA@	; `string'
PUBLIC	??_C@_0O@FNFBHCOO@0?9pixel?5image?$AA@		; `string'
PUBLIC	??_C@_0P@JEAFOMAF@first?5not?5IHDR?$AA@		; `string'
PUBLIC	??_C@_0N@JCPAJAKB@invalid?5PLTE?$AA@		; `string'
PUBLIC	??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT?$AA@	; `string'
PUBLIC	??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE?$AA@	; `string'
PUBLIC	??_C@_0N@KDLCCKCH@bad?5tRNS?5len?$AA@		; `string'
PUBLIC	??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha?$AA@	; `string'
PUBLIC	??_C@_07CKIELOEH@no?5PLTE?$AA@			; `string'
PUBLIC	??_C@_09MNNCNKEO@outofdata?$AA@			; `string'
PUBLIC	??_C@_07MLPECBNA@no?5IDAT?$AA@			; `string'
PUBLIC	??_C@_07IANEBNLB@not?5BMP?$AA@			; `string'
PUBLIC	??_C@_0M@KHBIBJBG@unknown?5BMP?$AA@		; `string'
PUBLIC	??_C@_07IEJCHBDI@bad?5BMP?$AA@			; `string'
PUBLIC	??_C@_0L@FEJFGKNE@monochrome?$AA@		; `string'
PUBLIC	??_C@_07IMHMNOIB@BMP?5RLE?$AA@			; `string'
PUBLIC	??_C@_07MALOAKCI@invalid?$AA@			; `string'
PUBLIC	??_C@_07JNJHIMGH@bad?5bpp?$AA@			; `string'
PUBLIC	??_C@_09DAEBACAB@bad?5masks?$AA@		; `string'
PUBLIC	??_C@_0L@DMAPJJO@bad?5format?$AA@		; `string'
PUBLIC	??_C@_0M@ILLOCNCO@bad?5palette?$AA@		; `string'
PUBLIC	??_C@_02DPNLHKJD@a?$CL?$AA@			; `string'
PUBLIC	??_C@_09JFHIBJMD@mgear?4log?$AA@		; `string'
PUBLIC	??_C@_1DA@PFAEBODD@?$AAO?$AAp?$AAe?$AAn?$AAi?$AAn?$AAg?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_1CE@CDPPCMAP@?$AAC?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_08PJPFOJIA@?$CFs?5?$CF?42f?6?$AA@		; `string'
PUBLIC	??_C@_0BA@BIGBPAJK@Engine?5started?6?$AA@	; `string'
PUBLIC	??_C@_0N@JPOOLMEG@Log?5created?6?$AA@		; `string'
PUBLIC	??_C@_0N@NDCMMGFF@?$CFs?5fps?3?5?$CF?42f?$AA@	; `string'
PUBLIC	??_C@_05PDOBBJNA@Color?$AA@			; `string'
PUBLIC	??_C@_08GCJNLIKG@Position?$AA@			; `string'
PUBLIC	??_C@_08NGMLKGCO@TexCoord?$AA@			; `string'
PUBLIC	??_C@_08DGBKPNED@TexLight?$AA@			; `string'
PUBLIC	??_C@_0BM@HCNBMJIE@SDL?5Initilization?5failed?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BD@DNBPCBJE@SDL?52?40?5initialzed?$AA@	; `string'
PUBLIC	??_C@_0CG@LLIBEPGC@Error?5while?5initializing?5SDL?5TTF@ ; `string'
PUBLIC	??_C@_0BE@MBBIJNFJ@SDL?5TTF?5initialized?$AA@	; `string'
PUBLIC	??_C@_0DJ@GHPNMNEC@Error?5setting?5fullscreen?5video?5m@ ; `string'
PUBLIC	??_C@_0DG@HINKMIAE@Error?5setting?5widowed?5video?5mode@ ; `string'
PUBLIC	??_C@_0CB@CJINDJOG@Window?5created?0?5?$CFd?5x?5?$CFd?0?5?$CFd?5bits@ ; `string'
PUBLIC	??_C@_0BL@JKBAOCCM@Error?5setting?5renderer?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BH@PJDJGOFF@Opengl?5context?5created?$AA@ ; `string'
PUBLIC	??_C@_0BL@PNJKGHIL@GL_ARB_vertex_array_object?$AA@ ; `string'
PUBLIC	??_C@_0FD@HGLPPOCA@VAO?5not?5supported?0?5check?5your?5vi@ ; `string'
PUBLIC	??_C@_0BD@HLIFEONF@GL_EXT_framebuffer?$AA@	; `string'
PUBLIC	??_C@_0DP@GKIFJBKD@Your?5video?5card?5is?5not?5adequate?5@ ; `string'
PUBLIC	??_C@_0O@BNBOBIPB@Shader?5?$CFd?3?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0BK@JJHKDBGE@Counld?5not?5compile?5shader?$AA@ ; `string'
PUBLIC	??_C@_04DBNNPNIH@texu?$AA@			; `string'
PUBLIC	??_C@_05JOJNJPAP@texu2?$AA@			; `string'
PUBLIC	??_C@_05IHIGKOEO@texu3?$AA@			; `string'
PUBLIC	??_C@_06IKLLLDHL@normal?$AA@			; `string'
PUBLIC	??_C@_0L@GLKJCCIE@light_type?$AA@		; `string'
PUBLIC	??_C@_0BD@MFHDJABA@Opengl?5initialized?$AA@	; `string'
PUBLIC	??_C@_0CA@IICOLDCN@GL_ARB_texture_non_power_of_two?$AA@ ; `string'
PUBLIC	??_C@_0GF@JPJDLJAN@Non?5power?5of?5two?5textures?5not?5su@ ; `string'
PUBLIC	??_C@_0BJ@NKHMPMDJ@GL_ARB_texture_rectangle?$AA@ ; `string'
PUBLIC	??_C@_0BI@KIAKBMLM@GL_NV_texture_rectangle?$AA@	; `string'
PUBLIC	??_C@_0FP@HOKOFLMI@Rectangle?5textures?5not?5supported@ ; `string'
PUBLIC	??_C@_0BC@DHDBMALK@Input?5initialized?$AA@	; `string'
PUBLIC	??_C@_0CC@HAGAANID@Error?5while?5opening?5TTF?5font?5?3?5?$CF@ ; `string'
PUBLIC	??_C@_0BA@NDONFOIB@Video?5restarted?$AA@	; `string'
PUBLIC	??_C@_0DH@KKJPEJIP@Error?5setting?5windowed?5video?5mod@ ; `string'
PUBLIC	??_C@_0BK@MKEONLB@Window?5resized?5to?5?$CFd?5x?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BK@JNFOJKPO@Error?5reading?5MGG?5file?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BD@IGEJGLBO@MGG?5File?5Version?51?$AA@	; `string'
PUBLIC	??_C@_0BL@HGJNDNHB@Invalid?5MGG?5file?5header?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BE@GOCIOEKA@Invalid?5MGG?5file?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BJ@MDEIDPPP@Invalid?5MGG?5file?5info?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0DJ@PPPGBEPE@Error?5allocating?5memory?5for?5text@ ; `string'
PUBLIC	??_C@_0CC@PLAHMHNO@Error?5loading?5texture?5from?5memor@ ; `string'
PUBLIC	??_C@_0EI@OCDBEPGI@Error?5allocating?5memory?5for?5norm@ ; `string'
PUBLIC	??_C@_0DB@EBPLCLOB@Error?5loading?5normal?5mapping?5tex@ ; `string'
PUBLIC	??_C@_0DG@BNCAOHGG@Error?5could?5not?5allocate?5memory?5@ ; `string'
PUBLIC	??_C@_0CH@GLOGGAHF@Warning?3?5max?5number?5os?5strings?5r@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	_vbdt_num
PUBLIC	_texone_num
EXTRN	__imp__SDL_FreeSurface:PROC
EXTRN	__imp__SDL_Quit:PROC
EXTRN	__imp__TTF_Quit:PROC
EXTRN	__imp__glLoadIdentity@0:PROC
EXTRN	__GLEE_VERSION_3_0:BYTE
EXTRN	_GLeeFuncPtr_glDrawBuffers:DWORD
EXTRN	_GLeeFuncPtr_glRenderbufferStorage:DWORD
EXTRN	_exit:PROC
EXTRN	_GLeeFuncPtr_glCreateProgram:DWORD
EXTRN	_GLeeFuncPtr_glGenerateMipmap:DWORD
EXTRN	__imp__glGenTextures@8:PROC
EXTRN	_fclose:PROC
EXTRN	_GLeeFuncPtr_glBufferSubData:DWORD
EXTRN	_GLeeFuncPtr_glGetShaderiv:DWORD
EXTRN	__imp__SDL_SetWindowTitle:PROC
EXTRN	_fseek:PROC
EXTRN	__imp__glEnable@4:PROC
EXTRN	__imp__SDL_GL_SetAttribute:PROC
EXTRN	_realloc:PROC
EXTRN	_GLeeFuncPtr_glFramebufferRenderbuffer:DWORD
EXTRN	__imp__SDL_GetError:PROC
EXTRN	_ftell:PROC
EXTRN	__imp__SDL_GetTicks:PROC
EXTRN	_GLeeFuncPtr_glGetProgramiv:DWORD
EXTRN	_GLeeFuncPtr_glDeleteShader:DWORD
EXTRN	__imp__glViewport@16:PROC
EXTRN	__imp__glMatrixMode@4:PROC
EXTRN	_GLeeFuncPtr_glBufferData:DWORD
EXTRN	__imp__TTF_Init:PROC
EXTRN	_GLeeFuncPtr_glCompileShader:DWORD
EXTRN	__imp__glBlendFunc@8:PROC
EXTRN	_GLeeFuncPtr_glUniform1f:DWORD
EXTRN	_GLeeFuncPtr_glGenBuffers:DWORD
EXTRN	__imp__SDL_GetRelativeMouseMode:PROC
EXTRN	_GLeeFuncPtr_glDrawRangeElements:DWORD
EXTRN	_GLeeFuncPtr_glEnableVertexAttribArray:DWORD
EXTRN	__imp__TTF_OpenFont:PROC
EXTRN	_fprintf:PROC
EXTRN	_GLeeFuncPtr_glGenVertexArrays:DWORD
EXTRN	_fread:PROC
EXTRN	__imp__SDL_Log:PROC
EXTRN	__imp__TTF_RenderUTF8_Blended:PROC
EXTRN	_fopen:PROC
EXTRN	__imp__glTexParameteri@12:PROC
EXTRN	_GLeeFuncPtr_glUseProgram:DWORD
EXTRN	__imp__SDL_GL_CreateContext:PROC
EXTRN	__imp__SDL_SetRelativeMouseMode:PROC
EXTRN	_GLeeFuncPtr_glBindRenderbuffer:DWORD
EXTRN	__imp__glGetTexImage@20:PROC
EXTRN	_fopen_s:PROC
EXTRN	_GLeeFuncPtr_glActiveTexture:DWORD
EXTRN	_GLeeFuncPtr_glBindBuffer:DWORD
EXTRN	_GLeeFuncPtr_glGetUniformLocation:DWORD
EXTRN	_GLeeFuncPtr_glUniform1i:DWORD
EXTRN	__imp__glGetString@4:PROC
EXTRN	_GLeeFuncPtr_glGetShaderInfoLog:DWORD
EXTRN	_GLeeEnabled:PROC
EXTRN	_GLeeFuncPtr_glCreateShader:DWORD
EXTRN	__imp__glTexImage2D@36:PROC
EXTRN	_GLeeFuncPtr_glGetAttribLocation:DWORD
EXTRN	_GLeeFuncPtr_glDeleteProgram:DWORD
EXTRN	_GLeeFuncPtr_glDisableVertexAttribArray:DWORD
EXTRN	__imp__glBindTexture@8:PROC
EXTRN	__imp__SDL_CreateWindow:PROC
EXTRN	_GLeeFuncPtr_glShaderSource:DWORD
EXTRN	__imp__glPixelStorei@8:PROC
EXTRN	_GLeeFuncPtr_glDetachShader:DWORD
EXTRN	_GLeeFuncPtr_glLinkProgram:DWORD
EXTRN	_strstr:PROC
EXTRN	_rewind:PROC
EXTRN	_malloc:PROC
EXTRN	_GLeeFuncPtr_glBindVertexArray:DWORD
EXTRN	_calloc:PROC
EXTRN	__imp__glOrtho@48:PROC
EXTRN	__imp__glTexParameterf@12:PROC
EXTRN	_free:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	__imp__SDL_LogSetOutputFunction:PROC
EXTRN	__imp__glTexSubImage2D@36:PROC
EXTRN	__imp__SDL_GL_SetSwapInterval:PROC
EXTRN	__imp__SDL_DestroyWindow:PROC
EXTRN	_GLeeFuncPtr_glGenFramebuffers:DWORD
EXTRN	__imp__SDL_Init:PROC
EXTRN	__imp__glClearColor@16:PROC
EXTRN	__imp__glClear@4:PROC
EXTRN	_GLeeFuncPtr_glAttachShader:DWORD
EXTRN	__imp__glDepthFunc@4:PROC
EXTRN	_GLeeFuncPtr_glVertexAttribPointer:DWORD
EXTRN	_feof:PROC
EXTRN	_GLeeFuncPtr_glBindFramebuffer:DWORD
EXTRN	_sprintf:PROC
EXTRN	_GLeeFuncPtr_glGenRenderbuffers:DWORD
EXTRN	_GLeeFuncPtr_glGetProgramInfoLog:DWORD
EXTRN	__imp__glClearDepth@8:PROC
EXTRN	__imp__glDeleteTextures@8:PROC
EXTRN	_GLeeFuncPtr_glFramebufferTexture2D:DWORD
EXTRN	@__security_check_cookie@4:PROC
COMM	_lm:DWORD
COMM	_z_buffer:WORD:01c800H
COMM	_events:BYTE:038H
COMM	_DATA_TEST:DWORD
_stbi__vertically_flip_on_load DD 01H DUP (?)
COMM	_movie:BYTE:03cH
COMM	_z_slot:WORD:039H
_vbdt_num DW	01H DUP (?)
	ALIGN	4

_stbi__unpremultiply_on_load DD 01H DUP (?)
COMM	_mgg_map:BYTE:0f00H
COMM	_game_lights:BYTE:0280H
COMM	_lmp:BYTE:08400H
COMM	_wn:DWORD
_stbi__de_iphone_flag DD 01H DUP (?)
COMM	_mgg_sys:BYTE:0b4H
COMM	_texone_ids:WORD:0800H
COMM	_st:BYTE:0328140H
COMM	_mgg_game:BYTE:01e00H
COMM	_vbd:BYTE:040H
?tesg@?1??Renderer@@9@9 DD 01H DUP (?)			; `Renderer'::`2'::tesg
COMM	_DataNT:DWORD
COMM	_DataN:DWORD
COMM	_z_used:BYTE
COMM	_ent:BYTE:084000H
_texone_num DW	01H DUP (?)
COMM	_vbdt:DWORD
_DATA	ENDS
_Texture_VShader DD FLAT:??_C@_0PM@NPFOCGLD@?$CDversion?5130?6in?5vec3?5Position?$DL?6i@
	ORG $+252
_TextureNoT_FShader DD FLAT:??_C@_0NB@HNGLJMAI@?$CDversion?5130?6uniform?5sampler2D?5t@
	ORG $+252
_stbi__stdio_callbacks DD FLAT:_stbi__stdio_read
	DD	FLAT:_stbi__stdio_skip
	DD	FLAT:_stbi__stdio_eof
?invalid_chunk@?BO@??stbi__parse_png_file@@9@9 DB 'XXXX PNG chunk not kno'
	DB	'wn', 00H					; `stbi__parse_png_file'::`30'::invalid_chunk
	ORG $+3
_Texture_FShader DD FLAT:??_C@_0BDP@HLHOENOH@?$CDversion?5130?6uniform?5sampler2D?5t@
	ORG $+252
_Blend_FShader DD FLAT:??_C@_0BAB@HLALIPKD@?$CDversion?5130?6uniform?5sampler2D?5t@
	ORG $+252
_TextureT_FShader DD FLAT:??_C@_0BFE@LHCNEGLH@?$CDversion?5130?6uniform?5sampler2D?5t@
	ORG $+252
_Lightmap_FShader DD FLAT:??_C@_0CMF@PHINLJLD@?$CDversion?5130?6in?5vec2?5TexCoord2?$DL?6@
	ORG $+508
_stbi__zlength_base DD 03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0dH
	DD	0fH
	DD	011H
	DD	013H
	DD	017H
	DD	01bH
	DD	01fH
	DD	023H
	DD	02bH
	DD	033H
	DD	03bH
	DD	043H
	DD	053H
	DD	063H
	DD	073H
	DD	083H
	DD	0a3H
	DD	0c3H
	DD	0e3H
	DD	0102H
	DD	00H
	DD	00H
?length_dezigzag@?1??stbi__compute_huffman_codes@@9@9 DB 010H ; `stbi__compute_huffman_codes'::`2'::length_dezigzag
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
	ORG $+1
_stbi__zdefault_length DB 08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
_stbi__zdist_base DD 01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	07H
	DD	09H
	DD	0dH
	DD	011H
	DD	019H
	DD	021H
	DD	031H
	DD	041H
	DD	061H
	DD	081H
	DD	0c1H
	DD	0101H
	DD	0181H
	DD	0201H
	DD	0301H
	DD	0401H
	DD	0601H
	DD	0801H
	DD	0c01H
	DD	01001H
	DD	01801H
	DD	02001H
	DD	03001H
	DD	04001H
	DD	06001H
	DD	00H
	DD	00H
_stbi__depth_scale_table DB 00H
	DB	0ffH
	DB	055H
	DB	00H
	DB	011H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	ORG $+3
?png_sig@?1??stbi__check_png_header@@9@9 DB 089H	; `stbi__check_png_header'::`2'::png_sig
	DB	050H
	DB	04eH
	DB	047H
	DB	0dH
	DB	0aH
	DB	01aH
	DB	0aH
?rgb@?5??stbi__process_frame_header@@9@9 DB 052H	; `stbi__process_frame_header'::`6'::rgb
	DB	047H
	DB	042H
	ORG $+1
_stbi__zdist_extra DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
	ORG $+8
_stbi__zdefault_distance DB 05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
?tag@?O@??stbi__process_marker@@9@9 DB 04aH		; `stbi__process_marker'::`14'::tag
	DB	046H
	DB	049H
	DB	046H
	DB	00H
	ORG $+3
_stbi__jpeg_dezigzag DB 00H
	DB	01H
	DB	08H
	DB	010H
	DB	09H
	DB	02H
	DB	03H
	DB	0aH
	DB	011H
	DB	018H
	DB	020H
	DB	019H
	DB	012H
	DB	0bH
	DB	04H
	DB	05H
	DB	0cH
	DB	013H
	DB	01aH
	DB	021H
	DB	028H
	DB	030H
	DB	029H
	DB	022H
	DB	01bH
	DB	014H
	DB	0dH
	DB	06H
	DB	07H
	DB	0eH
	DB	015H
	DB	01cH
	DB	023H
	DB	02aH
	DB	031H
	DB	038H
	DB	039H
	DB	032H
	DB	02bH
	DB	024H
	DB	01dH
	DB	016H
	DB	0fH
	DB	017H
	DB	01eH
	DB	025H
	DB	02cH
	DB	033H
	DB	03aH
	DB	03bH
	DB	034H
	DB	02dH
	DB	026H
	DB	01fH
	DB	027H
	DB	02eH
	DB	035H
	DB	03cH
	DB	03dH
	DB	036H
	DB	02fH
	DB	037H
	DB	03eH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	ORG $+1
_stbi__zlength_extra DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	DD	00H
	DD	00H
?tag@?BA@??stbi__process_marker@@9@9 DB 041H		; `stbi__process_marker'::`16'::tag
	DB	064H
	DB	06fH
	DB	062H
	DB	065H
	DB	00H
	ORG $+2
_first_row_filter DB 00H
	DB	01H
	DB	00H
	DB	05H
	DB	06H
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GLOGGAHF@Warning?3?5max?5number?5os?5strings?5r@
CONST	SEGMENT
??_C@_0CH@GLOGGAHF@Warning?3?5max?5number?5os?5strings?5r@ DB 'Warning: m'
	DB	'ax number os strings reached', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@BNCAOHGG@Error?5could?5not?5allocate?5memory?5@
CONST	SEGMENT
??_C@_0DG@BNCAOHGG@Error?5could?5not?5allocate?5memory?5@ DB 'Error could'
	DB	' not allocate memory for the Vertex Buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@EBPLCLOB@Error?5loading?5normal?5mapping?5tex@
CONST	SEGMENT
??_C@_0DB@EBPLCLOB@Error?5loading?5normal?5mapping?5tex@ DB 'Error loadin'
	DB	'g normal mapping texture from memory', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@OCDBEPGI@Error?5allocating?5memory?5for?5norm@
CONST	SEGMENT
??_C@_0EI@OCDBEPGI@Error?5allocating?5memory?5for?5norm@ DB 'Error alloca'
	DB	'ting memory for normal mapping texture %d, size %d, file %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PLAHMHNO@Error?5loading?5texture?5from?5memor@
CONST	SEGMENT
??_C@_0CC@PLAHMHNO@Error?5loading?5texture?5from?5memor@ DB 'Error loadin'
	DB	'g texture from memory', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@PPPGBEPE@Error?5allocating?5memory?5for?5text@
CONST	SEGMENT
??_C@_0DJ@PPPGBEPE@Error?5allocating?5memory?5for?5text@ DB 'Error alloca'
	DB	'ting memory for texture %d, size %d, file %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MDEIDPPP@Invalid?5MGG?5file?5info?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BJ@MDEIDPPP@Invalid?5MGG?5file?5info?5?$CFs?$AA@ DB 'Invalid MGG f'
	DB	'ile info %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GOCIOEKA@Invalid?5MGG?5file?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BE@GOCIOEKA@Invalid?5MGG?5file?5?$CFs?$AA@ DB 'Invalid MGG file %s'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HGJNDNHB@Invalid?5MGG?5file?5header?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BL@HGJNDNHB@Invalid?5MGG?5file?5header?5?$CFs?$AA@ DB 'Invalid MGG'
	DB	' file header %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IGEJGLBO@MGG?5File?5Version?51?$AA@
CONST	SEGMENT
??_C@_0BD@IGEJGLBO@MGG?5File?5Version?51?$AA@ DB 'MGG File Version 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JNFOJKPO@Error?5reading?5MGG?5file?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BK@JNFOJKPO@Error?5reading?5MGG?5file?5?$CFs?$AA@ DB 'Error readin'
	DB	'g MGG file %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MKEONLB@Window?5resized?5to?5?$CFd?5x?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BK@MKEONLB@Window?5resized?5to?5?$CFd?5x?5?$CFd?$AA@ DB 'Window re'
	DB	'sized to %d x %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@KKJPEJIP@Error?5setting?5windowed?5video?5mod@
CONST	SEGMENT
??_C@_0DH@KKJPEJIP@Error?5setting?5windowed?5video?5mod@ DB 'Error settin'
	DB	'g windowed video mode %d x %d %d bits - %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NDONFOIB@Video?5restarted?$AA@
CONST	SEGMENT
??_C@_0BA@NDONFOIB@Video?5restarted?$AA@ DB 'Video restarted', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HAGAANID@Error?5while?5opening?5TTF?5font?5?3?5?$CF@
CONST	SEGMENT
??_C@_0CC@HAGAANID@Error?5while?5opening?5TTF?5font?5?3?5?$CF@ DB 'Error '
	DB	'while opening TTF font : %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DHDBMALK@Input?5initialized?$AA@
CONST	SEGMENT
??_C@_0BC@DHDBMALK@Input?5initialized?$AA@ DB 'Input initialized', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@HOKOFLMI@Rectangle?5textures?5not?5supported@
CONST	SEGMENT
??_C@_0FP@HOKOFLMI@Rectangle?5textures?5not?5supported@ DB 'Rectangle tex'
	DB	'tures not supported, your video card is not supported or try '
	DB	'updating your driver', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KIAKBMLM@GL_NV_texture_rectangle?$AA@
CONST	SEGMENT
??_C@_0BI@KIAKBMLM@GL_NV_texture_rectangle?$AA@ DB 'GL_NV_texture_rectang'
	DB	'le', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NKHMPMDJ@GL_ARB_texture_rectangle?$AA@
CONST	SEGMENT
??_C@_0BJ@NKHMPMDJ@GL_ARB_texture_rectangle?$AA@ DB 'GL_ARB_texture_recta'
	DB	'ngle', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@JPJDLJAN@Non?5power?5of?5two?5textures?5not?5su@
CONST	SEGMENT
??_C@_0GF@JPJDLJAN@Non?5power?5of?5two?5textures?5not?5su@ DB 'Non power '
	DB	'of two textures not supported, loading times might increase a'
	DB	'nd video''s fps might decrease', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IICOLDCN@GL_ARB_texture_non_power_of_two?$AA@
CONST	SEGMENT
??_C@_0CA@IICOLDCN@GL_ARB_texture_non_power_of_two?$AA@ DB 'GL_ARB_textur'
	DB	'e_non_power_of_two', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MFHDJABA@Opengl?5initialized?$AA@
CONST	SEGMENT
??_C@_0BD@MFHDJABA@Opengl?5initialized?$AA@ DB 'Opengl initialized', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GLKJCCIE@light_type?$AA@
CONST	SEGMENT
??_C@_0L@GLKJCCIE@light_type?$AA@ DB 'light_type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKLLLDHL@normal?$AA@
CONST	SEGMENT
??_C@_06IKLLLDHL@normal?$AA@ DB 'normal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IHIGKOEO@texu3?$AA@
CONST	SEGMENT
??_C@_05IHIGKOEO@texu3?$AA@ DB 'texu3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JOJNJPAP@texu2?$AA@
CONST	SEGMENT
??_C@_05JOJNJPAP@texu2?$AA@ DB 'texu2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DBNNPNIH@texu?$AA@
CONST	SEGMENT
??_C@_04DBNNPNIH@texu?$AA@ DB 'texu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JJHKDBGE@Counld?5not?5compile?5shader?$AA@
CONST	SEGMENT
??_C@_0BK@JJHKDBGE@Counld?5not?5compile?5shader?$AA@ DB 'Counld not compi'
	DB	'le shader', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNBOBIPB@Shader?5?$CFd?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0O@BNBOBIPB@Shader?5?$CFd?3?5?$CFs?$AA@ DB 'Shader %d: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@GKIFJBKD@Your?5video?5card?5is?5not?5adequate?5@
CONST	SEGMENT
??_C@_0DP@GKIFJBKD@Your?5video?5card?5is?5not?5adequate?5@ DB 'Your video'
	DB	' card is not adequate to play this game... Goodbye!!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HLIFEONF@GL_EXT_framebuffer?$AA@
CONST	SEGMENT
??_C@_0BD@HLIFEONF@GL_EXT_framebuffer?$AA@ DB 'GL_EXT_framebuffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@HGLPPOCA@VAO?5not?5supported?0?5check?5your?5vi@
CONST	SEGMENT
??_C@_0FD@HGLPPOCA@VAO?5not?5supported?0?5check?5your?5vi@ DB 'VAO not su'
	DB	'pported, check your video''s card driver for updates... Using'
	DB	' VBO instead', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PNJKGHIL@GL_ARB_vertex_array_object?$AA@
CONST	SEGMENT
??_C@_0BL@PNJKGHIL@GL_ARB_vertex_array_object?$AA@ DB 'GL_ARB_vertex_arra'
	DB	'y_object', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PJDJGOFF@Opengl?5context?5created?$AA@
CONST	SEGMENT
??_C@_0BH@PJDJGOFF@Opengl?5context?5created?$AA@ DB 'Opengl context creat'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JKBAOCCM@Error?5setting?5renderer?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BL@JKBAOCCM@Error?5setting?5renderer?3?5?$CFs?$AA@ DB 'Error setti'
	DB	'ng renderer: %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CJINDJOG@Window?5created?0?5?$CFd?5x?5?$CFd?0?5?$CFd?5bits@
CONST	SEGMENT
??_C@_0CB@CJINDJOG@Window?5created?0?5?$CFd?5x?5?$CFd?0?5?$CFd?5bits@ DB 'W'
	DB	'indow created, %d x %d, %d bits', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HINKMIAE@Error?5setting?5widowed?5video?5mode@
CONST	SEGMENT
??_C@_0DG@HINKMIAE@Error?5setting?5widowed?5video?5mode@ DB 'Error settin'
	DB	'g widowed video mode %d x %d %d bits - %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@GHPNMNEC@Error?5setting?5fullscreen?5video?5m@
CONST	SEGMENT
??_C@_0DJ@GHPNMNEC@Error?5setting?5fullscreen?5video?5m@ DB 'Error settin'
	DB	'g fullscreen video mode %d x %d %d bits - %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MBBIJNFJ@SDL?5TTF?5initialized?$AA@
CONST	SEGMENT
??_C@_0BE@MBBIJNFJ@SDL?5TTF?5initialized?$AA@ DB 'SDL TTF initialized', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LLIBEPGC@Error?5while?5initializing?5SDL?5TTF@
CONST	SEGMENT
??_C@_0CG@LLIBEPGC@Error?5while?5initializing?5SDL?5TTF@ DB 'Error while '
	DB	'initializing SDL TTF : %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DNBPCBJE@SDL?52?40?5initialzed?$AA@
CONST	SEGMENT
??_C@_0BD@DNBPCBJE@SDL?52?40?5initialzed?$AA@ DB 'SDL 2.0 initialzed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HCNBMJIE@SDL?5Initilization?5failed?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BM@HCNBMJIE@SDL?5Initilization?5failed?5?$CFs?$AA@ DB 'SDL Initili'
	DB	'zation failed %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DGBKPNED@TexLight?$AA@
CONST	SEGMENT
??_C@_08DGBKPNED@TexLight?$AA@ DB 'TexLight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NGMLKGCO@TexCoord?$AA@
CONST	SEGMENT
??_C@_08NGMLKGCO@TexCoord?$AA@ DB 'TexCoord', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GCJNLIKG@Position?$AA@
CONST	SEGMENT
??_C@_08GCJNLIKG@Position?$AA@ DB 'Position', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDOBBJNA@Color?$AA@
CONST	SEGMENT
??_C@_05PDOBBJNA@Color?$AA@ DB 'Color', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NDCMMGFF@?$CFs?5fps?3?5?$CF?42f?$AA@
CONST	SEGMENT
??_C@_0N@NDCMMGFF@?$CFs?5fps?3?5?$CF?42f?$AA@ DB '%s fps: %.2f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JPOOLMEG@Log?5created?6?$AA@
CONST	SEGMENT
??_C@_0N@JPOOLMEG@Log?5created?6?$AA@ DB 'Log created', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BIGBPAJK@Engine?5started?6?$AA@
CONST	SEGMENT
??_C@_0BA@BIGBPAJK@Engine?5started?6?$AA@ DB 'Engine started', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PJPFOJIA@?$CFs?5?$CF?42f?6?$AA@
CONST	SEGMENT
??_C@_08PJPFOJIA@?$CFs?5?$CF?42f?6?$AA@ DB '%s %.2f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@CDPPCMAP@?$AAC?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@CDPPCMAP@?$AAC?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@ DB 'C'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H
	DB	'l', 00H, 'o', 00H, 'g', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@PFAEBODD@?$AAO?$AAp?$AAe?$AAn?$AAi?$AAn?$AAg?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@PFAEBODD@?$AAO?$AAp?$AAe?$AAn?$AAi?$AAn?$AAg?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@ DB 'O'
	DB	00H, 'p', 00H, 'e', 00H, 'n', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 'l', 00H, 'o', 00H, 'g', 00H, ' ', 00H, 'f', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JFHIBJMD@mgear?4log?$AA@
CONST	SEGMENT
??_C@_09JFHIBJMD@mgear?4log?$AA@ DB 'mgear.log', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNLHKJD@a?$CL?$AA@
CONST	SEGMENT
??_C@_02DPNLHKJD@a?$CL?$AA@ DB 'a+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ILLOCNCO@bad?5palette?$AA@
CONST	SEGMENT
??_C@_0M@ILLOCNCO@bad?5palette?$AA@ DB 'bad palette', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DMAPJJO@bad?5format?$AA@
CONST	SEGMENT
??_C@_0L@DMAPJJO@bad?5format?$AA@ DB 'bad format', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DAEBACAB@bad?5masks?$AA@
CONST	SEGMENT
??_C@_09DAEBACAB@bad?5masks?$AA@ DB 'bad masks', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNJHIMGH@bad?5bpp?$AA@
CONST	SEGMENT
??_C@_07JNJHIMGH@bad?5bpp?$AA@ DB 'bad bpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MALOAKCI@invalid?$AA@
CONST	SEGMENT
??_C@_07MALOAKCI@invalid?$AA@ DB 'invalid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IMHMNOIB@BMP?5RLE?$AA@
CONST	SEGMENT
??_C@_07IMHMNOIB@BMP?5RLE?$AA@ DB 'BMP RLE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FEJFGKNE@monochrome?$AA@
CONST	SEGMENT
??_C@_0L@FEJFGKNE@monochrome?$AA@ DB 'monochrome', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IEJCHBDI@bad?5BMP?$AA@
CONST	SEGMENT
??_C@_07IEJCHBDI@bad?5BMP?$AA@ DB 'bad BMP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KHBIBJBG@unknown?5BMP?$AA@
CONST	SEGMENT
??_C@_0M@KHBIBJBG@unknown?5BMP?$AA@ DB 'unknown BMP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IANEBNLB@not?5BMP?$AA@
CONST	SEGMENT
??_C@_07IANEBNLB@not?5BMP?$AA@ DB 'not BMP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MLPECBNA@no?5IDAT?$AA@
CONST	SEGMENT
??_C@_07MLPECBNA@no?5IDAT?$AA@ DB 'no IDAT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MNNCNKEO@outofdata?$AA@
CONST	SEGMENT
??_C@_09MNNCNKEO@outofdata?$AA@ DB 'outofdata', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CKIELOEH@no?5PLTE?$AA@
CONST	SEGMENT
??_C@_07CKIELOEH@no?5PLTE?$AA@ DB 'no PLTE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha?$AA@
CONST	SEGMENT
??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha?$AA@ DB 'tRNS with alpha', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDLCCKCH@bad?5tRNS?5len?$AA@
CONST	SEGMENT
??_C@_0N@KDLCCKCH@bad?5tRNS?5len?$AA@ DB 'bad tRNS len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE?$AA@
CONST	SEGMENT
??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE?$AA@ DB 'tRNS before PLTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT?$AA@
CONST	SEGMENT
??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT?$AA@ DB 'tRNS after IDAT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JCPAJAKB@invalid?5PLTE?$AA@
CONST	SEGMENT
??_C@_0N@JCPAJAKB@invalid?5PLTE?$AA@ DB 'invalid PLTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JEAFOMAF@first?5not?5IHDR?$AA@
CONST	SEGMENT
??_C@_0P@JEAFOMAF@first?5not?5IHDR?$AA@ DB 'first not IHDR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FNFBHCOO@0?9pixel?5image?$AA@
CONST	SEGMENT
??_C@_0O@FNFBHCOO@0?9pixel?5image?$AA@ DB '0-pixel image', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JCGDPBAA@bad?5interlace?5method?$AA@
CONST	SEGMENT
??_C@_0BF@JCGDPBAA@bad?5interlace?5method?$AA@ DB 'bad interlace method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GHLIKKMD@bad?5filter?5method?$AA@
CONST	SEGMENT
??_C@_0BC@GHLIKKMD@bad?5filter?5method?$AA@ DB 'bad filter method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDMBDDFG@bad?5comp?5method?$AA@
CONST	SEGMENT
??_C@_0BA@MDMBDDFG@bad?5comp?5method?$AA@ DB 'bad comp method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBBNGCKB@bad?5ctype?$AA@
CONST	SEGMENT
??_C@_09MBBNGCKB@bad?5ctype?$AA@ DB 'bad ctype', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only?$AA@
CONST	SEGMENT
??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only?$AA@ DB '1/2/4/8/16-bit only'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@POJLKMKK@bad?5IHDR?5len?$AA@
CONST	SEGMENT
??_C@_0N@POJLKMKK@bad?5IHDR?5len?$AA@ DB 'bad IHDR len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KBHBNJOK@multiple?5IHDR?$AA@
CONST	SEGMENT
??_C@_0O@KBHBNJOK@multiple?5IHDR?$AA@ DB 'multiple IHDR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FBBCPGMN@invalid?5filter?$AA@
CONST	SEGMENT
??_C@_0P@FBBCPGMN@invalid?5filter?$AA@ DB 'invalid filter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BHMPBBMG@not?5enough?5pixels?$AA@
CONST	SEGMENT
??_C@_0BC@BHMPBBMG@not?5enough?5pixels?$AA@ DB 'not enough pixels', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DMDNBACF@bad?5png?5sig?$AA@
CONST	SEGMENT
??_C@_0M@DMDNBACF@bad?5png?5sig?$AA@ DB 'bad png sig', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MCNBDLPD@bad?5compression?$AA@
CONST	SEGMENT
??_C@_0BA@MCNBDLPD@bad?5compression?$AA@ DB 'bad compression', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DOGMHEBI@no?5preset?5dict?$AA@
CONST	SEGMENT
??_C@_0P@DOGMHEBI@no?5preset?5dict?$AA@ DB 'no preset dict', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OBKOPAFL@bad?5zlib?5header?$AA@
CONST	SEGMENT
??_C@_0BA@OBKOPAFL@bad?5zlib?5header?$AA@ DB 'bad zlib header', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PIPBCKIA@read?5past?5buffer?$AA@
CONST	SEGMENT
??_C@_0BB@PIPBCKIA@read?5past?5buffer?$AA@ DB 'read past buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IECDHMDI@zlib?5corrupt?$AA@
CONST	SEGMENT
??_C@_0N@IECDHMDI@zlib?5corrupt?$AA@ DB 'zlib corrupt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DIAPIMGJ@bad?5dist?$AA@
CONST	SEGMENT
??_C@_08DIAPIMGJ@bad?5dist?$AA@ DB 'bad dist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IBFIPFO@output?5buffer?5limit?$AA@
CONST	SEGMENT
??_C@_0BE@IBFIPFO@output?5buffer?5limit?$AA@ DB 'output buffer limit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDNKOBMC@bad?5codelengths?$AA@
CONST	SEGMENT
??_C@_0BA@MDNKOBMC@bad?5codelengths?$AA@ DB 'bad codelengths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EOHLEIKL@bad?5sizes?$AA@
CONST	SEGMENT
??_C@_09EOHLEIKL@bad?5sizes?$AA@ DB 'bad sizes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KBPNPPBJ@bad?5req_comp?$AA@
CONST	SEGMENT
??_C@_0N@KBPNPPBJ@bad?5req_comp?$AA@ DB 'bad req_comp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PNCLKCLJ@bad?5DNL?5height?$AA@
CONST	SEGMENT
??_C@_0P@PNCLKCLJ@bad?5DNL?5height?$AA@ DB 'bad DNL height', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EPMOIECP@bad?5DNL?5len?$AA@
CONST	SEGMENT
??_C@_0M@EPMOIECP@bad?5DNL?5len?$AA@ DB 'bad DNL len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IFCEAHIA@no?5SOF?$AA@
CONST	SEGMENT
??_C@_06IFCEAHIA@no?5SOF?$AA@ DB 'no SOF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CLMBLEP@no?5SOI?$AA@
CONST	SEGMENT
??_C@_06CLMBLEP@no?5SOI?$AA@ DB 'no SOI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OJDLMMBJ@too?5large?$AA@
CONST	SEGMENT
??_C@_09OJDLMMBJ@too?5large?$AA@ DB 'too large', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LJIHDFHI@bad?5TQ?$AA@
CONST	SEGMENT
??_C@_06LJIHDFHI@bad?5TQ?$AA@ DB 'bad TQ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPLLHCJG@bad?5V?$AA@
CONST	SEGMENT
??_C@_05MPLLHCJG@bad?5V?$AA@ DB 'bad V', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BLPKENEJ@bad?5H?$AA@
CONST	SEGMENT
??_C@_05BLPKENEJ@bad?5H?$AA@ DB 'bad H', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DAPHADHL@bad?5component?5count?$AA@
CONST	SEGMENT
??_C@_0BE@DAPHADHL@bad?5component?5count?$AA@ DB 'bad component count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BIDACDEF@0?5width?$AA@
CONST	SEGMENT
??_C@_07BIDACDEF@0?5width?$AA@ DB '0 width', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LNEGOMA@no?5header?5height?$AA@
CONST	SEGMENT
??_C@_0BB@LNEGOMA@no?5header?5height?$AA@ DB 'no header height', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCINMEBJ@only?58?9bit?$AA@
CONST	SEGMENT
??_C@_0L@BCINMEBJ@only?58?9bit?$AA@ DB 'only 8-bit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DOFMJEMP@bad?5SOF?5len?$AA@
CONST	SEGMENT
??_C@_0M@DOFMJEMP@bad?5SOF?5len?$AA@ DB 'bad SOF len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EEJOMGGP@bad?5SOS?$AA@
CONST	SEGMENT
??_C@_07EEJOMGGP@bad?5SOS?$AA@ DB 'bad SOS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JGMCBLGG@bad?5AC?5huff?$AA@
CONST	SEGMENT
??_C@_0M@JGMCBLGG@bad?5AC?5huff?$AA@ DB 'bad AC huff', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NOCCBFAC@bad?5DC?5huff?$AA@
CONST	SEGMENT
??_C@_0M@NOCCBFAC@bad?5DC?5huff?$AA@ DB 'bad DC huff', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GNEHAHOH@bad?5SOS?5len?$AA@
CONST	SEGMENT
??_C@_0M@GNEHAHOH@bad?5SOS?5len?$AA@ DB 'bad SOS len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count?$AA@
CONST	SEGMENT
??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count?$AA@ DB 'bad SOS component '
	DB	'count', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NNGPHMMK@unknown?5marker?$AA@
CONST	SEGMENT
??_C@_0P@NNGPHMMK@unknown?5marker?$AA@ DB 'unknown marker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EENLKPDI@bad?5APP?5len?$AA@
CONST	SEGMENT
??_C@_0M@EENLKPDI@bad?5APP?5len?$AA@ DB 'bad APP len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CICAFFCH@bad?5COM?5len?$AA@
CONST	SEGMENT
??_C@_0M@CICAFFCH@bad?5COM?5len?$AA@ DB 'bad COM len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JLGKOCGN@bad?5DHT?5header?$AA@
CONST	SEGMENT
??_C@_0P@JLGKOCGN@bad?5DHT?5header?$AA@ DB 'bad DHT header', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CNHKKDIM@bad?5DQT?5table?$AA@
CONST	SEGMENT
??_C@_0O@CNHKKDIM@bad?5DQT?5table?$AA@ DB 'bad DQT table', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BOFJCHAP@bad?5DQT?5type?$AA@
CONST	SEGMENT
??_C@_0N@BOFJCHAP@bad?5DQT?5type?$AA@ DB 'bad DQT type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LPHNODCG@bad?5DRI?5len?$AA@
CONST	SEGMENT
??_C@_0M@LPHNODCG@bad?5DRI?5len?$AA@ DB 'bad DRI len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KLNDOKJD@expected?5marker?$AA@
CONST	SEGMENT
??_C@_0BA@KLNDOKJD@expected?5marker?$AA@ DB 'expected marker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac?$AA@
CONST	SEGMENT
??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac?$AA@ DB 'can''t merge dc an'
	DB	'd ac', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IIMLINA@bad?5huffman?5code?$AA@
CONST	SEGMENT
??_C@_0BB@IIMLINA@bad?5huffman?5code?$AA@ DB 'bad huffman code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FOKGPEKG@bad?5code?5lengths?$AA@
CONST	SEGMENT
??_C@_0BB@FOKGPEKG@bad?5code?5lengths?$AA@ DB 'bad code lengths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JPDHFAGK@can?8t?5fopen?$AA@
CONST	SEGMENT
??_C@_0M@JPDHFAGK@can?8t?5fopen?$AA@ DB 'can''t fopen', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NOGIMCHF@outofmem?$AA@
CONST	SEGMENT
??_C@_08NOGIMCHF@outofmem?$AA@ DB 'outofmem', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CBEDEJPH@unknown?5image?5type?$AA@
CONST	SEGMENT
??_C@_0BD@CBEDEJPH@unknown?5image?5type?$AA@ DB 'unknown image type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CMF@PHINLJLD@?$CDversion?5130?6in?5vec2?5TexCoord2?$DL?6@
CONST	SEGMENT
??_C@_0CMF@PHINLJLD@?$CDversion?5130?6in?5vec2?5TexCoord2?$DL?6@ DB '#ver'
	DB	'sion 130', 0aH, 'in vec2 TexCoord2;', 0aH, 'in vec4 colore;', 0aH
	DB	'in vec2 TexLight2;', 0aH, 'out vec4 FColor;', 0aH, 'uniform s'
	DB	'ampler2D texu;', 0aH, 'uniform sampler2D texu2;', 0aH, 'unifo'
	DB	'rm sampler2D texu3;', 0aH, 'uniform float normal;', 0aH, 'voi'
	DB	'd main()', 0aH, '{', 0aH, 'if(normal == 0.0)', 0aH, 'FColor ='
	DB	' texture(texu, TexCoord2) * colore;', 0aH, 'else', 0aH, 'if(n'
	DB	'ormal == 1.0)', 0aH, '{', 0aH, 'vec4 Lightmap = texture(texu2'
	DB	', TexLight2) * 4.0;', 0aH, 'vec3 L = normalize(Lightmap.rgb);'
	DB	0aH, 'vec3 N = normalize(texture(texu3, TexCoord2).rgb * 2.0 -'
	DB	' 1.0);', 0aH, 'FColor = texture(texu, TexCoord2) * colore * ('
	DB	'Lightmap * max(dot(N, L), 0.0));', 0aH, '}', 0aH, 'else', 0aH
	DB	'if(normal == 2.0)', 0aH, '{', 0aH, 'vec4 Lightmap = texture(t'
	DB	'exu2, TexLight2) * 4.0;', 0aH, 'FColor = texture(texu, TexCoo'
	DB	'rd2) * colore * Lightmap;', 0aH, '}', 0aH, 'else', 0aH, 'if(n'
	DB	'ormal == 3.0)', 0aH, 'FColor = texture(texu, TexCoord2) * col'
	DB	'ore;', 0aH, '}', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAB@HLALIPKD@?$CDversion?5130?6uniform?5sampler2D?5t@
CONST	SEGMENT
??_C@_0BAB@HLALIPKD@?$CDversion?5130?6uniform?5sampler2D?5t@ DB '#version'
	DB	' 130', 0aH, 'uniform sampler2D texu;', 0aH, 'uniform sampler2'
	DB	'D texu2;', 0aH, 'in vec2 TexCoord2;', 0aH, 'in vec4 colore;', 0aH
	DB	'out vec4 FColor;', 0aH, 'void main()', 0aH, '{', 0aH, 'vec4 D'
	DB	'iffuse = texture(texu, TexCoord2);', 0aH, 'vec4 Alpha = textu'
	DB	're(texu2, TexCoord2);', 0aH, 'FColor = vec4(Alpha.rgb * Diffu'
	DB	'se.rgb,1.0);', 0aH, '};', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BFE@LHCNEGLH@?$CDversion?5130?6uniform?5sampler2D?5t@
CONST	SEGMENT
??_C@_0BFE@LHCNEGLH@?$CDversion?5130?6uniform?5sampler2D?5t@ DB '#version'
	DB	' 130', 0aH, 'uniform sampler2D texu;', 0aH, 'uniform sampler2'
	DB	'D texu2;', 0aH, 'in vec2 TexCoord2;', 0aH, 'in vec4 colore;', 0aH
	DB	'out vec4 FColor;', 0aH, 'void main()', 0aH, '{', 0aH, 'vec4 D'
	DB	'iffuse = texture(texu, TexCoord2) * colore;', 0aH, 'vec4 Bckg'
	DB	' = texture(texu2, TexCoord2);', 0aH, 'if(Diffuse.a == 1.0)', 0aH
	DB	'discard;', 0aH, 'else', 0aH, '{', 0aH, 'FColor = vec4((Diffus'
	DB	'e.a * Diffuse.rgb) + ((1.0 - Diffuse.a) * Bckg.rgb), 1.0);', 0aH
	DB	'}', 0aH, '};', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0NB@HNGLJMAI@?$CDversion?5130?6uniform?5sampler2D?5t@
CONST	SEGMENT
??_C@_0NB@HNGLJMAI@?$CDversion?5130?6uniform?5sampler2D?5t@ DB '#version '
	DB	'130', 0aH, 'uniform sampler2D texu;', 0aH, 'in vec2 TexCoord2'
	DB	';', 0aH, 'in vec4 colore;', 0aH, 'out vec4 FColor;', 0aH, 'vo'
	DB	'id main()', 0aH, '{', 0aH, 'vec4 Diffuse = texture(texu, TexC'
	DB	'oord2) * colore;', 0aH, 'if(Diffuse.a < 1.0)', 0aH, 'discard;'
	DB	0aH, 'else', 0aH, 'FColor = Diffuse;', 0aH, '};', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BDP@HLHOENOH@?$CDversion?5130?6uniform?5sampler2D?5t@
CONST	SEGMENT
??_C@_0BDP@HLHOENOH@?$CDversion?5130?6uniform?5sampler2D?5t@ DB '#version'
	DB	' 130', 0aH, 'uniform sampler2D texu;', 0aH, 'uniform int ligh'
	DB	't_type;in vec2 TexCoord2;', 0aH, 'in vec4 colore;', 0aH, 'out'
	DB	' vec4 FColor;', 0aH, 'void main()', 0aH, '{', 0aH, 'if( light'
	DB	'_type == 0)', 0aH, 'FColor = texture(texu, TexCoord2);', 0aH, 'e'
	DB	'lse', 0aH, 'if( light_type == 1)', 0aH, 'FColor = texture(tex'
	DB	'u, TexCoord2) * 2.0;', 0aH, 'else', 0aH, 'if( light_type == 2'
	DB	')', 0aH, 'FColor = texture(texu, TexCoord2) * 4.0;', 0aH, '};'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0PM@NPFOCGLD@?$CDversion?5130?6in?5vec3?5Position?$DL?6i@
CONST	SEGMENT
??_C@_0PM@NPFOCGLD@?$CDversion?5130?6in?5vec3?5Position?$DL?6i@ DB '#vers'
	DB	'ion 130', 0aH, 'in vec3 Position;', 0aH, 'in vec2 TexCoord;', 0aH
	DB	'in vec4 Color;', 0aH, 'in vec2 TexLight;', 0aH, 'out vec2 Tex'
	DB	'Coord2;', 0aH, 'out vec4 colore;', 0aH, 'out vec2 TexLight2;', 0aH
	DB	'void main()', 0aH, '{', 0aH, 'gl_Position = vec4(Position, 1.'
	DB	'0);', 0aH, 'TexCoord2 = TexCoord;', 0aH, 'colore = Color;', 0aH
	DB	'TexLight2 = TexLight;', 0aH, '};', 0aH, 00H	; `string'
CONST	ENDS
PUBLIC	_Finish
PUBLIC	_Renderer
PUBLIC	_DrawSys
PUBLIC	_DrawString2UI
PUBLIC	_DrawStringUI
PUBLIC	_DrawStringUIv
PUBLIC	_DrawString2
PUBLIC	_DrawLine
PUBLIC	_DrawUI
PUBLIC	_BASICBKD
PUBLIC	_InitMGG
PUBLIC	_LoadMGG
PUBLIC	_CheckMGGInSystem
PUBLIC	_WindowEvents
PUBLIC	_RestartVideo
PUBLIC	_OpenFont
PUBLIC	_Init
PUBLIC	_Quit
PUBLIC	_mSin
PUBLIC	_mCos
PUBLIC	_WTSf
PUBLIC	_FPSCounter
PUBLIC	@SetTimerM@8
PUBLIC	_CreateLog
PUBLIC	_LogIn
PUBLIC	__real@00000000
PUBLIC	__real@0c780258
PUBLIC	__real@296b8c59
PUBLIC	__real@358637bd
PUBLIC	__real@38000000
PUBLIC	__real@38800000
PUBLIC	__real@39000000
PUBLIC	__real@3910f359
PUBLIC	__real@39638e39
PUBLIC	__real@3a000000
PUBLIC	__real@3a800000
PUBLIC	__real@3a81c79e
PUBLIC	__real@3b473a13
PUBLIC	__real@3b808081
PUBLIC	__real@3ba3d70a
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c46b2e5
PUBLIC	__real@3c98e4a6
PUBLIC	__real@3caa6a57
PUBLIC	__real@3cdb0412
PUBLIC	__real@3d1c6f36
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3dcccccd
PUBLIC	__real@3ddb63b9
PUBLIC	__real@3df1f042
PUBLIC	__real@3e0d6486
PUBLIC	__real@3e800000
PUBLIC	__real@3eb33333
PUBLIC	__real@3ec9ec7b
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f801c6e
PUBLIC	__real@3f804e2f
PUBLIC	__real@3f847ae140000000
PUBLIC	__real@3fc00000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@400921fb53c8d4f1
PUBLIC	__real@40400000
PUBLIC	__real@40490fdb
PUBLIC	__real@404ca5dc1af05a77
PUBLIC	__real@4066800000000000
PUBLIC	__real@40800000
PUBLIC	__real@40c90fdb
PUBLIC	__real@41200000
PUBLIC	__real@41400000
PUBLIC	__real@41500000
PUBLIC	__real@41c80000
PUBLIC	__real@41f00000
PUBLIC	__real@42340000
PUBLIC	__real@42c80000
PUBLIC	__real@42fe0000
PUBLIC	__real@437f0000
PUBLIC	__real@43800000
PUBLIC	__real@43b40ccd
PUBLIC	__real@447a0000
PUBLIC	__real@46100000
PUBLIC	__real@46fffe00
PUBLIC	__real@477fff00
PUBLIC	__real@4f000000
PUBLIC	__real@4f800000
PUBLIC	__real@bf800000
PUBLIC	__real@c2fe0000
PUBLIC	__real@c6fffe00
PUBLIC	__real@cf000000
PUBLIC	__xmm@00000000000000000000000040000000
PUBLIC	__xmm@0000000000000000c000000000000000
PUBLIC	__xmm@000000003f8000000000000000000000
PUBLIC	__xmm@00000000461000000000000000000000
PUBLIC	__xmm@00000000bf8000000000000000000000
PUBLIC	__xmm@00000003000000020000000100000000
PUBLIC	__xmm@00000008000000080000000800000008
PUBLIC	__xmm@00000200000002000000020000000200
PUBLIC	__xmm@00080008000800080008000800080008
PUBLIC	__xmm@00ff00ff00ff00ff00ff00ff00ff00ff
PUBLIC	__xmm@01010000010100000101000001010000
PUBLIC	__xmm@08a914e808a914e808a914e808a914e8
PUBLIC	__xmm@11c8e09e11c8e09e11c8e09e11c8e09e
PUBLIC	__xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
PUBLIC	__xmm@12d0046b12d0046b12d0046b12d0046b
PUBLIC	__xmm@166f166f166f166f166f166f166f166f
PUBLIC	__xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
PUBLIC	__xmm@3f80000000000000000000003f800000
PUBLIC	__xmm@3f800000000000003f8000003f800000
PUBLIC	__xmm@3f800000000000003f800000bf800000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@46100000468000000000000000000000
PUBLIC	__xmm@46800000000000000000000000000000
PUBLIC	__xmm@7fffffff7fffffff7fffffff7fffffff
PUBLIC	__xmm@80000000800000008000000080000000
PUBLIC	__xmm@80808080808080808080808080808080
PUBLIC	__xmm@e09ee565e09ee565e09ee565e09ee565
PUBLIC	__xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
PUBLIC	__xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
PUBLIC	__xmm@f493f493f493f493f493f493f493f493
PUBLIC	__xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
PUBLIC	__xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
EXTRN	__CIatan2:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftoui3:PROC
EXTRN	__libm_sse2_cos_precise:PROC
EXTRN	__libm_sse2_sin_precise:PROC
EXTRN	__libm_sse2_tan_precise:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
CONST	SEGMENT
__xmm@fa7efa7efa7efa7efa7efa7efa7efa7e DB '~', 0faH, '~', 0faH, '~', 0faH
	DB	'~', 0faH, '~', 0faH, '~', 0faH, '~', 0faH, '~', 0faH
CONST	ENDS
;	COMDAT __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
CONST	SEGMENT
__xmm@f9c31a9df9c31a9df9c31a9df9c31a9d DB 09dH, 01aH, 0c3H, 0f9H, 09dH, 01aH
	DB	0c3H, 0f9H, 09dH, 01aH, 0c3H, 0f9H, 09dH, 01aH, 0c3H, 0f9H
CONST	ENDS
;	COMDAT __xmm@f493f493f493f493f493f493f493f493
CONST	SEGMENT
__xmm@f493f493f493f493f493f493f493f493 DB 093H, 0f4H, 093H, 0f4H, 093H, 0f4H
	DB	093H, 0f4H, 093H, 0f4H, 093H, 0f4H, 093H, 0f4H, 093H, 0f4H
CONST	ENDS
;	COMDAT __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
CONST	SEGMENT
__xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9 DB 0a9H, 08H, 01aH, 0ebH, 0a9H, 08H
	DB	01aH, 0ebH, 0a9H, 08H, 01aH, 0ebH, 0a9H, 08H, 01aH, 0ebH
CONST	ENDS
;	COMDAT __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
CONST	SEGMENT
__xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0 DB 0d0H, 012H, 0cfH, 0e9H, 0d0H, 012H
	DB	0cfH, 0e9H, 0d0H, 012H, 0cfH, 0e9H, 0d0H, 012H, 0cfH, 0e9H
CONST	ENDS
;	COMDAT __xmm@e09ee565e09ee565e09ee565e09ee565
CONST	SEGMENT
__xmm@e09ee565e09ee565e09ee565e09ee565 DB 'e', 0e5H, 09eH, 0e0H, 'e', 0e5H
	DB	09eH, 0e0H, 'e', 0e5H, 09eH, 0e0H, 'e', 0e5H, 09eH, 0e0H
CONST	ENDS
;	COMDAT __xmm@80808080808080808080808080808080
CONST	SEGMENT
__xmm@80808080808080808080808080808080 DB 080H, 080H, 080H, 080H, 080H, 080H
	DB	080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffff7fffffff7fffffff7fffffff
CONST	SEGMENT
__xmm@7fffffff7fffffff7fffffff7fffffff DB 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@46800000000000000000000000000000
CONST	SEGMENT
__xmm@46800000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, 'F'
CONST	ENDS
;	COMDAT __xmm@46100000468000000000000000000000
CONST	SEGMENT
__xmm@46100000468000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 080H, 'F', 00H, 00H, 010H, 'F'
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __xmm@3f800000000000003f800000bf800000
CONST	SEGMENT
__xmm@3f800000000000003f800000bf800000 DB 00H, 00H, 080H, 0bfH, 00H, 00H, 080H
	DB	'?', 00H, 00H, 00H, 00H, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f800000000000003f8000003f800000
CONST	SEGMENT
__xmm@3f800000000000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 00H, 00H, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f80000000000000000000003f800000
CONST	SEGMENT
__xmm@3f80000000000000000000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
CONST	SEGMENT
__xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a DB 'Z', 01cH, 'Z', 01cH, 'Z', 01cH
	DB	'Z', 01cH, 'Z', 01cH, 'Z', 01cH, 'Z', 01cH, 'Z', 01cH
CONST	ENDS
;	COMDAT __xmm@166f166f166f166f166f166f166f166f
CONST	SEGMENT
__xmm@166f166f166f166f166f166f166f166f DB 'o', 016H, 'o', 016H, 'o', 016H
	DB	'o', 016H, 'o', 016H, 'o', 016H, 'o', 016H, 'o', 016H
CONST	ENDS
;	COMDAT __xmm@12d0046b12d0046b12d0046b12d0046b
CONST	SEGMENT
__xmm@12d0046b12d0046b12d0046b12d0046b DB 'k', 04H, 0d0H, 012H, 'k', 04H, 0d0H
	DB	012H, 'k', 04H, 0d0H, 012H, 'k', 04H, 0d0H, 012H
CONST	ENDS
;	COMDAT __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
CONST	SEGMENT
__xmm@11c8f9c311c8f9c311c8f9c311c8f9c3 DB 0c3H, 0f9H, 0c8H, 011H, 0c3H, 0f9H
	DB	0c8H, 011H, 0c3H, 0f9H, 0c8H, 011H, 0c3H, 0f9H, 0c8H, 011H
CONST	ENDS
;	COMDAT __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
CONST	SEGMENT
__xmm@11c8e09e11c8e09e11c8e09e11c8e09e DB 09eH, 0e0H, 0c8H, 011H, 09eH, 0e0H
	DB	0c8H, 011H, 09eH, 0e0H, 0c8H, 011H, 09eH, 0e0H, 0c8H, 011H
CONST	ENDS
;	COMDAT __xmm@08a914e808a914e808a914e808a914e8
CONST	SEGMENT
__xmm@08a914e808a914e808a914e808a914e8 DB 0e8H, 014H, 0a9H, 08H, 0e8H, 014H
	DB	0a9H, 08H, 0e8H, 014H, 0a9H, 08H, 0e8H, 014H, 0a9H, 08H
CONST	ENDS
;	COMDAT __xmm@01010000010100000101000001010000
CONST	SEGMENT
__xmm@01010000010100000101000001010000 DB 00H, 00H, 01H, 01H, 00H, 00H, 01H
	DB	01H, 00H, 00H, 01H, 01H, 00H, 00H, 01H, 01H
CONST	ENDS
;	COMDAT __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
CONST	SEGMENT
__xmm@00ff00ff00ff00ff00ff00ff00ff00ff DB 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
	DB	0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
CONST	ENDS
;	COMDAT __xmm@00080008000800080008000800080008
CONST	SEGMENT
__xmm@00080008000800080008000800080008 DB 08H, 00H, 08H, 00H, 08H, 00H, 08H
	DB	00H, 08H, 00H, 08H, 00H, 08H, 00H, 08H, 00H
CONST	ENDS
;	COMDAT __xmm@00000200000002000000020000000200
CONST	SEGMENT
__xmm@00000200000002000000020000000200 DB 00H, 02H, 00H, 00H, 00H, 02H, 00H
	DB	00H, 00H, 02H, 00H, 00H, 00H, 02H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000008000000080000000800000008
CONST	SEGMENT
__xmm@00000008000000080000000800000008 DB 08H, 00H, 00H, 00H, 08H, 00H, 00H
	DB	00H, 08H, 00H, 00H, 00H, 08H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000003000000020000000100000000
CONST	SEGMENT
__xmm@00000003000000020000000100000000 DB 00H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 02H, 00H, 00H, 00H, 03H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000bf8000000000000000000000
CONST	SEGMENT
__xmm@00000000bf8000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 080H, 0bfH, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000461000000000000000000000
CONST	SEGMENT
__xmm@00000000461000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 010H, 'F', 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@000000003f8000000000000000000000
CONST	SEGMENT
__xmm@000000003f8000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 080H, '?', 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000000000000c000000000000000
CONST	SEGMENT
__xmm@0000000000000000c000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	0c0H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000000000000040000000
CONST	SEGMENT
__xmm@00000000000000000000000040000000 DB 00H, 00H, 00H, '@', 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@cf000000
CONST	SEGMENT
__real@cf000000 DD 0cf000000r			; -2.14748e+009
CONST	ENDS
;	COMDAT __real@c6fffe00
CONST	SEGMENT
__real@c6fffe00 DD 0c6fffe00r			; -32767
CONST	ENDS
;	COMDAT __real@c2fe0000
CONST	SEGMENT
__real@c2fe0000 DD 0c2fe0000r			; -127
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@4f800000
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
CONST	ENDS
;	COMDAT __real@4f000000
CONST	SEGMENT
__real@4f000000 DD 04f000000r			; 2.14748e+009
CONST	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@46100000
CONST	SEGMENT
__real@46100000 DD 046100000r			; 9216
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43b40ccd
CONST	SEGMENT
__real@43b40ccd DD 043b40ccdr			; 360.1
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42fe0000
CONST	SEGMENT
__real@42fe0000 DD 042fe0000r			; 127
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42340000
CONST	SEGMENT
__real@42340000 DD 042340000r			; 45
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@41500000
CONST	SEGMENT
__real@41500000 DD 041500000r			; 13
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
CONST	ENDS
;	COMDAT __real@404ca5dc1af05a77
CONST	SEGMENT
__real@404ca5dc1af05a77 DQ 0404ca5dc1af05a77r	; 57.2958
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@400921fb53c8d4f1
CONST	SEGMENT
__real@400921fb53c8d4f1 DQ 0400921fb53c8d4f1r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f847ae140000000
CONST	SEGMENT
__real@3f847ae140000000 DQ 03f847ae140000000r	; 0.01
CONST	ENDS
;	COMDAT __real@3f804e2f
CONST	SEGMENT
__real@3f804e2f DD 03f804e2fr			; 1.00239
CONST	ENDS
;	COMDAT __real@3f801c6e
CONST	SEGMENT
__real@3f801c6e DD 03f801c6er			; 1.00087
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ec9ec7b
CONST	SEGMENT
__real@3ec9ec7b DD 03ec9ec7br			; 0.394382
CONST	ENDS
;	COMDAT __real@3eb33333
CONST	SEGMENT
__real@3eb33333 DD 03eb33333r			; 0.35
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e0d6486
CONST	SEGMENT
__real@3e0d6486 DD 03e0d6486r			; 0.138079
CONST	ENDS
;	COMDAT __real@3df1f042
CONST	SEGMENT
__real@3df1f042 DD 03df1f042r			; 0.118134
CONST	ENDS
;	COMDAT __real@3ddb63b9
CONST	SEGMENT
__real@3ddb63b9 DD 03ddb63b9r			; 0.107124
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3d1c6f36
CONST	SEGMENT
__real@3d1c6f36 DD 03d1c6f36r			; 0.038192
CONST	ENDS
;	COMDAT __real@3cdb0412
CONST	SEGMENT
__real@3cdb0412 DD 03cdb0412r			; 0.0267353
CONST	ENDS
;	COMDAT __real@3caa6a57
CONST	SEGMENT
__real@3caa6a57 DD 03caa6a57r			; 0.0208027
CONST	ENDS
;	COMDAT __real@3c98e4a6
CONST	SEGMENT
__real@3c98e4a6 DD 03c98e4a6r			; 0.0186637
CONST	ENDS
;	COMDAT __real@3c46b2e5
CONST	SEGMENT
__real@3c46b2e5 DD 03c46b2e5r			; 0.0121276
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3ba3d70a
CONST	SEGMENT
__real@3ba3d70a DD 03ba3d70ar			; 0.005
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT __real@3b473a13
CONST	SEGMENT
__real@3b473a13 DD 03b473a13r			; 0.00303996
CONST	ENDS
;	COMDAT __real@3a81c79e
CONST	SEGMENT
__real@3a81c79e DD 03a81c79er			; 0.000990141
CONST	ENDS
;	COMDAT __real@3a800000
CONST	SEGMENT
__real@3a800000 DD 03a800000r			; 0.000976563
CONST	ENDS
;	COMDAT __real@3a000000
CONST	SEGMENT
__real@3a000000 DD 03a000000r			; 0.000488281
CONST	ENDS
;	COMDAT __real@39638e39
CONST	SEGMENT
__real@39638e39 DD 039638e39r			; 0.000217014
CONST	ENDS
;	COMDAT __real@3910f359
CONST	SEGMENT
__real@3910f359 DD 03910f359r			; 0.000138236
CONST	ENDS
;	COMDAT __real@39000000
CONST	SEGMENT
__real@39000000 DD 039000000r			; 0.00012207
CONST	ENDS
;	COMDAT __real@38800000
CONST	SEGMENT
__real@38800000 DD 038800000r			; 6.10352e-005
CONST	ENDS
;	COMDAT __real@38000000
CONST	SEGMENT
__real@38000000 DD 038000000r			; 3.05176e-005
CONST	ENDS
;	COMDAT __real@358637bd
CONST	SEGMENT
__real@358637bd DD 0358637bdr			; 1e-006
CONST	ENDS
;	COMDAT __real@296b8c59
CONST	SEGMENT
__real@296b8c59 DD 0296b8c59r			; 5.23022e-014
CONST	ENDS
;	COMDAT __real@0c780258
CONST	SEGMENT
__real@0c780258 DD 00c780258r			; 1.91059e-031
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__stdio_read
_TEXT	SEGMENT
_user$ = 8						; size = 4
_data$ = 12						; size = 4
_size$ = 16						; size = 4
_stbi__stdio_read PROC					; COMDAT

; 725  : {

	push	ebp
	mov	ebp, esp

; 726  :    return (int) fread(data,1,size,(FILE*) user);

	push	DWORD PTR _user$[ebp]
	push	DWORD PTR _size$[ebp]
	push	1
	push	DWORD PTR _data$[ebp]
	call	_fread
	add	esp, 16					; 00000010H

; 727  : }

	pop	ebp
	ret	0
_stbi__stdio_read ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__stdio_skip
_TEXT	SEGMENT
_user$ = 8						; size = 4
_n$ = 12						; size = 4
_stbi__stdio_skip PROC					; COMDAT

; 730  : {

	push	ebp
	mov	ebp, esp

; 731  :    fseek((FILE*) user, n, SEEK_CUR);

	push	1
	push	DWORD PTR _n$[ebp]
	push	DWORD PTR _user$[ebp]
	call	_fseek
	add	esp, 12					; 0000000cH

; 732  : }

	pop	ebp
	ret	0
_stbi__stdio_skip ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__stdio_eof
_TEXT	SEGMENT
_user$ = 8						; size = 4
_stbi__stdio_eof PROC					; COMDAT

; 735  : {

	push	ebp
	mov	ebp, esp

; 737  : }

	pop	ebp

; 736  :    return feof((FILE*) user);

	jmp	_feof
_stbi__stdio_eof ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__clamp
_TEXT	SEGMENT
_stbi__clamp PROC					; COMDAT
; _x$ = ecx

; 2106 :    // trick to use a single test to catch both cases
; 2107 :    if ((unsigned int) x > 255) {

	cmp	ecx, 255				; 000000ffH
	jbe	SHORT $LN1@stbi__clam

; 2108 :       if (x < 0) return 0;

	test	ecx, ecx
	jns	SHORT $LN2@stbi__clam
	xor	al, al

; 2112 : }

	ret	0
$LN2@stbi__clam:

; 2109 :       if (x > 255) return 255;

	cmp	ecx, 255				; 000000ffH
	jle	SHORT $LN1@stbi__clam
	or	al, 255					; 000000ffH

; 2112 : }

	ret	0
$LN1@stbi__clam:

; 2110 :    }
; 2111 :    return (stbi_uc) x;

	mov	al, cl

; 2112 : }

	ret	0
_stbi__clamp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__idct_block
_TEXT	SEGMENT
_out_stride$GSCopy$1$ = -312				; size = 4
_t0$3$ = -308						; size = 4
_x$1$ = -304						; size = 4
_x1$1$ = -304						; size = 4
_x$1$ = -300						; size = 4
_t2$3$ = -300						; size = 4
_x$1$ = -296						; size = 4
_x0$1$ = -296						; size = 4
tv1383 = -292						; size = 4
tv1379 = -292						; size = 4
_out$GSCopy$1$ = -288					; size = 4
_p4$1$ = -288						; size = 4
_t3$3$ = -288						; size = 4
_t2$3$ = -284						; size = 4
_t3$3$ = -284						; size = 4
_t3$2$ = -284						; size = 4
_x2$1$ = -280						; size = 4
tv1377 = -280						; size = 4
_t1$3$ = -276						; size = 4
_p2$3$ = -276						; size = 4
_x3$1$ = -276						; size = 4
_x$1$ = -272						; size = 4
tv1382 = -272						; size = 4
tv1381 = -268						; size = 4
tv1380 = -268						; size = 4
_x$1$ = -264						; size = 4
_p4$1$ = -264						; size = 4
_t1$3$ = -264						; size = 4
tv1378 = -264						; size = 4
_val$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_out_stride$ = 12					; size = 4
_data$ = 16						; size = 4
_stbi__idct_block PROC					; COMDAT

; 2156 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _out$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _data$[ebp]
	push	esi
	mov	DWORD PTR _out$GSCopy$1$[ebp], eax
	lea	esi, DWORD PTR _val$[ebp+32]
	mov	eax, DWORD PTR _out_stride$[ebp]
	add	ebx, 96					; 00000060H
	push	edi
	mov	DWORD PTR _out_stride$GSCopy$1$[ebp], eax
	mov	DWORD PTR tv1382[ebp], esi
	mov	DWORD PTR tv1381[ebp], ebx
	mov	DWORD PTR tv1383[ebp], 8
	npad	6
$LL8@stbi__idct:

; 2163 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2164 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2165 :            && d[40]==0 && d[48]==0 && d[56]==0) {

	movzx	eax, WORD PTR [ebx-80]
	mov	DWORD PTR tv1378[ebp], eax
	test	ax, ax
	jne	SHORT $LN5@stbi__idct
	cmp	WORD PTR [ebx-64], ax
	jne	SHORT $LN5@stbi__idct
	cmp	WORD PTR [ebx-48], ax
	jne	SHORT $LN5@stbi__idct
	cmp	WORD PTR [ebx-32], ax
	jne	SHORT $LN5@stbi__idct
	cmp	WORD PTR [ebx-16], ax
	jne	SHORT $LN5@stbi__idct
	cmp	WORD PTR [ebx], ax
	jne	SHORT $LN5@stbi__idct
	cmp	WORD PTR [ebx+16], ax
	jne	SHORT $LN5@stbi__idct

; 2166 :          //    no shortcut                 0     seconds
; 2167 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2168 :          //    all separate               -0.047 seconds
; 2169 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2170 :          int dcterm = d[0] << 2;

	movsx	eax, WORD PTR [ebx-96]
	shl	eax, 2

; 2171 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;

	mov	DWORD PTR [esi+192], eax
	mov	DWORD PTR [esi+160], eax
	mov	DWORD PTR [esi+128], eax
	mov	DWORD PTR [esi+96], eax
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi-32], eax

; 2172 :       } else {

	jmp	$LN59@stbi__idct
$LN5@stbi__idct:

; 2173 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])

	movsx	esi, WORD PTR [ebx-64]
	movsx	ecx, WORD PTR [ebx]
	lea	eax, DWORD PTR [ecx+esi]
	imul	edx, eax, 2217
	imul	eax, ecx, 7567
	imul	ecx, esi, 3135
	mov	edi, edx
	sub	edi, eax
	movsx	eax, WORD PTR [ebx-32]
	add	ecx, edx
	movsx	edx, WORD PTR [ebx-96]
	lea	ebx, DWORD PTR [eax+edx]
	sub	edx, eax
	shl	ebx, 12					; 0000000cH
	shl	edx, 12					; 0000000cH
	lea	eax, DWORD PTR [ebx+ecx]
	sub	ebx, ecx
	mov	ecx, DWORD PTR tv1378[ebp]
	mov	DWORD PTR _x0$1$[ebp], eax
	lea	eax, DWORD PTR [edx+edi]
	mov	DWORD PTR _x1$1$[ebp], eax
	sub	edx, edi
	mov	eax, DWORD PTR tv1381[ebp]
	mov	DWORD PTR _x2$1$[ebp], edx
	movsx	esi, cx
	mov	DWORD PTR _x3$1$[ebp], ebx
	movsx	edi, WORD PTR [eax+16]
	movsx	edx, WORD PTR [eax-16]
	movsx	eax, WORD PTR [eax-48]
	add	edx, esi
	mov	DWORD PTR _t3$2$[ebp], esi
	mov	DWORD PTR _p4$1$[ebp], edx

; 2174 :          // constants scaled things up by 1<<12; let's bring them back
; 2175 :          // down, but keep 2 extra bits of precision
; 2176 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;

	add	DWORD PTR _x2$1$[ebp], 512		; 00000200H
	lea	ecx, DWORD PTR [edi+eax]
	add	DWORD PTR _x3$1$[ebp], 512		; 00000200H
	lea	eax, DWORD PTR [edx+ecx]
	imul	ecx, ecx, -8034
	imul	ebx, eax, 4816
	lea	eax, DWORD PTR [edi+esi]
	mov	esi, DWORD PTR tv1381[ebp]
	imul	eax, eax, 3685
	movsx	edx, WORD PTR [esi-16]
	mov	edi, ebx
	sub	edi, eax
	movsx	eax, WORD PTR [esi-48]
	add	eax, edx
	imul	edx, DWORD PTR _t3$2$[ebp], 6149
	imul	eax, eax, 10497
	sub	ebx, eax
	imul	eax, DWORD PTR _p4$1$[ebp], -1597
	add	edx, eax
	add	edx, edi
	mov	DWORD PTR _t3$3$[ebp], edx
	mov	edx, esi
	movsx	esi, WORD PTR [edx-48]
	imul	esi, esi, 12586
	add	esi, ecx
	add	esi, ebx
	mov	DWORD PTR _t2$3$[ebp], esi
	movsx	esi, WORD PTR [edx-16]
	imul	esi, esi, 8410
	add	esi, eax
	mov	DWORD PTR _t1$3$[ebp], esi
	add	DWORD PTR _t1$3$[ebp], ebx
	mov	ebx, edx

; 2177 :          v[ 0] = (x0+t3) >> 10;

	mov	edx, DWORD PTR _t3$3$[ebp]
	mov	esi, DWORD PTR tv1382[ebp]
	movsx	eax, WORD PTR [ebx+16]
	imul	ebx, eax, 1223
	add	ebx, edi
	mov	edi, DWORD PTR _x1$1$[ebp]
	add	ebx, ecx
	add	edi, 512				; 00000200H
	mov	ecx, DWORD PTR _x0$1$[ebp]
	add	ecx, 512				; 00000200H
	lea	eax, DWORD PTR [ecx+edx]

; 2178 :          v[56] = (x0-t3) >> 10;

	sub	ecx, edx
	sar	eax, 10					; 0000000aH
	mov	edx, esi
	mov	DWORD PTR [esi-32], eax
	sar	ecx, 10					; 0000000aH

; 2179 :          v[ 8] = (x1+t2) >> 10;

	mov	esi, DWORD PTR _t2$3$[ebp]
	mov	DWORD PTR [edx+192], ecx

; 2180 :          v[48] = (x1-t2) >> 10;
; 2181 :          v[16] = (x2+t1) >> 10;

	mov	ecx, DWORD PTR _t1$3$[ebp]
	lea	eax, DWORD PTR [edi+esi]
	sub	edi, esi
	sar	eax, 10					; 0000000aH
	mov	esi, edx
	mov	DWORD PTR [edx], eax
	mov	edx, DWORD PTR _x2$1$[ebp]
	sar	edi, 10					; 0000000aH
	mov	DWORD PTR [esi+160], edi
	lea	eax, DWORD PTR [edx+ecx]

; 2182 :          v[40] = (x2-t1) >> 10;

	sub	edx, ecx

; 2183 :          v[24] = (x3+t0) >> 10;

	mov	ecx, DWORD PTR _x3$1$[ebp]
	sar	eax, 10					; 0000000aH
	mov	DWORD PTR [esi+32], eax
	sar	edx, 10					; 0000000aH
	lea	eax, DWORD PTR [ecx+ebx]
	mov	DWORD PTR [esi+128], edx

; 2184 :          v[32] = (x3-t0) >> 10;

	sub	ecx, ebx
	sar	eax, 10					; 0000000aH
	mov	ebx, DWORD PTR tv1381[ebp]
	sar	ecx, 10					; 0000000aH
	mov	DWORD PTR [esi+96], ecx
$LN59@stbi__idct:

; 2157 :    int i,val[64],*v=val;
; 2158 :    stbi_uc *o;
; 2159 :    short *d = data;
; 2160 : 
; 2161 :    // columns
; 2162 :    for (i=0; i < 8; ++i,++d, ++v) {

	mov	DWORD PTR [esi+64], eax
	add	ebx, 2
	add	esi, 4
	mov	DWORD PTR tv1381[ebp], ebx
	dec	DWORD PTR tv1383[ebp]
	mov	DWORD PTR tv1382[ebp], esi
	jne	$LL8@stbi__idct

; 2185 :       }
; 2186 :    }
; 2187 : 
; 2188 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {

	mov	eax, DWORD PTR _out$GSCopy$1$[ebp]
	lea	ebx, DWORD PTR _val$[ebp+24]
	inc	eax
	mov	DWORD PTR tv1380[ebp], ebx
	mov	DWORD PTR tv1379[ebp], eax
	mov	DWORD PTR tv1377[ebp], 8
$LL3@stbi__idct:

; 2189 :       // no fast case since the first 1D IDCT spread components out
; 2190 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])

	mov	ecx, DWORD PTR [ebx]
	mov	esi, DWORD PTR [ebx-16]
	lea	eax, DWORD PTR [ecx+esi]
	imul	esi, esi, 3135
	imul	edx, eax, 2217
	imul	eax, ecx, 7567
	mov	ecx, DWORD PTR [ebx-8]
	mov	edi, edx
	add	esi, edx
	sub	edi, eax
	mov	eax, DWORD PTR [ebx-24]
	lea	edx, DWORD PTR [ecx+eax]
	sub	eax, ecx
	shl	eax, 12					; 0000000cH
	shl	edx, 12					; 0000000cH
	lea	ecx, DWORD PTR [edx+esi]
	sub	edx, esi
	mov	esi, DWORD PTR tv1380[ebp]
	mov	DWORD PTR _x$1$[ebp], ecx
	lea	ecx, DWORD PTR [eax+edi]
	sub	eax, edi
	mov	DWORD PTR _x$1$[ebp], edx
	mov	edx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx-4]
	mov	edi, DWORD PTR [esi-20]
	add	edx, DWORD PTR [esi-12]
	mov	DWORD PTR _x$1$[ebp], ecx
	mov	DWORD PTR _x$1$[ebp], eax
	lea	esi, DWORD PTR [ebx+edi]

; 2191 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2192 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2193 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2194 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2195 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2196 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2197 :       x0 += 65536 + (128<<17);
; 2198 :       x1 += 65536 + (128<<17);
; 2199 :       x2 += 65536 + (128<<17);
; 2200 :       x3 += 65536 + (128<<17);

	add	DWORD PTR _x$1$[ebp], 16842752		; 01010000H
	lea	ecx, DWORD PTR [esi+edx]
	mov	DWORD PTR _p4$1$[ebp], esi
	mov	esi, DWORD PTR tv1380[ebp]
	mov	eax, esi
	imul	ebx, ecx, 4816
	imul	edx, edx, -8034
	mov	ecx, DWORD PTR [esi+4]
	add	ecx, edi
	imul	ecx, ecx, 3685
	mov	DWORD PTR _p2$3$[ebp], ebx
	sub	ebx, ecx
	mov	ecx, DWORD PTR [eax-12]
	add	ecx, DWORD PTR [eax-4]
	imul	ecx, ecx, 10497
	imul	eax, edi, 6149
	mov	edi, esi
	sub	DWORD PTR _p2$3$[ebp], ecx
	imul	ecx, DWORD PTR _p4$1$[ebp], -1597
	add	eax, ecx
	add	eax, ebx
	mov	DWORD PTR _t3$3$[ebp], eax
	imul	eax, DWORD PTR [edi-12], 12586

; 2201 :       // tried computing the shifts into temps, or'ing the temps to see
; 2202 :       // if any were out of range, but that was slower
; 2203 :       o[0] = stbi__clamp((x0+t3) >> 17);

	mov	edi, DWORD PTR _t3$3$[ebp]
	add	eax, edx
	add	eax, DWORD PTR _p2$3$[ebp]
	mov	DWORD PTR _t2$3$[ebp], eax
	mov	eax, esi
	imul	eax, DWORD PTR [eax-4], 8410
	add	eax, ecx
	add	DWORD PTR _p2$3$[ebp], eax
	imul	eax, DWORD PTR [esi+4], 1223
	add	eax, ebx
	mov	ebx, DWORD PTR _x$1$[ebp]
	add	eax, edx
	add	ebx, 16842752				; 01010000H
	mov	edx, DWORD PTR _x$1$[ebp]
	mov	DWORD PTR _t0$3$[ebp], eax
	add	edx, 16842752				; 01010000H
	mov	eax, DWORD PTR _x$1$[ebp]
	lea	ecx, DWORD PTR [ebx+edi]
	add	eax, 16842752				; 01010000H
	sar	ecx, 17					; 00000011H
	mov	DWORD PTR _x$1$[ebp], ecx

; 2107 :    if ((unsigned int) x > 255) {

	cmp	ecx, 255				; 000000ffH
	jbe	SHORT $LN11@stbi__idct

; 2108 :       if (x < 0) return 0;

	test	ecx, ecx
	jge	SHORT $LN12@stbi__idct
	mov	BYTE PTR _x$1$[ebp], 0
	jmp	SHORT $LN11@stbi__idct
$LN12@stbi__idct:

; 2109 :       if (x > 255) return 255;

	cmp	DWORD PTR _x$1$[ebp], 255		; 000000ffH
	jle	SHORT $LN11@stbi__idct
	mov	BYTE PTR _x$1$[ebp], 255		; 000000ffH
$LN11@stbi__idct:

; 2201 :       // tried computing the shifts into temps, or'ing the temps to see
; 2202 :       // if any were out of range, but that was slower
; 2203 :       o[0] = stbi__clamp((x0+t3) >> 17);

	mov	esi, DWORD PTR tv1379[ebp]

; 2204 :       o[7] = stbi__clamp((x0-t3) >> 17);

	sub	ebx, edi
	mov	ecx, DWORD PTR _x$1$[ebp]
	sar	ebx, 17					; 00000011H
	mov	BYTE PTR [esi-1], cl

; 2107 :    if ((unsigned int) x > 255) {

	mov	ecx, DWORD PTR _x$1$[ebp]
	cmp	ebx, 255				; 000000ffH
	jbe	SHORT $LN16@stbi__idct

; 2108 :       if (x < 0) return 0;

	test	ebx, ebx
	jns	SHORT $LN17@stbi__idct
	xor	bl, bl
	jmp	SHORT $LN16@stbi__idct
$LN17@stbi__idct:

; 2109 :       if (x > 255) return 255;

	cmp	ebx, 255				; 000000ffH
	jle	SHORT $LN16@stbi__idct
	or	bl, 255					; 000000ffH
$LN16@stbi__idct:

; 2205 :       o[1] = stbi__clamp((x1+t2) >> 17);

	mov	edi, DWORD PTR _t2$3$[ebp]
	mov	BYTE PTR [esi+6], bl
	lea	ebx, DWORD PTR [edx+edi]
	sar	ebx, 17					; 00000011H

; 2107 :    if ((unsigned int) x > 255) {

	cmp	ebx, 255				; 000000ffH
	jbe	SHORT $LN21@stbi__idct

; 2108 :       if (x < 0) return 0;

	test	ebx, ebx
	jns	SHORT $LN22@stbi__idct
	xor	bl, bl
	jmp	SHORT $LN21@stbi__idct
$LN22@stbi__idct:

; 2109 :       if (x > 255) return 255;

	cmp	ebx, 255				; 000000ffH
	jle	SHORT $LN21@stbi__idct
	or	bl, 255					; 000000ffH
$LN21@stbi__idct:

; 2206 :       o[6] = stbi__clamp((x1-t2) >> 17);

	sub	edx, edi
	mov	BYTE PTR [esi], bl
	sar	edx, 17					; 00000011H

; 2107 :    if ((unsigned int) x > 255) {

	cmp	edx, 255				; 000000ffH
	jbe	SHORT $LN26@stbi__idct

; 2108 :       if (x < 0) return 0;

	test	edx, edx
	jns	SHORT $LN27@stbi__idct
	xor	dl, dl
	jmp	SHORT $LN26@stbi__idct
$LN27@stbi__idct:

; 2109 :       if (x > 255) return 255;

	cmp	edx, 255				; 000000ffH
	jle	SHORT $LN26@stbi__idct
	or	dl, 255					; 000000ffH
$LN26@stbi__idct:

; 2207 :       o[2] = stbi__clamp((x2+t1) >> 17);

	mov	edi, DWORD PTR _t1$3$[ebp]
	mov	BYTE PTR [esi+5], dl
	lea	edx, DWORD PTR [eax+edi]
	sar	edx, 17					; 00000011H

; 2107 :    if ((unsigned int) x > 255) {

	cmp	edx, 255				; 000000ffH
	jbe	SHORT $LN31@stbi__idct

; 2108 :       if (x < 0) return 0;

	test	edx, edx
	jns	SHORT $LN32@stbi__idct
	xor	dl, dl
	jmp	SHORT $LN31@stbi__idct
$LN32@stbi__idct:

; 2109 :       if (x > 255) return 255;

	cmp	edx, 255				; 000000ffH
	jle	SHORT $LN31@stbi__idct
	or	dl, 255					; 000000ffH
$LN31@stbi__idct:

; 2208 :       o[5] = stbi__clamp((x2-t1) >> 17);

	sub	eax, edi
	mov	BYTE PTR [esi+1], dl
	sar	eax, 17					; 00000011H

; 2107 :    if ((unsigned int) x > 255) {

	cmp	eax, 255				; 000000ffH
	jbe	SHORT $LN36@stbi__idct

; 2108 :       if (x < 0) return 0;

	test	eax, eax
	jns	SHORT $LN37@stbi__idct
	xor	al, al
	jmp	SHORT $LN36@stbi__idct
$LN37@stbi__idct:

; 2109 :       if (x > 255) return 255;

	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN36@stbi__idct
	or	al, 255					; 000000ffH
$LN36@stbi__idct:

; 2209 :       o[3] = stbi__clamp((x3+t0) >> 17);

	mov	edx, DWORD PTR _t0$3$[ebp]
	mov	BYTE PTR [esi+4], al
	lea	eax, DWORD PTR [ecx+edx]
	sar	eax, 17					; 00000011H

; 2107 :    if ((unsigned int) x > 255) {

	cmp	eax, 255				; 000000ffH
	jbe	SHORT $LN41@stbi__idct

; 2108 :       if (x < 0) return 0;

	test	eax, eax
	jns	SHORT $LN42@stbi__idct
	xor	al, al
	jmp	SHORT $LN41@stbi__idct
$LN42@stbi__idct:

; 2109 :       if (x > 255) return 255;

	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN41@stbi__idct
	or	al, 255					; 000000ffH
$LN41@stbi__idct:

; 2210 :       o[4] = stbi__clamp((x3-t0) >> 17);

	sub	ecx, edx
	mov	BYTE PTR [esi+2], al
	sar	ecx, 17					; 00000011H

; 2107 :    if ((unsigned int) x > 255) {

	cmp	ecx, 255				; 000000ffH
	jbe	SHORT $LN46@stbi__idct

; 2108 :       if (x < 0) return 0;

	test	ecx, ecx
	jns	SHORT $LN47@stbi__idct
	xor	cl, cl
	jmp	SHORT $LN46@stbi__idct
$LN47@stbi__idct:

; 2109 :       if (x > 255) return 255;

	cmp	ecx, 255				; 000000ffH
	jle	SHORT $LN46@stbi__idct
	or	cl, 255					; 000000ffH
$LN46@stbi__idct:

; 2185 :       }
; 2186 :    }
; 2187 : 
; 2188 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {

	mov	ebx, DWORD PTR tv1380[ebp]

; 2210 :       o[4] = stbi__clamp((x3-t0) >> 17);

	mov	BYTE PTR [esi+3], cl
	add	ebx, 32					; 00000020H
	add	esi, DWORD PTR _out_stride$GSCopy$1$[ebp]
	dec	DWORD PTR tv1377[ebp]
	mov	DWORD PTR tv1380[ebp], ebx
	mov	DWORD PTR tv1379[ebp], esi
	jne	$LL3@stbi__idct

; 2211 :    }
; 2212 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__idct_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__idct_simd
_TEXT	SEGMENT
_p3$1$ = -240						; size = 16
_y5o_h$1$ = -240					; size = 16
_x7_h$1$ = -224						; size = 16
_y5o_h$1$ = -224					; size = 16
_row7$4$ = -224						; size = 16
_abiased_h$1$ = -208					; size = 16
_row5$2$ = -208						; size = 16
_abiased_h$1$ = -192					; size = 16
_row4$2$ = -192						; size = 16
_x7_l$1$ = -176						; size = 16
_x6_l$1$ = -176						; size = 16
_abiased_l$1$ = -160					; size = 16
_t3e_l$1$ = -160					; size = 16
_p2$1$ = -144						; size = 16
_t2e_h$1$ = -144					; size = 16
_x6_h$1$ = -128						; size = 16
_x6_h$1$ = -128						; size = 16
_row7$2$ = -128						; size = 16
_t3e_h$1$ = -112					; size = 16
_t2e_l$1$ = -112					; size = 16
_x4_l$1$ = -96						; size = 16
_abiased_h$1$ = -96					; size = 16
_t3e_l$1$ = -80						; size = 16
_t3e_h$1$ = -80						; size = 16
_p3$3$ = -64						; size = 16
_t2e_l$1$ = -64						; size = 16
_x4_h$1$ = -64						; size = 16
_x5_l$1$ = -48						; size = 16
_x5_l$1$ = -48						; size = 16
_x6_l$1$ = -32						; size = 16
_abiased_h$1$ = -32					; size = 16
_t2e_h$1$ = -16						; size = 16
_x4_l$1$ = -16						; size = 16
_out$ = 8						; size = 4
_out_stride$ = 12					; size = 4
_data$ = 16						; size = 4
_stbi__idct_simd PROC					; COMDAT

; 2219 : {

	push	ebp
	mov	ebp, esp
	and	esp, -16				; fffffff0H
	sub	esp, 240				; 000000f0H

; 2220 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2221 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2222 :    __m128i tmp;
; 2223 : 
; 2224 :    // dot product constant: even elems=x, odd elems=y
; 2225 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2226 : 
; 2227 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2228 :    // out(1) = c1[even]*x + c1[odd]*y
; 2229 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2230 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2231 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2232 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2233 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2234 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2235 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2236 : 
; 2237 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2238 :    #define dct_widen(out, in) \
; 2239 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2240 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2241 : 
; 2242 :    // wide add
; 2243 :    #define dct_wadd(out, a, b) \
; 2244 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2245 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2246 : 
; 2247 :    // wide sub
; 2248 :    #define dct_wsub(out, a, b) \
; 2249 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2250 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2251 : 
; 2252 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2253 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2254 :       { \
; 2255 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2256 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2257 :          dct_wadd(sum, abiased, b); \
; 2258 :          dct_wsub(dif, abiased, b); \
; 2259 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2260 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2261 :       }
; 2262 : 
; 2263 :    // 8-bit interleave step (for transposes)
; 2264 :    #define dct_interleave8(a, b) \
; 2265 :       tmp = a; \
; 2266 :       a = _mm_unpacklo_epi8(a, b); \
; 2267 :       b = _mm_unpackhi_epi8(tmp, b)
; 2268 : 
; 2269 :    // 16-bit interleave step (for transposes)
; 2270 :    #define dct_interleave16(a, b) \
; 2271 :       tmp = a; \
; 2272 :       a = _mm_unpacklo_epi16(a, b); \
; 2273 :       b = _mm_unpackhi_epi16(tmp, b)
; 2274 : 
; 2275 :    #define dct_pass(bias,shift) \
; 2276 :       { \
; 2277 :          /* even part */ \
; 2278 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2279 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2280 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2281 :          dct_widen(t0e, sum04); \
; 2282 :          dct_widen(t1e, dif04); \
; 2283 :          dct_wadd(x0, t0e, t3e); \
; 2284 :          dct_wsub(x3, t0e, t3e); \
; 2285 :          dct_wadd(x1, t1e, t2e); \
; 2286 :          dct_wsub(x2, t1e, t2e); \
; 2287 :          /* odd part */ \
; 2288 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2289 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2290 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2291 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2292 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2293 :          dct_wadd(x4, y0o, y4o); \
; 2294 :          dct_wadd(x5, y1o, y5o); \
; 2295 :          dct_wadd(x6, y2o, y5o); \
; 2296 :          dct_wadd(x7, y3o, y4o); \
; 2297 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2298 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2299 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2300 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2301 :       }
; 2302 : 
; 2303 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
; 2304 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
; 2305 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
; 2306 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
; 2307 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
; 2308 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
; 2309 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
; 2310 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
; 2311 : 
; 2312 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2313 :    __m128i bias_0 = _mm_set1_epi32(512);
; 2314 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
; 2315 : 
; 2316 :    // load
; 2317 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));

	mov	eax, DWORD PTR _data$[ebp]

; 2318 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));
; 2319 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));
; 2320 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));
; 2321 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));
; 2322 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));
; 2323 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));
; 2324 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));

	movdqa	xmm6, XMMWORD PTR [eax+112]
	movdqa	xmm7, XMMWORD PTR [eax+32]
	movdqa	xmm2, XMMWORD PTR [eax]
	movdqa	XMMWORD PTR _y5o_h$1$[esp+240], xmm6

; 2325 : 
; 2326 :    // column pass
; 2327 :    dct_pass(bias_0, 10);

	movdqa	xmm6, xmm7
	punpcklwd xmm6, XMMWORD PTR [eax+96]
	punpckhwd xmm7, XMMWORD PTR [eax+96]
	movdqa	xmm0, xmm6
	pmaddwd	xmm0, XMMWORD PTR __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
	pmaddwd	xmm6, XMMWORD PTR __xmm@08a914e808a914e808a914e808a914e8
	movdqa	xmm3, XMMWORD PTR [eax+48]
	movdqa	xmm4, XMMWORD PTR [eax+16]
	movdqa	xmm5, XMMWORD PTR [eax+80]
	movdqa	XMMWORD PTR _t2e_l$1$[esp+240], xmm0
	movdqa	xmm0, xmm7
	pmaddwd	xmm0, XMMWORD PTR __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
	movdqa	XMMWORD PTR _t3e_l$1$[esp+240], xmm6
	xorps	xmm6, xmm6
	pmaddwd	xmm7, XMMWORD PTR __xmm@08a914e808a914e808a914e808a914e8
	movdqa	xmm1, xmm6
	movdqa	XMMWORD PTR _t2e_h$1$[esp+240], xmm0
	movdqa	xmm0, XMMWORD PTR [eax+64]
	paddw	xmm0, xmm2
	movdqa	XMMWORD PTR _t3e_h$1$[esp+240], xmm7
	psubw	xmm2, XMMWORD PTR [eax+64]
	movdqa	xmm7, xmm5
	punpcklwd xmm1, xmm0
	psrad	xmm1, 4
	punpckhwd xmm7, xmm4
	movdqa	XMMWORD PTR _row4$2$[esp+240], xmm1
	movdqa	xmm1, xmm6
	punpckhwd xmm1, xmm0
	movdqa	xmm0, xmm6
	punpcklwd xmm0, xmm2
	psrad	xmm0, 4
	psrad	xmm1, 4
	movdqa	XMMWORD PTR _row5$2$[esp+240], xmm0
	movdqa	xmm0, xmm6
	punpckhwd xmm0, xmm2
	movdqa	xmm6, xmm5
	movdqa	xmm2, XMMWORD PTR _y5o_h$1$[esp+240]
	paddw	xmm5, xmm3
	psrad	xmm0, 4
	movdqa	XMMWORD PTR _abiased_h$1$[esp+240], xmm1
	movdqa	XMMWORD PTR _abiased_h$1$[esp+240], xmm0
	movdqa	xmm0, xmm2
	punpcklwd xmm0, xmm3
	movdqa	XMMWORD PTR _x6_l$1$[esp+240], xmm0
	movdqa	xmm0, xmm2
	punpckhwd xmm0, xmm3
	paddw	xmm2, xmm4
	movdqa	xmm3, XMMWORD PTR _x6_l$1$[esp+240]
	pmaddwd	xmm3, XMMWORD PTR __xmm@e09ee565e09ee565e09ee565e09ee565
	movdqa	XMMWORD PTR _x6_h$1$[esp+240], xmm0
	movdqa	xmm0, xmm2
	punpcklwd xmm0, xmm5
	movdqa	xmm1, xmm0
	punpckhwd xmm2, xmm5
	pmaddwd	xmm1, XMMWORD PTR __xmm@12d0046b12d0046b12d0046b12d0046b
	pmaddwd	xmm0, XMMWORD PTR __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
	movdqa	XMMWORD PTR _y5o_h$1$[esp+240], xmm2
	pmaddwd	xmm2, XMMWORD PTR __xmm@12d0046b12d0046b12d0046b12d0046b
	punpcklwd xmm6, xmm4
	movdqa	xmm4, XMMWORD PTR _y5o_h$1$[esp+240]
	paddd	xmm3, xmm1
	pmaddwd	xmm4, XMMWORD PTR __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
	movdqa	xmm5, xmm6
	pmaddwd	xmm5, XMMWORD PTR __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
	movdqa	XMMWORD PTR _x4_l$1$[esp+240], xmm3
	movdqa	xmm3, XMMWORD PTR _x6_h$1$[esp+240]
	pmaddwd	xmm3, XMMWORD PTR __xmm@e09ee565e09ee565e09ee565e09ee565
	paddd	xmm5, xmm0
	movdqa	XMMWORD PTR _x5_l$1$[esp+240], xmm5
	movdqa	xmm5, XMMWORD PTR _x6_l$1$[esp+240]
	pmaddwd	xmm5, XMMWORD PTR __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
	paddd	xmm3, xmm2
	movdqa	XMMWORD PTR _x4_h$1$[esp+240], xmm3
	movdqa	xmm3, xmm7
	pmaddwd	xmm3, XMMWORD PTR __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
	paddd	xmm3, xmm4
	pmaddwd	xmm7, XMMWORD PTR __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
	paddd	xmm5, xmm0
	pmaddwd	xmm6, XMMWORD PTR __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
	movdqa	XMMWORD PTR _x6_l$1$[esp+240], xmm5
	movdqa	xmm5, XMMWORD PTR _x6_h$1$[esp+240]
	pmaddwd	xmm5, XMMWORD PTR __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
	paddd	xmm7, xmm2
	movdqa	xmm2, XMMWORD PTR _row4$2$[esp+240]
	paddd	xmm2, XMMWORD PTR _t3e_l$1$[esp+240]
	paddd	xmm6, xmm1
	paddd	xmm2, XMMWORD PTR __xmm@00000200000002000000020000000200
	movdqa	xmm1, XMMWORD PTR _abiased_h$1$[esp+240]
	movdqa	xmm0, xmm2
	paddd	xmm1, XMMWORD PTR _t3e_h$1$[esp+240]
	paddd	xmm0, xmm6
	paddd	xmm1, XMMWORD PTR __xmm@00000200000002000000020000000200
	paddd	xmm5, xmm4
	psrad	xmm0, 10				; 0000000aH
	psubd	xmm2, xmm6
	movdqa	xmm6, XMMWORD PTR _row5$2$[esp+240]
	paddd	xmm6, XMMWORD PTR _t2e_l$1$[esp+240]
	paddd	xmm6, XMMWORD PTR __xmm@00000200000002000000020000000200
	movdqa	XMMWORD PTR _y5o_h$1$[esp+240], xmm0
	movdqa	xmm0, xmm1
	movdqa	xmm4, XMMWORD PTR _y5o_h$1$[esp+240]
	psubd	xmm1, xmm7
	paddd	xmm0, xmm7
	psrad	xmm1, 10				; 0000000aH
	movdqa	xmm7, XMMWORD PTR _abiased_h$1$[esp+240]
	psrad	xmm0, 10				; 0000000aH
	psrad	xmm2, 10				; 0000000aH
	packssdw xmm4, xmm0
	packssdw xmm2, xmm1
	movdqa	xmm1, xmm7
	paddd	xmm1, XMMWORD PTR _t2e_h$1$[esp+240]
	paddd	xmm1, XMMWORD PTR __xmm@00000200000002000000020000000200
	psubd	xmm7, XMMWORD PTR _t2e_h$1$[esp+240]
	movdqa	xmm0, xmm1
	movdqa	XMMWORD PTR _y5o_h$1$[esp+240], xmm4
	psubd	xmm1, xmm5
	movdqa	xmm4, xmm6
	psrad	xmm1, 10				; 0000000aH
	paddd	xmm4, XMMWORD PTR _x6_l$1$[esp+240]
	paddd	xmm0, xmm5
	psubd	xmm6, XMMWORD PTR _x6_l$1$[esp+240]
	movdqa	xmm5, XMMWORD PTR _abiased_h$1$[esp+240]
	psubd	xmm5, XMMWORD PTR _t3e_h$1$[esp+240]
	psrad	xmm0, 10				; 0000000aH
	psrad	xmm4, 10				; 0000000aH
	psrad	xmm6, 10				; 0000000aH
	packssdw xmm4, xmm0
	packssdw xmm6, xmm1
	movdqa	xmm1, XMMWORD PTR _row5$2$[esp+240]
	psubd	xmm1, XMMWORD PTR _t2e_l$1$[esp+240]
	movdqa	XMMWORD PTR _row7$2$[esp+240], xmm2
	movdqa	xmm2, XMMWORD PTR __xmm@00000200000002000000020000000200
	paddd	xmm7, xmm2
	movdqa	XMMWORD PTR _row7$4$[esp+240], xmm4
	paddd	xmm1, xmm2
	movdqa	xmm0, xmm7
	psubd	xmm7, xmm3
	movdqa	xmm4, xmm1
	psubd	xmm1, XMMWORD PTR _x5_l$1$[esp+240]
	paddd	xmm0, xmm3
	paddd	xmm4, XMMWORD PTR _x5_l$1$[esp+240]
	paddd	xmm5, xmm2
	psrad	xmm7, 10				; 0000000aH
	psrad	xmm1, 10				; 0000000aH
	psrad	xmm0, 10				; 0000000aH
	packssdw xmm1, xmm7
	movdqa	xmm7, XMMWORD PTR _row4$2$[esp+240]
	psubd	xmm7, XMMWORD PTR _t3e_l$1$[esp+240]
	psrad	xmm4, 10				; 0000000aH
	paddd	xmm7, xmm2
	movdqa	xmm3, xmm7
	movdqa	XMMWORD PTR _row5$2$[esp+240], xmm1
	paddd	xmm3, XMMWORD PTR _x4_l$1$[esp+240]
	packssdw xmm4, xmm0
	movdqa	xmm0, xmm5
	paddd	xmm0, XMMWORD PTR _x4_h$1$[esp+240]
	psrad	xmm3, 10				; 0000000aH
	psubd	xmm7, XMMWORD PTR _x4_l$1$[esp+240]
	psubd	xmm5, XMMWORD PTR _x4_h$1$[esp+240]

; 2328 : 
; 2329 :    {
; 2330 :       // 16bit 8x8 transpose pass 1
; 2331 :       dct_interleave16(row0, row4);

	movdqa	xmm1, XMMWORD PTR _y5o_h$1$[esp+240]
	psrad	xmm0, 10				; 0000000aH
	psrad	xmm7, 10				; 0000000aH
	packssdw xmm3, xmm0

; 2332 :       dct_interleave16(row1, row5);

	movdqa	xmm0, XMMWORD PTR _row7$4$[esp+240]
	movdqa	xmm2, xmm0
	psrad	xmm5, 10				; 0000000aH
	punpckhwd xmm0, XMMWORD PTR _row5$2$[esp+240]
	punpcklwd xmm2, XMMWORD PTR _row5$2$[esp+240]
	movdqa	XMMWORD PTR _row7$4$[esp+240], xmm0

; 2333 :       dct_interleave16(row2, row6);

	movdqa	xmm0, xmm4
	punpcklwd xmm0, xmm6
	packssdw xmm7, xmm5
	punpckhwd xmm4, xmm6
	movdqa	XMMWORD PTR _row4$2$[esp+240], xmm7
	movdqa	xmm7, xmm1
	punpckhwd xmm1, XMMWORD PTR _row4$2$[esp+240]
	punpcklwd xmm7, XMMWORD PTR _row4$2$[esp+240]
	movdqa	XMMWORD PTR _y5o_h$1$[esp+240], xmm1

; 2334 :       dct_interleave16(row3, row7);
; 2335 : 
; 2336 :       // transpose pass 2
; 2337 :       dct_interleave16(row0, row2);

	movdqa	xmm6, xmm7
	punpcklwd xmm6, xmm0
	movdqa	xmm1, xmm3
	punpcklwd xmm1, XMMWORD PTR _row7$2$[esp+240]
	punpckhwd xmm3, XMMWORD PTR _row7$2$[esp+240]
	punpckhwd xmm7, xmm0

; 2338 :       dct_interleave16(row1, row3);

	movdqa	xmm0, xmm2
	punpcklwd xmm0, xmm1
	punpckhwd xmm2, xmm1

; 2339 :       dct_interleave16(row4, row6);

	movdqa	xmm1, XMMWORD PTR _y5o_h$1$[esp+240]
	movdqa	xmm5, xmm1
	punpckhwd xmm1, xmm4
	movdqa	XMMWORD PTR _y5o_h$1$[esp+240], xmm1
	punpcklwd xmm5, xmm4

; 2340 :       dct_interleave16(row5, row7);

	movdqa	xmm4, XMMWORD PTR _row7$4$[esp+240]
	movdqa	xmm1, xmm4
	punpckhwd xmm4, xmm3
	punpcklwd xmm1, xmm3

; 2341 : 
; 2342 :       // transpose pass 3
; 2343 :       dct_interleave16(row0, row1);

	movdqa	xmm3, xmm6
	punpcklwd xmm3, xmm0
	punpckhwd xmm6, xmm0

; 2344 :       dct_interleave16(row2, row3);

	movdqa	xmm0, xmm7
	punpcklwd xmm0, xmm2
	movdqa	XMMWORD PTR _t3e_h$1$[esp+240], xmm0
	punpckhwd xmm7, xmm2

; 2345 :       dct_interleave16(row4, row5);

	movdqa	xmm2, xmm5
	punpcklwd xmm2, xmm1
	punpckhwd xmm5, xmm1

; 2346 :       dct_interleave16(row6, row7);

	movdqa	xmm1, XMMWORD PTR _y5o_h$1$[esp+240]
	movdqa	xmm0, xmm1
	punpckhwd xmm1, xmm4
	punpcklwd xmm0, xmm4

; 2347 :    }
; 2348 : 
; 2349 :    // row pass
; 2350 :    dct_pass(bias_1, 17);

	movdqa	xmm4, XMMWORD PTR _t3e_h$1$[esp+240]
	movdqa	XMMWORD PTR _y5o_h$1$[esp+240], xmm1
	movdqa	xmm1, xmm4
	punpcklwd xmm1, xmm0
	punpckhwd xmm4, xmm0
	movdqa	xmm0, xmm1
	pmaddwd	xmm0, XMMWORD PTR __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
	pmaddwd	xmm1, XMMWORD PTR __xmm@08a914e808a914e808a914e808a914e8
	movdqa	XMMWORD PTR _t2e_l$1$[esp+240], xmm0
	movdqa	xmm0, xmm4
	pmaddwd	xmm0, XMMWORD PTR __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
	pmaddwd	xmm4, XMMWORD PTR __xmm@08a914e808a914e808a914e808a914e8
	movdqa	XMMWORD PTR _t3e_l$1$[esp+240], xmm1
	movdqa	XMMWORD PTR _t2e_h$1$[esp+240], xmm0
	movdqa	xmm0, xmm2
	paddw	xmm0, xmm3
	movdqa	XMMWORD PTR _t3e_h$1$[esp+240], xmm4
	psubw	xmm3, xmm2
	xorps	xmm2, xmm2
	movdqa	xmm1, xmm2
	punpcklwd xmm1, xmm0
	psrad	xmm1, 4
	movdqa	XMMWORD PTR _p2$1$[esp+240], xmm1
	movdqa	xmm1, xmm2
	punpckhwd xmm1, xmm0
	movdqa	xmm0, xmm2
	psrad	xmm1, 4
	movdqa	XMMWORD PTR _abiased_h$1$[esp+240], xmm1
	punpcklwd xmm0, xmm3
	punpckhwd xmm2, xmm3
	movdqa	xmm3, XMMWORD PTR _y5o_h$1$[esp+240]
	psrad	xmm0, 4
	movdqa	xmm4, xmm3
	psrad	xmm2, 4
	movdqa	XMMWORD PTR _abiased_l$1$[esp+240], xmm0
	movdqa	xmm0, xmm3
	punpckhwd xmm0, xmm7
	paddw	xmm3, xmm6
	movdqa	XMMWORD PTR _x6_h$1$[esp+240], xmm0
	movdqa	xmm0, xmm5
	punpcklwd xmm0, xmm6
	movdqa	XMMWORD PTR _x7_l$1$[esp+240], xmm0
	movdqa	xmm0, xmm5
	punpckhwd xmm0, xmm6
	paddw	xmm5, xmm7
	movdqa	XMMWORD PTR _x7_h$1$[esp+240], xmm0
	movdqa	xmm0, xmm3
	punpckhwd xmm3, xmm5
	movdqa	XMMWORD PTR _abiased_h$1$[esp+240], xmm2
	movdqa	xmm2, xmm3
	pmaddwd	xmm3, XMMWORD PTR __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
	punpcklwd xmm0, xmm5
	movdqa	xmm5, XMMWORD PTR _x6_h$1$[esp+240]
	movdqa	xmm1, xmm0
	pmaddwd	xmm1, XMMWORD PTR __xmm@12d0046b12d0046b12d0046b12d0046b
	pmaddwd	xmm0, XMMWORD PTR __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
	movdqa	XMMWORD PTR _y5o_h$1$[esp+240], xmm3
	pmaddwd	xmm2, XMMWORD PTR __xmm@12d0046b12d0046b12d0046b12d0046b
	punpcklwd xmm4, xmm7
	movdqa	xmm7, xmm5
	pmaddwd	xmm7, XMMWORD PTR __xmm@e09ee565e09ee565e09ee565e09ee565
	movdqa	xmm3, xmm4
	pmaddwd	xmm3, XMMWORD PTR __xmm@e09ee565e09ee565e09ee565e09ee565
	pmaddwd	xmm4, XMMWORD PTR __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
	pmaddwd	xmm5, XMMWORD PTR __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
	paddd	xmm7, xmm2
	paddd	xmm3, xmm1
	movdqa	XMMWORD PTR _x4_l$1$[esp+240], xmm3
	paddd	xmm4, xmm0
	movdqa	xmm3, XMMWORD PTR _x7_l$1$[esp+240]
	pmaddwd	xmm3, XMMWORD PTR __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
	paddd	xmm5, XMMWORD PTR _y5o_h$1$[esp+240]
	movdqa	XMMWORD PTR _x6_l$1$[esp+240], xmm4
	movdqa	xmm4, XMMWORD PTR _p2$1$[esp+240]
	paddd	xmm4, XMMWORD PTR _t3e_l$1$[esp+240]
	paddd	xmm3, xmm0
	movdqa	XMMWORD PTR _x6_h$1$[esp+240], xmm5
	movdqa	xmm0, XMMWORD PTR _x7_l$1$[esp+240]
	pmaddwd	xmm0, XMMWORD PTR __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
	movdqa	XMMWORD PTR _x5_l$1$[esp+240], xmm3
	movdqa	xmm3, XMMWORD PTR _x7_h$1$[esp+240]
	movdqa	xmm6, xmm3
	pmaddwd	xmm3, XMMWORD PTR __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
	pmaddwd	xmm6, XMMWORD PTR __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
	paddd	xmm0, xmm1
	movdqa	xmm1, XMMWORD PTR _abiased_l$1$[esp+240]
	paddd	xmm1, XMMWORD PTR _t2e_l$1$[esp+240]
	movdqa	XMMWORD PTR _x7_l$1$[esp+240], xmm0
	paddd	xmm3, xmm2
	movdqa	xmm2, XMMWORD PTR __xmm@01010000010100000101000001010000
	paddd	xmm6, XMMWORD PTR _y5o_h$1$[esp+240]
	paddd	xmm1, xmm2
	movdqa	XMMWORD PTR _p3$1$[esp+240], xmm1
	paddd	xmm4, xmm2
	movdqa	xmm1, XMMWORD PTR _abiased_l$1$[esp+240]
	psubd	xmm1, XMMWORD PTR _t2e_l$1$[esp+240]
	movdqa	XMMWORD PTR _x7_h$1$[esp+240], xmm3
	movdqa	xmm3, XMMWORD PTR _abiased_h$1$[esp+240]
	paddd	xmm3, XMMWORD PTR _t3e_h$1$[esp+240]
	movdqa	XMMWORD PTR _abiased_l$1$[esp+240], xmm1
	paddd	xmm3, xmm2
	movdqa	xmm0, XMMWORD PTR _abiased_l$1$[esp+240]
	movdqa	xmm1, XMMWORD PTR __xmm@01010000010100000101000001010000
	movdqa	xmm2, XMMWORD PTR _abiased_h$1$[esp+240]
	paddd	xmm0, xmm1
	paddd	xmm2, XMMWORD PTR _t2e_h$1$[esp+240]
	paddd	xmm2, XMMWORD PTR __xmm@01010000010100000101000001010000
	movdqa	XMMWORD PTR _abiased_l$1$[esp+240], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$1$[esp+240]
	psubd	xmm0, XMMWORD PTR _t2e_h$1$[esp+240]
	movdqa	xmm5, xmm4
	paddd	xmm0, xmm1
	paddd	xmm5, XMMWORD PTR _x7_l$1$[esp+240]
	movdqa	XMMWORD PTR _abiased_h$1$[esp+240], xmm0
	movdqa	xmm0, XMMWORD PTR _p2$1$[esp+240]
	psubd	xmm0, XMMWORD PTR _t3e_l$1$[esp+240]
	paddd	xmm0, xmm1
	psrad	xmm5, 17				; 00000011H
	movdqa	XMMWORD PTR _p2$1$[esp+240], xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$1$[esp+240]
	psubd	xmm0, XMMWORD PTR _t3e_h$1$[esp+240]
	paddd	xmm0, xmm1
	psubd	xmm4, XMMWORD PTR _x7_l$1$[esp+240]
	movdqa	xmm1, XMMWORD PTR _p3$1$[esp+240]
	paddd	xmm1, XMMWORD PTR _x6_l$1$[esp+240]
	movdqa	XMMWORD PTR _abiased_h$1$[esp+240], xmm0
	movdqa	xmm0, xmm3
	paddd	xmm0, XMMWORD PTR _x7_h$1$[esp+240]
	psrad	xmm0, 17				; 00000011H
	psrad	xmm1, 17				; 00000011H
	packssdw xmm5, xmm0
	movdqa	xmm0, xmm2
	paddd	xmm0, XMMWORD PTR _x6_h$1$[esp+240]
	psrad	xmm0, 17				; 00000011H
	psubd	xmm3, XMMWORD PTR _x7_h$1$[esp+240]
	packssdw xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$1$[esp+240]

; 2351 : 
; 2352 :    {
; 2353 :       // pack
; 2354 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7

	packuswb xmm5, xmm1
	paddd	xmm0, xmm6
	movdqa	xmm1, XMMWORD PTR _p2$1$[esp+240]
	paddd	xmm1, XMMWORD PTR _x4_l$1$[esp+240]
	psrad	xmm0, 17				; 00000011H
	movdqa	XMMWORD PTR _p3$3$[esp+240], xmm5
	movdqa	xmm5, XMMWORD PTR _abiased_l$1$[esp+240]
	paddd	xmm5, XMMWORD PTR _x5_l$1$[esp+240]
	psrad	xmm5, 17				; 00000011H
	psrad	xmm1, 17				; 00000011H
	packssdw xmm5, xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$1$[esp+240]
	paddd	xmm0, xmm7
	psubd	xmm2, XMMWORD PTR _x6_h$1$[esp+240]
	psrad	xmm0, 17				; 00000011H
	psrad	xmm4, 17				; 00000011H
	packssdw xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_h$1$[esp+240]

; 2355 :       __m128i p1 = _mm_packus_epi16(row2, row3);

	packuswb xmm5, xmm1
	psubd	xmm0, xmm7
	movdqa	xmm1, XMMWORD PTR _p2$1$[esp+240]
	psubd	xmm1, XMMWORD PTR _x4_l$1$[esp+240]
	movdqa	xmm7, XMMWORD PTR _abiased_h$1$[esp+240]
	psrad	xmm0, 17				; 00000011H
	psubd	xmm7, xmm6

; 2356 :       __m128i p2 = _mm_packus_epi16(row4, row5);
; 2357 :       __m128i p3 = _mm_packus_epi16(row6, row7);
; 2358 : 
; 2359 :       // 8bit 8x8 transpose pass 1
; 2360 :       dct_interleave8(p0, p2); // a0e0a1e1...

	movdqa	xmm6, XMMWORD PTR _p3$3$[esp+240]
	psrad	xmm1, 17				; 00000011H
	psrad	xmm7, 17				; 00000011H
	packssdw xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR _abiased_l$1$[esp+240]
	psubd	xmm0, XMMWORD PTR _x5_l$1$[esp+240]
	psrad	xmm0, 17				; 00000011H
	psrad	xmm3, 17				; 00000011H
	packssdw xmm0, xmm7
	packuswb xmm1, xmm0

; 2361 :       dct_interleave8(p1, p3); // c0g0c1g1...

	movdqa	xmm0, xmm5
	movdqa	XMMWORD PTR _p2$1$[esp+240], xmm1
	movdqa	xmm1, XMMWORD PTR _p3$1$[esp+240]
	psubd	xmm1, XMMWORD PTR _x6_l$1$[esp+240]
	packssdw xmm4, xmm3
	psrad	xmm1, 17				; 00000011H
	psrad	xmm2, 17				; 00000011H
	packssdw xmm1, xmm2
	packuswb xmm1, xmm4
	movdqa	xmm4, xmm6
	punpcklbw xmm4, XMMWORD PTR _p2$1$[esp+240]
	punpckhbw xmm6, XMMWORD PTR _p2$1$[esp+240]

; 2362 : 
; 2363 :       // transpose pass 2
; 2364 :       dct_interleave8(p0, p1); // a0c0e0g0...

	movdqa	xmm3, xmm4
	punpcklbw xmm0, xmm1
	punpcklbw xmm3, xmm0
	punpckhbw xmm4, xmm0

; 2365 :       dct_interleave8(p2, p3); // b0d0f0h0...

	movdqa	xmm0, xmm6
	punpckhbw xmm5, xmm1

; 2366 : 
; 2367 :       // transpose pass 3
; 2368 :       dct_interleave8(p0, p2); // a0b0c0d0...
; 2369 :       dct_interleave8(p1, p3); // a4b4c4d4...
; 2370 : 
; 2371 :       // store
; 2372 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;

	mov	ecx, DWORD PTR _out$[ebp]
	movdqa	xmm1, xmm3
	mov	eax, DWORD PTR _out_stride$[ebp]
	movdqa	xmm2, xmm4
	punpcklbw xmm0, xmm5
	punpcklbw xmm1, xmm0
	movq	QWORD PTR [ecx], xmm1
	add	ecx, eax
	punpckhbw xmm3, xmm0

; 2373 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;

	pshufd	xmm0, xmm1, 78				; 0000004eH
	punpckhbw xmm6, xmm5
	movq	QWORD PTR [ecx], xmm0
	add	ecx, eax

; 2374 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
; 2375 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;

	pshufd	xmm0, xmm3, 78				; 0000004eH
	punpcklbw xmm2, xmm6
	punpckhbw xmm4, xmm6
	movq	QWORD PTR [ecx], xmm3
	add	ecx, eax
	movq	QWORD PTR [ecx], xmm0
	add	ecx, eax

; 2376 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
; 2377 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;

	pshufd	xmm0, xmm2, 78				; 0000004eH
	movq	QWORD PTR [ecx], xmm2
	add	ecx, eax
	movq	QWORD PTR [ecx], xmm0
	add	ecx, eax

; 2378 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
; 2379 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));

	pshufd	xmm0, xmm4, 78				; 0000004eH
	movq	QWORD PTR [ecx], xmm4
	movq	QWORD PTR [ecx+eax], xmm0

; 2380 :    }
; 2381 : 
; 2382 : #undef dct_const
; 2383 : #undef dct_rot
; 2384 : #undef dct_widen
; 2385 : #undef dct_wadd
; 2386 : #undef dct_wsub
; 2387 : #undef dct_bfly32o
; 2388 : #undef dct_interleave8
; 2389 : #undef dct_interleave16
; 2390 : #undef dct_pass
; 2391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__idct_simd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _resample_row_1
_TEXT	SEGMENT
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
_resample_row_1 PROC					; COMDAT

; 3116 : {

	push	ebp
	mov	ebp, esp

; 3117 :    STBI_NOTUSED(out);
; 3118 :    STBI_NOTUSED(in_far);
; 3119 :    STBI_NOTUSED(w);
; 3120 :    STBI_NOTUSED(hs);
; 3121 :    return in_near;

	mov	eax, DWORD PTR _in_near$[ebp]

; 3122 : }

	pop	ebp
	ret	0
_resample_row_1 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__resample_row_v_2
_TEXT	SEGMENT
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
tv222 = 20						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
_stbi__resample_row_v_2 PROC				; COMDAT

; 3125 : {

	push	ebp
	mov	ebp, esp

; 3126 :    // need to generate two samples vertically for every one in input
; 3127 :    int i;
; 3128 :    STBI_NOTUSED(hs);
; 3129 :    for (i=0; i < w; ++i)

	mov	eax, DWORD PTR _out$[ebp]
	push	edi
	mov	edi, DWORD PTR _w$[ebp]
	test	edi, edi
	jle	SHORT $LN1@stbi__resa
	mov	ecx, DWORD PTR _in_far$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _in_near$[ebp]
	sub	ebx, ecx
	sub	eax, ecx
	push	esi
	mov	DWORD PTR tv222[ebp], eax
	npad	3
$LL3@stbi__resa:

; 3130 :       out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);

	movzx	eax, BYTE PTR [ebx+ecx]
	lea	ecx, DWORD PTR [ecx+1]
	movzx	edx, BYTE PTR [ecx-1]
	add	edx, 2
	lea	esi, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR tv222[ebp]
	add	edx, esi
	sar	edx, 2
	mov	BYTE PTR [eax+ecx-1], dl
	dec	edi
	jne	SHORT $LL3@stbi__resa

; 3131 :    return out;

	mov	eax, DWORD PTR _out$[ebp]
	pop	esi
	pop	ebx
$LN1@stbi__resa:
	pop	edi

; 3132 : }

	pop	ebp
	ret	0
_stbi__resample_row_v_2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__resample_row_h_2
_TEXT	SEGMENT
tv214 = -4						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
_stbi__resample_row_h_2 PROC				; COMDAT

; 3135 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 3136 :    // need to generate two samples horizontally for every one in input
; 3137 :    int i;
; 3138 :    stbi_uc *input = in_near;
; 3139 : 
; 3140 :    if (w == 1) {

	mov	ebx, DWORD PTR _w$[ebp]
	cmp	ebx, 1
	jne	SHORT $LN4@stbi__resa

; 3141 :       // if only one sample, can't do any interpolation
; 3142 :       out[0] = out[1] = input[0];

	mov	eax, DWORD PTR _in_near$[ebp]
	pop	ebx
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+1], cl
	mov	BYTE PTR [eax], cl

; 3160 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@stbi__resa:

; 3143 :       return out;
; 3144 :    }
; 3145 : 
; 3146 :    out[0] = input[0];

	mov	edx, DWORD PTR _in_near$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _out$[ebp]

; 3147 :    out[1] = stbi__div4(input[0]*3 + input[1] + 2);
; 3148 :    for (i=1; i < w-1; ++i) {

	mov	esi, 1
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [edi], al
	movzx	eax, BYTE PTR [edx]
	lea	ecx, DWORD PTR [eax+eax*2]
	movzx	eax, BYTE PTR [edx+1]
	add	eax, 2
	add	eax, ecx
	sar	eax, 2
	mov	BYTE PTR [edi+1], al
	lea	eax, DWORD PTR [ebx-1]
	cmp	eax, esi
	jle	SHORT $LN1@stbi__resa
	mov	ebx, eax
	npad	2
$LL3@stbi__resa:

; 3149 :       int n = 3*input[i]+2;

	movzx	eax, BYTE PTR [edx+esi]
	lea	ecx, DWORD PTR [eax+1]
	lea	ecx, DWORD PTR [eax+ecx*2]

; 3150 :       out[i*2+0] = stbi__div4(n+input[i-1]);

	movzx	eax, BYTE PTR [edx+esi-1]
	add	eax, ecx
	sar	eax, 2
	mov	BYTE PTR [edi+esi*2], al

; 3151 :       out[i*2+1] = stbi__div4(n+input[i+1]);

	movzx	eax, BYTE PTR [edx+esi+1]
	add	eax, ecx
	sar	eax, 2
	mov	BYTE PTR [edi+esi*2+1], al
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL3@stbi__resa
	mov	ebx, DWORD PTR _w$[ebp]
$LN1@stbi__resa:

; 3152 :    }
; 3153 :    out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);

	movzx	ecx, BYTE PTR [edx+ebx-2]
	mov	eax, DWORD PTR _in_near$[ebp]
	lea	edx, DWORD PTR [ecx+ecx*2]
	movzx	ecx, BYTE PTR [eax+ebx-1]
	add	ecx, 2
	add	ecx, edx
	sar	ecx, 2
	mov	BYTE PTR [edi+esi*2], cl

; 3154 :    out[i*2+1] = input[w-1];

	mov	cl, BYTE PTR [eax+ebx-1]

; 3155 : 
; 3156 :    STBI_NOTUSED(in_far);
; 3157 :    STBI_NOTUSED(hs);
; 3158 : 
; 3159 :    return out;

	mov	eax, edi
	mov	BYTE PTR [edi+esi*2+1], cl
	pop	edi
	pop	esi
	pop	ebx

; 3160 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__resample_row_h_2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__resample_row_hv_2
_TEXT	SEGMENT
_in_near$1$ = -8					; size = 4
_i$1$ = -4						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
_stbi__resample_row_hv_2 PROC				; COMDAT

; 3165 : {

	push	ebp
	mov	ebp, esp

; 3166 :    // need to generate 2x2 samples for every one in input
; 3167 :    int i,t0,t1;
; 3168 :    if (w == 1) {
; 3169 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);

	mov	eax, DWORD PTR _in_near$[ebp]
	sub	esp, 8
	movzx	eax, BYTE PTR [eax]
	push	edi
	mov	edi, DWORD PTR _w$[ebp]
	cmp	edi, 1
	jne	SHORT $LN4@stbi__resa
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR _in_far$[ebp]
	pop	edi
	movzx	eax, BYTE PTR [eax]
	add	eax, 2
	add	ecx, eax
	mov	eax, DWORD PTR _out$[ebp]
	sar	ecx, 2
	mov	BYTE PTR [eax+1], cl
	mov	BYTE PTR [eax], cl

; 3186 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@stbi__resa:

; 3170 :       return out;
; 3171 :    }
; 3172 : 
; 3173 :    t1 = 3*in_near[0] + in_far[0];

	mov	edx, DWORD PTR _in_far$[ebp]
	lea	eax, DWORD PTR [eax+eax*2]
	push	esi

; 3174 :    out[0] = stbi__div4(t1+2);

	mov	esi, DWORD PTR _out$[ebp]

; 3175 :    for (i=1; i < w; ++i) {

	mov	DWORD PTR _i$1$[ebp], 1
	movzx	ecx, BYTE PTR [edx]
	add	eax, ecx
	lea	ecx, DWORD PTR [eax+2]
	sar	ecx, 2
	mov	BYTE PTR [esi], cl
	cmp	edi, 1
	jle	SHORT $LN1@stbi__resa
	mov	ecx, DWORD PTR _in_near$[ebp]
	sub	ecx, edx
	push	ebx
	lea	ebx, DWORD PTR [edx+1]
	mov	DWORD PTR _in_near$1$[ebp], ecx
$LL3@stbi__resa:

; 3176 :       t0 = t1;
; 3177 :       t1 = 3*in_near[i]+in_far[i];
; 3178 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);

	mov	edi, DWORD PTR _i$1$[ebp]
	lea	ebx, DWORD PTR [ebx+1]
	mov	edx, eax
	movzx	eax, BYTE PTR [ecx+ebx-1]
	movzx	ecx, BYTE PTR [ebx-1]
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, ecx
	lea	ecx, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx*2]
	add	ecx, edx
	sar	ecx, 4
	mov	BYTE PTR [esi+edi*2-1], cl

; 3179 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);

	lea	ecx, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [ecx+eax*2]
	mov	edx, edi
	mov	edi, DWORD PTR _w$[ebp]
	add	ecx, eax
	sar	ecx, 4
	mov	BYTE PTR [esi+edx*2], cl
	inc	edx
	mov	ecx, DWORD PTR _in_near$1$[ebp]
	mov	DWORD PTR _i$1$[ebp], edx
	cmp	edx, edi
	jl	SHORT $LL3@stbi__resa
	pop	ebx
$LN1@stbi__resa:

; 3180 :    }
; 3181 :    out[w*2-1] = stbi__div4(t1+2);

	add	eax, 2
	sar	eax, 2
	mov	BYTE PTR [esi+edi*2-1], al

; 3182 : 
; 3183 :    STBI_NOTUSED(hs);
; 3184 : 
; 3185 :    return out;

	mov	eax, esi
	pop	esi
	pop	edi

; 3186 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__resample_row_hv_2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__resample_row_hv_2_simd
_TEXT	SEGMENT
_t0$1$ = -20						; size = 4
tv638 = -16						; size = 4
tv680 = -12						; size = 4
tv683 = -8						; size = 4
_in_near$1$ = -8					; size = 4
tv677 = -4						; size = 4
_t0$2$ = -4						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
_stbi__resample_row_hv_2_simd PROC			; COMDAT

; 3190 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 24					; 00000018H
	push	esi
	push	edi

; 3191 :    // need to generate 2x2 samples for every one in input
; 3192 :    int i=0,t0,t1;
; 3193 : 
; 3194 :    if (w == 1) {

	mov	edi, DWORD PTR _w$[ebp]
	xor	esi, esi
	cmp	edi, 1
	jne	SHORT $LN7@stbi__resa

; 3195 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);

	mov	eax, DWORD PTR _in_near$[ebp]
	movzx	eax, BYTE PTR [eax]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR _in_far$[ebp]
	movzx	eax, BYTE PTR [eax]
	add	eax, 2
	add	ecx, eax
	mov	eax, DWORD PTR _out$[ebp]
	sar	ecx, 2
	mov	BYTE PTR [eax+1], cl
	mov	BYTE PTR [eax], cl

; 3302 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@stbi__resa:

; 3196 :       return out;
; 3197 :    }
; 3198 : 
; 3199 :    t1 = 3*in_near[0] + in_far[0];

	mov	edx, DWORD PTR _in_near$[ebp]
	mov	ecx, DWORD PTR _in_far$[ebp]
	movzx	eax, BYTE PTR [edx]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _t0$1$[esp+32], eax
	movzx	eax, BYTE PTR [ecx]
	add	DWORD PTR _t0$1$[esp+32], eax

; 3200 :    // process groups of 8 pixels for as long as we can.
; 3201 :    // note we can't handle the last pixel in a row in this loop
; 3202 :    // because we need to handle the filter boundary conditions.
; 3203 :    for (; i < ((w-1) & ~7); i += 8) {

	lea	eax, DWORD PTR [edi-1]
	and	eax, -8					; fffffff8H
	mov	DWORD PTR tv683[esp+32], eax
	jle	$LN4@stbi__resa

; 3196 :       return out;
; 3197 :    }
; 3198 : 
; 3199 :    t1 = 3*in_near[0] + in_far[0];

	mov	eax, DWORD PTR _out$[ebp]
	mov	edi, ecx
	movdqa	xmm5, XMMWORD PTR __xmm@00080008000800080008000800080008
	xorps	xmm4, xmm4
	mov	DWORD PTR tv638[esp+32], eax

; 3200 :    // process groups of 8 pixels for as long as we can.
; 3201 :    // note we can't handle the last pixel in a row in this loop
; 3202 :    // because we need to handle the filter boundary conditions.
; 3203 :    for (; i < ((w-1) & ~7); i += 8) {

	mov	eax, edx
	sub	eax, ecx
	lea	ecx, DWORD PTR [edx+7]
	mov	edx, DWORD PTR tv683[esp+32]
	mov	DWORD PTR tv680[esp+32], ecx
	mov	ecx, DWORD PTR _t0$1$[esp+32]
	mov	DWORD PTR tv677[esp+32], eax
	npad	4
$LL6@stbi__resa:

; 3204 : #if defined(STBI_SSE2)
; 3205 :       // load and perform the vertical filtering pass
; 3206 :       // this uses 3*x + y = 4*x + (y - x)
; 3207 :       __m128i zero  = _mm_setzero_si128();
; 3208 :       __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
; 3209 :       __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));

	movq	xmm0, QWORD PTR [eax+edi]
	lea	edi, DWORD PTR [edi+8]
	movq	xmm3, QWORD PTR [edi-8]

; 3210 :       __m128i farw  = _mm_unpacklo_epi8(farb, zero);
; 3211 :       __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
; 3212 :       __m128i diff  = _mm_sub_epi16(farw, nearw);
; 3213 :       __m128i nears = _mm_slli_epi16(nearw, 2);
; 3214 :       __m128i curr  = _mm_add_epi16(nears, diff); // current row
; 3215 : 
; 3216 :       // horizontal filter works the same based on shifted vers of current
; 3217 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3218 :       // insert the previous pixel value (from t1).
; 3219 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3220 :       // of next block of 8 pixels added in.
; 3221 :       __m128i prv0 = _mm_slli_si128(curr, 2);
; 3222 :       __m128i nxt0 = _mm_srli_si128(curr, 2);
; 3223 :       __m128i prev = _mm_insert_epi16(prv0, t1, 0);
; 3224 :       __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

	mov	eax, DWORD PTR tv680[esp+32]
	punpcklbw xmm0, xmm4
	punpcklbw xmm3, xmm4
	psubw	xmm3, xmm0
	psllw	xmm0, 2
	movzx	eax, BYTE PTR [eax+esi+1]
	paddw	xmm3, xmm0
	movdqa	xmm2, xmm3

; 3225 : 
; 3226 :       // horizontal filter, polyphase implementation since it's convenient:
; 3227 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3228 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3229 :       // note the shared term.
; 3230 :       __m128i bias  = _mm_set1_epi16(8);
; 3231 :       __m128i curs = _mm_slli_epi16(curr, 2);

	movdqa	xmm0, xmm3
	pslldq	xmm2, 2
	movdqa	xmm1, xmm3
	pinsrw	xmm2, ecx, 0
	lea	ecx, DWORD PTR [eax+eax*2]
	movzx	eax, BYTE PTR [edi]

; 3232 :       __m128i prvd = _mm_sub_epi16(prev, curr);

	psubw	xmm2, xmm3
	add	ecx, eax
	psllw	xmm0, 2

; 3233 :       __m128i nxtd = _mm_sub_epi16(next, curr);
; 3234 :       __m128i curb = _mm_add_epi16(curs, bias);
; 3235 :       __m128i even = _mm_add_epi16(prvd, curb);
; 3236 :       __m128i odd  = _mm_add_epi16(nxtd, curb);
; 3237 : 
; 3238 :       // interleave even and odd pixels, then undo scaling.
; 3239 :       __m128i int0 = _mm_unpacklo_epi16(even, odd);
; 3240 :       __m128i int1 = _mm_unpackhi_epi16(even, odd);
; 3241 :       __m128i de0  = _mm_srli_epi16(int0, 4);
; 3242 :       __m128i de1  = _mm_srli_epi16(int1, 4);
; 3243 : 
; 3244 :       // pack and write output
; 3245 :       __m128i outv = _mm_packus_epi16(de0, de1);
; 3246 :       _mm_storeu_si128((__m128i *) (out + i*2), outv);

	mov	eax, DWORD PTR tv638[esp+32]
	paddw	xmm0, xmm5
	psrldq	xmm1, 2
	add	DWORD PTR tv638[esp+32], 16		; 00000010H
	paddw	xmm2, xmm0
	pinsrw	xmm1, ecx, 7
	psubw	xmm1, xmm3
	paddw	xmm1, xmm0
	movdqa	xmm0, xmm2
	punpcklwd xmm0, xmm1
	punpckhwd xmm2, xmm1
	psrlw	xmm0, 4
	psrlw	xmm2, 4
	packuswb xmm0, xmm2
	movdqu	XMMWORD PTR [eax], xmm0

; 3247 : #elif defined(STBI_NEON)
; 3248 :       // load and perform the vertical filtering pass
; 3249 :       // this uses 3*x + y = 4*x + (y - x)
; 3250 :       uint8x8_t farb  = vld1_u8(in_far + i);
; 3251 :       uint8x8_t nearb = vld1_u8(in_near + i);
; 3252 :       int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
; 3253 :       int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
; 3254 :       int16x8_t curr  = vaddq_s16(nears, diff); // current row
; 3255 : 
; 3256 :       // horizontal filter works the same based on shifted vers of current
; 3257 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3258 :       // insert the previous pixel value (from t1).
; 3259 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3260 :       // of next block of 8 pixels added in.
; 3261 :       int16x8_t prv0 = vextq_s16(curr, curr, 7);
; 3262 :       int16x8_t nxt0 = vextq_s16(curr, curr, 1);
; 3263 :       int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
; 3264 :       int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
; 3265 : 
; 3266 :       // horizontal filter, polyphase implementation since it's convenient:
; 3267 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3268 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3269 :       // note the shared term.
; 3270 :       int16x8_t curs = vshlq_n_s16(curr, 2);
; 3271 :       int16x8_t prvd = vsubq_s16(prev, curr);
; 3272 :       int16x8_t nxtd = vsubq_s16(next, curr);
; 3273 :       int16x8_t even = vaddq_s16(curs, prvd);
; 3274 :       int16x8_t odd  = vaddq_s16(curs, nxtd);
; 3275 : 
; 3276 :       // undo scaling and round, then store with even/odd phases interleaved
; 3277 :       uint8x8x2_t o;
; 3278 :       o.val[0] = vqrshrun_n_s16(even, 4);
; 3279 :       o.val[1] = vqrshrun_n_s16(odd,  4);
; 3280 :       vst2_u8(out + i*2, o);
; 3281 : #endif
; 3282 : 
; 3283 :       // "previous" value for next iter
; 3284 :       t1 = 3*in_near[i+7] + in_far[i+7];

	mov	eax, DWORD PTR tv680[esp+32]
	movzx	eax, BYTE PTR [eax+esi]
	add	esi, 8
	lea	ecx, DWORD PTR [eax+eax*2]
	movzx	eax, BYTE PTR [edi-1]
	add	ecx, eax
	mov	eax, DWORD PTR tv677[esp+32]
	cmp	esi, edx
	jl	$LL6@stbi__resa
	mov	edx, DWORD PTR _in_near$[ebp]
	mov	edi, DWORD PTR _w$[ebp]
	mov	DWORD PTR _t0$1$[esp+32], ecx
	mov	ecx, DWORD PTR _in_far$[ebp]
$LN4@stbi__resa:

; 3285 :    }
; 3286 : 
; 3287 :    t0 = t1;
; 3288 :    t1 = 3*in_near[i] + in_far[i];

	movzx	eax, BYTE PTR [esi+edx]
	movzx	ecx, BYTE PTR [esi+ecx]

; 3289 :    out[i*2] = stbi__div16(3*t1 + t0 + 8);

	mov	edx, DWORD PTR _out$[ebp]
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, ecx
	mov	ecx, DWORD PTR _t0$1$[esp+32]
	lea	ecx, DWORD PTR [ecx+eax*2]
	add	ecx, 8
	add	ecx, eax
	sar	ecx, 4
	mov	BYTE PTR [edx+esi*2], cl

; 3290 : 
; 3291 :    for (++i; i < w; ++i) {

	inc	esi
	cmp	esi, edi
	jge	SHORT $LN1@stbi__resa
	mov	edx, DWORD PTR _in_far$[ebp]
	mov	ecx, DWORD PTR _in_near$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _in_near$1$[esp+32], ecx
	lea	edi, DWORD PTR [esi+edx]
$LL3@stbi__resa:

; 3292 :       t0 = t1;

	mov	edx, eax
	lea	edi, DWORD PTR [edi+1]

; 3293 :       t1 = 3*in_near[i]+in_far[i];

	movzx	eax, BYTE PTR [edi+ecx-1]
	movzx	ecx, BYTE PTR [edi-1]
	mov	DWORD PTR _t0$2$[esp+32], edx
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, ecx

; 3294 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);

	lea	ecx, DWORD PTR [eax+edx*2]
	add	edx, 8
	add	ecx, edx
	mov	edx, DWORD PTR _out$[ebp]
	sar	ecx, 4
	mov	BYTE PTR [edx+esi*2-1], cl

; 3295 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);

	mov	ecx, DWORD PTR _t0$2$[esp+32]
	add	ecx, 8
	lea	ecx, DWORD PTR [ecx+eax*2]
	add	ecx, eax
	sar	ecx, 4
	mov	BYTE PTR [edx+esi*2], cl
	inc	esi
	mov	ecx, DWORD PTR _in_near$1$[esp+32]
	cmp	esi, DWORD PTR _w$[ebp]
	jl	SHORT $LL3@stbi__resa
	mov	edi, DWORD PTR _w$[ebp]
$LN1@stbi__resa:

; 3296 :    }
; 3297 :    out[w*2-1] = stbi__div4(t1+2);

	mov	ecx, DWORD PTR _out$[ebp]
	add	eax, 2
	sar	eax, 2
	mov	BYTE PTR [ecx+edi*2-1], al

; 3298 : 
; 3299 :    STBI_NOTUSED(hs);
; 3300 : 
; 3301 :    return out;

	mov	eax, ecx

; 3302 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__resample_row_hv_2_simd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__resample_row_generic
_TEXT	SEGMENT
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
_stbi__resample_row_generic PROC			; COMDAT

; 3306 : {

	push	ebp
	mov	ebp, esp

; 3307 :    // resample with nearest-neighbor
; 3308 :    int i,j;
; 3309 :    STBI_NOTUSED(in_far);
; 3310 :    for (i=0; i < w; ++i)

	xor	edx, edx
	cmp	DWORD PTR _w$[ebp], edx
	jle	SHORT $LN17@stbi__resa
	push	ebx
	mov	ebx, DWORD PTR _in_near$[ebp]
	push	esi
	mov	esi, DWORD PTR _out$[ebp]
	push	edi
	mov	edi, DWORD PTR _hs$[ebp]
$LL6@stbi__resa:

; 3311 :       for (j=0; j < hs; ++j)

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN5@stbi__resa
	npad	4
$LL3@stbi__resa:

; 3312 :          out[i*hs+j] = in_near[i];

	mov	cl, BYTE PTR [edx+ebx]
	mov	BYTE PTR [esi+eax], cl
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL3@stbi__resa
$LN5@stbi__resa:

; 3307 :    // resample with nearest-neighbor
; 3308 :    int i,j;
; 3309 :    STBI_NOTUSED(in_far);
; 3310 :    for (i=0; i < w; ++i)

	inc	edx
	add	esi, edi
	cmp	edx, DWORD PTR _w$[ebp]
	jl	SHORT $LL6@stbi__resa
	pop	edi
	pop	esi
	pop	ebx
$LN17@stbi__resa:

; 3313 :    return out;

	mov	eax, DWORD PTR _out$[ebp]

; 3314 : }

	pop	ebp
	ret	0
_stbi__resample_row_generic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__YCbCr_to_RGB_row
_TEXT	SEGMENT
_out$ = 8						; size = 4
_y$ = 12						; size = 4
_pcb$ = 16						; size = 4
_pcr$ = 20						; size = 4
_count$ = 24						; size = 4
_step$ = 28						; size = 4
_stbi__YCbCr_to_RGB_row PROC				; COMDAT

; 3320 : {

	push	ebp
	mov	ebp, esp

; 3321 :    int i;
; 3322 :    for (i=0; i < count; ++i) {

	cmp	DWORD PTR _count$[ebp], 0
	jle	$LN10@stbi__YCbC

; 3339 :       out[3] = 255;

	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _pcr$[ebp]
	sub	edx, eax
	push	ebx
	mov	ebx, DWORD PTR _pcb$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _out$[ebp]
	add	edi, 2
	mov	DWORD PTR _y$[ebp], edx
	sub	ebx, eax
	mov	DWORD PTR _pcb$[ebp], ebx
	npad	7
$LL12@stbi__YCbC:

; 3323 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3324 :       int r,g,b;
; 3325 :       int cr = pcr[i] - 128;
; 3326 :       int cb = pcb[i] - 128;

	movzx	esi, BYTE PTR [edx+eax]
	movzx	edx, BYTE PTR [ebx+eax]
	movzx	ecx, BYTE PTR [eax]
	add	edx, -128				; ffffff80H

; 3327 :       r = y_fixed +  cr* stbi__float2fixed(1.40200f);
; 3328 :       g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);

	imul	eax, edx, -360960
	add	ecx, -128				; ffffff80H
	imul	ebx, ecx, 1470208
	imul	ecx, ecx, 748800

; 3329 :       b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);

	imul	edx, edx, 1858048
	shl	esi, 20					; 00000014H
	and	eax, -65536				; ffff0000H
	add	esi, 524288				; 00080000H
	add	ebx, esi

; 3330 :       r >>= 20;
; 3331 :       g >>= 20;

	sub	eax, ecx
	sar	ebx, 20					; 00000014H
	add	eax, esi
	add	edx, esi
	sar	eax, 20					; 00000014H

; 3332 :       b >>= 20;

	sar	edx, 20					; 00000014H

; 3333 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }

	cmp	ebx, 255				; 000000ffH
	jbe	SHORT $LN8@stbi__YCbC
	xor	esi, esi
	mov	ecx, 255				; 000000ffH
	test	ebx, ebx
	cmovs	ecx, esi
	mov	ebx, ecx
$LN8@stbi__YCbC:

; 3334 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }

	cmp	eax, 255				; 000000ffH
	jbe	SHORT $LN5@stbi__YCbC
	xor	esi, esi
	mov	ecx, 255				; 000000ffH
	test	eax, eax
	cmovs	ecx, esi
	mov	eax, ecx
$LN5@stbi__YCbC:

; 3335 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }

	cmp	edx, 255				; 000000ffH
	jbe	SHORT $LN2@stbi__YCbC
	xor	esi, esi
	mov	ecx, 255				; 000000ffH
	test	edx, edx
	cmovs	ecx, esi
	mov	edx, ecx
$LN2@stbi__YCbC:

; 3336 :       out[0] = (stbi_uc)r;
; 3337 :       out[1] = (stbi_uc)g;

	mov	BYTE PTR [edi-1], al
	mov	eax, DWORD PTR _pcr$[ebp]
	mov	BYTE PTR [edi-2], bl
	inc	eax
	mov	ebx, DWORD PTR _pcb$[ebp]

; 3338 :       out[2] = (stbi_uc)b;

	mov	BYTE PTR [edi], dl
	mov	edx, DWORD PTR _y$[ebp]

; 3339 :       out[3] = 255;

	mov	BYTE PTR [edi+1], 255			; 000000ffH

; 3340 :       out += step;

	add	edi, DWORD PTR _step$[ebp]
	dec	DWORD PTR _count$[ebp]
	mov	DWORD PTR _pcr$[ebp], eax
	jne	$LL12@stbi__YCbC
	pop	edi
	pop	esi
	pop	ebx
$LN10@stbi__YCbC:

; 3341 :    }
; 3342 : }

	pop	ebp
	ret	0
_stbi__YCbCr_to_RGB_row ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\apis\stb\stb_image.h
;	COMDAT _stbi__YCbCr_to_RGB_simd
_TEXT	SEGMENT
_r$1$ = -16						; size = 4
tv650 = -16						; size = 4
_i$1$ = -16						; size = 4
tv652 = -12						; size = 4
tv647 = -12						; size = 4
tv649 = -8						; size = 4
tv651 = -4						; size = 4
_out$ = 8						; size = 4
_y$ = 12						; size = 4
_pcb$ = 16						; size = 4
_pcr$ = 20						; size = 4
_count$ = 24						; size = 4
_step$ = 28						; size = 4
_stbi__YCbCr_to_RGB_simd PROC				; COMDAT

; 3346 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H

; 3357 :       __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3358 :       __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3359 :       __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3360 :       __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
; 3361 :       __m128i xw = _mm_set1_epi16(255); // alpha channel
; 3362 : 
; 3363 :       for (; i+7 < count; i += 8) {

	mov	ecx, DWORD PTR _count$[ebp]
	xor	eax, eax
	cmp	DWORD PTR _step$[ebp], 4
	push	esi
	push	edi
	mov	DWORD PTR _i$1$[esp+24], eax
	jne	$LN27@stbi__YCbC

; 3347 :    int i = 0;
; 3348 : 
; 3349 : #ifdef STBI_SSE2
; 3350 :    // step == 3 is pretty ugly on the final interleave, and i'm not convinced
; 3351 :    // it's useful in practice (you wouldn't use it for textures, for example).
; 3352 :    // so just accelerate step == 4 case.
; 3353 :    if (step == 4) {
; 3354 :       // this is a fairly straightforward implementation and not super-optimized.
; 3355 :       __m128i signflip  = _mm_set1_epi8(-0x80);
; 3356 :       __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));

	movdqa	xmm5, XMMWORD PTR __xmm@80808080808080808080808080808080
	movdqa	xmm7, XMMWORD PTR __xmm@166f166f166f166f166f166f166f166f

; 3357 :       __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3358 :       __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3359 :       __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3360 :       __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
; 3361 :       __m128i xw = _mm_set1_epi16(255); // alpha channel
; 3362 : 
; 3363 :       for (; i+7 < count; i += 8) {

	cmp	ecx, 7
	jle	$LN27@stbi__YCbC
	mov	edx, DWORD PTR _pcb$[ebp]
	mov	esi, 7
	mov	edi, DWORD PTR _y$[ebp]
	sub	esi, edx
	mov	eax, DWORD PTR _pcr$[ebp]
	sub	edi, edx
	sub	eax, edx
	mov	DWORD PTR tv650[esp+24], edi
	mov	edi, DWORD PTR _out$[ebp]
	xorps	xmm6, xmm6
	mov	DWORD PTR tv649[esp+24], esi
	xor	esi, esi
	mov	DWORD PTR tv651[esp+24], eax
	npad	1
$LL15@stbi__YCbC:

; 3364 :          // load
; 3365 :          __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
; 3366 :          __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));

	movq	xmm0, QWORD PTR [eax+edx]

; 3367 :          __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
; 3368 :          __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
; 3369 :          __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128
; 3370 : 
; 3371 :          // unpack to short (and left-shift cr, cb by 8)
; 3372 :          __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
; 3373 :          __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);

	movdqa	xmm2, xmm6
	mov	eax, DWORD PTR tv650[esp+24]
	pxor	xmm0, xmm5
	punpcklbw xmm2, xmm0

; 3374 :          __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

	movdqa	xmm4, xmm6
	movq	xmm0, QWORD PTR [edx]
	movdqa	xmm1, xmm5
	pxor	xmm0, xmm5

; 3375 : 
; 3376 :          // color transform
; 3377 :          __m128i yws = _mm_srli_epi16(yw, 4);
; 3378 :          __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);

	movdqa	xmm3, xmm2

; 3379 :          __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
; 3380 :          __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
; 3381 :          __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);

	pmulhw	xmm2, XMMWORD PTR __xmm@f493f493f493f493f493f493f493f493
	add	esi, 8
	punpcklbw xmm4, xmm0
	movq	xmm0, QWORD PTR [eax+edx]
	add	edx, 8
	punpcklbw xmm1, xmm0
	movdqa	xmm0, xmm4
	pmulhw	xmm0, XMMWORD PTR __xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
	pmulhw	xmm4, XMMWORD PTR __xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
	mov	eax, DWORD PTR tv649[esp+24]
	pmulhw	xmm3, xmm7
	add	eax, edx
	psrlw	xmm1, 4

; 3382 :          __m128i rws = _mm_add_epi16(cr0, yws);
; 3383 :          __m128i gwt = _mm_add_epi16(cb0, yws);
; 3384 :          __m128i bws = _mm_add_epi16(yws, cb1);

	paddw	xmm0, xmm1
	paddw	xmm4, xmm1

; 3385 :          __m128i gws = _mm_add_epi16(gwt, cr1);
; 3386 : 
; 3387 :          // descale
; 3388 :          __m128i rw = _mm_srai_epi16(rws, 4);
; 3389 :          __m128i bw = _mm_srai_epi16(bws, 4);

	psraw	xmm0, 4
	paddw	xmm4, xmm2
	paddw	xmm3, xmm1

; 3390 :          __m128i gw = _mm_srai_epi16(gws, 4);

	psraw	xmm4, 4
	psraw	xmm3, 4

; 3391 : 
; 3392 :          // back to byte, set up for transpose
; 3393 :          __m128i brb = _mm_packus_epi16(rw, bw);
; 3394 :          __m128i gxb = _mm_packus_epi16(gw, xw);

	packuswb xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	packuswb xmm3, xmm0

; 3395 : 
; 3396 :          // transpose to interleave channels
; 3397 :          __m128i t0 = _mm_unpacklo_epi8(brb, gxb);

	movdqa	xmm1, xmm3

; 3398 :          __m128i t1 = _mm_unpackhi_epi8(brb, gxb);

	punpckhbw xmm3, xmm4
	punpcklbw xmm1, xmm4

; 3399 :          __m128i o0 = _mm_unpacklo_epi16(t0, t1);

	movdqa	xmm0, xmm1

; 3400 :          __m128i o1 = _mm_unpackhi_epi16(t0, t1);

	punpckhwd xmm1, xmm3
	punpcklwd xmm0, xmm3

; 3401 : 
; 3402 :          // store
; 3403 :          _mm_storeu_si128((__m128i *) (out + 0), o0);

	movdqu	XMMWORD PTR [edi], xmm0

; 3404 :          _mm_storeu_si128((__m128i *) (out + 16), o1);

	movdqu	XMMWORD PTR [edi+16], xmm1

; 3405 :          out += 32;

	add	edi, 32					; 00000020H
	cmp	eax, ecx
	mov	eax, DWORD PTR tv651[esp+24]
	jl	$LL15@stbi__YCbC
	mov	DWORD PTR _i$1$[esp+24], esi
	mov	eax, esi
	jmp	SHORT $LN29@stbi__YCbC
$LN27@stbi__YCbC:

; 3357 :       __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3358 :       __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3359 :       __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3360 :       __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
; 3361 :       __m128i xw = _mm_set1_epi16(255); // alpha channel
; 3362 : 
; 3363 :       for (; i+7 < count; i += 8) {

	mov	edi, DWORD PTR _out$[ebp]
$LN29@stbi__YCbC:
	mov	esi, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR _pcb$[ebp]

; 3406 :       }
; 3407 :    }
; 3408 : #endif
; 3409 : 
; 3410 : #ifdef STBI_NEON
; 3411 :    // in this version, step=3 support would be easy to add. but is there demand?
; 3412 :    if (step == 4) {
; 3413 :       // this is a fairly straightforward implementation and not super-optimized.
; 3414 :       uint8x8_t signflip = vdup_n_u8(0x80);
; 3415 :       int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3416 :       int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3417 :       int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3418 :       int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3419 : 
; 3420 :       for (; i+7 < count; i += 8) {
; 3421 :          // load
; 3422 :          uint8x8_t y_bytes  = vld1_u8(y + i);
; 3423 :          uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3424 :          uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3425 :          int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3426 :          int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3427 : 
; 3428 :          // expand to s16
; 3429 :          int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3430 :          int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3431 :          int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3432 : 
; 3433 :          // color transform
; 3434 :          int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3435 :          int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3436 :          int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3437 :          int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3438 :          int16x8_t rws = vaddq_s16(yws, cr0);
; 3439 :          int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3440 :          int16x8_t bws = vaddq_s16(yws, cb1);
; 3441 : 
; 3442 :          // undo scaling, round, convert to byte
; 3443 :          uint8x8x4_t o;
; 3444 :          o.val[0] = vqrshrun_n_s16(rws, 4);
; 3445 :          o.val[1] = vqrshrun_n_s16(gws, 4);
; 3446 :          o.val[2] = vqrshrun_n_s16(bws, 4);
; 3447 :          o.val[3] = vdup_n_u8(255);
; 3448 : 
; 3449 :          // store, interleaving r/g/b/a
; 3450 :          vst4_u8(out, o);
; 3451 :          out += 8*4;
; 3452 :       }
; 3453 :    }
; 3454 : #endif
; 3455 : 
; 3456 :    for (; i < count; ++i) {

	cmp	eax, ecx
	jge	$LN10@stbi__YCbC
	mov	ecx, DWORD PTR _pcr$[ebp]
	add	edi, 2
	add	eax, ecx

; 3473 :       out[3] = 255;

	sub	esi, ecx
	sub	edx, ecx
	mov	DWORD PTR tv647[esp+24], eax
	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, DWORD PTR _i$1$[esp+24]
	mov	DWORD PTR _y$[ebp], esi
	mov	DWORD PTR _pcb$[ebp], edx
	mov	DWORD PTR _count$[ebp], ecx
	npad	5
$LL12@stbi__YCbC:

; 3457 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3458 :       int r,g,b;
; 3459 :       int cr = pcr[i] - 128;
; 3460 :       int cb = pcb[i] - 128;

	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR [edx+eax]
	add	ecx, -128				; ffffff80H
	movzx	esi, BYTE PTR [esi+eax]
	add	edx, -128				; ffffff80H

; 3461 :       r = y_fixed + cr* stbi__float2fixed(1.40200f);

	imul	eax, ecx, 1470208
	shl	esi, 20					; 00000014H
	add	esi, 524288				; 00080000H

; 3462 :       g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);

	imul	ecx, ecx, 748800
	add	eax, esi

; 3463 :       b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
; 3464 :       r >>= 20;

	sar	eax, 20					; 00000014H
	mov	DWORD PTR _r$1$[esp+24], eax
	imul	eax, edx, -360960
	imul	edx, edx, 1858048
	and	eax, -65536				; ffff0000H

; 3465 :       g >>= 20;

	sub	eax, ecx
	add	edx, esi
	add	eax, esi

; 3466 :       b >>= 20;

	sar	edx, 20					; 00000014H
	sar	eax, 20					; 00000014H

; 3467 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }

	cmp	DWORD PTR _r$1$[esp+24], 255		; 000000ffH
	jbe	SHORT $LN8@stbi__YCbC
	xor	esi, esi
	mov	ecx, 255				; 000000ffH
	cmp	DWORD PTR _r$1$[esp+24], esi
	cmovl	ecx, esi
	mov	DWORD PTR _r$1$[esp+24], ecx
$LN8@stbi__YCbC:

; 3468 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }

	cmp	eax, 255				; 000000ffH
	jbe	SHORT $LN5@stbi__YCbC
	xor	esi, esi
	mov	ecx, 255				; 000000ffH
	test	eax, eax
	cmovs	ecx, esi
	mov	eax, ecx
$LN5@stbi__YCbC:

; 3469 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }

	cmp	edx, 255				; 000000ffH
	jbe	SHORT $LN2@stbi__YCbC
	xor	esi, esi
	mov	ecx, 255				; 000000ffH
	test	edx, edx
	cmovs	ecx, esi
	mov	edx, ecx
$LN2@stbi__YCbC:

; 3470 :       out[0] = (stbi_uc)r;

	mov	ecx, DWORD PTR _r$1$[esp+24]
	mov	esi, DWORD PTR _y$[ebp]

; 3471 :       out[1] = (stbi_uc)g;

	mov	BYTE PTR [edi-1], al
	mov	eax, DWORD PTR tv647[esp+24]

; 3472 :       out[2] = (stbi_uc)b;

	mov	BYTE PTR [edi], dl
	inc	eax
	mov	edx, DWORD PTR _pcb$[ebp]
	mov	BYTE PTR [edi-2], cl

; 3473 :       out[3] = 255;

	mov	BYTE PTR [edi+1], 255			; 000000ffH

; 3474 :       out += step;

	add	edi, DWORD PTR _step$[ebp]
	dec	DWORD PTR _count$[ebp]
	mov	DWORD PTR tv647[esp+24], eax
	jne	$LL12@stbi__YCbC
$LN10@stbi__YCbC:

; 3475 :    }
; 3476 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi__YCbCr_to_RGB_simd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _LogIn
_TEXT	SEGMENT
_userdata$ = 8						; size = 4
_category$ = 12						; size = 4
_log$ = 16						; size = 4
_message$ = 20						; size = 4
_LogIn	PROC						; COMDAT

; 80   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 81   : 	FILE *file;
; 82   : 	size_t size;
; 83   : 	if((file=fopen("mgear.log","a+"))==NULL)

	push	OFFSET ??_C@_02DPNLHKJD@a?$CL?$AA@
	push	OFFSET ??_C@_09JFHIBJMD@mgear?4log?$AA@
	call	_fopen
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN1@LogIn

; 84   : 	{
; 85   : 		if(MessageBox(NULL,L"Opening log file failed",NULL,MB_OK | MB_ICONERROR)==IDOK)

	push	16					; 00000010H
	push	eax
	push	OFFSET ??_C@_1DA@PFAEBODD@?$AAO?$AAp?$AAe?$AAn?$AAi?$AAn?$AAg?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@
	push	eax
	call	DWORD PTR __imp__MessageBoxW@16
	cmp	eax, 1
	je	SHORT $LN6@LogIn
$LN1@LogIn:

; 87   : 	}
; 88   : 
; 89   : 	fseek(file,0,SEEK_END);

	push	2
	push	0
	push	esi
	call	_fseek

; 90   : 	fprintf(file,"%s\n",message);

	push	DWORD PTR _message$[ebp]
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	push	esi
	call	_fprintf

; 91   : 
; 92   : 	fclose(file);

	push	esi
	call	_fclose
	add	esp, 28					; 0000001cH
	pop	esi

; 93   : }

	pop	ebp
	ret	0
$LN6@LogIn:

; 86   : 			Quit();

	call	_Quit
$LN8@LogIn:
$LN5@LogIn:
	int	3
_LogIn	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CreateLog
_TEXT	SEGMENT
_CreateLog PROC						; COMDAT

; 96   : {

	push	esi

; 97   : 	FILE *file;
; 98   : 	float version=_ENGINE_VERSION;
; 99   : 	if((file=fopen("mgear.log","w"))==NULL)

	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	OFFSET ??_C@_09JFHIBJMD@mgear?4log?$AA@
	call	_fopen
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN1@CreateLog

; 100  : 	{
; 101  : 		if(MessageBox(NULL,L"Create log failed",NULL,MB_OK | MB_ICONERROR)==IDOK) 

	push	16					; 00000010H
	push	eax
	push	OFFSET ??_C@_1CE@CDPPCMAP@?$AAC?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAl?$AAo?$AAg?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AA@
	push	eax
	call	DWORD PTR __imp__MessageBoxW@16
	cmp	eax, 1
	je	SHORT $LN6@CreateLog
$LN1@CreateLog:

; 103  : 	}
; 104  : 
; 105  : 	SDL_LogSetOutputFunction(&LogIn,NULL);

	push	0
	push	OFFSET _LogIn
	call	DWORD PTR __imp__SDL_LogSetOutputFunction

; 106  : 
; 107  : 	fprintf(file,"%s %.2f\n",st.WindowTitle,version);

	movsd	xmm0, QWORD PTR __real@3f847ae140000000
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET _st+196
	push	OFFSET ??_C@_08PJPFOJIA@?$CFs?5?$CF?42f?6?$AA@
	push	esi
	call	_fprintf

; 108  : 	fprintf(file,"Engine started\n");

	push	OFFSET ??_C@_0BA@BIGBPAJK@Engine?5started?6?$AA@
	push	esi
	call	_fprintf

; 109  : 	fprintf(file,"Log created\n");

	push	OFFSET ??_C@_0N@JPOOLMEG@Log?5created?6?$AA@
	push	esi
	call	_fprintf

; 110  : 
; 111  : 	fclose(file);

	push	esi
	call	_fclose
	add	esp, 40					; 00000028H

; 112  : }

	pop	esi
	ret	0
$LN6@CreateLog:

; 102  : 			exit(1);

	push	1
	call	_exit
$LN8@CreateLog:
$LN5@CreateLog:
	int	3
_CreateLog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT @SetTimerM@8
_TEXT	SEGMENT
_x$dead$ = 8						; size = 8
@SetTimerM@8 PROC					; COMDAT

; 123  : 	st.time+=x;

	add	DWORD PTR _st+64272, 1
	adc	DWORD PTR _st+64276, 0

; 124  : }

	ret	8
@SetTimerM@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _FPSCounter
_TEXT	SEGMENT
_FPSCounter PROC					; COMDAT

; 132  : {

	push	esi

; 133  : 	if((SDL_GetTicks() - st.FPSTime)!=0)

	mov	esi, DWORD PTR __imp__SDL_GetTicks
	call	esi
	sub	eax, DWORD PTR _st+2335432
	je	SHORT $LN1@FPSCounter

; 134  : 	{
; 135  : 		st.FPS=SDL_GetTicks()-st.FPSTime;

	call	esi
	sub	eax, DWORD PTR _st+2335432

; 136  : 		st.FPS=1000/st.FPS;
; 137  : 		sprintf(st.WINDOW_NAME,"%s fps: %.2f",st.WindowTitle,st.FPS);

	sub	esp, 8
	movss	xmm1, DWORD PTR __real@447a0000
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	cvtps2pd xmm0, xmm1
	movss	DWORD PTR _st+2335436, xmm1
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET _st+196
	push	OFFSET ??_C@_0N@NDCMMGFF@?$CFs?5fps?3?5?$CF?42f?$AA@
	push	OFFSET _st+132
	call	_sprintf

; 138  : 		//if(st.FPS<50) printf("%d\n",st.time);
; 139  : 		//st.FPS=0;
; 140  : 		st.FPSTime=SDL_GetTicks();

	call	esi

; 141  : 		SDL_SetWindowTitle(wn,st.WINDOW_NAME);

	push	OFFSET _st+132
	push	DWORD PTR _wn
	mov	DWORD PTR _st+2335432, eax
	call	DWORD PTR __imp__SDL_SetWindowTitle
	add	esp, 28					; 0000001cH
$LN1@FPSCounter:

; 142  : 	}
; 143  : }

	pop	esi
	ret	0
_FPSCounter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _WTSf
_TEXT	SEGMENT
_WTSf	PROC						; COMDAT
; _x$ = ecx
; _y$ = edx

; 201  : {

	movd	xmm0, DWORD PTR _st+2335380

; 202  : 	*x-=st.Camera.position.x;

	movss	xmm1, DWORD PTR [ecx]
	cvtdq2ps xmm0, xmm0
	subss	xmm1, xmm0
	movss	DWORD PTR [ecx], xmm1
	movd	xmm0, DWORD PTR _st+2335384

; 203  : 	*y-=st.Camera.position.y;

	movss	xmm1, DWORD PTR [edx]
	cvtdq2ps xmm0, xmm0
	subss	xmm1, xmm0
	movss	DWORD PTR [edx], xmm1

; 204  : 
; 205  : 	*x=(float) ((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;

	movzx	eax, WORD PTR _st+228
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR __real@38800000
	mulss	xmm0, DWORD PTR _st+2335396
	movss	DWORD PTR [ecx], xmm0

; 206  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;

	movzx	eax, WORD PTR _st+230
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR [edx]
	divss	xmm0, DWORD PTR __real@46100000
	mulss	xmm0, DWORD PTR _st+2335400
	movss	DWORD PTR [edx], xmm0

; 207  : }

	ret	0
_WTSf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _mCos
_TEXT	SEGMENT
_mCos	PROC						; COMDAT
; _ang$ = ecx

; 217  : 	if(ang>3600) ang-=3600;

	mov	eax, 3600				; 00000e10H
	cmp	cx, ax
	jle	SHORT $LN3@mCos
	sub	ecx, eax

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	eax, cx
	movss	xmm0, DWORD PTR _st[eax*4+2717808]

; 221  : }

	ret	0
$LN3@mCos:

; 218  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN6@mCos
	add	ecx, eax
$LN6@mCos:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	eax, cx
	movss	xmm0, DWORD PTR _st[eax*4+2717808]

; 221  : }

	ret	0
_mCos	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _mSin
_TEXT	SEGMENT
_mSin	PROC						; COMDAT
; _ang$ = ecx

; 225  : 	if(ang>3600) ang-=3600;

	mov	eax, 3600				; 00000e10H
	cmp	cx, ax
	jle	SHORT $LN3@mSin
	sub	ecx, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	movsx	eax, cx
	movss	xmm0, DWORD PTR _st[eax*4+2732212]

; 229  : }

	ret	0
$LN3@mSin:

; 226  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN6@mSin
	add	ecx, eax
$LN6@mSin:

; 227  : 
; 228  : 	return st.SinTable[ang];

	movsx	eax, cx
	movss	xmm0, DWORD PTR _st[eax*4+2732212]

; 229  : }

	ret	0
_mSin	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _Quit
_TEXT	SEGMENT
_Quit	PROC						; COMDAT

; 538  : 	//ResetVB();
; 539  : 	InputClose();

	call	_InputClose

; 540  : 	SDL_DestroyWindow(wn);

	push	DWORD PTR _wn
	call	DWORD PTR __imp__SDL_DestroyWindow
	add	esp, 4

; 541  : 	SDL_Quit();

	call	DWORD PTR __imp__SDL_Quit

; 542  : #ifndef MGEAR_CLEAN_VERSION
; 543  : 	FMOD_System_Close(st.sound_sys.Sound_System);
; 544  : 	FMOD_System_Release(st.sound_sys.Sound_System);
; 545  : #endif
; 546  : 	TTF_Quit();

	call	DWORD PTR __imp__TTF_Quit

; 547  : 	exit(1);

	push	1
	call	_exit
$LN4@Quit:
$LN3@Quit:
	int	3
_Quit	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CreateVAO
_TEXT	SEGMENT
_col$1$ = -16						; size = 4
_texl$1$ = -12						; size = 4
_texc$1$ = -8						; size = 4
_pos$1$ = -4						; size = 4
_pr$dead$ = 8						; size = 1
_CreateVAO PROC						; COMDAT
; _data$ = ecx
; _type$ = dl

; 995  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	mov	bl, dl
	push	edi
	mov	edi, ecx

; 996  : 	GLint pos, texc, col, texl, texr;
; 997  : 
; 998  : 	if(type==1)

	cmp	bl, 1
	jne	SHORT $LN3@CreateVAO

; 999  : 	{
; 1000 : 		data->buffer_elements=1;
; 1001 : 		data->num_elements=1;

	mov	DWORD PTR [edi+46], 65537		; 00010001H
$LN3@CreateVAO:

; 1002 : 	}
; 1003 : 
; 1004 : 	glGenVertexArrays(1,&data->vao_id);

	push	edi
	push	1
	call	DWORD PTR _GLeeFuncPtr_glGenVertexArrays

; 1005 : 	glBindVertexArray(data->vao_id);

	push	DWORD PTR [edi]
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray

; 1006 : 
; 1007 : 	col=glGetAttribLocation(st.renderer.Program[pr],"Color");

	push	OFFSET ??_C@_05PDOBBJNA@Color?$AA@
	push	DWORD PTR _st+2336660
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation

; 1008 : 	pos=glGetAttribLocation(st.renderer.Program[pr],"Position");

	push	OFFSET ??_C@_08GCJNLIKG@Position?$AA@
	push	DWORD PTR _st+2336660
	mov	esi, eax
	mov	DWORD PTR _col$1$[ebp], esi
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation

; 1009 : 	texc=glGetAttribLocation(st.renderer.Program[pr],"TexCoord");

	push	OFFSET ??_C@_08NGMLKGCO@TexCoord?$AA@
	push	DWORD PTR _st+2336660
	mov	DWORD PTR _pos$1$[ebp], eax
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation

; 1010 : 	texl=glGetAttribLocation(st.renderer.Program[pr],"TexLight");

	push	OFFSET ??_C@_08DGBKPNED@TexLight?$AA@
	push	DWORD PTR _st+2336660
	mov	DWORD PTR _texc$1$[ebp], eax
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation

; 1011 : 	//texr=glGetAttribLocation(st.renderer.Program[pr],"TexRepeat");
; 1012 : 
; 1013 : 
; 1014 : 	glEnableVertexAttribArray(pos);

	push	DWORD PTR _pos$1$[ebp]
	mov	DWORD PTR _texl$1$[ebp], eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray

; 1015 : 	glEnableVertexAttribArray(texc);

	push	DWORD PTR _texc$1$[ebp]
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray

; 1016 : 	glEnableVertexAttribArray(col);

	push	esi
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray

; 1017 : 	glEnableVertexAttribArray(texl);

	push	DWORD PTR _texl$1$[ebp]
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray

; 1018 : 	//glEnableVertexAttribArray(texr);
; 1019 : 
; 1020 : 	glGenBuffers(1,&data->vbo_id);

	lea	esi, DWORD PTR [edi+8]
	push	esi
	push	1
	call	DWORD PTR _GLeeFuncPtr_glGenBuffers

; 1021 : 	glBindBuffer(GL_ARRAY_BUFFER,data->vbo_id);

	push	DWORD PTR [esi]
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer

; 1022 : 
; 1023 : 	glBufferData(GL_ARRAY_BUFFER,((data->buffer_elements*12)*sizeof(GLfloat))+((data->buffer_elements*8)*sizeof(GLfloat))+((data->buffer_elements*16)*sizeof(GLubyte))+((data->buffer_elements*8)*sizeof(GLfloat))+((data->buffer_elements*4)*sizeof(GLfloat)),NULL,GL_STREAM_DRAW);

	movzx	eax, WORD PTR [edi+48]
	push	35040					; 000088e0H
	push	0
	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 4
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferData

; 1024 : 	/*
; 1025 : 	glBufferSubData(GL_ARRAY_BUFFER,0,(12*data->num_elements)*sizeof(GLfloat),data->vertex);
; 1026 : 	glBufferSubData(GL_ARRAY_BUFFER,(12*data->num_elements)*sizeof(GLfloat),(8*data->num_elements)*sizeof(GLfloat),data->texcoord);
; 1027 : 	glBufferSubData(GL_ARRAY_BUFFER,(12*data->num_elements)*sizeof(GLfloat)+(8*data->num_elements)*sizeof(GLfloat),(((data->num_elements*16)*sizeof(GLubyte))),data->color);
; 1028 : 	*/
; 1029 : 
; 1030 : 	glVertexAttribPointer(pos,3,GL_FLOAT,GL_FALSE,0,0);

	push	0
	push	0
	push	0
	push	5126					; 00001406H
	push	3
	push	DWORD PTR _pos$1$[ebp]
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer

; 1031 : 	glVertexAttribPointer(texc,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) ((12*data->buffer_elements)*sizeof(GLfloat)));

	movzx	eax, WORD PTR [edi+48]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	push	eax
	push	0
	push	0
	push	5126					; 00001406H
	push	2
	push	DWORD PTR _texc$1$[ebp]
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer

; 1032 : 	glVertexAttribPointer(col,4,GL_UNSIGNED_BYTE,GL_TRUE,0,(GLvoid*) ((12*data->buffer_elements)*sizeof(GLfloat)+(8*data->buffer_elements)*sizeof(GLfloat)));

	movzx	eax, WORD PTR [edi+48]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 4
	push	eax
	push	0
	push	1
	push	5121					; 00001401H
	push	4
	push	DWORD PTR _col$1$[ebp]
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer

; 1033 : 	glVertexAttribPointer(texl,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((16*data->buffer_elements)*sizeof(GLubyte))));

	movzx	eax, WORD PTR [edi+48]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 5
	push	eax
	push	0
	push	0
	push	5126					; 00001406H
	push	2
	push	DWORD PTR _texl$1$[ebp]
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer

; 1034 : 	//glVertexAttribPointer(texr,4,GL_FLOAT,GL_FALSE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((16*data->buffer_elements)*sizeof(GLubyte))+((data->buffer_elements*8)*sizeof(GLfloat))));
; 1035 : 
; 1036 : 
; 1037 : 	glGenBuffers(1,&data->ibo_id);

	lea	esi, DWORD PTR [edi+4]
	push	esi
	push	1
	call	DWORD PTR _GLeeFuncPtr_glGenBuffers

; 1038 : 	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,data->ibo_id);

	push	DWORD PTR [esi]
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer

; 1039 : 
; 1040 : 	if(type==1)
; 1041 : 		glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*data->buffer_elements)*sizeof(GLushort),data->index,GL_STATIC_DRAW);

	movzx	eax, WORD PTR [edi+48]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	cmp	bl, 1
	jne	SHORT $LN2@CreateVAO
	push	35044					; 000088e4H
	push	DWORD PTR [edi+32]

; 1042 : 	else

	jmp	SHORT $LN6@CreateVAO
$LN2@CreateVAO:

; 1043 : 		glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*data->buffer_elements)*sizeof(GLushort),NULL,GL_DYNAMIC_DRAW);

	push	35048					; 000088e8H
	push	0
$LN6@CreateVAO:
	push	eax
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBufferData

; 1044 : 	
; 1045 : 	glBindVertexArray(0);

	push	0
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray

; 1046 : 
; 1047 : 	glDisableVertexAttribArray(pos);

	push	DWORD PTR _pos$1$[ebp]
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray

; 1048 : 	glDisableVertexAttribArray(texc);

	push	DWORD PTR _texc$1$[ebp]
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray

; 1049 : 	glDisableVertexAttribArray(col);

	push	DWORD PTR _col$1$[ebp]
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray

; 1050 : 	glDisableVertexAttribArray(texl);

	push	DWORD PTR _texl$1$[ebp]
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray

; 1051 : 	//glDisableVertexAttribArray(texr);
; 1052 : 
; 1053 : 	data->num_elements2=0;

	xor	eax, eax
	mov	WORD PTR [edi+50], ax
	pop	edi
	pop	esi
	pop	ebx

; 1054 : 	
; 1055 : 	/*
; 1056 : 	free(data->texcoord);
; 1057 : 	free(data->index);
; 1058 : 	free(data->color);
; 1059 : 	free(data->vertex);
; 1060 : 	*/
; 1061 : 
; 1062 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CreateVAO ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _UpdateVAO
_TEXT	SEGMENT
_col$1$ = -8						; size = 4
_data$1$ = -4						; size = 4
_upd_index$ = 8						; size = 1
_pr$dead$ = 12						; size = 1
_UpdateVAO PROC						; COMDAT
; _data$ = ecx
; _upd_buff$ = dl

; 1065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _data$1$[ebp], ebx

; 1066 : 	GLint pos, texc, col, texl, texr;
; 1067 : 	GLenum error;
; 1068 : 
; 1069 : 	//glUseProgram(st.renderer.Program[pr]);
; 1070 : 
; 1071 : 	if(!upd_buff)

	test	dl, dl
	jne	$LN8@UpdateVAO

; 1072 : 	{
; 1073 : 		if(data->num_elements>data->buffer_elements) return 1;

	mov	ax, WORD PTR [ebx+46]
	cmp	ax, WORD PTR [ebx+48]
	jbe	SHORT $LN7@UpdateVAO
	mov	eax, 1
	pop	ebx

; 1210 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@UpdateVAO:

; 1074 : 		else
; 1075 : 		{
; 1076 : 			
; 1077 : 			glBindVertexArray(data->vao_id);

	push	DWORD PTR [ebx]
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray

; 1078 : 			glBindBuffer(GL_ARRAY_BUFFER,data->vbo_id);

	push	DWORD PTR [ebx+8]
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer

; 1079 : 
; 1080 : 			glBufferSubData(GL_ARRAY_BUFFER,0,(12*data->num_elements)*sizeof(GLfloat),data->vertex);

	movzx	eax, WORD PTR [ebx+46]
	push	DWORD PTR [ebx+12]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	push	eax
	push	0
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 1081 : 			glBufferSubData(GL_ARRAY_BUFFER,(12*data->buffer_elements)*sizeof(GLfloat),(8*data->num_elements)*sizeof(GLfloat),data->texcoord);

	push	DWORD PTR [ebx+16]
	movzx	eax, WORD PTR [ebx+46]
	shl	eax, 5
	push	eax
	movzx	eax, WORD PTR [ebx+48]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 1082 : 			glBufferSubData(GL_ARRAY_BUFFER,(((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))),(((data->num_elements*16)*sizeof(GLubyte))),data->color);

	push	DWORD PTR [ebx+28]
	movzx	eax, WORD PTR [ebx+46]
	shl	eax, 4
	push	eax
	movzx	eax, WORD PTR [ebx+48]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 4
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 1083 : 			glBufferSubData(GL_ARRAY_BUFFER,(((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((data->buffer_elements*16)*sizeof(GLubyte))),(data->num_elements*8)*sizeof(float),data->texcoordlight);

	push	DWORD PTR [ebx+20]
	movzx	eax, WORD PTR [ebx+46]
	shl	eax, 5
	push	eax
	movzx	eax, WORD PTR [ebx+48]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 5
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 1084 : 		//	glBufferSubData(GL_ARRAY_BUFFER,(((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((data->buffer_elements*16)*sizeof(GLubyte))+((data->num_elements*8)*sizeof(float))),(data->num_elements*4)*sizeof(float),data->texrepeat);
; 1085 : 
; 1086 : 			if(upd_index)

	cmp	BYTE PTR _upd_index$[ebp], 0
	je	SHORT $LN5@UpdateVAO

; 1087 : 			{
; 1088 : 				glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,data->ibo_id);

	push	DWORD PTR [ebx+4]
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer

; 1089 : 				glBufferSubData(GL_ELEMENT_ARRAY_BUFFER,0,(6*data->num_elements)*sizeof(GLushort),data->index);

	movzx	eax, WORD PTR [ebx+46]
	push	DWORD PTR [ebx+32]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	push	eax
	push	0
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData
$LN5@UpdateVAO:

; 1090 : 				//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);
; 1091 : 			}
; 1092 : 
; 1093 : 			glBindVertexArray(0);

	push	0
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray

; 1094 : 			
; 1095 : 			
; 1096 : 			free(data->texcoord);

	push	DWORD PTR [ebx+16]
	call	_free

; 1097 : 			free(data->index);

	push	DWORD PTR [ebx+32]
	call	_free

; 1098 : 			free(data->color);

	push	DWORD PTR [ebx+28]
	call	_free

; 1099 : 			free(data->vertex);

	push	DWORD PTR [ebx+12]
	call	_free

; 1100 : 			free(data->texcoordlight);

	push	DWORD PTR [ebx+20]
	call	_free
	add	esp, 20					; 00000014H

; 1163 : 		//free(data->texrepeat);
; 1164 : 	}
; 1165 : 	else
; 1166 : 	if(upd_buff==2)
; 1167 : 	{
; 1168 : 		glBindVertexArray(data->vao_id);
; 1169 : 		glBindBuffer(GL_ARRAY_BUFFER,data->vbo_id);
; 1170 : 		//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,data->ibo_id);
; 1171 : 
; 1172 : 		col=glGetAttribLocation(st.renderer.Program[pr],"Color");
; 1173 : 		pos=glGetAttribLocation(st.renderer.Program[pr],"Position");
; 1174 : 		texc=glGetAttribLocation(st.renderer.Program[pr],"TexCoord");
; 1175 : 		texl=glGetAttribLocation(st.renderer.Program[pr],"TexLight");
; 1176 : 		//texr=glGetAttribLocation(st.renderer.Program[pr],"TexRepeat");
; 1177 : 
; 1178 : 		glEnableVertexAttribArray(pos);
; 1179 : 		glEnableVertexAttribArray(texc);
; 1180 : 		glEnableVertexAttribArray(col);
; 1181 : 		glEnableVertexAttribArray(texl);
; 1182 : 		//glEnableVertexAttribArray(texr);
; 1183 : 
; 1184 : 		glBufferData(GL_ARRAY_BUFFER,((data->buffer_elements*12)*sizeof(GLfloat))+((data->buffer_elements*8)*sizeof(GLfloat))+((data->buffer_elements*16)*sizeof(GLubyte))+((data->buffer_elements*8)*sizeof(GLfloat))+((data->buffer_elements*4)*sizeof(GLfloat)),NULL,GL_STREAM_DRAW);
; 1185 : 
; 1186 : 		glVertexAttribPointer(pos,3,GL_FLOAT,GL_FALSE,0,0);
; 1187 : 		glVertexAttribPointer(texc,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) ((12*data->buffer_elements)*sizeof(GLfloat)));
; 1188 : 		glVertexAttribPointer(col,4,GL_UNSIGNED_BYTE,GL_TRUE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))));
; 1189 : 		glVertexAttribPointer(texl,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((16*data->buffer_elements)*sizeof(GLubyte))));
; 1190 : 		//glVertexAttribPointer(texr,4,GL_FLOAT,GL_FALSE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((16*data->buffer_elements)*sizeof(GLubyte))+((data->buffer_elements*8)*sizeof(GLfloat))));
; 1191 : 
; 1192 : 		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,data->ibo_id);
; 1193 : 
; 1194 : 		glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*data->buffer_elements)*sizeof(GLushort),NULL,GL_DYNAMIC_DRAW);
; 1195 : 
; 1196 : 		glDisableVertexAttribArray(pos);
; 1197 : 		glDisableVertexAttribArray(texc);
; 1198 : 		glDisableVertexAttribArray(col);
; 1199 : 		glDisableVertexAttribArray(texl);
; 1200 : 		//glDisableVertexAttribArray(texr);
; 1201 : 
; 1202 : 		//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);
; 1203 : 		//glBindBuffer(GL_ARRAY_BUFFER,0);
; 1204 : 		glBindVertexArray(0);
; 1205 : 	}
; 1206 : 
; 1207 : 	//glUseProgram(0);
; 1208 : 
; 1209 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1210 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@UpdateVAO:

; 1101 : 			//free(data->texrepeat);
; 1102 : 			
; 1103 : 		}
; 1104 : 	}
; 1105 : 	else
; 1106 : 	if(upd_buff==1)

	cmp	dl, 1
	jne	$LN3@UpdateVAO

; 1107 : 	{
; 1108 : 		
; 1109 : 		glBindVertexArray(data->vao_id);

	push	esi
	push	edi
	push	DWORD PTR [ebx]
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray

; 1110 : 
; 1111 : 		col=glGetAttribLocation(st.renderer.Program[pr],"Color");

	push	OFFSET ??_C@_05PDOBBJNA@Color?$AA@
	push	DWORD PTR _st+2336660
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation

; 1112 : 		pos=glGetAttribLocation(st.renderer.Program[pr],"Position");

	push	OFFSET ??_C@_08GCJNLIKG@Position?$AA@
	push	DWORD PTR _st+2336660
	mov	DWORD PTR _col$1$[ebp], eax
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation

; 1113 : 		texc=glGetAttribLocation(st.renderer.Program[pr],"TexCoord");

	push	OFFSET ??_C@_08NGMLKGCO@TexCoord?$AA@
	push	DWORD PTR _st+2336660
	mov	ebx, eax
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation

; 1114 : 		texl=glGetAttribLocation(st.renderer.Program[pr],"TexLight");

	push	OFFSET ??_C@_08DGBKPNED@TexLight?$AA@
	push	DWORD PTR _st+2336660
	mov	edi, eax
	call	DWORD PTR _GLeeFuncPtr_glGetAttribLocation

; 1115 : 		//texr=glGetAttribLocation(st.renderer.Program[pr],"TexRepeat");
; 1116 : 
; 1117 : 
; 1118 : 		glEnableVertexAttribArray(pos);

	push	ebx
	mov	esi, eax
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray

; 1119 : 		glEnableVertexAttribArray(texc);

	push	edi
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray

; 1120 : 		glEnableVertexAttribArray(col);

	push	DWORD PTR _col$1$[ebp]
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray

; 1121 : 		glEnableVertexAttribArray(texl);

	push	esi
	call	DWORD PTR _GLeeFuncPtr_glEnableVertexAttribArray

; 1122 : 		//glEnableVertexAttribArray(texr);
; 1123 : 
; 1124 : 		glBindBuffer(GL_ARRAY_BUFFER,data->vbo_id);

	mov	eax, DWORD PTR _data$1$[ebp]
	push	DWORD PTR [eax+8]
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer

; 1125 : 
; 1126 : 		glBufferData(GL_ARRAY_BUFFER,((data->buffer_elements*12)*sizeof(GLfloat))+((data->buffer_elements*8)*sizeof(GLfloat))+((data->buffer_elements*16)*sizeof(GLubyte))+((data->buffer_elements*8)*sizeof(GLfloat))+((data->buffer_elements*4)*sizeof(GLfloat)),NULL,GL_STREAM_DRAW);

	mov	eax, DWORD PTR _data$1$[ebp]
	push	35040					; 000088e0H
	push	0
	movzx	eax, WORD PTR [eax+48]
	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 4
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferData

; 1127 : 
; 1128 : 		glBufferSubData(GL_ARRAY_BUFFER,0,(12*data->num_elements)*sizeof(GLfloat),data->vertex);

	mov	eax, DWORD PTR _data$1$[ebp]
	push	DWORD PTR [eax+12]
	movzx	eax, WORD PTR [eax+46]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	push	eax
	push	0
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 1129 : 		glBufferSubData(GL_ARRAY_BUFFER,(12*data->buffer_elements)*sizeof(GLfloat),(8*data->num_elements)*sizeof(GLfloat),data->texcoord);

	mov	ecx, DWORD PTR _data$1$[ebp]
	push	DWORD PTR [ecx+16]
	movzx	eax, WORD PTR [ecx+46]
	shl	eax, 5
	push	eax
	movzx	eax, WORD PTR [ecx+48]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 1130 : 		glBufferSubData(GL_ARRAY_BUFFER,(((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))),(((data->num_elements*16)*sizeof(GLubyte))),data->color);

	mov	ecx, DWORD PTR _data$1$[ebp]
	push	DWORD PTR [ecx+28]
	movzx	eax, WORD PTR [ecx+46]
	shl	eax, 4
	push	eax
	movzx	eax, WORD PTR [ecx+48]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 4
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 1131 : 		glBufferSubData(GL_ARRAY_BUFFER,(((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((data->buffer_elements*16)*sizeof(GLubyte))),(data->num_elements*8)*sizeof(float),data->texcoordlight);

	mov	ecx, DWORD PTR _data$1$[ebp]
	push	DWORD PTR [ecx+20]
	movzx	eax, WORD PTR [ecx+46]
	shl	eax, 5
	push	eax
	movzx	eax, WORD PTR [ecx+48]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 5
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 1132 : 		//glBufferSubData(GL_ARRAY_BUFFER,(((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((data->buffer_elements*16)*sizeof(GLubyte))+((data->num_elements*8)*sizeof(float))),(data->num_elements*4)*sizeof(float),data->texrepeat);
; 1133 : 
; 1134 : 
; 1135 : 		glVertexAttribPointer(pos,3,GL_FLOAT,GL_FALSE,0,0);

	push	0
	push	0
	push	0
	push	5126					; 00001406H
	push	3
	push	ebx
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer

; 1136 : 		glVertexAttribPointer(texc,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) ((12*data->buffer_elements)*sizeof(GLfloat)));

	mov	ecx, DWORD PTR _data$1$[ebp]
	movzx	eax, WORD PTR [ecx+48]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	push	eax
	push	0
	push	0
	push	5126					; 00001406H
	push	2
	push	edi
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer

; 1137 : 		glVertexAttribPointer(col,4,GL_UNSIGNED_BYTE,GL_TRUE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))));

	mov	ecx, DWORD PTR _data$1$[ebp]
	movzx	eax, WORD PTR [ecx+48]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 4
	push	eax
	push	0
	push	1
	push	5121					; 00001401H
	push	4
	push	DWORD PTR _col$1$[ebp]
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer

; 1138 : 		glVertexAttribPointer(texl,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((16*data->buffer_elements)*sizeof(GLubyte))));

	mov	ecx, DWORD PTR _data$1$[ebp]
	movzx	eax, WORD PTR [ecx+48]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 5
	push	eax
	push	0
	push	0
	push	5126					; 00001406H
	push	2
	push	esi
	call	DWORD PTR _GLeeFuncPtr_glVertexAttribPointer

; 1139 : 		//glVertexAttribPointer(texr,4,GL_FLOAT,GL_FALSE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((16*data->buffer_elements)*sizeof(GLubyte))+((data->buffer_elements*8)*sizeof(GLfloat))));
; 1140 : 
; 1141 : 
; 1142 : 		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,data->ibo_id);

	mov	eax, DWORD PTR _data$1$[ebp]
	push	DWORD PTR [eax+4]
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer

; 1143 : 
; 1144 : 		glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*data->buffer_elements)*sizeof(GLushort),NULL,GL_DYNAMIC_DRAW);

	mov	eax, DWORD PTR _data$1$[ebp]
	push	35048					; 000088e8H
	push	0
	movzx	eax, WORD PTR [eax+48]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	push	eax
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBufferData

; 1145 : 		glBufferSubData(GL_ELEMENT_ARRAY_BUFFER,0,(6*data->num_elements)*sizeof(GLushort),data->index);

	mov	eax, DWORD PTR _data$1$[ebp]
	push	DWORD PTR [eax+32]
	movzx	eax, WORD PTR [eax+46]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	push	eax
	push	0
	push	34963					; 00008893H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 1146 : 
; 1147 : 		glBindVertexArray(0);

	push	0
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray

; 1148 : 
; 1149 : 		glDisableVertexAttribArray(pos);

	push	ebx
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray

; 1150 : 		glDisableVertexAttribArray(texc);

	push	edi
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray

; 1151 : 		glDisableVertexAttribArray(col);

	push	DWORD PTR _col$1$[ebp]
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray

; 1152 : 		glDisableVertexAttribArray(texl);

	push	esi
	call	DWORD PTR _GLeeFuncPtr_glDisableVertexAttribArray

; 1153 : 		//glDisableVertexAttribArray(texr);
; 1154 : 
; 1155 : 		//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);
; 1156 : 		//glBindBuffer(GL_ARRAY_BUFFER,0);
; 1157 : 
; 1158 : 		free(data->texcoord);

	mov	ebx, DWORD PTR _data$1$[ebp]
	push	DWORD PTR [ebx+16]
	call	_free

; 1159 : 		free(data->index);

	push	DWORD PTR [ebx+32]
	call	_free

; 1160 : 		free(data->color);

	push	DWORD PTR [ebx+28]
	call	_free

; 1161 : 		free(data->vertex);

	push	DWORD PTR [ebx+12]
	call	_free

; 1162 : 		free(data->texcoordlight);

	push	DWORD PTR [ebx+20]
	call	_free
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
$LN3@UpdateVAO:

; 1163 : 		//free(data->texrepeat);
; 1164 : 	}
; 1165 : 	else
; 1166 : 	if(upd_buff==2)
; 1167 : 	{
; 1168 : 		glBindVertexArray(data->vao_id);
; 1169 : 		glBindBuffer(GL_ARRAY_BUFFER,data->vbo_id);
; 1170 : 		//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,data->ibo_id);
; 1171 : 
; 1172 : 		col=glGetAttribLocation(st.renderer.Program[pr],"Color");
; 1173 : 		pos=glGetAttribLocation(st.renderer.Program[pr],"Position");
; 1174 : 		texc=glGetAttribLocation(st.renderer.Program[pr],"TexCoord");
; 1175 : 		texl=glGetAttribLocation(st.renderer.Program[pr],"TexLight");
; 1176 : 		//texr=glGetAttribLocation(st.renderer.Program[pr],"TexRepeat");
; 1177 : 
; 1178 : 		glEnableVertexAttribArray(pos);
; 1179 : 		glEnableVertexAttribArray(texc);
; 1180 : 		glEnableVertexAttribArray(col);
; 1181 : 		glEnableVertexAttribArray(texl);
; 1182 : 		//glEnableVertexAttribArray(texr);
; 1183 : 
; 1184 : 		glBufferData(GL_ARRAY_BUFFER,((data->buffer_elements*12)*sizeof(GLfloat))+((data->buffer_elements*8)*sizeof(GLfloat))+((data->buffer_elements*16)*sizeof(GLubyte))+((data->buffer_elements*8)*sizeof(GLfloat))+((data->buffer_elements*4)*sizeof(GLfloat)),NULL,GL_STREAM_DRAW);
; 1185 : 
; 1186 : 		glVertexAttribPointer(pos,3,GL_FLOAT,GL_FALSE,0,0);
; 1187 : 		glVertexAttribPointer(texc,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) ((12*data->buffer_elements)*sizeof(GLfloat)));
; 1188 : 		glVertexAttribPointer(col,4,GL_UNSIGNED_BYTE,GL_TRUE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))));
; 1189 : 		glVertexAttribPointer(texl,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((16*data->buffer_elements)*sizeof(GLubyte))));
; 1190 : 		//glVertexAttribPointer(texr,4,GL_FLOAT,GL_FALSE,0,(GLvoid*) (((12*data->buffer_elements)*sizeof(GLfloat))+((8*data->buffer_elements)*sizeof(GLfloat))+((16*data->buffer_elements)*sizeof(GLubyte))+((data->buffer_elements*8)*sizeof(GLfloat))));
; 1191 : 
; 1192 : 		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,data->ibo_id);
; 1193 : 
; 1194 : 		glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*data->buffer_elements)*sizeof(GLushort),NULL,GL_DYNAMIC_DRAW);
; 1195 : 
; 1196 : 		glDisableVertexAttribArray(pos);
; 1197 : 		glDisableVertexAttribArray(texc);
; 1198 : 		glDisableVertexAttribArray(col);
; 1199 : 		glDisableVertexAttribArray(texl);
; 1200 : 		//glDisableVertexAttribArray(texr);
; 1201 : 
; 1202 : 		//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);
; 1203 : 		//glBindBuffer(GL_ARRAY_BUFFER,0);
; 1204 : 		glBindVertexArray(0);
; 1205 : 	}
; 1206 : 
; 1207 : 	//glUseProgram(0);
; 1208 : 
; 1209 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1210 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_UpdateVAO ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _Init
_TEXT	SEGMENT
tv1645 = -33048						; size = 8
_k$1$ = -33036						; size = 4
_statusCM$ = -33032					; size = 128
_statusLK$ = -32904					; size = 128
_logs$ = -32776						; size = 32768
__$ArrayPad$ = -4					; size = 4
_Init	PROC						; COMDAT

; 1412 : {	

	push	ebp
	mov	ebp, esp
	mov	eax, 33052				; 0000811cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1413 : 	 uint16 i=0, j=0, l=0;
; 1414 : 	 float k=0;
; 1415 : 
; 1416 : 	int check;
; 1417 : #ifndef MGEAR_CLEAN_VERSION
; 1418 : 	FMOD_RESULT result;
; 1419 : #endif
; 1420 : 
; 1421 : 	GLenum checkfb;
; 1422 : 
; 1423 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 1424 : 
; 1425 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER)
; 1426 : 	GLint statusCM[32], statusLK[32];
; 1427 : 	GLchar logs[32][1024];
; 1428 : 
; 1429 : #ifdef _DEBUG
; 1430 : 	printf("Waiting...\n");
; 1431 : 	system("pause");
; 1432 : #endif
; 1433 : 
; 1434 : 	CreateLog();

	call	_CreateLog

; 1435 : 
; 1436 : 	vbd.vertex=(float*) malloc(12*sizeof(float));

	push	48					; 00000030H
	call	_malloc
	add	esp, 4
	mov	esi, eax
	mov	DWORD PTR _vbd+12, esi

; 1437 : 	vbd.texcoord=(float*) malloc(8*sizeof(float));

	push	32					; 00000020H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _vbd+16, eax

; 1438 : #endif
; 1439 : 	vbd.color=(GLubyte*) malloc(16*sizeof(GLubyte));

	push	16					; 00000010H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _vbd+28, eax

; 1440 : 	vbd.index=(GLushort*) malloc(6*sizeof(GLushort));

	push	12					; 0000000cH
	call	_malloc
	mov	DWORD PTR _vbd+32, eax
	xorps	xmm0, xmm0

; 1441 : 	
; 1442 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER)
; 1443 : 
; 1444 : 	vbd.vertex[0]=-1.0f;

	mov	DWORD PTR [esi], -1082130432		; bf800000H
	add	esp, 4

; 1445 : 	vbd.vertex[1]=-1.0f;

	mov	eax, DWORD PTR _vbd+12

; 1446 : 	vbd.vertex[2]=0.0f;

	movss	DWORD PTR _k$1$[ebp], xmm0
	mov	DWORD PTR [eax+4], -1082130432		; bf800000H
	mov	eax, DWORD PTR _vbd+12
	mov	DWORD PTR [eax+8], 0

; 1447 : 	vbd.vertex[3]=1.0f;

	mov	eax, DWORD PTR _vbd+12
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 1448 : 	vbd.vertex[4]=-1.0f;

	mov	eax, DWORD PTR _vbd+12
	mov	DWORD PTR [eax+16], -1082130432		; bf800000H

; 1449 : 	vbd.vertex[5]=0.0f;

	mov	eax, DWORD PTR _vbd+12
	mov	DWORD PTR [eax+20], 0

; 1450 : 	vbd.vertex[6]=1.0f;

	mov	eax, DWORD PTR _vbd+12
	mov	DWORD PTR [eax+24], 1065353216		; 3f800000H

; 1451 : 	vbd.vertex[7]=1.0f;

	mov	eax, DWORD PTR _vbd+12
	mov	DWORD PTR [eax+28], 1065353216		; 3f800000H

; 1452 : 	vbd.vertex[8]=0.0f;

	mov	eax, DWORD PTR _vbd+12
	mov	DWORD PTR [eax+32], 0

; 1453 : 	vbd.vertex[9]=-1.0f;

	mov	eax, DWORD PTR _vbd+12
	mov	DWORD PTR [eax+36], -1082130432		; bf800000H

; 1454 : 	vbd.vertex[10]=1.0f;

	mov	eax, DWORD PTR _vbd+12
	mov	DWORD PTR [eax+40], 1065353216		; 3f800000H

; 1455 : 	vbd.vertex[11]=0.0f;

	mov	eax, DWORD PTR _vbd+12
	mov	DWORD PTR [eax+44], 0

; 1456 : 
; 1457 : 	vbd.texcoord[0]=0.0f;

	mov	eax, DWORD PTR _vbd+16
	mov	DWORD PTR [eax], 0

; 1458 : 	vbd.texcoord[1]=0.0f;

	mov	eax, DWORD PTR _vbd+16
	mov	DWORD PTR [eax+4], 0

; 1459 : 	vbd.texcoord[2]=1.0f;

	mov	eax, DWORD PTR _vbd+16
	mov	DWORD PTR [eax+8], 1065353216		; 3f800000H

; 1460 : 	vbd.texcoord[3]=0.0f;

	mov	eax, DWORD PTR _vbd+16
	mov	DWORD PTR [eax+12], 0

; 1461 : 	vbd.texcoord[4]=1.0f;

	mov	eax, DWORD PTR _vbd+16
	mov	DWORD PTR [eax+16], 1065353216		; 3f800000H

; 1462 : 	vbd.texcoord[5]=1.0f;

	mov	eax, DWORD PTR _vbd+16
	mov	DWORD PTR [eax+20], 1065353216		; 3f800000H

; 1463 : 	vbd.texcoord[6]=0.0f;

	mov	eax, DWORD PTR _vbd+16
	mov	DWORD PTR [eax+24], 0

; 1464 : 	vbd.texcoord[7]=1.0f;

	mov	eax, DWORD PTR _vbd+16
	mov	DWORD PTR [eax+28], 1065353216		; 3f800000H

; 1465 : 
; 1466 : #endif
; 1467 : 
; 1468 : 	vbd.color[0]=255;

	mov	eax, DWORD PTR _vbd+28
	mov	BYTE PTR [eax], 255			; 000000ffH

; 1469 : 	vbd.color[1]=255;

	mov	eax, DWORD PTR _vbd+28
	mov	BYTE PTR [eax+1], 255			; 000000ffH

; 1470 : 	vbd.color[2]=255;

	mov	eax, DWORD PTR _vbd+28
	mov	BYTE PTR [eax+2], 255			; 000000ffH

; 1471 : 	vbd.color[3]=255;

	mov	eax, DWORD PTR _vbd+28
	mov	BYTE PTR [eax+3], 255			; 000000ffH

; 1472 : 	vbd.color[4]=255;

	mov	eax, DWORD PTR _vbd+28
	mov	BYTE PTR [eax+4], 255			; 000000ffH

; 1473 : 	vbd.color[5]=255;

	mov	eax, DWORD PTR _vbd+28
	mov	BYTE PTR [eax+5], 255			; 000000ffH

; 1474 : 	vbd.color[6]=255;

	mov	eax, DWORD PTR _vbd+28
	mov	BYTE PTR [eax+6], 255			; 000000ffH

; 1475 : 	vbd.color[7]=255;

	mov	eax, DWORD PTR _vbd+28
	mov	BYTE PTR [eax+7], 255			; 000000ffH

; 1476 : 	vbd.color[8]=255;

	mov	eax, DWORD PTR _vbd+28
	mov	BYTE PTR [eax+8], 255			; 000000ffH

; 1477 : 	vbd.color[9]=255;

	mov	eax, DWORD PTR _vbd+28
	mov	BYTE PTR [eax+9], 255			; 000000ffH

; 1478 : 	vbd.color[10]=255;
; 1479 : 	vbd.color[11]=255;
; 1480 : 	vbd.color[12]=255;
; 1481 : 	vbd.color[13]=255;
; 1482 : 	vbd.color[14]=255;
; 1483 : 	vbd.color[15]=255;
; 1484 : 
; 1485 : 	vbd.index[0]=0;

	xor	ecx, ecx
	mov	eax, DWORD PTR _vbd+28

; 1486 : 	vbd.index[1]=1;
; 1487 : 	vbd.index[2]=2;
; 1488 : 	vbd.index[3]=2;
; 1489 : 	vbd.index[4]=3;
; 1490 : 	vbd.index[5]=0;
; 1491 : 	
; 1492 : 	vbdt_num=0;
; 1493 : 
; 1494 : #endif
; 1495 : 
; 1496 : 	//Initialize SDL
; 1497 : 	if((SDL_Init(SDL_INIT_EVERYTHING))!=NULL)

	push	29233					; 00007231H
	mov	BYTE PTR [eax+10], 255			; 000000ffH
	mov	eax, DWORD PTR _vbd+28
	mov	BYTE PTR [eax+11], 255			; 000000ffH
	mov	eax, DWORD PTR _vbd+28
	mov	BYTE PTR [eax+12], 255			; 000000ffH
	mov	eax, DWORD PTR _vbd+28
	mov	BYTE PTR [eax+13], 255			; 000000ffH
	mov	eax, DWORD PTR _vbd+28
	mov	BYTE PTR [eax+14], 255			; 000000ffH
	mov	eax, DWORD PTR _vbd+28
	mov	BYTE PTR [eax+15], 255			; 000000ffH
	mov	eax, DWORD PTR _vbd+32
	mov	WORD PTR [eax], cx
	mov	ecx, 1
	mov	eax, DWORD PTR _vbd+32
	mov	WORD PTR [eax+2], cx
	mov	ecx, 2
	mov	eax, DWORD PTR _vbd+32
	mov	WORD PTR [eax+4], cx
	mov	eax, DWORD PTR _vbd+32
	mov	WORD PTR [eax+6], cx
	mov	ecx, 3
	mov	eax, DWORD PTR _vbd+32
	mov	WORD PTR [eax+8], cx
	xor	ecx, ecx
	mov	eax, DWORD PTR _vbd+32
	mov	WORD PTR [eax+10], cx
	xor	eax, eax
	mov	WORD PTR _vbdt_num, ax
	call	DWORD PTR __imp__SDL_Init
	add	esp, 4
	test	eax, eax
	jne	$LN96@Init

; 1501 : 	}
; 1502 : 
; 1503 : 	LogApp("SDL 2.0 initialzed");

	mov	edi, DWORD PTR __imp__SDL_Log
	push	OFFSET ??_C@_0BD@DNBPCBJE@SDL?52?40?5initialzed?$AA@
	call	edi
	add	esp, 4

; 1504 : 		
; 1505 : #if !defined (MGEAR_CLEAN_VERSION) || defined (ENABLE_SOUND_SYS) 
; 1506 : 
; 1507 : 	if((result=FMOD_System_Create(&st.sound_sys.Sound_System))!=FMOD_OK)
; 1508 : 	{
; 1509 : 		LogApp("Error while initializing FMOD, Creating System : %s",FMOD_ErrorString(result));
; 1510 : 			Quit();
; 1511 : 	}
; 1512 : 	LogApp("FMOD system created");
; 1513 : 	
; 1514 : 	if((result=FMOD_System_Init(st.sound_sys.Sound_System,MAX_CHANNELS,FMOD_INIT_NORMAL,NULL))!=FMOD_OK)
; 1515 : 	{
; 1516 : 		LogApp("Error while initializing FMOD : %s",FMOD_ErrorString(result));
; 1517 : 			Quit();
; 1518 : 	}
; 1519 : 
; 1520 : 	LogApp("FMOD system initialzed, %d channels",MAX_CHANNELS);
; 1521 : 	/*
; 1522 : 	for(i=0;i<MAX_SOUNDS;i++)
; 1523 : 		st.sound_sys.slot_ID[i]=-1;
; 1524 : 
; 1525 : 	for(i=0;i<MAX_CHANNELS;i++)
; 1526 : 		st.sound_sys.slotch_ID[i]=-1;
; 1527 : 		*/
; 1528 : #endif
; 1529 : 
; 1530 : 	if(TTF_Init()==-1)

	call	DWORD PTR __imp__TTF_Init
	cmp	eax, -1
	je	$LN98@Init

; 1534 : 	}
; 1535 : 
; 1536 : 	LogApp("SDL TTF initialized");

	push	OFFSET ??_C@_0BE@MBBIJNFJ@SDL?5TTF?5initialized?$AA@
	call	edi

; 1537 : 
; 1538 : //#ifndef MGEAR_MFC
; 1539 : 	
; 1540 : 	SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER,1);

	mov	esi, DWORD PTR __imp__SDL_GL_SetAttribute
	add	esp, 4
	push	1
	push	5
	call	esi

; 1541 : 	SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL,1);

	push	1
	push	15					; 0000000fH
	call	esi

; 1542 : 
; 1543 : 	//Set video mode
; 1544 : 	if(st.fullscreen)
; 1545 : 	{
; 1546 : 		if((wn=SDL_CreateWindow(st.WINDOW_NAME, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, st.screenx, st.screeny, SDL_WINDOW_FULLSCREEN | SDL_WINDOW_OPENGL ))==NULL)

	movzx	eax, WORD PTR _st+230
	add	esp, 16					; 00000010H
	cmp	BYTE PTR _st+233, 0
	je	SHORT $LN92@Init
	push	3
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	805240832				; 2fff0000H
	push	805240832				; 2fff0000H
	push	OFFSET _st+132
	call	DWORD PTR __imp__SDL_CreateWindow
	add	esp, 24					; 00000018H
	mov	DWORD PTR _wn, eax
	test	eax, eax
	jne	SHORT $LN52@Init
	jmp	$LN99@Init
$LN92@Init:

; 1550 : 		}
; 1551 : 	}
; 1552 : 	else
; 1553 : 	if(!st.fullscreen)
; 1554 : 	{
; 1555 : 		if((wn=SDL_CreateWindow(st.WINDOW_NAME, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, st.screenx, st.screeny, SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE))==NULL)

	push	34					; 00000022H
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	805240832				; 2fff0000H
	push	805240832				; 2fff0000H
	push	OFFSET _st+132
	call	DWORD PTR __imp__SDL_CreateWindow
	add	esp, 24					; 00000018H
	mov	DWORD PTR _wn, eax
	test	eax, eax
	je	$LN100@Init
$LN52@Init:

; 1559 : 		}
; 1560 : 	}
; 1561 : 
; 1562 : 	LogApp("Window created, %d x %d, %d bits",st.screenx,st.screeny,st.bpp);

	movzx	eax, BYTE PTR _st+232
	push	eax
	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	OFFSET ??_C@_0CB@CJINDJOG@Window?5created?0?5?$CFd?5x?5?$CFd?0?5?$CFd?5bits@
	call	edi

; 1563 : 
; 1564 : 	if((st.glc=SDL_GL_CreateContext(wn))==NULL)

	push	DWORD PTR _wn
	call	DWORD PTR __imp__SDL_GL_CreateContext
	add	esp, 20					; 00000014H
	mov	DWORD PTR _st+2335412, eax
	test	eax, eax
	je	$LN101@Init

; 1568 : 	}
; 1569 : 
; 1570 : 	LogApp("Opengl context created");

	push	OFFSET ??_C@_0BH@PJDJGOFF@Opengl?5context?5created?$AA@
	call	edi
	add	esp, 4

; 1571 : 
; 1572 : //#endif
; 1573 : 
; 1574 : #ifdef _VAO_RENDER
; 1575 : 	st.renderer.VAO_ON=0;

	mov	BYTE PTR _st+2336440, 0

; 1576 : #endif
; 1577 : 
; 1578 : #ifdef _VBO_RENDER
; 1579 : 	st.renderer.VBO_ON=0;
; 1580 : #endif
; 1581 : 
; 1582 : #ifdef _VA_RENDER
; 1583 : 	st.renderer.VA_ON=0;
; 1584 : #endif
; 1585 : 
; 1586 : #ifdef _VAO_RENDER
; 1587 : 	if(!GLEE_VERSION_3_0 || strstr((char const*) glGetString(GL_EXTENSIONS),"GL_ARB_vertex_array_object")==NULL)

	push	OFFSET __GLEE_VERSION_3_0
	call	_GLeeEnabled
	mov	ebx, DWORD PTR __imp__glGetString@4
	add	esp, 4
	test	al, al
	je	SHORT $LN49@Init
	push	OFFSET ??_C@_0BL@PNJKGHIL@GL_ARB_vertex_array_object?$AA@
	push	7939					; 00001f03H
	call	ebx
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN49@Init

; 1591 : 
; 1592 : #ifdef _VBO_RENDER
; 1593 : 
; 1594 : 		if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_ARB_vertex_buffer_object")==NULL)
; 1595 : 		{
; 1596 : #ifdef _VA_RENDER
; 1597 : 			st.renderer.VA_ON=1;
; 1598 : 			LogApp("VBOs not supported, check your video's card driver for updates... Using VA instead!!");
; 1599 : #else 
; 1600 : 			LogApp("Your video card is not adequate to play this game... Goodbye!!");
; 1601 : 			Quit();
; 1602 : #endif
; 1603 : 		}
; 1604 : 		else
; 1605 : 			st.renderer.VBO_ON=1;
; 1606 : #endif
; 1607 : 
; 1608 : #ifdef _VA_RENDER
; 1609 : 		if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_EXT_vertex_array")==NULL)
; 1610 : 		{
; 1611 : 			LogApp("Your video card is not adequate to play this game... Goodbye!!");
; 1612 : 			Quit();
; 1613 : 		}
; 1614 : #endif
; 1615 : 	}
; 1616 : 	else
; 1617 : 		st.renderer.VAO_ON=1;

	mov	BYTE PTR _st+2336440, 1
	jmp	SHORT $LN48@Init
$LN49@Init:

; 1588 : 	{
; 1589 : 		LogApp("VAO not supported, check your video's card driver for updates... Using VBO instead");

	push	OFFSET ??_C@_0FD@HGLPPOCA@VAO?5not?5supported?0?5check?5your?5vi@
	call	edi
	add	esp, 4

; 1590 : 		st.renderer.VAO_ON=0;

	mov	BYTE PTR _st+2336440, 0
$LN48@Init:

; 1618 : #endif
; 1619 : 
; 1620 : #if !defined (_VAO_RENDER) && defined (_VBO_RENDER)
; 1621 : 	if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_ARB_vertex_buffer_object")==NULL)
; 1622 : 	{
; 1623 : #ifdef _VA_RENDER
; 1624 : 		st.renderer.VA_ON=1;
; 1625 : 		LogApp("VBOs not supported, check your video's card driver for updates... Using VA instead!!");
; 1626 : #else
; 1627 : 		LogApp("Your video card is not adequate to play this game... Goodbye!!");
; 1628 : 		Quit();
; 1629 : #endif
; 1630 : 
; 1631 : 	}
; 1632 : 	else
; 1633 : 		st.renderer.VBO_ON=1;
; 1634 : #endif
; 1635 : 
; 1636 : #if !defined (_VAO_RENDER) && !defined (_VBO_RENDER) && defined (_VA_RENDER)
; 1637 : 	if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_EXT_vertex_array")==NULL)
; 1638 : 	{
; 1639 : 		LogApp("Your video card is not adequate to play this game... Goodbye!!");
; 1640 : 		Quit();
; 1641 : 	}
; 1642 : 	else
; 1643 : 		st.renderer.VA_ON=1;
; 1644 : #endif
; 1645 : 
; 1646 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER)
; 1647 : 	if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_EXT_framebuffer")==NULL)

	push	OFFSET ??_C@_0BD@HLIFEONF@GL_EXT_framebuffer?$AA@
	push	7939					; 00001f03H
	call	ebx
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	$LN102@Init

; 1655 : #endif
; 1656 : 	}
; 1657 : #endif
; 1658 : 
; 1659 : 	//Initialize OpenGL
; 1660 : 	glClearColor(0,0,0,0);

	sub	esp, 16					; 00000010H
	mov	DWORD PTR [esp+12], 0
	mov	DWORD PTR [esp+8], 0
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 0
	call	DWORD PTR __imp__glClearColor@16

; 1661 : 	glMatrixMode(GL_MODELVIEW);

	push	5888					; 00001700H
	call	DWORD PTR __imp__glMatrixMode@4

; 1662 : 	glLoadIdentity();

	call	DWORD PTR __imp__glLoadIdentity@0

; 1663 : 	glViewport(0,0,st.screenx,st.screeny);

	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	0
	push	0
	call	DWORD PTR __imp__glViewport@16

; 1664 : 	glEnable(GL_TEXTURE_2D);

	mov	esi, DWORD PTR __imp__glEnable@4
	push	3553					; 00000de1H
	call	esi

; 1665 : 	glDepthFunc(GL_LEQUAL);

	push	515					; 00000203H
	call	DWORD PTR __imp__glDepthFunc@4

; 1666 : 	glEnable(GL_DEPTH_TEST);

	push	2929					; 00000b71H
	call	esi

; 1667 : 	glClearDepth(1.0);

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__glClearDepth@8

; 1668 : 	glEnable(GL_BLEND);

	push	3042					; 00000be2H
	call	esi

; 1669 : 	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR __imp__glBlendFunc@8

; 1670 : 
; 1671 : #ifndef MGEAR_MFC
; 1672 : 	SDL_GL_SetSwapInterval(st.vsync);

	movzx	eax, BYTE PTR _st+241
	push	eax
	call	DWORD PTR __imp__SDL_GL_SetSwapInterval

; 1673 : #endif
; 1674 : 
; 1675 : 	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

	mov	esi, DWORD PTR __imp__glPixelStorei@8
	add	esp, 4
	push	1
	push	3317					; 00000cf5H
	call	esi

; 1676 : 	glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);

	push	0
	push	3314					; 00000cf2H
	call	esi

; 1677 : 	glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);

	push	0
	push	3316					; 00000cf4H
	call	esi

; 1678 : 	glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);

	push	0
	push	3315					; 00000cf3H
	call	esi

; 1679 : 
; 1680 : 	//glHint(GL_GENERATE_MIPMAP_HINT,GL_FASTEST);
; 1681 : 
; 1682 : 	if(st.renderer.VAO_ON)

	cmp	BYTE PTR _st+2336440, 0
	mov	eax, 130				; 00000082H
	jne	SHORT $LN94@Init

; 1683 : 		st.renderer.shader_version=130;
; 1684 : 	else
; 1685 : 	if(st.renderer.VBO_ON)

	cmp	BYTE PTR _st+2336452, 0
	je	SHORT $LN44@Init

; 1686 : 		st.renderer.shader_version=110;

	mov	eax, 110				; 0000006eH

; 1687 : 	else

	jmp	SHORT $LN94@Init
$LN44@Init:

; 1688 : 		st.renderer.shader_version=0;

	xor	eax, eax
$LN94@Init:

; 1689 : 
; 1690 : 	//Initialize with 32 slots
; 1691 : 	//Reallocation is done if necessary
; 1692 : 	//z_slots keeps track of the current number of slots available
; 1693 : 
; 1694 : 	//z_buffer=(int16**) calloc((3*8)*32,sizeof(int16));
; 1695 : 	//z_slots=32;
; 1696 : 
; 1697 : 	memset(z_buffer,0,((7*8)*2048)*sizeof(int16));

	push	229376					; 00038000H
	push	0
	push	OFFSET _z_buffer
	mov	WORD PTR _st+2336872, ax
	call	_memset
	add	esp, 12					; 0000000cH

; 1698 : 	memset(z_slot,0,(7*8)*sizeof(int16));

	push	112					; 00000070H
	push	0
	push	OFFSET _z_slot
	call	_memset

; 1699 : 
; 1700 : 	z_used=0;
; 1701 : 
; 1702 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER)
; 1703 : 	if(st.renderer.VAO_ON || st.renderer.VBO_ON)

	mov	esi, DWORD PTR __imp__glGenTextures@8
	add	esp, 12					; 0000000cH
	cmp	BYTE PTR _st+2336440, 0
	mov	BYTE PTR _z_used, 0
	jne	SHORT $LN41@Init
	cmp	BYTE PTR _st+2336452, 0
	je	$LN35@Init
$LN41@Init:

; 1704 : 	{
; 1705 : 		glGenFramebuffers(1,&st.renderer.FBO[0]);

	push	OFFSET _st+2336776
	push	1
	call	DWORD PTR _GLeeFuncPtr_glGenFramebuffers

; 1706 : 		glBindFramebuffer(GL_FRAMEBUFFER,st.renderer.FBO[0]);

	push	DWORD PTR _st+2336776
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glBindFramebuffer

; 1707 : 
; 1708 : 		glGenRenderbuffers(1,&st.renderer.RBO[0]);

	push	OFFSET _st+2336824
	push	1
	call	DWORD PTR _GLeeFuncPtr_glGenRenderbuffers

; 1709 : 		glBindRenderbuffer(GL_RENDERBUFFER,st.renderer.RBO[0]);

	push	DWORD PTR _st+2336824
	push	36161					; 00008d41H
	call	DWORD PTR _GLeeFuncPtr_glBindRenderbuffer

; 1710 : 		glRenderbufferStorage(GL_RENDERBUFFER,GL_DEPTH_COMPONENT,st.screenx,st.screeny);

	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	6402					; 00001902H
	push	36161					; 00008d41H
	call	DWORD PTR _GLeeFuncPtr_glRenderbufferStorage

; 1711 : 
; 1712 : 		glBindRenderbuffer(GL_RENDERBUFFER,0);

	push	0
	push	36161					; 00008d41H
	call	DWORD PTR _GLeeFuncPtr_glBindRenderbuffer

; 1713 : 
; 1714 : 		glGenTextures(1,&st.renderer.FBTex[0]);

	push	OFFSET _st+2336792
	push	1
	call	esi

; 1715 : 		glBindTexture(GL_TEXTURE_2D,st.renderer.FBTex[0]);

	push	DWORD PTR _st+2336792
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 1716 : 		glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,st.screenx,st.screeny,0,GL_BGRA,GL_UNSIGNED_BYTE,NULL);

	movzx	eax, WORD PTR _st+230
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36

; 1717 : 
; 1718 : 		glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D,st.renderer.FBTex[0],0);

	push	0
	push	DWORD PTR _st+2336792
	push	3553					; 00000de1H
	push	36064					; 00008ce0H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D

; 1719 : 
; 1720 : 		glFramebufferRenderbuffer(GL_FRAMEBUFFER,GL_DEPTH_ATTACHMENT,GL_RENDERBUFFER,st.renderer.RBO[0]);

	push	DWORD PTR _st+2336824
	push	36161					; 00008d41H
	push	36096					; 00008d00H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferRenderbuffer

; 1721 : 
; 1722 : 		glGenTextures(1,&st.renderer.FBTex[1]);

	push	OFFSET _st+2336796
	push	1
	call	esi

; 1723 : 		glBindTexture(GL_TEXTURE_2D,st.renderer.FBTex[1]);

	push	DWORD PTR _st+2336796
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 1724 : 		glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,st.screenx,st.screeny,0,GL_BGRA,GL_UNSIGNED_BYTE,NULL);

	movzx	eax, WORD PTR _st+230
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36

; 1725 : 
; 1726 : 		glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT1,GL_TEXTURE_2D,st.renderer.FBTex[1],0);

	push	0
	push	DWORD PTR _st+2336796
	push	3553					; 00000de1H
	push	36065					; 00008ce1H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D

; 1727 : 
; 1728 : 		glGenTextures(1,&st.renderer.FBTex[2]);

	push	OFFSET _st+2336800
	push	1
	call	esi

; 1729 : 		glBindTexture(GL_TEXTURE_2D,st.renderer.FBTex[2]);

	push	DWORD PTR _st+2336800
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 1730 : 		glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,st.screenx,st.screeny,0,GL_BGRA,GL_UNSIGNED_BYTE,NULL);

	movzx	eax, WORD PTR _st+230
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36

; 1731 : 
; 1732 : 		glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT2,GL_TEXTURE_2D,st.renderer.FBTex[2],0);

	push	0
	push	DWORD PTR _st+2336800
	push	3553					; 00000de1H
	push	36066					; 00008ce2H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D

; 1733 : 
; 1734 : 		glGenTextures(1,&st.renderer.FBTex[3]);

	push	OFFSET _st+2336804
	push	1
	call	esi

; 1735 : 		glBindTexture(GL_TEXTURE_2D,st.renderer.FBTex[3]);

	push	DWORD PTR _st+2336804
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 1736 : 		glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,st.screenx,st.screeny,0,GL_BGRA,GL_UNSIGNED_BYTE,NULL);

	movzx	eax, WORD PTR _st+230
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36

; 1737 : 
; 1738 : 		glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT3,GL_TEXTURE_2D,st.renderer.FBTex[3],0);

	push	0
	push	DWORD PTR _st+2336804
	push	3553					; 00000de1H
	push	36067					; 00008ce3H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D

; 1739 : 
; 1740 : 		glBindFramebuffer(GL_FRAMEBUFFER,0);

	push	0
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glBindFramebuffer

; 1741 : 		
; 1742 : 		st.renderer.Buffers[0]=GL_COLOR_ATTACHMENT0;
; 1743 : 		st.renderer.Buffers[1]=GL_COLOR_ATTACHMENT1;
; 1744 : 		st.renderer.Buffers[2]=GL_COLOR_ATTACHMENT2;
; 1745 : 		st.renderer.Buffers[3]=GL_COLOR_ATTACHMENT3;
; 1746 : 
; 1747 : SHADER_CREATION:
; 1748 : 
; 1749 : 		st.renderer.VShader[0]=glCreateShader(GL_VERTEX_SHADER);

	push	35633					; 00008b31H
	mov	DWORD PTR _st+2336856, 36064		; 00008ce0H
	mov	DWORD PTR _st+2336860, 36065		; 00008ce1H
	mov	DWORD PTR _st+2336864, 36066		; 00008ce2H
	mov	DWORD PTR _st+2336868, 36067		; 00008ce3H
$SHADER_CREATION$109:
	call	DWORD PTR _GLeeFuncPtr_glCreateShader

; 1750 : 		//st.renderer.FShader[0]=glCreateShader(GL_FRAGMENT_SHADER);
; 1751 : 		//st.renderer.FShader[1]=glCreateShader(GL_FRAGMENT_SHADER);
; 1752 : 		st.renderer.FShader[2]=glCreateShader(GL_FRAGMENT_SHADER);

	push	35632					; 00008b30H
	mov	DWORD PTR _st+2336456, eax
	call	DWORD PTR _GLeeFuncPtr_glCreateShader

; 1753 : 		st.renderer.FShader[3]=glCreateShader(GL_FRAGMENT_SHADER);

	push	35632					; 00008b30H
	mov	DWORD PTR _st+2336528, eax
	call	DWORD PTR _GLeeFuncPtr_glCreateShader

; 1754 : 		st.renderer.FShader[4]=glCreateShader(GL_FRAGMENT_SHADER);

	push	35632					; 00008b30H
	mov	DWORD PTR _st+2336532, eax
	call	DWORD PTR _GLeeFuncPtr_glCreateShader

; 1755 : 		st.renderer.FShader[5]=glCreateShader(GL_FRAGMENT_SHADER);

	push	35632					; 00008b30H
	mov	DWORD PTR _st+2336536, eax
	call	DWORD PTR _GLeeFuncPtr_glCreateShader

; 1756 : 		st.renderer.FShader[6]=glCreateShader(GL_FRAGMENT_SHADER);

	push	35632					; 00008b30H
	mov	DWORD PTR _st+2336540, eax
	call	DWORD PTR _GLeeFuncPtr_glCreateShader
	mov	DWORD PTR _st+2336544, eax

; 1757 : 
; 1758 : #ifdef _VAO_RENDER
; 1759 : 
; 1760 : 		if(st.renderer.shader_version==130)

	mov	eax, 130				; 00000082H
	cmp	WORD PTR _st+2336872, ax
	jne	SHORT $LN40@Init

; 1761 : 		{
; 1762 : 			glShaderSource(st.renderer.VShader[0],1,(const GLchar**) Texture_VShader,0);

	push	0
	push	OFFSET _Texture_VShader
	push	1
	push	DWORD PTR _st+2336456
	call	DWORD PTR _GLeeFuncPtr_glShaderSource

; 1763 : 			//glShaderSource(st.renderer.FShader[0],1,(const GLchar**) Lighting_FShader,0);
; 1764 : 			//glShaderSource(st.renderer.FShader[1],1,(const GLchar**) Normal_FShader,0);
; 1765 : 			glShaderSource(st.renderer.FShader[2],1,(const GLchar**) Texture_FShader,0);

	push	0
	push	OFFSET _Texture_FShader
	push	1
	push	DWORD PTR _st+2336528
	call	DWORD PTR _GLeeFuncPtr_glShaderSource

; 1766 : 			glShaderSource(st.renderer.FShader[3],1,(const GLchar**) Lightmap_FShader,0);

	push	0
	push	OFFSET _Lightmap_FShader
	push	1
	push	DWORD PTR _st+2336532
	call	DWORD PTR _GLeeFuncPtr_glShaderSource

; 1767 : 			glShaderSource(st.renderer.FShader[4],1,(const GLchar**) TextureNoT_FShader,0);

	push	0
	push	OFFSET _TextureNoT_FShader
	push	1
	push	DWORD PTR _st+2336536
	call	DWORD PTR _GLeeFuncPtr_glShaderSource

; 1768 : 			glShaderSource(st.renderer.FShader[5],1,(const GLchar**) TextureT_FShader,0);

	push	0
	push	OFFSET _TextureT_FShader
	push	1
	push	DWORD PTR _st+2336540
	call	DWORD PTR _GLeeFuncPtr_glShaderSource

; 1769 : 			glShaderSource(st.renderer.FShader[6],1,(const GLchar**) Blend_FShader,0);

	push	0
	push	OFFSET _Blend_FShader
	push	1
	push	DWORD PTR _st+2336544
	call	DWORD PTR _GLeeFuncPtr_glShaderSource
$LN40@Init:

; 1770 : 		}
; 1771 : #endif
; 1772 : 		//else
; 1773 : #ifdef _VBO_RENDER
; 1774 : 		if(st.renderer.shader_version==110)
; 1775 : 		{
; 1776 : 			
; 1777 : 			glShaderSource(st.renderer.VShader[0],1,(const GLchar**) Texture_VShader110,0);
; 1778 : 			glShaderSource(st.renderer.FShader[2],1,(const GLchar**) Texture_FShader110,0);
; 1779 : 			glShaderSource(st.renderer.FShader[3],1,(const GLchar**) Lightmap_FShader110,0);
; 1780 : 			glShaderSource(st.renderer.FShader[4],1,(const GLchar**) TextureNoT_FShader110,0);
; 1781 : 			glShaderSource(st.renderer.FShader[5],1,(const GLchar**) TextureT_FShader110,0);
; 1782 : 			glShaderSource(st.renderer.FShader[6],1,(const GLchar**) Blend_FShader110,0);
; 1783 : 		}
; 1784 : #endif
; 1785 : 
; 1786 : 		glCompileShader(st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	call	DWORD PTR _GLeeFuncPtr_glCompileShader

; 1787 : 		//glCompileShader(st.renderer.FShader[0]);
; 1788 : 		//glCompileShader(st.renderer.FShader[1]);
; 1789 : 		glCompileShader(st.renderer.FShader[2]);

	push	DWORD PTR _st+2336528
	call	DWORD PTR _GLeeFuncPtr_glCompileShader

; 1790 : 		glCompileShader(st.renderer.FShader[3]);

	push	DWORD PTR _st+2336532
	call	DWORD PTR _GLeeFuncPtr_glCompileShader

; 1791 : 		glCompileShader(st.renderer.FShader[4]);

	push	DWORD PTR _st+2336536
	call	DWORD PTR _GLeeFuncPtr_glCompileShader

; 1792 : 		glCompileShader(st.renderer.FShader[5]);

	push	DWORD PTR _st+2336540
	call	DWORD PTR _GLeeFuncPtr_glCompileShader

; 1793 : 		glCompileShader(st.renderer.FShader[6]);

	push	DWORD PTR _st+2336544
	call	DWORD PTR _GLeeFuncPtr_glCompileShader

; 1794 : 
; 1795 : 		glGetShaderiv(st.renderer.VShader[0],GL_COMPILE_STATUS,&statusCM[0]);

	lea	eax, DWORD PTR _statusCM$[ebp]
	push	eax
	push	35713					; 00008b81H
	push	DWORD PTR _st+2336456
	call	DWORD PTR _GLeeFuncPtr_glGetShaderiv

; 1796 : 		//glGetShaderiv(st.renderer.FShader[0],GL_COMPILE_STATUS,&statusCM[1]);
; 1797 : 		//glGetShaderiv(st.renderer.FShader[1],GL_COMPILE_STATUS,&statusCM[2]);
; 1798 : 		glGetShaderiv(st.renderer.FShader[2],GL_COMPILE_STATUS,&statusCM[3]);

	lea	eax, DWORD PTR _statusCM$[ebp+12]
	push	eax
	push	35713					; 00008b81H
	push	DWORD PTR _st+2336528
	call	DWORD PTR _GLeeFuncPtr_glGetShaderiv

; 1799 : 		glGetShaderiv(st.renderer.FShader[3],GL_COMPILE_STATUS,&statusCM[4]);

	lea	eax, DWORD PTR _statusCM$[ebp+16]
	push	eax
	push	35713					; 00008b81H
	push	DWORD PTR _st+2336532
	call	DWORD PTR _GLeeFuncPtr_glGetShaderiv

; 1800 : 		glGetShaderiv(st.renderer.FShader[4],GL_COMPILE_STATUS,&statusCM[5]);

	lea	eax, DWORD PTR _statusCM$[ebp+20]
	push	eax
	push	35713					; 00008b81H
	push	DWORD PTR _st+2336536
	call	DWORD PTR _GLeeFuncPtr_glGetShaderiv

; 1801 : 		glGetShaderiv(st.renderer.FShader[5],GL_COMPILE_STATUS,&statusCM[6]);

	lea	eax, DWORD PTR _statusCM$[ebp+24]
	push	eax
	push	35713					; 00008b81H
	push	DWORD PTR _st+2336540
	call	DWORD PTR _GLeeFuncPtr_glGetShaderiv

; 1802 : 		glGetShaderiv(st.renderer.FShader[6],GL_COMPILE_STATUS,&statusCM[7]);

	lea	eax, DWORD PTR _statusCM$[ebp+28]
	push	eax
	push	35713					; 00008b81H
	push	DWORD PTR _st+2336544
	call	DWORD PTR _GLeeFuncPtr_glGetShaderiv

; 1803 : 
; 1804 : 		if(!statusCM[0] || !statusCM[3] || !statusCM[4] || !statusCM[5] || !statusCM[6] || !statusCM[7])

	cmp	DWORD PTR _statusCM$[ebp], 0
	je	$LN38@Init
	cmp	DWORD PTR _statusCM$[ebp+12], 0
	je	$LN38@Init
	cmp	DWORD PTR _statusCM$[ebp+16], 0
	je	$LN38@Init
	cmp	DWORD PTR _statusCM$[ebp+20], 0
	je	$LN38@Init
	cmp	DWORD PTR _statusCM$[ebp+24], 0
	je	$LN38@Init
	cmp	DWORD PTR _statusCM$[ebp+28], 0
	je	$LN38@Init

; 1823 : 				}
; 1824 : 			}
; 1825 : 
; 1826 : #ifdef _VBO_RENDER
; 1827 : 			if(st.renderer.shader_version==130)
; 1828 : 			{
; 1829 : 				LogApp("Changing to VBO...");
; 1830 : 
; 1831 : 				if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_ARB_vertex_buffer_object")==NULL)
; 1832 : 				{
; 1833 : #ifdef _VA_RENDER
; 1834 : 					st.renderer.VA_ON=1;
; 1835 : 					LogApp("VBOs not supported, check your video's card driver for updates... Using VA instead!!");
; 1836 : #else
; 1837 : 					LogApp("Your video card is not adequate to play this game... Goodbye!!");
; 1838 : 					Quit();
; 1839 : #endif
; 1840 : 				}
; 1841 : 				else
; 1842 : 				{
; 1843 : 					st.renderer.VBO_ON=1;
; 1844 : 					st.renderer.shader_version=110;
; 1845 : 
; 1846 : 					glDeleteShader(st.renderer.VShader[0]);
; 1847 : 					glDeleteShader(st.renderer.VShader[3]);
; 1848 : 					glDeleteShader(st.renderer.VShader[4]);
; 1849 : 					glDeleteShader(st.renderer.VShader[5]);
; 1850 : 					glDeleteShader(st.renderer.VShader[6]);
; 1851 : 					glDeleteShader(st.renderer.VShader[7]);
; 1852 : 
; 1853 : 					goto SHADER_CREATION;
; 1854 : 				}
; 1855 : 			}
; 1856 : 			else
; 1857 : 			if(st.renderer.shader_version==110)
; 1858 : 			{
; 1859 : 
; 1860 : #ifdef _VA_RENDER
; 1861 : 
; 1862 : 				LogApp("Changing to VA...");
; 1863 : 
; 1864 : 				if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_EXT_vertex_array")==NULL)
; 1865 : 				{
; 1866 : 					LogApp("Your video card is not adequate to play this game... Goodbye!!");
; 1867 : 					Quit();
; 1868 : 				}
; 1869 : 				else
; 1870 : 				{
; 1871 : 					st.renderer.VA_ON=1;
; 1872 : 
; 1873 : 					glDeleteShader(st.renderer.VShader[0]);
; 1874 : 					glDeleteShader(st.renderer.VShader[3]);
; 1875 : 					glDeleteShader(st.renderer.VShader[4]);
; 1876 : 					glDeleteShader(st.renderer.VShader[5]);
; 1877 : 					glDeleteShader(st.renderer.VShader[6]);
; 1878 : 					glDeleteShader(st.renderer.VShader[7]);
; 1879 : 				}
; 1880 : 			}
; 1881 : #endif
; 1882 : 
; 1883 : #endif
; 1884 : 		}
; 1885 : 		else
; 1886 : 		if(statusCM[0] && statusCM[3] && statusCM[4] && statusCM[5] && statusCM[6] && statusCM[7])
; 1887 : 		{
; 1888 : 			//st.renderer.Program[0]=glCreateProgram();
; 1889 : 			//st.renderer.Program[1]=glCreateProgram();
; 1890 : 			st.renderer.Program[2]=glCreateProgram();

	call	DWORD PTR _GLeeFuncPtr_glCreateProgram
	mov	DWORD PTR _st+2336656, eax

; 1891 : 			st.renderer.Program[3]=glCreateProgram();

	call	DWORD PTR _GLeeFuncPtr_glCreateProgram
	mov	DWORD PTR _st+2336660, eax

; 1892 : 			st.renderer.Program[4]=glCreateProgram();

	call	DWORD PTR _GLeeFuncPtr_glCreateProgram
	mov	DWORD PTR _st+2336664, eax

; 1893 : 			st.renderer.Program[5]=glCreateProgram();

	call	DWORD PTR _GLeeFuncPtr_glCreateProgram
	mov	DWORD PTR _st+2336668, eax

; 1894 : 			st.renderer.Program[6]=glCreateProgram();

	call	DWORD PTR _GLeeFuncPtr_glCreateProgram

; 1895 : 
; 1896 : 			//glAttachShader(st.renderer.Program[0],st.renderer.VShader[0]);
; 1897 : 			//glAttachShader(st.renderer.Program[0],st.renderer.FShader[0]);
; 1898 : 			
; 1899 : 			//glAttachShader(st.renderer.Program[1],st.renderer.VShader[0]);
; 1900 : 			//glAttachShader(st.renderer.Program[1],st.renderer.FShader[1]);
; 1901 : 
; 1902 : 			glAttachShader(st.renderer.Program[2],st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	mov	DWORD PTR _st+2336672, eax
	push	DWORD PTR _st+2336656
	call	DWORD PTR _GLeeFuncPtr_glAttachShader

; 1903 : 			glAttachShader(st.renderer.Program[2],st.renderer.FShader[2]);

	push	DWORD PTR _st+2336528
	push	DWORD PTR _st+2336656
	call	DWORD PTR _GLeeFuncPtr_glAttachShader

; 1904 : 			
; 1905 : 			glAttachShader(st.renderer.Program[3],st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	push	DWORD PTR _st+2336660
	call	DWORD PTR _GLeeFuncPtr_glAttachShader

; 1906 : 			glAttachShader(st.renderer.Program[3],st.renderer.FShader[3]);

	push	DWORD PTR _st+2336532
	push	DWORD PTR _st+2336660
	call	DWORD PTR _GLeeFuncPtr_glAttachShader

; 1907 : 
; 1908 : 			glAttachShader(st.renderer.Program[4],st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	push	DWORD PTR _st+2336664
	call	DWORD PTR _GLeeFuncPtr_glAttachShader

; 1909 : 			glAttachShader(st.renderer.Program[4],st.renderer.FShader[4]);

	push	DWORD PTR _st+2336536
	push	DWORD PTR _st+2336664
	call	DWORD PTR _GLeeFuncPtr_glAttachShader

; 1910 : 
; 1911 : 			glAttachShader(st.renderer.Program[5],st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	push	DWORD PTR _st+2336668
	call	DWORD PTR _GLeeFuncPtr_glAttachShader

; 1912 : 			glAttachShader(st.renderer.Program[5],st.renderer.FShader[5]);

	push	DWORD PTR _st+2336540
	push	DWORD PTR _st+2336668
	call	DWORD PTR _GLeeFuncPtr_glAttachShader

; 1913 : 
; 1914 : 			glAttachShader(st.renderer.Program[6],st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	push	DWORD PTR _st+2336672
	call	DWORD PTR _GLeeFuncPtr_glAttachShader

; 1915 : 			glAttachShader(st.renderer.Program[6],st.renderer.FShader[6]);

	push	DWORD PTR _st+2336544
	push	DWORD PTR _st+2336672
	call	DWORD PTR _GLeeFuncPtr_glAttachShader

; 1916 : 
; 1917 : 			//glLinkProgram(st.renderer.Program[0]);
; 1918 : 			//glLinkProgram(st.renderer.Program[1]);
; 1919 : 			glLinkProgram(st.renderer.Program[2]);

	push	DWORD PTR _st+2336656
	call	DWORD PTR _GLeeFuncPtr_glLinkProgram

; 1920 : 			glLinkProgram(st.renderer.Program[3]);

	push	DWORD PTR _st+2336660
	call	DWORD PTR _GLeeFuncPtr_glLinkProgram

; 1921 : 			glLinkProgram(st.renderer.Program[4]);

	push	DWORD PTR _st+2336664
	call	DWORD PTR _GLeeFuncPtr_glLinkProgram

; 1922 : 			glLinkProgram(st.renderer.Program[5]);

	push	DWORD PTR _st+2336668
	call	DWORD PTR _GLeeFuncPtr_glLinkProgram

; 1923 : 			glLinkProgram(st.renderer.Program[6]);

	push	DWORD PTR _st+2336672
	call	DWORD PTR _GLeeFuncPtr_glLinkProgram

; 1924 : 
; 1925 : 			//glGetProgramiv(st.renderer.Program[0],GL_LINK_STATUS,&statusLK[0]);
; 1926 : 			//glGetProgramiv(st.renderer.Program[1],GL_LINK_STATUS,&statusLK[1]);
; 1927 : 			glGetProgramiv(st.renderer.Program[2],GL_LINK_STATUS,&statusLK[2]);

	lea	eax, DWORD PTR _statusLK$[ebp+8]
	push	eax
	push	35714					; 00008b82H
	push	DWORD PTR _st+2336656
	call	DWORD PTR _GLeeFuncPtr_glGetProgramiv

; 1928 : 			glGetProgramiv(st.renderer.Program[3],GL_LINK_STATUS,&statusLK[3]);

	lea	eax, DWORD PTR _statusLK$[ebp+12]
	push	eax
	push	35714					; 00008b82H
	push	DWORD PTR _st+2336660
	call	DWORD PTR _GLeeFuncPtr_glGetProgramiv

; 1929 : 			glGetProgramiv(st.renderer.Program[4],GL_LINK_STATUS,&statusLK[4]);

	lea	eax, DWORD PTR _statusLK$[ebp+16]
	push	eax
	push	35714					; 00008b82H
	push	DWORD PTR _st+2336664
	call	DWORD PTR _GLeeFuncPtr_glGetProgramiv

; 1930 : 			glGetProgramiv(st.renderer.Program[5],GL_LINK_STATUS,&statusLK[5]);

	lea	eax, DWORD PTR _statusLK$[ebp+20]
	push	eax
	push	35714					; 00008b82H
	push	DWORD PTR _st+2336668
	call	DWORD PTR _GLeeFuncPtr_glGetProgramiv

; 1931 : 			glGetProgramiv(st.renderer.Program[6],GL_LINK_STATUS,&statusLK[6]);

	lea	eax, DWORD PTR _statusLK$[ebp+24]
	push	eax
	push	35714					; 00008b82H
	push	DWORD PTR _st+2336672
	call	DWORD PTR _GLeeFuncPtr_glGetProgramiv

; 1932 : 			/*
; 1933 : 			if(!statusLK[0])
; 1934 : 			{
; 1935 : 				glDeleteProgram(st.renderer.Program[0]);
; 1936 : 				glDeleteShader(st.renderer.VShader[0]);
; 1937 : 				glDeleteShader(st.renderer.FShader[0]);
; 1938 : 			}
; 1939 : 			else
; 1940 : 			{
; 1941 : 				glDetachShader(st.renderer.Program[0],st.renderer.VShader[0]);
; 1942 : 				glDetachShader(st.renderer.Program[0],st.renderer.FShader[0]);
; 1943 : 			}
; 1944 : 			
; 1945 : 			if(!statusLK[1])
; 1946 : 			{
; 1947 : 				glDeleteProgram(st.renderer.Program[1]);
; 1948 : 				glDeleteShader(st.renderer.VShader[0]);
; 1949 : 				glDeleteShader(st.renderer.FShader[1]);
; 1950 : 			}
; 1951 : 			else
; 1952 : 			{
; 1953 : 				glDetachShader(st.renderer.Program[1],st.renderer.VShader[0]);
; 1954 : 				glDetachShader(st.renderer.Program[1],st.renderer.FShader[1]);
; 1955 : 			}
; 1956 : 			*/
; 1957 : 			if(!statusLK[2])

	cmp	DWORD PTR _statusLK$[ebp+8], 0
	jne	SHORT $LN25@Init

; 1958 : 			{
; 1959 : 				glDeleteProgram(st.renderer.Program[2]);

	push	DWORD PTR _st+2336656
	call	DWORD PTR _GLeeFuncPtr_glDeleteProgram

; 1960 : 				glDeleteShader(st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader

; 1961 : 				glDeleteShader(st.renderer.FShader[2]);

	push	DWORD PTR _st+2336528
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader

; 1962 : 			}
; 1963 : 			else

	jmp	SHORT $LN24@Init
$LN25@Init:

; 1964 : 			{
; 1965 : 				glDetachShader(st.renderer.Program[2],st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	push	DWORD PTR _st+2336656
	call	DWORD PTR _GLeeFuncPtr_glDetachShader

; 1966 : 				glDetachShader(st.renderer.Program[2],st.renderer.FShader[2]);

	push	DWORD PTR _st+2336528
	push	DWORD PTR _st+2336656
	call	DWORD PTR _GLeeFuncPtr_glDetachShader
$LN24@Init:

; 1967 : 			}
; 1968 : 			
; 1969 : 			if(!statusLK[3])

	cmp	DWORD PTR _statusLK$[ebp+12], 0
	jne	SHORT $LN23@Init

; 1970 : 			{
; 1971 : 				glGetProgramInfoLog(st.renderer.Program[3],1024,NULL,logs[0]);

	lea	eax, DWORD PTR _logs$[ebp]
	push	eax
	push	0
	push	1024					; 00000400H
	push	DWORD PTR _st+2336660
	call	DWORD PTR _GLeeFuncPtr_glGetProgramInfoLog

; 1972 : 				glDeleteProgram(st.renderer.Program[3]);

	push	DWORD PTR _st+2336660
	call	DWORD PTR _GLeeFuncPtr_glDeleteProgram

; 1973 : 				glDeleteShader(st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader

; 1974 : 				glDeleteShader(st.renderer.FShader[3]);

	push	DWORD PTR _st+2336532
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader

; 1975 : 			}
; 1976 : 			else

	jmp	SHORT $LN22@Init
$LN23@Init:

; 1977 : 			{
; 1978 : 				glDetachShader(st.renderer.Program[3],st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	push	DWORD PTR _st+2336660
	call	DWORD PTR _GLeeFuncPtr_glDetachShader

; 1979 : 				glDetachShader(st.renderer.Program[3],st.renderer.FShader[3]);

	push	DWORD PTR _st+2336532
	push	DWORD PTR _st+2336660
	call	DWORD PTR _GLeeFuncPtr_glDetachShader
$LN22@Init:

; 1980 : 			}
; 1981 : 
; 1982 : 			if(!statusLK[4])

	cmp	DWORD PTR _statusLK$[ebp+16], 0
	jne	SHORT $LN21@Init

; 1983 : 			{
; 1984 : 				glGetProgramInfoLog(st.renderer.Program[4],1024,NULL,logs[0]);

	lea	eax, DWORD PTR _logs$[ebp]
	push	eax
	push	0
	push	1024					; 00000400H
	push	DWORD PTR _st+2336664
	call	DWORD PTR _GLeeFuncPtr_glGetProgramInfoLog

; 1985 : 				glDeleteProgram(st.renderer.Program[4]);

	push	DWORD PTR _st+2336664
	call	DWORD PTR _GLeeFuncPtr_glDeleteProgram

; 1986 : 				glDeleteShader(st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader

; 1987 : 				glDeleteShader(st.renderer.FShader[4]);

	push	DWORD PTR _st+2336536
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader

; 1988 : 			}
; 1989 : 			else

	jmp	SHORT $LN20@Init
$LN21@Init:

; 1990 : 			{
; 1991 : 				glDetachShader(st.renderer.Program[4],st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	push	DWORD PTR _st+2336664
	call	DWORD PTR _GLeeFuncPtr_glDetachShader

; 1992 : 				glDetachShader(st.renderer.Program[4],st.renderer.FShader[4]);

	push	DWORD PTR _st+2336536
	push	DWORD PTR _st+2336664
	call	DWORD PTR _GLeeFuncPtr_glDetachShader
$LN20@Init:

; 1993 : 			}
; 1994 : 
; 1995 : 			if(!statusLK[5])

	cmp	DWORD PTR _statusLK$[ebp+20], 0
	jne	SHORT $LN19@Init

; 1996 : 			{
; 1997 : 				glGetProgramInfoLog(st.renderer.Program[5],1024,NULL,logs[0]);

	lea	eax, DWORD PTR _logs$[ebp]
	push	eax
	push	0
	push	1024					; 00000400H
	push	DWORD PTR _st+2336668
	call	DWORD PTR _GLeeFuncPtr_glGetProgramInfoLog

; 1998 : 				glDeleteProgram(st.renderer.Program[5]);

	push	DWORD PTR _st+2336668
	call	DWORD PTR _GLeeFuncPtr_glDeleteProgram

; 1999 : 				glDeleteShader(st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader

; 2000 : 				glDeleteShader(st.renderer.FShader[5]);

	push	DWORD PTR _st+2336540
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader

; 2001 : 			}
; 2002 : 			else

	jmp	SHORT $LN18@Init
$LN19@Init:

; 2003 : 			{
; 2004 : 				glDetachShader(st.renderer.Program[5],st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	push	DWORD PTR _st+2336668
	call	DWORD PTR _GLeeFuncPtr_glDetachShader

; 2005 : 				glDetachShader(st.renderer.Program[5],st.renderer.FShader[5]);

	push	DWORD PTR _st+2336540
	push	DWORD PTR _st+2336668
	call	DWORD PTR _GLeeFuncPtr_glDetachShader
$LN18@Init:

; 2006 : 			}
; 2007 : 
; 2008 : 			if(!statusLK[6])

	cmp	DWORD PTR _statusLK$[ebp+24], 0
	jne	SHORT $LN17@Init

; 2009 : 			{
; 2010 : 				glGetProgramInfoLog(st.renderer.Program[6],1024,NULL,logs[0]);

	lea	eax, DWORD PTR _logs$[ebp]
	push	eax
	push	0
	push	1024					; 00000400H
	push	DWORD PTR _st+2336672
	call	DWORD PTR _GLeeFuncPtr_glGetProgramInfoLog

; 2011 : 				glDeleteProgram(st.renderer.Program[6]);

	push	DWORD PTR _st+2336672
	call	DWORD PTR _GLeeFuncPtr_glDeleteProgram

; 2012 : 				glDeleteShader(st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader

; 2013 : 				glDeleteShader(st.renderer.FShader[6]);

	push	DWORD PTR _st+2336544
	call	DWORD PTR _GLeeFuncPtr_glDeleteShader

; 2014 : 			}
; 2015 : 			else

	jmp	SHORT $LN16@Init
$LN17@Init:

; 2016 : 			{
; 2017 : 				glDetachShader(st.renderer.Program[6],st.renderer.VShader[0]);

	push	DWORD PTR _st+2336456
	push	DWORD PTR _st+2336672
	call	DWORD PTR _GLeeFuncPtr_glDetachShader

; 2018 : 				glDetachShader(st.renderer.Program[6],st.renderer.FShader[6]);

	push	DWORD PTR _st+2336544
	push	DWORD PTR _st+2336672
	call	DWORD PTR _GLeeFuncPtr_glDetachShader
$LN16@Init:

; 2019 : 			}
; 2020 : 
; 2021 : 			if(!statusLK[2] || !statusLK[3] || !statusLK[4] || !statusLK[5] || !statusLK[6])
; 2022 : 			{
; 2023 : #ifdef _VA_RENDER
; 2024 : 
; 2025 : 				LogApp("Changing to VA...");
; 2026 : 
; 2027 : 				if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_EXT_vertex_array")==NULL)
; 2028 : 				{
; 2029 : 					LogApp("Your video card is not adequate to play this game... Goodbye!!");
; 2030 : 					Quit();
; 2031 : 				}
; 2032 : 				else
; 2033 : 					st.renderer.VA_ON=1;
; 2034 : #endif
; 2035 : 			}
; 2036 : 
; 2037 : 			//This is the main VAO/VBO, used for 1 Quad only objects
; 2038 : 
; 2039 : 			if(statusLK[0] || statusLK[3] || statusLK[4] || statusLK[5] || statusLK[6])

	cmp	DWORD PTR _statusLK$[ebp], 0
	jne	SHORT $LN12@Init
	cmp	DWORD PTR _statusLK$[ebp+12], 0
	jne	SHORT $LN12@Init
	cmp	DWORD PTR _statusLK$[ebp+16], 0
	jne	SHORT $LN12@Init
	cmp	DWORD PTR _statusLK$[ebp+20], 0
	jne	SHORT $LN12@Init
	cmp	DWORD PTR _statusLK$[ebp+24], 0
	je	$LN35@Init
$LN12@Init:

; 2040 : 			{
; 2041 : 				glUseProgram(st.renderer.Program[2]);

	push	DWORD PTR _st+2336656
	call	DWORD PTR _GLeeFuncPtr_glUseProgram

; 2042 : 				st.renderer.unifs[0]=glGetUniformLocation(st.renderer.Program[2],"texu");

	push	OFFSET ??_C@_04DBNNPNIH@texu?$AA@
	push	DWORD PTR _st+2336656
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation

; 2043 : 				glUseProgram(st.renderer.Program[3]);

	push	DWORD PTR _st+2336660
	mov	DWORD PTR _st+2336712, eax
	call	DWORD PTR _GLeeFuncPtr_glUseProgram

; 2044 : 				st.renderer.unifs[1]=glGetUniformLocation(st.renderer.Program[3],"texu");

	push	OFFSET ??_C@_04DBNNPNIH@texu?$AA@
	push	DWORD PTR _st+2336660
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation

; 2045 : 				st.renderer.unifs[2]=glGetUniformLocation(st.renderer.Program[3],"texu2");

	push	OFFSET ??_C@_05JOJNJPAP@texu2?$AA@
	push	DWORD PTR _st+2336660
	mov	DWORD PTR _st+2336716, eax
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation

; 2046 : 				st.renderer.unifs[3]=glGetUniformLocation(st.renderer.Program[3],"texu3");

	push	OFFSET ??_C@_05IHIGKOEO@texu3?$AA@
	push	DWORD PTR _st+2336660
	mov	DWORD PTR _st+2336720, eax
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation

; 2047 : 				st.renderer.unifs[4]=glGetUniformLocation(st.renderer.Program[3],"normal");

	push	OFFSET ??_C@_06IKLLLDHL@normal?$AA@
	push	DWORD PTR _st+2336660
	mov	DWORD PTR _st+2336724, eax
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation

; 2048 : 				st.renderer.unifs[5]=glGetUniformLocation(st.renderer.Program[2],"light_type");

	push	OFFSET ??_C@_0L@GLKJCCIE@light_type?$AA@
	push	DWORD PTR _st+2336656
	mov	DWORD PTR _st+2336728, eax
	call	DWORD PTR _GLeeFuncPtr_glGetUniformLocation

; 2049 : 				//st.renderer.unifs[6]=glGetUniformLocation(st.renderer.Program[3],"Tile");
; 2050 : 				//st.renderer.unifs[7]=glGetUniformLocation(st.renderer.Program[3],"Tiles");
; 2051 : 
; 2052 : #ifdef _VAO_RENDER
; 2053 : 			CreateVAO(&vbd,1,3);

	push	ecx
	mov	dl, 1
	mov	DWORD PTR _st+2336732, eax
	mov	ecx, OFFSET _vbd
	call	_CreateVAO
	add	esp, 4
	jmp	SHORT $LN35@Init
$LN38@Init:

; 1805 : 		{
; 1806 : 			
; 1807 : 			for(i=0;i<8;i++)

	xor	esi, esi
	npad	1
$LL37@Init:

; 1808 : 			{
; 1809 : 				if(i==1 || i==2) continue;

	cmp	si, 1
	je	SHORT $LN36@Init
	cmp	si, 2
	je	SHORT $LN36@Init

; 1810 : 
; 1811 : 				if(!statusCM[i])

	movzx	ebx, si
	cmp	DWORD PTR _statusCM$[ebp+ebx*4], 0
	jne	SHORT $LN36@Init

; 1812 : 				{
; 1813 : 					if(i==1)
; 1814 : 						glGetShaderInfoLog(st.renderer.FShader[0],1024,NULL,logs[0]);
; 1815 : 					else
; 1816 : 					if(i==0)
; 1817 : 						glGetShaderInfoLog(st.renderer.VShader[0],1024,NULL,logs[0]);

	lea	eax, DWORD PTR _logs$[ebp]
	push	eax
	push	0
	push	1024					; 00000400H
	test	si, si
	jne	SHORT $LN29@Init
	push	DWORD PTR _st+2336456

; 1818 : 					else

	jmp	SHORT $LN95@Init
$LN29@Init:

; 1819 : 						glGetShaderInfoLog(st.renderer.FShader[i-1],1024,NULL,logs[0]);

	push	DWORD PTR _st[ebx*4+2336516]
$LN95@Init:
	call	DWORD PTR _GLeeFuncPtr_glGetShaderInfoLog

; 1820 : 
; 1821 : 					LogApp("Shader %d: %s",i ,logs[0]);

	lea	eax, DWORD PTR _logs$[ebp]
	push	eax
	push	ebx
	push	OFFSET ??_C@_0O@BNBOBIPB@Shader?5?$CFd?3?5?$CFs?$AA@
	call	edi
	add	esp, 12					; 0000000cH

; 1822 : 					LogApp("Counld not compile shader");

	push	OFFSET ??_C@_0BK@JJHKDBGE@Counld?5not?5compile?5shader?$AA@
	call	edi
	add	esp, 4
$LN36@Init:

; 1805 : 		{
; 1806 : 			
; 1807 : 			for(i=0;i<8;i++)

	inc	esi
	cmp	si, 8
	jb	SHORT $LL37@Init
	mov	ebx, DWORD PTR __imp__glGetString@4
$LN35@Init:

; 2054 : #elif _VBO_RENDER
; 2055 : 			CreateVBO(&vbd, 1);
; 2056 : #endif 
; 2057 : 			}
; 2058 : 		}
; 2059 : 	}
; 2060 : 
; 2061 : #endif
; 2062 : 
; 2063 : 	LogApp("Opengl initialized");

	push	OFFSET ??_C@_0BD@MFHDJABA@Opengl?5initialized?$AA@
	call	edi
	add	esp, 4

; 2064 : 
; 2065 : 	if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_ARB_texture_non_power_of_two")==NULL)

	push	OFFSET ??_C@_0CA@IICOLDCN@GL_ARB_texture_non_power_of_two?$AA@
	push	7939					; 00001f03H
	call	ebx
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@Init

; 2066 : 	{
; 2067 : 		st.LOWRES=1;
; 2068 : 		LogApp("Non power of two textures not supported, loading times might increase and video's fps might decrease");

	push	OFFSET ??_C@_0GF@JPJDLJAN@Non?5power?5of?5two?5textures?5not?5su@
	mov	BYTE PTR _st+2335446, 1
	call	edi
	add	esp, 4
$LN11@Init:

; 2069 : 	}
; 2070 : 
; 2071 : 	if(strstr((char const*) glGetString(GL_EXTENSIONS),"GL_ARB_texture_rectangle")==NULL && strstr((char const*) glGetString(GL_EXTENSIONS),"GL_NV_texture_rectangle")==NULL && strstr((char const*) glGetString(GL_EXTENSIONS),"GL_NV_texture_rectangle")==NULL)

	push	OFFSET ??_C@_0BJ@NKHMPMDJ@GL_ARB_texture_rectangle?$AA@
	push	7939					; 00001f03H
	call	ebx
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@Init
	push	OFFSET ??_C@_0BI@KIAKBMLM@GL_NV_texture_rectangle?$AA@
	push	7939					; 00001f03H
	call	ebx
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@Init
	push	OFFSET ??_C@_0BI@KIAKBMLM@GL_NV_texture_rectangle?$AA@
	push	7939					; 00001f03H
	call	ebx
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@Init

; 2072 : 		LogApp("Rectangle textures not supported, your video card is not supported or try updating your driver");

	push	OFFSET ??_C@_0FP@HOKOFLMI@Rectangle?5textures?5not?5supported@
	call	edi
	add	esp, 4
$LN10@Init:

; 2073 : 
; 2074 : 	st.quit=0;

	xorps	xmm0, xmm0
	mov	WORD PTR _st+66668, 0

; 2075 : 
; 2076 : 	st.time=0;

	movlpd	QWORD PTR _st+64272, xmm0

; 2077 : 
; 2078 : 	st.PlayingVideo=0;
; 2079 : 
; 2080 : 	InputInit();

	call	_InputInit

; 2081 : 
; 2082 : 	LogApp("Input initialized");

	push	OFFSET ??_C@_0BC@DHDBMALK@Input?5initialized?$AA@
	call	edi

; 2083 : 
; 2084 : 	st.Camera.position.x=0;
; 2085 : 	st.Camera.position.y=0;
; 2086 : 	st.Camera.dimension.x=1.0f;
; 2087 : 	st.Camera.dimension.y=1.0f;
; 2088 : 	st.Camera.angle=0.0;

	xor	eax, eax
	mov	DWORD PTR _st+2335380, 0
	add	esp, 4
	mov	DWORD PTR _st+2335384, 0
	mov	DWORD PTR _st+2335396, 1065353216	; 3f800000H
	mov	DWORD PTR _st+2335400, 1065353216	; 3f800000H
	mov	WORD PTR _st+2335392, ax

; 2089 : 
; 2090 : 	st.Current_Map.num_lights=0;
; 2091 : 	st.Current_Map.num_mgg=0;
; 2092 : 	st.Current_Map.num_obj=0;
; 2093 : 	st.Current_Map.num_sector=0;
; 2094 : 	st.Current_Map.num_sprites=0;
; 2095 : 
; 2096 : 	st.num_hud=0;
; 2097 : 	st.num_tex=0;
; 2098 : 	st.num_ui=0;
; 2099 : 
; 2100 : 	st.num_sprites=0;
; 2101 : 
; 2102 : 	st.num_uiwindow=0;
; 2103 : 
; 2104 : 	st.cursor_type=0;
; 2105 : 
; 2106 : 	memset(&ent,0,MAX_GRAPHICS*sizeof(_ENTITIES));

	push	540672					; 00084000H
	push	eax
	push	OFFSET _ent
	mov	DWORD PTR _st+66846, eax
	mov	WORD PTR _st+66850, ax
	mov	WORD PTR _st+66844, ax
	mov	DWORD PTR _st+252, eax
	mov	DWORD PTR _st+248, eax
	mov	DWORD PTR _st+256, eax
	mov	WORD PTR _st+2335376, ax
	mov	BYTE PTR _st+264, al
	mov	BYTE PTR _st+3307836, al
	call	_memset
	add	esp, 12					; 0000000cH

; 2107 : 
; 2108 : #ifndef MGEAR_CLEAN_VERSION
; 2109 : 	memset(&lmp,0,MAX_LIGHTMAPS*sizeof(_ENTITIES));
; 2110 : 	memset(&st.Game_Sprites,0,MAX_SPRITES*sizeof(_SPRITES));
; 2111 : #endif
; 2112 : 
; 2113 : 	memset(&st.strings,0,MAX_STRINGS*sizeof(StringsE));

	push	546816					; 00085800H
	push	0
	push	OFFSET _st+2761020
	call	_memset
	add	esp, 12					; 0000000cH
	xorps	xmm1, xmm1
$LL9@Init:

; 2114 : 
; 2115 : 	//Calculates Cos, Sin and Tan tables
; 2116 : 	for(k=0.0f;k<360.1f;k+=0.1f)
; 2117 : 	{
; 2118 : 		i=k*10;

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si eax, xmm0

; 2119 : 		st.CosTable[i]=cos((k*pi)/180);

	cvtps2pd xmm0, xmm1
	movzx	esi, ax
	mulsd	xmm0, QWORD PTR __real@400921fb53c8d4f1
	divsd	xmm0, QWORD PTR __real@4066800000000000
	movsd	QWORD PTR tv1645[ebp], xmm0
	call	__libm_sse2_cos_precise
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0

; 2120 : 		st.SinTable[i]=sin((k*pi)/180);

	movsd	xmm0, QWORD PTR tv1645[ebp]
	movss	DWORD PTR _st[esi*4+2717808], xmm1
	call	__libm_sse2_sin_precise
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0

; 2121 : 		st.TanTable[i]=tan((k*pi)/180);

	movsd	xmm0, QWORD PTR tv1645[ebp]
	movss	DWORD PTR _st[esi*4+2732212], xmm1
	call	__libm_sse2_tan_precise
	movss	xmm1, DWORD PTR _k$1$[ebp]
	addss	xmm1, DWORD PTR __real@3dcccccd
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _k$1$[ebp], xmm1
	movss	DWORD PTR _st[esi*4+2746616], xmm0
	movss	xmm0, DWORD PTR __real@43b40ccd
	comiss	xmm0, xmm1
	ja	$LL9@Init

; 2122 : 	}
; 2123 : 
; 2124 : #ifndef MGEAR_CLEAN_VERSION
; 2125 : 	memset(&st.game_lightmaps,0,MAX_LIGHTMAPS*sizeof(_GAME_LIGHTMAPS));
; 2126 : 
; 2127 : 	st.game_lightmaps[0].stat=1;
; 2128 : 
; 2129 : 	st.game_lightmaps[0].W_w=GAME_WIDTH;
; 2130 : 	st.game_lightmaps[0].W_h=GAME_HEIGHT;
; 2131 : 
; 2132 : 	st.game_lightmaps[0].T_w=4;
; 2133 : 	st.game_lightmaps[0].T_h=2;
; 2134 : 
; 2135 : 	st.game_lightmaps[0].num_lights=1;
; 2136 : 	st.game_lightmaps[0].w_pos.x=GAME_HEIGHT;
; 2137 : 	st.game_lightmaps[0].w_pos.y=4096;
; 2138 : 	st.game_lightmaps[0].w_pos.z=0;
; 2139 : 
; 2140 : 	st.game_lightmaps[0].t_pos[0].x=2;
; 2141 : 	st.game_lightmaps[0].t_pos[0].y=1;
; 2142 : 	st.game_lightmaps[0].t_pos[0].z=0;
; 2143 : 
; 2144 : 	st.game_lightmaps[0].t_pos[1].x=0;
; 2145 : 	st.game_lightmaps[0].t_pos[1].y=0;
; 2146 : 	st.game_lightmaps[0].t_pos[1].z=0;
; 2147 : 
; 2148 : 	st.game_lightmaps[0].t_pos[2].x=200;
; 2149 : 	st.game_lightmaps[0].t_pos[2].y=95;
; 2150 : 	st.game_lightmaps[0].t_pos[2].z=0;
; 2151 : 
; 2152 : 	st.game_lightmaps[0].data=GenerateLightmap(st.game_lightmaps[0].T_w, st.game_lightmaps[0].T_h);
; 2153 : 	AddLightToLightmap(st.game_lightmaps[0].data,st.game_lightmaps[0].T_w,st.game_lightmaps[0].T_h,255,255,255,0.1,st.game_lightmaps[0].t_pos[0].x,st.game_lightmaps[0].t_pos[0].y,st.game_lightmaps[0].t_pos[0].z,255,POINT_LIGHT_NORMAL);
; 2154 : 	//AddLightToLightmap(st.game_lightmaps[0].data,st.game_lightmaps[0].T_w,st.game_lightmaps[0].T_h,255,255,255,16,st.game_lightmaps[0].t_pos[1].x,st.game_lightmaps[0].t_pos[1].y,st.game_lightmaps[0].t_pos[1].z,128);
; 2155 : 	//AddLightToLightmap(st.game_lightmaps[0].data,st.game_lightmaps[0].T_w,st.game_lightmaps[0].T_h,255,255,255,16,st.game_lightmaps[0].t_pos[2].x,st.game_lightmaps[0].t_pos[2].y,st.game_lightmaps[0].t_pos[0].z,255);
; 2156 : 
; 2157 : 	st.game_lightmaps[0].tex=GenerateLightmapTexture(st.game_lightmaps[0].data,st.game_lightmaps[0].T_w,st.game_lightmaps[0].T_h);
; 2158 : 
; 2159 : #endif
; 2160 : 
; 2161 : 	DataN=(unsigned char*) calloc(64*64*3,sizeof(unsigned char));

	push	1
	push	12288					; 00003000H
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _DataN, eax
	add	eax, 2
	mov	edx, 64					; 00000040H
	npad	2
$LL6@Init:

; 2164 : 	{
; 2165 : 		for(j=0;j<64;j++)

	mov	ecx, 64					; 00000040H
	npad	11
$LL3@Init:

; 2166 : 		{
; 2167 : 			DataN[(i*64*3)+(j*3)]=255;

	mov	WORD PTR [eax-2], 65535			; 0000ffffH

; 2168 : 			DataN[(i*64*3)+(j*3)+1]=255;
; 2169 : 			DataN[(i*64*3)+(j*3)+2]=255;

	mov	BYTE PTR [eax], 255			; 000000ffH
	add	eax, 3
	dec	ecx
	jne	SHORT $LL3@Init

; 2162 : 
; 2163 : 	for(i=0;i<64;i++)

	dec	edx
	jne	SHORT $LL6@Init

; 2170 : 		}
; 2171 : 	}
; 2172 : 
; 2173 : 	glGenTextures(1,&DataNT);

	push	OFFSET _DataNT
	push	1
	call	DWORD PTR __imp__glGenTextures@8

; 2174 : 	glBindTexture(GL_TEXTURE_2D,DataNT);

	push	DWORD PTR _DataNT
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 2175 : 
; 2176 : 	glTexImage2D(GL_TEXTURE_2D,0,GL_RGB8,64,64,0,GL_BGR,GL_UNSIGNED_BYTE,DataN);

	push	DWORD PTR _DataN
	push	5121					; 00001401H
	push	32992					; 000080e0H
	push	0
	push	64					; 00000040H
	push	64					; 00000040H
	push	32849					; 00008051H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36

; 2177 : 
; 2178 : 	glGenerateMipmap(GL_TEXTURE_2D);

	push	3553					; 00000de1H
	call	DWORD PTR _GLeeFuncPtr_glGenerateMipmap

; 2179 : 
; 2180 : 	//glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
; 2181 : 	//glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
; 2182 : 	
; 2183 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN96@Init:

; 1498 : 	{
; 1499 : 		LogApp("SDL Initilization failed %s",SDL_GetError());

	call	DWORD PTR __imp__SDL_GetError
	push	eax
	push	OFFSET ??_C@_0BM@HCNBMJIE@SDL?5Initilization?5failed?5?$CFs?$AA@
	call	DWORD PTR __imp__SDL_Log
	add	esp, 8

; 1500 : 			Quit();

	call	_Quit
$LN103@Init:
$LN98@Init:

; 1531 : 	{
; 1532 : 		LogApp("Error while initializing SDL TTF : %s",TTF_GetError());

	call	DWORD PTR __imp__SDL_GetError
	push	eax
	push	OFFSET ??_C@_0CG@LLIBEPGC@Error?5while?5initializing?5SDL?5TTF@
	call	edi
	add	esp, 8

; 1533 : 			Quit();

	call	_Quit
$LN104@Init:
$LN99@Init:

; 1547 : 		{
; 1548 : 			LogApp("Error setting fullscreen video mode %d x %d %d bits - %s",st.screenx,st.screeny,st.bpp,SDL_GetError());

	call	DWORD PTR __imp__SDL_GetError
	push	eax
	movzx	eax, BYTE PTR _st+232
	push	eax
	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	OFFSET ??_C@_0DJ@GHPNMNEC@Error?5setting?5fullscreen?5video?5m@
	call	edi
	add	esp, 20					; 00000014H

; 1549 : 				Quit();

	call	_Quit
$LN105@Init:
$LN100@Init:

; 1556 : 		{
; 1557 : 			LogApp("Error setting widowed video mode %d x %d %d bits - %s",st.screenx,st.screeny,st.bpp,SDL_GetError());

	call	DWORD PTR __imp__SDL_GetError
	push	eax
	movzx	eax, BYTE PTR _st+232
	push	eax
	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	OFFSET ??_C@_0DG@HINKMIAE@Error?5setting?5widowed?5video?5mode@
	call	edi
	add	esp, 20					; 00000014H

; 1558 : 				Quit();

	call	_Quit
$LN106@Init:
$LN101@Init:

; 1565 : 	{
; 1566 : 		LogApp("Error setting renderer: %s",SDL_GetError());

	call	DWORD PTR __imp__SDL_GetError
	push	eax
	push	OFFSET ??_C@_0BL@JKBAOCCM@Error?5setting?5renderer?3?5?$CFs?$AA@
	call	edi
	add	esp, 8

; 1567 : 				Quit();

	call	_Quit
$LN107@Init:
$LN102@Init:

; 1648 : 	{
; 1649 : #ifdef _VA_RENDER
; 1650 : 		st.renderer.VA_ON=1;
; 1651 : 		LogApp("Framebuffer object not support, check your video's card driver for updates... Usign VA instead!");
; 1652 : #else
; 1653 : 		LogApp("Your video card is not adequate to play this game... Goodbye!!");

	push	OFFSET ??_C@_0DP@GKIFJBKD@Your?5video?5card?5is?5not?5adequate?5@
	call	edi
	add	esp, 4

; 1654 : 		Quit();

	call	_Quit
$LN108@Init:
$LN93@Init:
	int	3
_Init	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _OpenFont
_TEXT	SEGMENT
_OpenFont PROC						; COMDAT
; _name$ = ecx
; _index$ = dl

; 2187 : 	if((st.fonts[index].font=TTF_OpenFont(file,font_size))==NULL)
; 2188 : 	{
; 2189 : 		LogApp("Error while opening TTF font : %s",TTF_GetError());
; 2190 : 		return 0;
; 2191 : 	}
; 2192 : 
; 2193 : 	st.fonts[index].size_h_px=font_size;

	movzx	eax, dl
	imul	eax, eax, 84

; 2194 : 	st.fonts[index].size_w_px=font_size/2;
; 2195 : 	st.fonts[index].size_w_gm=font_size;
; 2196 : 	st.fonts[index].size_h_gm=font_size;
; 2197 : 	
; 2198 : 	strcpy(st.fonts[index].name,name);

	lea	edx, DWORD PTR _st[eax+64280]
	mov	DWORD PTR _st[eax+64352], 128		; 00000080H
	mov	DWORD PTR _st[eax+64348], 64		; 00000040H
	sub	edx, ecx
	mov	DWORD PTR _st[eax+64356], 128		; 00000080H
	mov	DWORD PTR _st[eax+64360], 128		; 00000080H
$LL4@OpenFont:
	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR [edx+ecx-1], al
	test	al, al
	jne	SHORT $LL4@OpenFont

; 2199 : 
; 2200 : 	return 1;

	mov	al, 1

; 2201 : }

	ret	0
_OpenFont ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _RestartVideo
_TEXT	SEGMENT
_RestartVideo PROC					; COMDAT

; 2204 : {

	push	esi

; 2205 : 	
; 2206 : 	LogApp("Video restarted");

	mov	esi, DWORD PTR __imp__SDL_Log
	push	edi
	push	OFFSET ??_C@_0BA@NDONFOIB@Video?5restarted?$AA@
	call	esi
	add	esp, 4

; 2207 : 
; 2208 : 	//SDL_DestroyWindow(wn);
; 2209 : 
; 2210 : //	wn=SDL_CreateWindow(st.WINDOW_NAME,SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED,st.screenx,st.screeny, st.fullscreen==1 ? SDL_WINDOW_FULLSCREEN : NULL | SDL_WINDOW_OPENGL);
; 2211 : 
; 2212 : 	if(wn==NULL)

	cmp	DWORD PTR _wn, 0
	jne	SHORT $LN2@RestartVid

; 2213 : 	{
; 2214 : 		if(st.fullscreen) LogApp("Error setting fullscreen video mode %d x %d %d bits - %s",st.screenx,st.screeny,st.bpp,SDL_GetError());

	cmp	BYTE PTR _st+233, 0
	je	SHORT $LN3@RestartVid
	call	DWORD PTR __imp__SDL_GetError
	push	eax
	movzx	eax, BYTE PTR _st+232
	push	eax
	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	OFFSET ??_C@_0DJ@GHPNMNEC@Error?5setting?5fullscreen?5video?5m@
	jmp	SHORT $LN7@RestartVid
$LN3@RestartVid:

; 2215 : 		else LogApp("Error setting windowed video mode %d x %d %d bits - %s",st.screenx,st.screeny,st.bpp,SDL_GetError());

	call	DWORD PTR __imp__SDL_GetError
	push	eax
	movzx	eax, BYTE PTR _st+232
	push	eax
	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	OFFSET ??_C@_0DH@KKJPEJIP@Error?5setting?5windowed?5video?5mod@
$LN7@RestartVid:
	call	esi
	add	esp, 20					; 00000014H
$LN2@RestartVid:

; 2216 : 	}
; 2217 : 
; 2218 : 	//LogApp("Window created, %d x %d, %d bits",st.screenx,st.screeny,st.bpp);
; 2219 : 
; 2220 : 	//SDL_GL_MakeCurrent(wn,st.glc);
; 2221 : 
; 2222 : 	//SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
; 2223 : //	SDL_RenderPresent(st.glc);
; 2224 : 
; 2225 : 	glViewport(0,0,st.screenx,st.screeny);

	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	0
	push	0
	call	DWORD PTR __imp__glViewport@16

; 2226 : 
; 2227 : 	glClearColor(0,0,0,0);

	sub	esp, 16					; 00000010H
	mov	DWORD PTR [esp+12], 0
	mov	DWORD PTR [esp+8], 0
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 0
	call	DWORD PTR __imp__glClearColor@16

; 2228 : 	glMatrixMode(GL_PROJECTION);

	mov	edi, DWORD PTR __imp__glMatrixMode@4
	push	5889					; 00001701H
	call	edi

; 2229 : 	glLoadIdentity();

	mov	esi, DWORD PTR __imp__glLoadIdentity@0
	call	esi

; 2230 : 	glOrtho(0,st.screenx,st.screeny,0,0,1);

	movzx	eax, WORD PTR _st+230
	sub	esp, 48					; 00000030H
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	xorps	xmm1, xmm1
	movsd	QWORD PTR [esp+40], xmm0
	movd	xmm0, eax
	movzx	eax, WORD PTR _st+228
	cvtdq2pd xmm0, xmm0
	movups	XMMWORD PTR [esp+24], xmm1
	movsd	QWORD PTR [esp+16], xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movsd	QWORD PTR [esp], xmm1
	call	DWORD PTR __imp__glOrtho@48

; 2231 : 	glMatrixMode(GL_MODELVIEW);

	push	5888					; 00001700H
	call	edi

; 2232 : 	glLoadIdentity();

	call	esi

; 2233 : 	glEnable(GL_BLEND);

	mov	esi, DWORD PTR __imp__glEnable@4
	push	3042					; 00000be2H
	call	esi

; 2234 : 	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR __imp__glBlendFunc@8

; 2235 : 	glEnable(GL_TEXTURE_2D);

	push	3553					; 00000de1H
	call	esi

; 2236 : 	SDL_GL_SetSwapInterval(st.vsync);

	movzx	eax, BYTE PTR _st+241
	push	eax
	call	DWORD PTR __imp__SDL_GL_SetSwapInterval
	add	esp, 4

; 2237 : 
; 2238 : 	glBindRenderbuffer(GL_RENDERBUFFER, st.renderer.RBO[0]);

	push	DWORD PTR _st+2336824
	push	36161					; 00008d41H
	call	DWORD PTR _GLeeFuncPtr_glBindRenderbuffer

; 2239 : 	glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, st.screenx, st.screeny);

	movzx	eax, WORD PTR _st+230
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	6402					; 00001902H
	push	36161					; 00008d41H
	call	DWORD PTR _GLeeFuncPtr_glRenderbufferStorage

; 2240 : 
; 2241 : 	glBindRenderbuffer(GL_RENDERBUFFER, 0);

	push	0
	push	36161					; 00008d41H
	call	DWORD PTR _GLeeFuncPtr_glBindRenderbuffer

; 2242 : 
; 2243 : 	glBindTexture(GL_TEXTURE_2D, st.renderer.FBTex[0]);

	push	DWORD PTR _st+2336792
	mov	edi, DWORD PTR __imp__glBindTexture@8
	push	3553					; 00000de1H
	call	edi

; 2244 : 	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, st.screenx, st.screeny, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);

	movzx	eax, WORD PTR _st+230
	mov	esi, DWORD PTR __imp__glTexImage2D@36
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	esi

; 2245 : 
; 2246 : 	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, st.renderer.FBTex[0], 0);

	push	0
	push	DWORD PTR _st+2336792
	push	3553					; 00000de1H
	push	36064					; 00008ce0H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D

; 2247 : 
; 2248 : 	glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, st.renderer.RBO[0]);

	push	DWORD PTR _st+2336824
	push	36161					; 00008d41H
	push	36096					; 00008d00H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferRenderbuffer

; 2249 : 
; 2250 : 	glBindTexture(GL_TEXTURE_2D, st.renderer.FBTex[1]);

	push	DWORD PTR _st+2336796
	push	3553					; 00000de1H
	call	edi

; 2251 : 	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, st.screenx, st.screeny, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);

	movzx	eax, WORD PTR _st+230
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	esi

; 2252 : 
; 2253 : 	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, st.renderer.FBTex[1], 0);

	push	0
	push	DWORD PTR _st+2336796
	push	3553					; 00000de1H
	push	36065					; 00008ce1H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D

; 2254 : 
; 2255 : 	glBindTexture(GL_TEXTURE_2D, st.renderer.FBTex[2]);

	push	DWORD PTR _st+2336800
	push	3553					; 00000de1H
	call	edi

; 2256 : 	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, st.screenx, st.screeny, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);

	movzx	eax, WORD PTR _st+230
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	esi

; 2257 : 
; 2258 : 	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, GL_TEXTURE_2D, st.renderer.FBTex[2], 0);

	push	0
	push	DWORD PTR _st+2336800
	push	3553					; 00000de1H
	push	36066					; 00008ce2H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D

; 2259 : 
; 2260 : 	glBindTexture(GL_TEXTURE_2D, st.renderer.FBTex[3]);

	push	DWORD PTR _st+2336804
	push	3553					; 00000de1H
	call	edi

; 2261 : 	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, st.screenx, st.screeny, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);

	movzx	eax, WORD PTR _st+230
	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	push	eax
	movzx	eax, WORD PTR _st+228
	push	eax
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	esi

; 2262 : 
; 2263 : 	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT3, GL_TEXTURE_2D, st.renderer.FBTex[3], 0);

	push	0
	push	DWORD PTR _st+2336804
	push	3553					; 00000de1H
	push	36067					; 00008ce3H
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glFramebufferTexture2D

; 2264 : 
; 2265 : 	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	push	0
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glBindFramebuffer

; 2266 : 	
; 2267 : 	if(SDL_GetRelativeMouseMode())

	call	DWORD PTR __imp__SDL_GetRelativeMouseMode
	test	eax, eax
	je	SHORT $LN1@RestartVid

; 2268 : 	{
; 2269 : 		SDL_SetRelativeMouseMode(SDL_FALSE);

	mov	esi, DWORD PTR __imp__SDL_SetRelativeMouseMode
	push	0
	call	esi

; 2270 : 		SDL_SetRelativeMouseMode(SDL_TRUE);

	push	1
	call	esi
	add	esp, 8
$LN1@RestartVid:

; 2271 : 	}
; 2272 : 	
; 2273 : }

	pop	edi
	pop	esi
	ret	0
_RestartVideo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _WindowEvents
_TEXT	SEGMENT
_WindowEvents PROC					; COMDAT

; 2276 : {

	push	ecx

; 2277 : 	if (events.type == SDL_QUIT) st.quit = 1;

	movzx	eax, BYTE PTR _st+66668
	mov	ecx, 1
	cmp	DWORD PTR _events, 256			; 00000100H
	cmove	eax, ecx
	mov	BYTE PTR _st+66668, al

; 2278 : 
; 2279 : 	InputProcess();

	call	_InputProcess

; 2280 : 
; 2281 : 	if (events.type == SDL_WINDOWEVENT)

	cmp	DWORD PTR _events, 512			; 00000200H
	jne	SHORT $LN1@WindowEven

; 2282 : 	{
; 2283 : 		if (events.window.event == SDL_WINDOWEVENT_SIZE_CHANGED)

	cmp	BYTE PTR _events+12, 6
	jne	SHORT $LN1@WindowEven

; 2284 : 		{
; 2285 : 			LogApp("Window resized to %d x %d", events.window.data1, events.window.data2);

	push	DWORD PTR _events+20
	push	DWORD PTR _events+16
	push	OFFSET ??_C@_0BK@MKEONLB@Window?5resized?5to?5?$CFd?5x?5?$CFd?$AA@
	call	DWORD PTR __imp__SDL_Log

; 2286 : 			st.screenx = events.window.data1;

	movzx	eax, WORD PTR _events+16
	add	esp, 12					; 0000000cH
	mov	WORD PTR _st+228, ax

; 2287 : 			st.screeny = events.window.data2;

	movzx	eax, WORD PTR _events+20
	mov	WORD PTR _st+230, ax

; 2288 : 			RestartVideo();

	call	_RestartVideo
$LN1@WindowEven:
	pop	ecx

; 2289 : 		}
; 2290 : 	}
; 2291 : }

	ret	0
_WindowEvents ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _CheckMGGInSystem
_TEXT	SEGMENT
_mggf$ = -104						; size = 76
_header$ = -28						; size = 21
__$ArrayPad$ = -4					; size = 4
_CheckMGGInSystem PROC					; COMDAT
; _name$dead$ = ecx

; 2330 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	edi

; 2331 : 	FILE *file;
; 2332 : 	char header[21];
; 2333 : 	int8 i;
; 2334 : 
; 2335 : 	_MGGFORMAT mggf;
; 2336 : 	/*
; 2337 : 	if((file=DecompressFile(name))==NULL)
; 2338 : 	{
; 2339 : 		LogApp("Error reading MGG file %s",name);
; 2340 : 			return -2;
; 2341 : 	}
; 2342 : 	*/
; 2343 : 
; 2344 : 	if((file=fopen(name,"rb"))==NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_0BA@GLINHHCI@data?1mEngUI?4mgg?$AA@
	call	_fopen
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	SHORT $LN14@CheckMGGIn

; 2345 : 	{
; 2346 : 		LogApp("Error reading MGG file %s",name);

	push	OFFSET ??_C@_0BA@GLINHHCI@data?1mEngUI?4mgg?$AA@
	push	OFFSET ??_C@_0BK@JNFOJKPO@Error?5reading?5MGG?5file?5?$CFs?$AA@
	call	DWORD PTR __imp__SDL_Log
	add	esp, 8

; 2347 : 			return -2;

	lea	eax, DWORD PTR [edi-2]
	pop	edi

; 2393 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@CheckMGGIn:

; 2348 : 	}
; 2349 : 
; 2350 : 	rewind(file);

	push	edi
	call	_rewind

; 2351 : 
; 2352 : 	fread(header,21,1,file);

	push	edi
	push	1
	lea	eax, DWORD PTR _header$[ebp]
	push	21					; 00000015H
	push	eax
	call	_fread
	add	esp, 20					; 00000014H

; 2353 : 
; 2354 : 	if(strcmp(header,"MGG File Version 1")!=NULL)

	lea	eax, DWORD PTR _header$[ebp]
	mov	ecx, OFFSET ??_C@_0BD@IGEJGLBO@MGG?5File?5Version?51?$AA@
	npad	3
$LL32@CheckMGGIn:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN33@CheckMGGIn
	test	dl, dl
	je	SHORT $LN34@CheckMGGIn
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN33@CheckMGGIn
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL32@CheckMGGIn
$LN34@CheckMGGIn:
	xor	eax, eax
	jmp	SHORT $LN35@CheckMGGIn
$LN33@CheckMGGIn:
	sbb	eax, eax
	or	eax, 1
$LN35@CheckMGGIn:
	test	eax, eax
	je	SHORT $LN13@CheckMGGIn

; 2355 : 	{
; 2356 : 		LogApp("Invalid MGG file header %s",header);

	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	push	OFFSET ??_C@_0BL@HGJNDNHB@Invalid?5MGG?5file?5header?5?$CFs?$AA@
	call	DWORD PTR __imp__SDL_Log

; 2357 : 		fclose(file);

	push	edi
	call	_fclose
	add	esp, 12					; 0000000cH

; 2358 : 		return -2;

	mov	eax, -2					; fffffffeH
	pop	edi

; 2393 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@CheckMGGIn:
	push	ebx
	push	esi

; 2359 : 	}
; 2360 : 
; 2361 : 	fread(&mggf,sizeof(_MGGFORMAT),1,file);

	push	edi
	push	1
	lea	eax, DWORD PTR _mggf$[ebp]
	push	76					; 0000004cH
	push	eax
	call	_fread

; 2362 : 
; 2363 : 	for(i=0;i<st.num_mgg_basic;i++)

	movzx	esi, BYTE PTR _st+266
	add	esp, 16					; 00000010H
	xor	bl, bl
	test	esi, esi
	jle	SHORT $LN10@CheckMGGIn
	xor	ecx, ecx
$LL12@CheckMGGIn:

; 2364 : 	{
; 2365 : 		if(strcmp(mggf.name,mgg_sys[i].name)==NULL)

	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx
	lea	ecx, DWORD PTR _mgg_sys[eax*4]
	lea	eax, DWORD PTR _mggf$[ebp]
$LL36@CheckMGGIn:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN37@CheckMGGIn
	test	dl, dl
	je	SHORT $LN38@CheckMGGIn
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN37@CheckMGGIn
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL36@CheckMGGIn
$LN38@CheckMGGIn:
	xor	eax, eax
	jmp	SHORT $LN39@CheckMGGIn
$LN37@CheckMGGIn:
	sbb	eax, eax
	or	eax, 1
$LN39@CheckMGGIn:
	test	eax, eax
	je	SHORT $LN20@CheckMGGIn

; 2362 : 
; 2363 : 	for(i=0;i<st.num_mgg_basic;i++)

	inc	bl
	movsx	ecx, bl
	cmp	ecx, esi
	jl	SHORT $LL12@CheckMGGIn
$LN10@CheckMGGIn:

; 2369 : 		}
; 2370 : 	}
; 2371 : 
; 2372 : 	for(i=0;i<st.num_mgg;i++)

	movzx	esi, BYTE PTR _st+265
	xor	bl, bl
	test	esi, esi
	jle	SHORT $LN6@CheckMGGIn
	xor	ecx, ecx
	npad	7
$LL8@CheckMGGIn:

; 2373 : 	{
; 2374 : 		if(strcmp(mggf.name,mgg_game[i].name)==NULL)

	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx
	lea	ecx, DWORD PTR _mgg_game[eax*4]
	lea	eax, DWORD PTR _mggf$[ebp]
$LL40@CheckMGGIn:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN41@CheckMGGIn
	test	dl, dl
	je	SHORT $LN42@CheckMGGIn
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN41@CheckMGGIn
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL40@CheckMGGIn
$LN42@CheckMGGIn:
	xor	eax, eax
	jmp	SHORT $LN43@CheckMGGIn
$LN20@CheckMGGIn:

; 2366 : 		{
; 2367 : 			fclose(file);

	push	edi
	call	_fclose
	add	esp, 4

; 2368 : 			return i+1000;

	movsx	eax, bl
	add	eax, 1000				; 000003e8H
	pop	esi
	pop	ebx
	pop	edi

; 2393 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@CheckMGGIn:

; 2373 : 	{
; 2374 : 		if(strcmp(mggf.name,mgg_game[i].name)==NULL)

	sbb	eax, eax
	or	eax, 1
$LN43@CheckMGGIn:
	test	eax, eax
	je	SHORT $LN21@CheckMGGIn

; 2369 : 		}
; 2370 : 	}
; 2371 : 
; 2372 : 	for(i=0;i<st.num_mgg;i++)

	inc	bl
	movsx	ecx, bl
	cmp	ecx, esi
	jl	SHORT $LL8@CheckMGGIn
$LN6@CheckMGGIn:

; 2378 : 		}
; 2379 : 	}
; 2380 : 
; 2381 : 	for(i=0;i<st.Current_Map.num_mgg;i++)

	movzx	esi, BYTE PTR _st+66848
	xor	bl, bl
	test	esi, esi
	jle	SHORT $LN2@CheckMGGIn
	xor	ecx, ecx
$LL4@CheckMGGIn:

; 2382 : 	{
; 2383 : 		if(strcmp(mggf.name,mgg_map[i].name)==NULL)

	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx
	lea	ecx, DWORD PTR _mgg_map[eax*4]
	lea	eax, DWORD PTR _mggf$[ebp]
$LL44@CheckMGGIn:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN45@CheckMGGIn
	test	dl, dl
	je	SHORT $LN46@CheckMGGIn
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN45@CheckMGGIn
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL44@CheckMGGIn
$LN46@CheckMGGIn:
	xor	eax, eax
	jmp	SHORT $LN47@CheckMGGIn
$LN21@CheckMGGIn:

; 2375 : 		{
; 2376 : 			fclose(file);

	push	edi
	call	_fclose
	add	esp, 4

; 2377 : 			return i+10000;

	movsx	eax, bl
	add	eax, 10000				; 00002710H
	pop	esi
	pop	ebx
	pop	edi

; 2393 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@CheckMGGIn:

; 2382 : 	{
; 2383 : 		if(strcmp(mggf.name,mgg_map[i].name)==NULL)

	sbb	eax, eax
	or	eax, 1
$LN47@CheckMGGIn:
	test	eax, eax
	je	SHORT $LN22@CheckMGGIn

; 2378 : 		}
; 2379 : 	}
; 2380 : 
; 2381 : 	for(i=0;i<st.Current_Map.num_mgg;i++)

	inc	bl
	movsx	ecx, bl
	cmp	ecx, esi
	jl	SHORT $LL4@CheckMGGIn
$LN2@CheckMGGIn:

; 2386 : 			return i+100000;
; 2387 : 		}
; 2388 : 	}
; 2389 : 
; 2390 : 	fclose(file);

	push	edi
	call	_fclose
	add	esp, 4

; 2391 : 
; 2392 : 	return -1;

	or	eax, -1
	pop	esi
	pop	ebx
	pop	edi

; 2393 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@CheckMGGIn:

; 2384 : 		{
; 2385 : 			fclose(file);

	push	edi
	call	_fclose

; 2393 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 4
	movsx	eax, bl
	xor	ecx, ebp
	add	eax, 100000				; 000186a0H
	pop	esi
	pop	ebx
	pop	edi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CheckMGGInSystem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _LoadMGG
_TEXT	SEGMENT
tv3572 = -106696					; size = 4
_k$1$ = -106692						; size = 4
_imgdata$ = -106692					; size = 4
_sizex$1$ = -106688					; size = 4
_posy$1$ = -106684					; size = 4
_posx$1$ = -106680					; size = 4
tv3447 = -106676					; size = 4
tv3404 = -106676					; size = 4
tv3393 = -106676					; size = 4
_framealone$1$ = -106672				; size = 4
tv3347 = -106668					; size = 4
tv3346 = -106668					; size = 4
tv3305 = -106668					; size = 4
_file$1$ = -106664					; size = 4
_l$1$ = -106660						; size = 4
tv3449 = -106656					; size = 4
tv3289 = -106656					; size = 4
_imgw$ = -106656					; size = 2
$T1 = -106652						; size = 4
tv3503 = -106652					; size = 4
tv3458 = -106652					; size = 4
tv3351 = -106652					; size = 4
tv3013 = -106652					; size = 4
tv3001 = -106652					; size = 4
_j$1$ = -106648						; size = 4
tv3400 = -106648					; size = 4
tv3323 = -106648					; size = 4
tv3286 = -106648					; size = 4
_sizey$1$ = -106644					; size = 4
tv3561 = -106644					; size = 4
tv3559 = -106644					; size = 4
tv3558 = -106644					; size = 4
tv3556 = -106644					; size = 4
_n$3$ = -106640						; size = 4
_offx$1$ = -106640					; size = 4
_imgdata$3$ = -106640					; size = 4
tv3462 = -106640					; size = 4
tv2984 = -106640					; size = 4
tv2752 = -106640					; size = 4
_currh$ = -106636					; size = 4
_h$ = -106632						; size = 4
_channel2$ = -106628					; size = 2
_imgh$ = -106628					; size = 2
_offy$1$ = -106624					; size = 4
_imgdata$6$ = -106624					; size = 4
_imgdata$2$ = -106624					; size = 4
_data$1$ = -106624					; size = 4
tv3466 = -106624					; size = 4
tv3461 = -106624					; size = 4
_imgatlas$1$ = -106620					; size = 4
tv3566 = -106620					; size = 4
tv3565 = -106620					; size = 4
tv3564 = -106620					; size = 4
tv3563 = -106620					; size = 4
tv3562 = -106620					; size = 4
tv3511 = -106620					; size = 4
_data$3$ = -106616					; size = 4
tv3554 = -106616					; size = 4
tv3550 = -106616					; size = 4
tv3549 = -106616					; size = 4
tv3445 = -106616					; size = 4
_w$ = -106612						; size = 4
_MGIcolor$ = -106605					; size = 1
_i$ = -106604						; size = 2
_mggf$ = -106600					; size = 76
_framesize$ = -106524					; size = 32768
_normalsize$ = -73756					; size = 32768
_frameoffset$ = -40988					; size = 32768
_normals$ = -8220					; size = 8192
_header$ = -28						; size = 21
__$ArrayPad$ = -4					; size = 4
_LoadMGG PROC						; COMDAT
; _mgg$dead$ = ecx
; _name$dead$ = edx

; 2444 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 106696				; 0001a0c8H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2445 : 	FILE *file, *file2;
; 2446 : 	unsigned char *data;
; 2447 : 	_MGGFORMAT mggf;
; 2448 : 	char header[21];
; 2449 : 	 uint16 i=0, j=0, k=0, l=0, m=0, n=0, o=0;

	mov	DWORD PTR _l$1$[ebp], 0

; 2450 : 	uint32 framesize[MAX_FRAMES], frameoffset[MAX_FRAMES], *framealone;
; 2451 : 	uint16 *posx, *posy, *sizex, *sizey, *dimx, *dimy, channel2;
; 2452 : 	uint8 *imgatlas;
; 2453 : 	uint16 *w, *h, *currh, *offx, *offy;
; 2454 : 	int width, height, channel;
; 2455 : 	unsigned char *imgdata;
; 2456 : 	uint8 normals[MAX_FRAMES];
; 2457 : 	uint32 normalsize[MAX_FRAMES];
; 2458 : 	_MGGANIM *mga;
; 2459 : 	int32 checkmgg;
; 2460 : 
; 2461 : 	//MGI format specs
; 2462 : 	char mgiheader[3];
; 2463 : 	uint8 MGIcolor;
; 2464 : 	uint8 RLE;
; 2465 : 	uint16 imgw, imgh;
; 2466 : 
; 2467 : 	size_t mgisize;
; 2468 : 
; 2469 : 	checkmgg=CheckMGGInSystem(name);

	call	_CheckMGGInSystem

; 2470 : 
; 2471 : 	if(checkmgg==-2)

	cmp	eax, -2					; fffffffeH
	jne	SHORT $LN140@LoadMGG
$LN234@LoadMGG:

; 2472 : 		return 0;

	xor	eax, eax

; 3425 : 		
; 3426 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN140@LoadMGG:

; 2473 : 	else
; 2474 : 	if(checkmgg>0)

	test	eax, eax
	jg	SHORT $LN234@LoadMGG

; 2475 : 	//{
; 2476 : 		//LogApp("This MGG is already loaded
; 2477 : 		return 0;
; 2478 : 	//}
; 2479 : 
; 2480 : 	memset(&normals,0,MAX_FRAMES*sizeof(uint8));

	push	ebx
	push	8192					; 00002000H
	lea	eax, DWORD PTR _normals$[ebp]
	push	0
	push	eax
	call	_memset

; 2481 : 
; 2482 : 	/*
; 2483 : 	if((file=DecompressFile(name))==NULL)
; 2484 : 	{
; 2485 : 		LogApp("Error reading MGG file %s",name);
; 2486 : 			return 0;
; 2487 : 	}
; 2488 : 	*/
; 2489 : 
; 2490 : 	
; 2491 : 	if((file=fopen(name,"rb"))==NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_0BA@GLINHHCI@data?1mEngUI?4mgg?$AA@
	call	_fopen
	mov	ebx, eax
	add	esp, 20					; 00000014H
	mov	DWORD PTR _file$1$[ebp], ebx
	test	ebx, ebx
	jne	SHORT $LN137@LoadMGG

; 2492 : 	{
; 2493 : 		LogApp("Error reading MGG file %s",name);

	push	OFFSET ??_C@_0BA@GLINHHCI@data?1mEngUI?4mgg?$AA@
	push	OFFSET ??_C@_0BK@JNFOJKPO@Error?5reading?5MGG?5file?5?$CFs?$AA@
	call	DWORD PTR __imp__SDL_Log
	add	esp, 8

; 2494 : 			return -2;

	mov	eax, -2					; fffffffeH
	pop	ebx

; 3425 : 		
; 3426 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN137@LoadMGG:

; 2495 : 	}
; 2496 : 
; 2497 : 	rewind(file);

	push	ebx
	call	_rewind

; 2498 : 
; 2499 : 	fread(header,21,1,file);

	push	ebx
	push	1
	lea	eax, DWORD PTR _header$[ebp]
	push	21					; 00000015H
	push	eax
	call	_fread
	add	esp, 20					; 00000014H

; 2500 : 
; 2501 : 	if(strcmp(header,"MGG File Version 1")!=NULL)

	lea	eax, DWORD PTR _header$[ebp]
	mov	ecx, OFFSET ??_C@_0BD@IGEJGLBO@MGG?5File?5Version?51?$AA@
$LL193@LoadMGG:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN194@LoadMGG
	test	dl, dl
	je	SHORT $LN195@LoadMGG
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN194@LoadMGG
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL193@LoadMGG
$LN195@LoadMGG:
	xor	eax, eax
	jmp	SHORT $LN196@LoadMGG
$LN194@LoadMGG:
	sbb	eax, eax
	or	eax, 1
$LN196@LoadMGG:
	test	eax, eax
	je	SHORT $LN136@LoadMGG

; 2502 : 	{
; 2503 : 		LogApp("Invalid MGG file header %s",header);

	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	push	OFFSET ??_C@_0BL@HGJNDNHB@Invalid?5MGG?5file?5header?5?$CFs?$AA@
	call	DWORD PTR __imp__SDL_Log

; 2504 : 		fclose(file);

	push	ebx
	call	_fclose
	add	esp, 12					; 0000000cH

; 2505 : 		return 0;

	xor	eax, eax
	pop	ebx

; 3425 : 		
; 3426 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN136@LoadMGG:
	push	esi
	push	edi

; 2506 : 	}
; 2507 : 
; 2508 : 	fread(&mggf,sizeof(_MGGFORMAT),1,file);

	push	ebx
	push	1
	lea	eax, DWORD PTR _mggf$[ebp]
	push	76					; 0000004cH
	push	eax
	call	_fread

; 2509 : 
; 2510 : 	if((mggf.type!=SPRITEM && mggf.type!=TEXTUREM && mggf.type!=NONE) || (mggf.num_animations<0 || mggf.num_animations>MAX_ANIMATIONS) || (mggf.num_frames<0 || mggf.num_frames>MAX_FRAMES))

	mov	edx, DWORD PTR _mggf$[ebp+36]
	add	esp, 16					; 00000010H
	test	edx, edx
	je	SHORT $LN133@LoadMGG
	cmp	edx, 1
	je	SHORT $LN133@LoadMGG
	cmp	edx, 2
	jne	$LN132@LoadMGG
$LN133@LoadMGG:
	mov	edi, DWORD PTR _mggf$[ebp+48]
	cmp	edi, 64					; 00000040H
	ja	$LN132@LoadMGG
	mov	si, WORD PTR _mggf$[ebp+32]
	mov	eax, 8192				; 00002000H
	cmp	si, ax
	ja	$LN132@LoadMGG

; 2514 : 		return 0;
; 2515 : 	}
; 2516 : 
; 2517 : 	strcpy(mgg->name,mggf.name);

	xor	ecx, ecx
	npad	3
$LL143@LoadMGG:
	mov	al, BYTE PTR _mggf$[ebp+ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR _mgg_sys[ecx-1], al
	test	al, al
	jne	SHORT $LL143@LoadMGG

; 2518 : 
; 2519 : 	mgg->num_frames=mggf.num_frames;
; 2520 : 
; 2521 : 	mgg->type=mggf.type;
; 2522 : 	
; 2523 : 	mgg->num_anims=mggf.num_animations;
; 2524 : 
; 2525 : 	mgg->frames=(TEX_DATA*) calloc(mgg->num_frames,sizeof(TEX_DATA));

	mov	WORD PTR _mgg_sys+32, si
	movzx	esi, si
	push	40					; 00000028H
	push	esi
	mov	DWORD PTR _mgg_sys+36, edx
	mov	DWORD PTR _mgg_sys+52, edi
	call	_calloc

; 2526 : 
; 2527 : 	framealone=(uint32*)calloc(mgg->num_frames,sizeof(uint32));

	push	4
	push	esi
	mov	DWORD PTR _mgg_sys+40, eax
	call	_calloc

; 2528 : 
; 2529 : 	mga=(_MGGANIM*) malloc(mgg->num_anims*sizeof(_MGGANIM));

	imul	esi, edi, 42
	mov	DWORD PTR _framealone$1$[ebp], eax
	push	esi
	call	_malloc

; 2530 : 	mgg->anim=(_MGGANIM*) malloc(mgg->num_anims*sizeof(_MGGANIM));

	push	esi
	mov	edi, eax
	call	_malloc

; 2531 : 
; 2532 : 	fread(mga,sizeof(_MGGANIM),mgg->num_anims,file);

	push	ebx
	push	DWORD PTR _mggf$[ebp+48]
	mov	DWORD PTR _mgg_sys+56, eax
	push	42					; 0000002aH
	push	edi
	call	_fread
	add	esp, 40					; 00000028H

; 2533 : 
; 2534 : 	for(i=0;i<mgg->num_anims;i++)

	cmp	DWORD PTR _mgg_sys+52, 0
	jbe	$LN129@LoadMGG
	xor	eax, eax
	xor	ebx, ebx
	npad	2
$LL131@LoadMGG:

; 2535 : 	{
; 2536 : 		mgg->anim[i]=mga[i];

	mov	ecx, DWORD PTR _mgg_sys+56
	inc	ebx
	imul	esi, eax, 42
	mov	DWORD PTR _i$[ebp], ebx
	movdqu	xmm0, XMMWORD PTR [esi+edi]
	movdqu	XMMWORD PTR [esi+ecx], xmm0
	movdqu	xmm0, XMMWORD PTR [esi+edi+16]
	movdqu	XMMWORD PTR [esi+ecx+16], xmm0
	movq	xmm0, QWORD PTR [esi+edi+32]
	movq	QWORD PTR [esi+ecx+32], xmm0
	movzx	eax, WORD PTR [esi+edi+40]
	mov	WORD PTR [esi+ecx+40], ax

; 2537 : 		mgg->anim[i].current_frame*=10;

	mov	edx, DWORD PTR _mgg_sys+56
	mov	ax, WORD PTR [esi+edx+34]
	mov	cx, ax
	shl	ax, 2
	add	cx, ax
	movzx	eax, bx
	add	cx, cx
	mov	WORD PTR [esi+edx+34], cx
	cmp	eax, DWORD PTR _mgg_sys+52
	jb	SHORT $LL131@LoadMGG
	mov	ebx, DWORD PTR _file$1$[ebp]
$LN129@LoadMGG:

; 2538 : 	}
; 2539 : 
; 2540 : 	rewind(file);

	push	ebx
	call	_rewind

; 2541 : 	fseek(file,mggf.framesize_offset,SEEK_CUR);

	push	1
	push	DWORD PTR _mggf$[ebp+60]
	push	ebx
	call	_fseek

; 2542 : 	fread(framesize,sizeof(uint32),mggf.num_singletex+mggf.num_atlas,file);

	movzx	eax, WORD PTR _mggf$[ebp+42]
	movzx	ecx, BYTE PTR _mggf$[ebp+40]
	push	ebx
	add	ecx, eax
	lea	eax, DWORD PTR _framesize$[ebp]
	push	ecx
	push	4
	push	eax
	call	_fread

; 2543 : 	fread(frameoffset,sizeof(uint32),mggf.num_singletex+mggf.num_atlas,file);

	movzx	eax, WORD PTR _mggf$[ebp+42]
	movzx	ecx, BYTE PTR _mggf$[ebp+40]
	push	ebx
	add	ecx, eax
	lea	eax, DWORD PTR _frameoffset$[ebp]
	push	ecx
	push	4
	push	eax
	call	_fread

; 2544 : 	fread(normals,sizeof(uint8),mggf.num_singletex+mggf.num_atlas,file);

	movzx	eax, WORD PTR _mggf$[ebp+42]
	movzx	ecx, BYTE PTR _mggf$[ebp+40]
	push	ebx
	add	ecx, eax
	lea	eax, DWORD PTR _normals$[ebp]
	push	ecx
	push	1
	push	eax
	call	_fread

; 2545 : 	fread(normalsize,sizeof(uint32),mggf.num_singletex+mggf.num_atlas,file);

	movzx	eax, WORD PTR _mggf$[ebp+42]
	add	esp, 64					; 00000040H
	movzx	ecx, BYTE PTR _mggf$[ebp+40]
	add	ecx, eax
	lea	eax, DWORD PTR _normalsize$[ebp]
	push	ebx
	push	ecx
	push	4
	push	eax
	call	_fread

; 2546 : 
; 2547 : 	mgg->size=(Pos*) malloc(mgg->num_frames*sizeof(Pos));

	movzx	eax, WORD PTR _mgg_sys+32
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	push	eax
	call	_malloc

; 2548 : 	mgg->atlas=(GLint*) malloc(mggf.num_atlas*sizeof(GLint));

	movzx	esi, BYTE PTR _mggf$[ebp+40]
	mov	DWORD PTR _mgg_sys+48, eax
	lea	eax, DWORD PTR [esi*4]
	push	eax
	call	_malloc
	mov	DWORD PTR _mgg_sys+44, eax
	add	esp, 24					; 00000018H

; 2549 : 
; 2550 : 	for(i=0, j=0;i<mggf.num_singletex+mggf.num_atlas;i++)

	movzx	eax, WORD PTR _mggf$[ebp+42]
	add	eax, esi
	mov	DWORD PTR _i$[ebp], 0
	mov	esi, DWORD PTR __imp__glTexParameteri@12
	mov	DWORD PTR _j$1$[ebp], 0
	test	eax, eax
	jle	$LN126@LoadMGG
	mov	edi, DWORD PTR _imgdata$[ebp]
	mov	bx, WORD PTR _i$[ebp]
	npad	3
$LL128@LoadMGG:

; 2551 : 	{
; 2552 : 		
; 2553 : 		if(i==0) fseek(file,mggf.textures_offset+1,SEEK_SET);

	push	0
	test	bx, bx
	jne	SHORT $LN125@LoadMGG
	mov	eax, DWORD PTR _mggf$[ebp+52]

; 2554 : 		else

	jmp	SHORT $LN222@LoadMGG
$LN125@LoadMGG:

; 2555 : 			fseek(file,frameoffset[i-1]+1,SEEK_SET);

	movzx	eax, bx
	mov	eax, DWORD PTR _frameoffset$[ebp+eax*4-4]
$LN222@LoadMGG:
	inc	eax
	push	eax
	push	DWORD PTR _file$1$[ebp]
	call	_fseek

; 2556 : 		
; 2557 : 		data=malloc(framesize[i]);

	movzx	eax, bx
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _framesize$[ebp+eax*4]
	push	eax
	mov	DWORD PTR tv3566[ebp], eax
	call	_malloc
	mov	ebx, eax
	add	esp, 4

; 2558 : 
; 2559 : 		if(data==NULL)

	test	ebx, ebx
	jne	SHORT $LN123@LoadMGG

; 2560 : 		{
; 2561 : 			LogApp("Error allocating memory for texture %d, size %d, file %s",i,framesize[i],name);

	movzx	eax, WORD PTR _i$[ebp]
	push	OFFSET ??_C@_0BA@GLINHHCI@data?1mEngUI?4mgg?$AA@
	push	DWORD PTR tv3566[ebp]
	push	eax
	push	OFFSET ??_C@_0DJ@PPPGBEPE@Error?5allocating?5memory?5for?5text@
	call	DWORD PTR __imp__SDL_Log
	add	esp, 16					; 00000010H

; 2562 : 			continue;

	jmp	$LN127@LoadMGG
$LN123@LoadMGG:

; 2563 : 		}
; 2564 : 
; 2565 : 		fread(data,framesize[i],1,file);

	push	DWORD PTR _file$1$[ebp]
	push	1
	push	DWORD PTR tv3566[ebp]
	push	ebx
	call	_fread

; 2566 : 
; 2567 : 		if(j<mggf.num_atlas)

	movzx	eax, BYTE PTR _mggf$[ebp+40]
	add	esp, 16					; 00000010H
	cmp	WORD PTR _j$1$[ebp], ax
	jae	$LN122@LoadMGG

; 2568 : 		{
; 2569 : 			//imgdata=SOIL_load_image_from_memory((unsigned char*)data,framesize[i],&width,&height,&channel,SOIL_LOAD_AUTO);
; 2570 : 
; 2571 : 			//mgg->atlas[i]=SOIL_create_OGL_texture(imgdata,width,height,channel,0,SOIL_FLAG_TEXTURE_REPEATS); //mgg->atlas[i]=SOIL_load_OGL_texture_from_memory((unsigned char*)data,framesize[i],SOIL_LOAD_AUTO,0,SOIL_FLAG_TEXTURE_REPEATS);
; 2572 : 
; 2573 : 			if (data[0] == 'M' && data[1] == 'G' && data[2] == 'I')

	cmp	BYTE PTR [ebx], 77			; 0000004dH
	jne	$LN121@LoadMGG
	cmp	BYTE PTR [ebx+1], 71			; 00000047H
	jne	$LN121@LoadMGG
	cmp	BYTE PTR [ebx+2], 73			; 00000049H
	jne	$LN121@LoadMGG

; 2574 : 			{
; 2575 : 				MGIcolor = data[3];
; 2576 : 				RLE = data[4];
; 2577 : 				imgw = data[5] << 8;

	movzx	ecx, BYTE PTR [ebx+5]

; 2578 : 				imgw |= data[6];

	movzx	eax, BYTE PTR [ebx+6]
	mov	dl, BYTE PTR [ebx+3]
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR _MGIcolor$[ebp], dl

; 2579 : 
; 2580 : 				imgh = data[7] << 8;
; 2581 : 				imgh |= data[8];

	movzx	eax, BYTE PTR [ebx+8]
	movzx	esi, cx
	movzx	ecx, BYTE PTR [ebx+7]
	shl	cx, 8
	or	cx, ax
	mov	DWORD PTR _imgw$[ebp], esi
	movzx	eax, cx

; 2582 : 				
; 2583 : 				mgisize = imgw * imgh * MGIcolor;

	mov	ecx, esi
	movzx	esi, dl
	imul	esi, ecx
	mov	DWORD PTR _imgh$[ebp], eax
	mov	DWORD PTR tv3565[ebp], eax
	mov	DWORD PTR tv3561[ebp], ecx
	imul	esi, eax

; 2584 : 
; 2585 : 				imgdata = malloc(mgisize);

	push	esi
	call	_malloc

; 2586 : 
; 2587 : 				memcpy(imgdata, data + 9, mgisize);

	push	esi
	lea	ecx, DWORD PTR [ebx+9]
	mov	edi, eax
	push	ecx
	push	edi
	call	_memcpy

; 2588 : 
; 2589 : 				glGenTextures(1, &mgg->atlas[i]);

	mov	ecx, DWORD PTR _mgg_sys+44
	add	esp, 16					; 00000010H
	movzx	esi, WORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [ecx+esi*4]
	push	ecx
	push	1
	call	DWORD PTR __imp__glGenTextures@8

; 2590 : 				glBindTexture(GL_TEXTURE_2D,mgg->atlas[i]);

	mov	eax, DWORD PTR _mgg_sys+44
	push	DWORD PTR [eax+esi*4]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 2591 : 
; 2592 : 				if (MGIcolor == 3)

	mov	al, BYTE PTR _MGIcolor$[ebp]
	cmp	al, 3
	jne	SHORT $LN120@LoadMGG

; 2593 : 					glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, imgw, imgh, 0, GL_RGB, GL_UNSIGNED_BYTE, imgdata);

	push	edi
	push	5121					; 00001401H
	push	6407					; 00001907H
	push	0
	push	DWORD PTR tv3565[ebp]
	push	DWORD PTR tv3561[ebp]
	push	32849					; 00008051H

; 2594 : 				else

	jmp	SHORT $LN223@LoadMGG
$LN120@LoadMGG:

; 2595 : 				if (MGIcolor == 4)

	cmp	al, 4
	jne	SHORT $LN118@LoadMGG

; 2596 : 					glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, imgw, imgh, 0, GL_RGBA, GL_UNSIGNED_BYTE, imgdata);

	push	edi
	push	5121					; 00001401H
	push	6408					; 00001908H
	push	0
	push	DWORD PTR tv3565[ebp]
	push	DWORD PTR tv3561[ebp]
	push	32856					; 00008058H
$LN223@LoadMGG:
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
$LN118@LoadMGG:

; 2597 : 
; 2598 : 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	mov	esi, DWORD PTR __imp__glTexParameteri@12
	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	esi

; 2599 : 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	esi
$LN121@LoadMGG:

; 2600 : 
; 2601 : 			}
; 2602 : 
; 2603 : 			if(mggf.mipmap)

	cmp	BYTE PTR _mggf$[ebp+72], 0
	je	SHORT $LN117@LoadMGG

; 2604 : 			{
; 2605 : 				glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);

	push	9728					; 00002600H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	esi

; 2606 : 				glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);

	push	9728					; 00002600H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	esi

; 2607 : 			}
; 2608 : 			else

	jmp	SHORT $LN116@LoadMGG
$LN117@LoadMGG:

; 2609 : 				glGenerateMipmap(GL_TEXTURE_2D);

	push	3553					; 00000de1H
	call	DWORD PTR _GLeeFuncPtr_glGenerateMipmap
$LN116@LoadMGG:

; 2610 : 
; 2611 : 			mgg->frames[i].channel=MGIcolor;

	movzx	edx, WORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _MGIcolor$[ebp]
	lea	eax, DWORD PTR [edx+edx*4]
	shl	eax, 3
	mov	DWORD PTR tv3554[ebp], eax
	mov	eax, DWORD PTR _mgg_sys+40
	mov	esi, DWORD PTR tv3554[ebp]
	mov	DWORD PTR [esi+eax+32], ecx

; 2612 : 			mgg->frames[i].w=imgw;

	mov	eax, DWORD PTR _imgw$[ebp]
	movzx	ecx, ax
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [esi+eax+24], ecx

; 2613 : 			mgg->frames[i].h=imgh;

	mov	eax, DWORD PTR _imgh$[ebp]
	movzx	ecx, ax
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [esi+eax+28], ecx

; 2614 : 
; 2615 : 			if(mgg->atlas[i]==NULL)

	mov	eax, DWORD PTR _mgg_sys+44
	mov	esi, DWORD PTR __imp__glTexParameteri@12
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $LN115@LoadMGG

; 2616 : 				LogApp("Error loading texture from memory");

	push	OFFSET ??_C@_0CC@PLAHMHNO@Error?5loading?5texture?5from?5memor@
	call	DWORD PTR __imp__SDL_Log
	add	esp, 4
$LN115@LoadMGG:

; 2617 : 
; 2618 : 			if (data)						
; 2619 : 				free(data);

	push	ebx
	call	_free
	add	esp, 4

; 2620 : 			if (imgdata)

	test	edi, edi
	je	SHORT $LN113@LoadMGG

; 2621 : 				free(imgdata);

	push	edi
	call	_free
	add	esp, 4
$LN113@LoadMGG:

; 2622 : 
; 2623 : 			if(normals[i])

	movzx	ebx, WORD PTR _i$[ebp]
	cmp	BYTE PTR _normals$[ebp+ebx], 0
	je	$LN112@LoadMGG

; 2624 : 			{
; 2625 : 				fseek(file,frameoffset[i]-normalsize[i],SEEK_SET);

	mov	eax, DWORD PTR _frameoffset$[ebp+ebx*4]
	sub	eax, DWORD PTR _normalsize$[ebp+ebx*4]
	push	0
	push	eax
	push	DWORD PTR _file$1$[ebp]
	call	_fseek

; 2626 : 		
; 2627 : 				data=malloc(normalsize[i]);

	mov	eax, DWORD PTR _normalsize$[ebp+ebx*4]
	push	eax
	mov	DWORD PTR tv3511[ebp], eax
	call	_malloc
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _data$1$[ebp], ebx

; 2628 : 
; 2629 : 				if(data==NULL)

	test	ebx, ebx
	jne	SHORT $LN111@LoadMGG

; 2630 : 				{
; 2631 : 					LogApp("Error allocating memory for normal mapping texture %d, size %d, file %s",i,normalsize[i],name);

	movzx	eax, WORD PTR _i$[ebp]
	push	OFFSET ??_C@_0BA@GLINHHCI@data?1mEngUI?4mgg?$AA@
	push	DWORD PTR tv3511[ebp]
	push	eax
	push	OFFSET ??_C@_0EI@OCDBEPGI@Error?5allocating?5memory?5for?5norm@
	call	DWORD PTR __imp__SDL_Log
	add	esp, 16					; 00000010H

; 2632 : 					continue;

	jmp	$LN127@LoadMGG
$LN111@LoadMGG:

; 2633 : 				}
; 2634 : 
; 2635 : 				fread(data,normalsize[i],1,file);

	push	DWORD PTR _file$1$[ebp]
	push	1
	push	DWORD PTR tv3511[ebp]
	push	ebx
	call	_fread
	add	esp, 16					; 00000010H

; 2636 : 
; 2637 : 				//imgdata=SOIL_load_image_from_memory((unsigned char*)data,normalsize[i],&width,&height,&channel,SOIL_LOAD_AUTO);
; 2638 : 				//mgg->frames[i].Ndata=SOIL_create_OGL_texture(imgdata,width,height,channel,0,SOIL_FLAG_TEXTURE_REPEATS);
; 2639 : 
; 2640 : 				if (data[0] == 'M' && data[1] == 'G' && data[2] == 'I')

	cmp	BYTE PTR [ebx], 77			; 0000004dH
	jne	$LN110@LoadMGG
	cmp	BYTE PTR [ebx+1], 71			; 00000047H
	jne	$LN110@LoadMGG
	cmp	BYTE PTR [ebx+2], 73			; 00000049H
	jne	$LN110@LoadMGG

; 2641 : 				{
; 2642 : 					MGIcolor = data[3];
; 2643 : 					RLE = data[4];
; 2644 : 					imgw = data[5] << 8;

	mov	edx, DWORD PTR _data$1$[ebp]
	mov	bl, BYTE PTR [ebx+3]
	mov	BYTE PTR _MGIcolor$[ebp], bl
	movzx	ecx, BYTE PTR [edx+5]

; 2645 : 					imgw |= data[6];

	movzx	eax, BYTE PTR [edx+6]
	shl	cx, 8
	or	cx, ax

; 2646 : 
; 2647 : 					imgh = data[7] << 8;
; 2648 : 					imgh |= data[8];

	movzx	eax, BYTE PTR [edx+8]
	movzx	esi, cx
	movzx	ecx, BYTE PTR [edx+7]
	shl	cx, 8
	or	cx, ax
	mov	DWORD PTR _imgw$[ebp], esi
	movzx	eax, cx

; 2649 : 
; 2650 : 					mgisize = imgw * imgh * MGIcolor;

	mov	ecx, esi
	movzx	esi, bl
	imul	esi, ecx
	mov	DWORD PTR _imgh$[ebp], eax
	mov	DWORD PTR tv3564[ebp], eax
	mov	DWORD PTR tv3559[ebp], ecx
	imul	esi, eax

; 2651 : 
; 2652 : 					imgdata = malloc(mgisize);

	push	esi
	call	_malloc
	mov	edi, eax

; 2653 : 
; 2654 : 					memcpy(imgdata, data + 9, mgisize);

	mov	eax, DWORD PTR _data$1$[ebp]
	push	esi
	add	eax, 9
	push	eax
	push	edi
	call	_memcpy

; 2655 : 
; 2656 : 					glGenTextures(1, &mgg->frames[i].Ndata);

	mov	eax, DWORD PTR _mgg_sys+40
	add	esp, 16					; 00000010H
	mov	esi, DWORD PTR tv3554[ebp]
	add	eax, 4
	add	eax, esi
	push	eax
	push	1
	call	DWORD PTR __imp__glGenTextures@8

; 2657 : 					glBindTexture(GL_TEXTURE_2D, mgg->frames[i].Ndata);

	mov	eax, DWORD PTR _mgg_sys+40
	push	DWORD PTR [esi+eax+4]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 2658 : 
; 2659 : 					if (MGIcolor == 3)

	cmp	bl, 3
	jne	SHORT $LN109@LoadMGG

; 2660 : 						glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, imgw, imgh, 0, GL_RGB, GL_UNSIGNED_BYTE, imgdata);

	push	edi
	push	5121					; 00001401H
	push	6407					; 00001907H
	push	0
	push	DWORD PTR tv3564[ebp]
	push	DWORD PTR tv3559[ebp]
	push	32849					; 00008051H

; 2661 : 					else

	jmp	SHORT $LN224@LoadMGG
$LN109@LoadMGG:

; 2662 : 					if (MGIcolor == 4)

	cmp	bl, 4
	jne	SHORT $LN107@LoadMGG

; 2663 : 						glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, imgw, imgh, 0, GL_RGBA, GL_UNSIGNED_BYTE, imgdata);

	push	edi
	push	5121					; 00001401H
	push	6408					; 00001908H
	push	0
	push	DWORD PTR tv3564[ebp]
	push	DWORD PTR tv3559[ebp]
	push	32856					; 00008058H
$LN224@LoadMGG:
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
$LN107@LoadMGG:

; 2664 : 
; 2665 : 					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	mov	esi, DWORD PTR __imp__glTexParameteri@12
	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	esi

; 2666 : 					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	esi
	mov	ebx, DWORD PTR _data$1$[ebp]
$LN110@LoadMGG:

; 2667 : 
; 2668 : 				}
; 2669 : 
; 2670 : 				if(mggf.mipmap)

	cmp	BYTE PTR _mggf$[ebp+72], 0
	je	SHORT $LN106@LoadMGG

; 2671 : 				{
; 2672 : 					glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);

	push	9728					; 00002600H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	esi

; 2673 : 					glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);

	push	9728					; 00002600H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	esi

; 2674 : 				}
; 2675 : 				else

	jmp	SHORT $LN105@LoadMGG
$LN106@LoadMGG:

; 2676 : 					glGenerateMipmap(GL_TEXTURE_2D);

	push	3553					; 00000de1H
	call	DWORD PTR _GLeeFuncPtr_glGenerateMipmap
$LN105@LoadMGG:

; 2677 : 
; 2678 : 				mgg->frames[i].normal=1;

	mov	eax, DWORD PTR _mgg_sys+40
	mov	ecx, DWORD PTR tv3554[ebp]
	mov	BYTE PTR [ecx+eax+8], 1

; 2679 : 
; 2680 : 				if(mgg->frames[i].Ndata==NULL)

	mov	eax, DWORD PTR _mgg_sys+40
	cmp	DWORD PTR [ecx+eax+4], 0
	jne	SHORT $LN104@LoadMGG

; 2681 : 					LogApp("Error loading normal mapping texture from memory");

	push	OFFSET ??_C@_0DB@EBPLCLOB@Error?5loading?5normal?5mapping?5tex@
	call	DWORD PTR __imp__SDL_Log
	add	esp, 4
$LN104@LoadMGG:

; 2682 : 
; 2683 : 					if (data)						
; 2684 : 						free(data);

	push	ebx
	call	_free
	add	esp, 4

; 2685 : 					if (imgdata)

	test	edi, edi
	je	SHORT $LN101@LoadMGG

; 2686 : 						free(imgdata);

	push	edi
	call	_free
	add	esp, 4

; 2690 : 
; 2691 : 			j++;

	inc	DWORD PTR _j$1$[ebp]

; 2692 : 		}
; 2693 : 		else

	jmp	$LN127@LoadMGG
$LN112@LoadMGG:

; 2687 : 			}
; 2688 : 			else
; 2689 : 				mgg->frames[i].normal=0;

	mov	eax, DWORD PTR _mgg_sys+40
	mov	ecx, DWORD PTR tv3554[ebp]
	mov	BYTE PTR [ecx+eax+8], 0
$LN101@LoadMGG:

; 2690 : 
; 2691 : 			j++;

	inc	DWORD PTR _j$1$[ebp]

; 2692 : 		}
; 2693 : 		else

	jmp	$LN127@LoadMGG
$LN122@LoadMGG:

; 2694 : 		{
; 2695 : 			i-=mggf.num_atlas;

	sub	DWORD PTR _i$[ebp], eax

; 2696 : 			//imgdata=SOIL_load_image_from_memory((unsigned char*)data,framesize[i],&width,&height,&channel,SOIL_LOAD_AUTO);
; 2697 : 			//mgg->frames[i+(mggf.num_frames-mggf.num_singletex)].data=SOIL_create_OGL_texture(imgdata,width,height,channel,0,SOIL_FLAG_TEXTURE_REPEATS);//SOIL_load_OGL_texture_from_memory((unsigned char*)data,framesize[i],SOIL_LOAD_AUTO,0,SOIL_FLAG_TEXTURE_REPEATS);
; 2698 : 
; 2699 : 			if (data[0] == 'M' && data[1] == 'G' && data[2] == 'I')

	cmp	BYTE PTR [ebx], 77			; 0000004dH
	jne	$LN99@LoadMGG
	cmp	BYTE PTR [ebx+1], 71			; 00000047H
	jne	$LN99@LoadMGG
	cmp	BYTE PTR [ebx+2], 73			; 00000049H
	jne	$LN99@LoadMGG

; 2700 : 			{
; 2701 : 				MGIcolor = data[3];
; 2702 : 				RLE = data[4];
; 2703 : 				imgw = data[5] << 8;

	movzx	ecx, BYTE PTR [ebx+5]

; 2704 : 				imgw |= data[6];

	movzx	eax, BYTE PTR [ebx+6]
	mov	dl, BYTE PTR [ebx+3]
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR _MGIcolor$[ebp], dl

; 2705 : 
; 2706 : 				imgh = data[7] << 8;
; 2707 : 				imgh |= data[8];

	movzx	eax, BYTE PTR [ebx+8]
	movzx	esi, cx
	movzx	ecx, BYTE PTR [ebx+7]
	shl	cx, 8
	or	cx, ax
	mov	DWORD PTR _imgw$[ebp], esi
	movzx	eax, cx

; 2708 : 
; 2709 : 				mgisize = imgw * imgh * MGIcolor;

	mov	ecx, esi
	movzx	esi, dl
	imul	esi, ecx
	mov	DWORD PTR _imgh$[ebp], eax
	mov	DWORD PTR tv3563[ebp], eax
	mov	DWORD PTR tv3558[ebp], ecx
	imul	esi, eax

; 2710 : 
; 2711 : 				imgdata = malloc(mgisize);

	push	esi
	call	_malloc
	mov	edi, eax

; 2712 : 
; 2713 : 				memcpy(imgdata, data + 9, mgisize);

	lea	eax, DWORD PTR [ebx+9]
	push	esi
	push	eax
	push	edi
	call	_memcpy

; 2714 : 
; 2715 : 				glGenTextures(1, &mgg->frames[i + (mggf.num_frames - mggf.num_singletex)].data);

	movzx	eax, WORD PTR _mggf$[ebp+42]
	add	esp, 16					; 00000010H
	movzx	ecx, WORD PTR _mggf$[ebp+32]
	movzx	esi, WORD PTR _i$[ebp]
	sub	ecx, eax
	mov	eax, DWORD PTR _mgg_sys+40
	add	ecx, esi
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	1
	call	DWORD PTR __imp__glGenTextures@8

; 2716 : 				glBindTexture(GL_TEXTURE_2D, mgg->frames[i + (mggf.num_frames - mggf.num_singletex)].data);

	movzx	eax, WORD PTR _mggf$[ebp+42]
	movzx	ecx, WORD PTR _mggf$[ebp+32]
	sub	ecx, eax
	mov	eax, DWORD PTR _mgg_sys+40
	add	ecx, esi
	lea	ecx, DWORD PTR [ecx+ecx*4]
	push	DWORD PTR [eax+ecx*8]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 2717 : 
; 2718 : 				if (MGIcolor == 3)

	mov	al, BYTE PTR _MGIcolor$[ebp]
	cmp	al, 3
	jne	SHORT $LN98@LoadMGG

; 2719 : 					glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, imgw, imgh, 0, GL_RGB, GL_UNSIGNED_BYTE, imgdata);

	push	edi
	push	5121					; 00001401H
	push	6407					; 00001907H
	push	0
	push	DWORD PTR tv3563[ebp]
	push	DWORD PTR tv3558[ebp]
	push	32849					; 00008051H

; 2720 : 				else

	jmp	SHORT $LN225@LoadMGG
$LN98@LoadMGG:

; 2721 : 				if (MGIcolor == 4)

	cmp	al, 4
	jne	SHORT $LN96@LoadMGG

; 2722 : 					glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, imgw, imgh, 0, GL_RGBA, GL_UNSIGNED_BYTE, imgdata);

	push	edi
	push	5121					; 00001401H
	push	6408					; 00001908H
	push	0
	push	DWORD PTR tv3563[ebp]
	push	DWORD PTR tv3558[ebp]
	push	32856					; 00008058H
$LN225@LoadMGG:
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
$LN96@LoadMGG:

; 2723 : 
; 2724 : 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	mov	esi, DWORD PTR __imp__glTexParameteri@12
	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	esi

; 2725 : 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	esi
$LN99@LoadMGG:

; 2726 : 
; 2727 : 			}
; 2728 : 
; 2729 : 			//glGenerateMipmap(GL_TEXTURE_2D);
; 2730 : 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	esi

; 2731 : 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

	push	10497					; 00002901H
	push	10243					; 00002803H
	push	3553					; 00000de1H
	call	esi

; 2732 : 
; 2733 : 			if(mggf.mipmap)

	cmp	BYTE PTR _mggf$[ebp+72], 0
	je	SHORT $LN95@LoadMGG

; 2734 : 			{
; 2735 : 				glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);

	push	9728					; 00002600H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	esi

; 2736 : 				glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);

	push	9728					; 00002600H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	esi

; 2737 : 			}
; 2738 : 			else

	jmp	SHORT $LN94@LoadMGG
$LN95@LoadMGG:

; 2739 : 				glGenerateMipmap(GL_TEXTURE_2D);

	push	3553					; 00000de1H
	call	DWORD PTR _GLeeFuncPtr_glGenerateMipmap
$LN94@LoadMGG:

; 2740 : 
; 2741 : 			mgg->frames[i+(mggf.num_texinatlas)].w=imgw;

	mov	eax, DWORD PTR _imgw$[ebp]

; 2742 : 			mgg->frames[i+(mggf.num_texinatlas)].h=imgh;
; 2743 : 			mgg->frames[i+(mggf.num_texinatlas)].channel=MGIcolor;
; 2744 : 
; 2745 : 			mgg->frames[i+(mggf.num_texinatlas)].posx=0;

	xor	esi, esi
	movzx	ecx, WORD PTR _i$[ebp]
	movzx	edx, ax
	movzx	eax, WORD PTR _mggf$[ebp+44]
	add	eax, ecx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [eax+ecx*8+24], edx
	mov	eax, DWORD PTR _imgh$[ebp]
	movzx	ecx, WORD PTR _i$[ebp]
	movzx	edx, ax
	movzx	eax, WORD PTR _mggf$[ebp+44]
	add	eax, ecx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [eax+ecx*8+28], edx
	movzx	eax, WORD PTR _mggf$[ebp+44]
	movzx	ecx, WORD PTR _i$[ebp]
	movzx	edx, BYTE PTR _MGIcolor$[ebp]
	add	eax, ecx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [eax+ecx*8+32], edx
	movzx	eax, WORD PTR _mggf$[ebp+44]
	movzx	edx, WORD PTR _i$[ebp]
	add	eax, edx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	WORD PTR [eax+ecx*8+14], si

; 2746 : 			mgg->frames[i+(mggf.num_texinatlas)].posy=0;

	movzx	eax, WORD PTR _mggf$[ebp+44]
	add	eax, edx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	WORD PTR [eax+ecx*8+16], si

; 2747 : 			mgg->frames[i+mggf.num_texinatlas].vb_id=-1;

	or	esi, -1
	movzx	eax, WORD PTR _mggf$[ebp+44]
	add	eax, edx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	WORD PTR [eax+ecx*8+10], si

; 2748 : 
; 2749 : 			if(mgg->frames[i+(mggf.num_texinatlas)].data==NULL)

	movzx	eax, WORD PTR _mggf$[ebp+44]
	mov	esi, DWORD PTR __imp__glTexParameteri@12
	add	eax, edx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _mgg_sys+40
	cmp	DWORD PTR [eax+ecx*8], 0
	jne	SHORT $LN93@LoadMGG

; 2750 : 				LogApp("Error loading texture from memory");

	push	OFFSET ??_C@_0CC@PLAHMHNO@Error?5loading?5texture?5from?5memor@
	call	DWORD PTR __imp__SDL_Log
	add	esp, 4
$LN93@LoadMGG:

; 2751 : 
; 2752 : 			if (data)						
; 2753 : 				free(data);

	push	ebx
	call	_free
	add	esp, 4

; 2754 : 			if(imgdata)

	test	edi, edi
	je	SHORT $LN91@LoadMGG

; 2755 : 				free(imgdata);

	push	edi
	call	_free
	add	esp, 4
$LN91@LoadMGG:

; 2756 : 
; 2757 : 			if(normals[i])

	movzx	ebx, WORD PTR _i$[ebp]
	cmp	BYTE PTR _normals$[ebp+ebx], 0
	je	$LN90@LoadMGG

; 2758 : 			{
; 2759 : 				fseek(file,frameoffset[i]-normalsize[i],SEEK_SET);

	mov	eax, DWORD PTR _frameoffset$[ebp+ebx*4]
	sub	eax, DWORD PTR _normalsize$[ebp+ebx*4]
	push	0
	push	eax
	push	DWORD PTR _file$1$[ebp]
	call	_fseek

; 2760 : 		
; 2761 : 				data=malloc(normalsize[i]);

	push	DWORD PTR _normalsize$[ebp+ebx*4]
	call	_malloc

; 2762 : 
; 2763 : 				if(data==NULL)
; 2764 : 				{
; 2765 : 					LogApp("Error allocating memory for normal mapping texture %d, size %d, file %s",i,normalsize[i],name);

	mov	ecx, DWORD PTR _normalsize$[ebp+ebx*4]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _data$3$[ebp], eax
	test	eax, eax
	jne	SHORT $LN89@LoadMGG
	push	OFFSET ??_C@_0BA@GLINHHCI@data?1mEngUI?4mgg?$AA@
	push	ecx
	push	ebx
	push	OFFSET ??_C@_0EI@OCDBEPGI@Error?5allocating?5memory?5for?5norm@
	call	DWORD PTR __imp__SDL_Log
	add	esp, 16					; 00000010H

; 2766 : 					continue;

	jmp	$LN127@LoadMGG
$LN89@LoadMGG:

; 2767 : 				}
; 2768 : 
; 2769 : 				fread(data,normalsize[i],1,file);

	push	DWORD PTR _file$1$[ebp]
	push	1
	push	ecx
	push	eax
	call	_fread

; 2770 : 
; 2771 : 				//imgdata=SOIL_load_image_from_memory((unsigned char*)data,normalsize[i],&width,&height,&channel,SOIL_LOAD_AUTO);
; 2772 : 				//mgg->frames[i+(mggf.num_texinatlas)].Ndata=SOIL_create_OGL_texture(imgdata,width,height,channel,0,SOIL_FLAG_TEXTURE_REPEATS || SOIL_FLAG_MIPMAPS);
; 2773 : 
; 2774 : 				if (data[0] == 'M' && data[1] == 'G' && data[2] == 'I')

	mov	eax, DWORD PTR _data$3$[ebp]
	add	esp, 16					; 00000010H
	cmp	BYTE PTR [eax], 77			; 0000004dH
	jne	$LN88@LoadMGG
	cmp	BYTE PTR [eax+1], 71			; 00000047H
	jne	$LN88@LoadMGG
	cmp	BYTE PTR [eax+2], 73			; 00000049H
	jne	$LN88@LoadMGG

; 2775 : 				{
; 2776 : 					MGIcolor = data[3];
; 2777 : 					RLE = data[4];
; 2778 : 					imgw = data[5] << 8;

	movzx	ecx, BYTE PTR [eax+5]
	mov	dl, BYTE PTR [eax+3]

; 2779 : 					imgw |= data[6];

	movzx	eax, BYTE PTR [eax+6]
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR _MGIcolor$[ebp], dl

; 2780 : 
; 2781 : 					imgh = data[7] << 8;

	mov	eax, DWORD PTR _data$3$[ebp]
	movzx	esi, cx
	mov	DWORD PTR _imgw$[ebp], esi
	movzx	ecx, BYTE PTR [eax+7]

; 2782 : 					imgh |= data[8];

	movzx	eax, BYTE PTR [eax+8]
	shl	cx, 8
	or	cx, ax
	movzx	eax, cx

; 2783 : 
; 2784 : 					mgisize = imgw * imgh * MGIcolor;

	mov	ecx, esi
	movzx	esi, dl
	imul	esi, ecx
	mov	DWORD PTR _imgh$[ebp], eax
	mov	DWORD PTR tv3562[ebp], eax
	mov	DWORD PTR tv3556[ebp], ecx
	imul	esi, eax

; 2785 : 
; 2786 : 					imgdata = malloc(mgisize);

	push	esi
	call	_malloc
	mov	edi, eax

; 2787 : 
; 2788 : 					memcpy(imgdata, data + 9, mgisize);

	mov	eax, DWORD PTR _data$3$[ebp]
	push	esi
	add	eax, 9
	push	eax
	push	edi
	call	_memcpy

; 2789 : 
; 2790 : 					//glGenTextures(1, &mgg->frames[i + (mggf.num_texinatlas)].Ndata);
; 2791 : 					//glBindTexture(GL_TEXTURE_2D, mgg->frames[i + (mggf.num_texinatlas)].Ndata);
; 2792 : 
; 2793 : 					glGenTextures(1, &mgg->frames[i + (mggf.num_frames - mggf.num_singletex)].Ndata);

	movzx	eax, WORD PTR _mggf$[ebp+42]
	add	esp, 16					; 00000010H
	movzx	ecx, WORD PTR _mggf$[ebp+32]
	sub	ecx, eax
	mov	eax, DWORD PTR _mgg_sys+40
	add	ecx, ebx
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	eax, DWORD PTR [eax+ecx*8]
	add	eax, 4
	push	eax
	push	1
	call	DWORD PTR __imp__glGenTextures@8

; 2794 : 					glBindTexture(GL_TEXTURE_2D, mgg->frames[i + (mggf.num_frames - mggf.num_singletex)].Ndata);

	movzx	eax, WORD PTR _mggf$[ebp+42]
	movzx	ecx, WORD PTR _mggf$[ebp+32]
	sub	ecx, eax
	mov	eax, DWORD PTR _mgg_sys+40
	add	ecx, ebx
	lea	ecx, DWORD PTR [ecx+ecx*4]
	push	DWORD PTR [eax+ecx*8+4]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 2795 : 					
; 2796 : 					if (MGIcolor == 3)

	mov	al, BYTE PTR _MGIcolor$[ebp]
	cmp	al, 3
	jne	SHORT $LN87@LoadMGG

; 2797 : 						glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, imgw, imgh, 0, GL_RGB, GL_UNSIGNED_BYTE, imgdata);

	push	edi
	push	5121					; 00001401H
	push	6407					; 00001907H
	push	0
	push	DWORD PTR tv3562[ebp]
	push	DWORD PTR tv3556[ebp]
	push	32849					; 00008051H

; 2798 : 					else

	jmp	SHORT $LN226@LoadMGG
$LN87@LoadMGG:

; 2799 : 					if (MGIcolor == 4)

	cmp	al, 4
	jne	SHORT $LN85@LoadMGG

; 2800 : 						glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, imgw, imgh, 0, GL_RGBA, GL_UNSIGNED_BYTE, imgdata);

	push	edi
	push	5121					; 00001401H
	push	6408					; 00001908H
	push	0
	push	DWORD PTR tv3562[ebp]
	push	DWORD PTR tv3556[ebp]
	push	32856					; 00008058H
$LN226@LoadMGG:
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
$LN85@LoadMGG:

; 2801 : 
; 2802 : 					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	mov	esi, DWORD PTR __imp__glTexParameteri@12
	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	esi

; 2803 : 					glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	push	10497					; 00002901H
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	esi
$LN88@LoadMGG:

; 2804 : 
; 2805 : 				}
; 2806 : 
; 2807 : 				if(mggf.mipmap)

	cmp	BYTE PTR _mggf$[ebp+72], 0
	je	SHORT $LN84@LoadMGG

; 2808 : 				{
; 2809 : 					glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);

	push	9728					; 00002600H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	esi

; 2810 : 					glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);

	push	9728					; 00002600H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	esi

; 2811 : 				}
; 2812 : 				else

	jmp	SHORT $LN83@LoadMGG
$LN84@LoadMGG:

; 2813 : 					glGenerateMipmap(GL_TEXTURE_2D);

	push	3553					; 00000de1H
	call	DWORD PTR _GLeeFuncPtr_glGenerateMipmap
$LN83@LoadMGG:

; 2814 : 
; 2815 : 				mgg->frames[i+(mggf.num_texinatlas)].normal=1;

	movzx	eax, WORD PTR _mggf$[ebp+44]
	add	eax, ebx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	BYTE PTR [eax+ecx*8+8], 1

; 2816 : 
; 2817 : 				if(mgg->frames[i+(mggf.num_texinatlas)].Ndata==NULL)

	movzx	eax, WORD PTR _mggf$[ebp+44]
	add	eax, ebx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _mgg_sys+40
	cmp	DWORD PTR [eax+ecx*8+4], 0
	jne	SHORT $LN82@LoadMGG

; 2818 : 					LogApp("Error loading normal mapping texture from memory");

	push	OFFSET ??_C@_0DB@EBPLCLOB@Error?5loading?5normal?5mapping?5tex@
	call	DWORD PTR __imp__SDL_Log
	add	esp, 4
$LN82@LoadMGG:

; 2819 : 
; 2820 : 				if(data)						
; 2821 : 					free(data);

	push	DWORD PTR _data$3$[ebp]
	call	_free
	add	esp, 4

; 2822 : 				if(imgdata)

	test	edi, edi
	je	SHORT $LN79@LoadMGG

; 2823 : 					free(imgdata);

	push	edi
	call	_free
	add	esp, 4

; 2824 : 
; 2825 : 			}
; 2826 : 			else

	jmp	SHORT $LN79@LoadMGG
$LN90@LoadMGG:

; 2827 : 				mgg->frames[i+(mggf.num_texinatlas)].normal=0;

	movzx	eax, WORD PTR _mggf$[ebp+44]
	add	eax, ebx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	BYTE PTR [eax+ecx*8+8], 0
$LN79@LoadMGG:

; 2828 : 
; 2829 : 			i+=mggf.num_atlas;

	movzx	eax, BYTE PTR _mggf$[ebp+40]
	add	WORD PTR _i$[ebp], ax
$LN127@LoadMGG:

; 2549 : 
; 2550 : 	for(i=0, j=0;i<mggf.num_singletex+mggf.num_atlas;i++)

	inc	DWORD PTR _i$[ebp]
	movzx	eax, WORD PTR _mggf$[ebp+42]
	movzx	ecx, BYTE PTR _mggf$[ebp+40]
	mov	bx, WORD PTR _i$[ebp]
	add	ecx, eax
	movzx	eax, bx
	cmp	eax, ecx
	jl	$LL128@LoadMGG
$LN126@LoadMGG:

; 2830 : 		}
; 2831 : 	}
; 2832 : 		
; 2833 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 2834 : 	if(mggf.num_atlas>0)

	mov	al, BYTE PTR _mggf$[ebp+40]
	test	al, al
	je	$LN75@LoadMGG

; 2835 : 	{
; 2836 : 		for(i=0;i<mggf.num_atlas;i++)

	mov	edx, DWORD PTR _vbdt
	mov	si, WORD PTR _vbdt_num
	mov	DWORD PTR _i$[ebp], 0
	mov	bx, WORD PTR _i$[ebp]
$LL77@LoadMGG:

; 2837 : 		{
; 2838 : 			if(!vbdt_num)

	test	si, si
	jne	SHORT $LN74@LoadMGG

; 2839 : 			{
; 2840 : 				vbdt_num++;

	mov	esi, 1

; 2841 : 				vbdt=(VB_DATAT*) malloc(sizeof(VB_DATAT));

	push	64					; 00000040H
	mov	WORD PTR _vbdt_num, si
	call	_malloc
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR _vbdt, edx

; 2842 : 				if(!vbdt)

	test	edx, edx
	jne	SHORT $LN72@LoadMGG

; 2843 : 					LogApp("Error could not allocate memory for the Vertex Buffer");

	push	OFFSET ??_C@_0DG@BNCAOHGG@Error?5could?5not?5allocate?5memory?5@
	call	DWORD PTR __imp__SDL_Log

; 2844 : 			}
; 2845 : 			else

	mov	edx, DWORD PTR _vbdt
	add	esp, 4
	mov	si, WORD PTR _vbdt_num
	jmp	SHORT $LN72@LoadMGG
$LN74@LoadMGG:

; 2846 : 			{
; 2847 : 				vbdt_num++;

	inc	si

; 2848 : 				vbdt=(VB_DATAT*) realloc(vbdt,vbdt_num*sizeof(VB_DATAT));

	movzx	eax, si
	shl	eax, 6
	push	eax
	push	edx
	mov	WORD PTR _vbdt_num, si
	call	_realloc
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR _vbdt, edx
$LN72@LoadMGG:

; 2849 : 			}
; 2850 : 
; 2851 : 			vbdt[vbdt_num-1].num_elements=0;

	movzx	edi, si
	xor	eax, eax
	shl	edi, 6

; 2852 : 			vbdt[vbdt_num-1].texture=mgg->atlas[i];

	movzx	ecx, bx
	mov	WORD PTR [edi+edx-18], ax
	mov	eax, DWORD PTR _mgg_sys+44
	mov	eax, DWORD PTR [eax+ecx*4]

; 2853 : 
; 2854 : 			vbdt[vbdt_num-1].normal=mgg->frames[i].normal;

	lea	ecx, DWORD PTR [ecx+ecx*4]
	mov	DWORD PTR [edi+edx-28], eax
	mov	eax, DWORD PTR _mgg_sys+40
	shl	ecx, 3
	mov	al, BYTE PTR [ecx+eax+8]
	mov	BYTE PTR [edi+edx-20], al

; 2855 : 
; 2856 : 			
; 2857 : 			if(mgg->frames[i].normal)

	mov	ebx, DWORD PTR _mgg_sys+40
	cmp	BYTE PTR [ecx+ebx+8], 0
	je	SHORT $LN71@LoadMGG

; 2858 : 				vbdt[vbdt_num-1].Ntexture=mgg->frames[i].Ndata;

	mov	eax, DWORD PTR [ecx+ebx+4]
	mov	DWORD PTR [edi+edx-24], eax
	mov	ebx, DWORD PTR _mgg_sys+40
$LN71@LoadMGG:

; 2859 : 
; 2860 : 			mgg->frames[i].vb_id=vbdt_num-1;

	mov	eax, DWORD PTR _vbdt_num
	dec	eax
	mov	WORD PTR [ecx+ebx+10], ax

; 2861 : 
; 2862 : 			vbdt[vbdt_num-1].buffer_elements=8;

	mov	eax, 8
	mov	WORD PTR [edi+edx-16], ax

; 2863 : 			
; 2864 : #ifdef _VAO_RENDER
; 2865 : 			if(st.renderer.VAO_ON) CreateVAO(&vbdt[vbdt_num-1],0,3);

	cmp	BYTE PTR _st+2336440, 0
	je	SHORT $LN76@LoadMGG
	push	ecx
	lea	ecx, DWORD PTR [edx-64]
	xor	dl, dl
	add	ecx, edi
	call	_CreateVAO
	mov	edx, DWORD PTR _vbdt
	add	esp, 4
	mov	si, WORD PTR _vbdt_num
$LN76@LoadMGG:

; 2835 : 	{
; 2836 : 		for(i=0;i<mggf.num_atlas;i++)

	inc	DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR _mggf$[ebp+40]
	mov	bx, WORD PTR _i$[ebp]
	cmp	bx, ax
	jb	$LL77@LoadMGG
$LN75@LoadMGG:

; 2866 : #endif
; 2867 : #ifdef _VBO_RENDER
; 2868 : 			if(st.renderer.VBO_ON) CreateVBO(&vbdt[vbdt_num-1], 0);
; 2869 : #endif
; 2870 : 		}
; 2871 : 
; 2872 : 	}
; 2873 : #endif
; 2874 : 
; 2875 : 	fseek(file,mggf.possize_offset,SEEK_SET);

	mov	ebx, DWORD PTR _file$1$[ebp]
	push	0
	push	DWORD PTR _mggf$[ebp+56]
	push	ebx
	call	_fseek

; 2876 : 
; 2877 : 	posx=(uint16*) malloc((mggf.num_texinatlas)*sizeof(uint16));

	movzx	edi, WORD PTR _mggf$[ebp+44]
	lea	esi, DWORD PTR [edi+edi]
	push	esi
	call	_malloc

; 2878 : 	posy=(uint16*) malloc((mggf.num_texinatlas)*sizeof(uint16));

	push	esi
	mov	DWORD PTR _posx$1$[ebp], eax
	call	_malloc

; 2879 : 	sizex=(uint16*) malloc((mggf.num_texinatlas)*sizeof(uint16));

	push	esi
	mov	DWORD PTR _posy$1$[ebp], eax
	call	_malloc

; 2880 : 	sizey=(uint16*) malloc((mggf.num_texinatlas)*sizeof(uint16));

	push	esi
	mov	DWORD PTR _sizex$1$[ebp], eax
	call	_malloc

; 2881 : 	imgatlas=(uint8*) malloc((mggf.num_texinatlas)*sizeof(uint8));

	push	edi
	mov	DWORD PTR _sizey$1$[ebp], eax
	call	_malloc

; 2882 : 	offx=malloc(mggf.num_frames*sizeof(int16));

	movzx	esi, WORD PTR _mggf$[ebp+32]
	add	esi, esi
	mov	DWORD PTR _imgatlas$1$[ebp], eax
	push	esi
	call	_malloc

; 2883 : 	offy=malloc(mggf.num_frames*sizeof(int16));

	push	esi
	mov	DWORD PTR _offx$1$[ebp], eax
	call	_malloc

; 2884 : 
; 2885 : 	fread(posx,sizeof(uint16),(mggf.num_texinatlas),file);

	push	ebx
	push	edi
	push	2
	push	DWORD PTR _posx$1$[ebp]
	mov	DWORD PTR _offy$1$[ebp], eax
	call	_fread

; 2886 : 	fread(posy,sizeof(uint16),(mggf.num_texinatlas),file);

	movzx	ecx, WORD PTR _mggf$[ebp+44]
	push	ebx
	push	ecx
	push	2
	push	DWORD PTR _posy$1$[ebp]
	call	_fread

; 2887 : 	fread(sizex,sizeof(uint16),(mggf.num_texinatlas),file);

	movzx	eax, WORD PTR _mggf$[ebp+44]
	add	esp, 72					; 00000048H
	push	ebx
	push	eax
	push	2
	push	DWORD PTR _sizex$1$[ebp]
	call	_fread

; 2888 : 	fread(sizey,sizeof(uint16),(mggf.num_texinatlas),file);

	movzx	eax, WORD PTR _mggf$[ebp+44]
	push	ebx
	push	eax
	push	2
	push	DWORD PTR _sizey$1$[ebp]
	call	_fread

; 2889 : 	fread(imgatlas,sizeof(uint8),(mggf.num_texinatlas),file);

	movzx	eax, WORD PTR _mggf$[ebp+44]
	push	ebx
	push	eax
	push	1
	push	DWORD PTR _imgatlas$1$[ebp]
	call	_fread

; 2890 : 
; 2891 : 	for(i=mggf.num_atlas-1;i<mggf.num_texinatlas;i++)

	movzx	eax, BYTE PTR _mggf$[ebp+40]
	add	esp, 48					; 00000030H
	dec	ax
	movzx	edi, ax
	mov	ax, di
	mov	DWORD PTR _i$[ebp], edi
	cmp	ax, WORD PTR _mggf$[ebp+44]
	jae	$LN67@LoadMGG
	mov	ebx, DWORD PTR _imgatlas$1$[ebp]
	npad	6
$LL69@LoadMGG:

; 2892 : 	{
; 2893 : 		mgg->frames[i].data=mgg->atlas[imgatlas[i]];

	movzx	edx, ax
	inc	edi
	mov	eax, DWORD PTR _mgg_sys+44
	mov	DWORD PTR _i$[ebp], edi
	movzx	ecx, BYTE PTR [edx+ebx]
	lea	esi, DWORD PTR [edx+edx*4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [eax+esi*8], ecx

; 2894 : 		mgg->frames[i].posx=posx[i];

	mov	eax, DWORD PTR _posx$1$[ebp]
	movzx	ecx, WORD PTR [eax+edx*2]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	WORD PTR [eax+esi*8+14], cx

; 2895 : 		mgg->frames[i].posy=posy[i];

	mov	eax, DWORD PTR _posy$1$[ebp]
	movzx	ecx, WORD PTR [eax+edx*2]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	WORD PTR [eax+esi*8+16], cx

; 2896 : 		mgg->frames[i].sizex=sizex[i];

	mov	eax, DWORD PTR _sizex$1$[ebp]
	movzx	ecx, WORD PTR [eax+edx*2]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	WORD PTR [eax+esi*8+18], cx

; 2897 : 		mgg->frames[i].sizey=sizey[i];

	mov	eax, DWORD PTR _sizey$1$[ebp]
	movzx	ecx, WORD PTR [eax+edx*2]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	WORD PTR [eax+esi*8+20], cx

; 2898 : 		mgg->frames[i].vb_id=mgg->frames[imgatlas[i]].vb_id;

	movzx	eax, BYTE PTR [edx+ebx]
	mov	ecx, DWORD PTR _mgg_sys+40
	lea	eax, DWORD PTR [eax+eax*4]
	movzx	eax, WORD PTR [ecx+eax*8+10]
	mov	WORD PTR [ecx+esi*8+10], ax

; 2899 : 		mgg->frames[i].w=mgg->frames[imgatlas[i]].w;

	movzx	eax, BYTE PTR [edx+ebx]
	mov	ecx, DWORD PTR _mgg_sys+40
	lea	eax, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx+eax*8+24]
	mov	DWORD PTR [ecx+esi*8+24], eax

; 2900 : 		mgg->frames[i].h=mgg->frames[imgatlas[i]].h;

	movzx	eax, BYTE PTR [edx+ebx]
	mov	ecx, DWORD PTR _mgg_sys+40
	lea	eax, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx+eax*8+28]
	mov	DWORD PTR [ecx+esi*8+28], eax
	mov	ax, di
	cmp	ax, WORD PTR _mggf$[ebp+44]
	jb	$LL69@LoadMGG
	mov	ebx, DWORD PTR _file$1$[ebp]
$LN67@LoadMGG:

; 2901 : 	}
; 2902 : 	
; 2903 : 	fseek(file,mggf.framealone_offset,SEEK_SET);

	push	0
	push	DWORD PTR _mggf$[ebp+64]
	push	ebx
	call	_fseek

; 2904 : 
; 2905 : 	fread(framealone,sizeof(uint32),mgg->num_frames,file);

	movzx	eax, WORD PTR _mgg_sys+32
	mov	esi, DWORD PTR _framealone$1$[ebp]
	push	ebx
	push	eax
	push	4
	push	esi
	call	_fread

; 2906 : 
; 2907 : 	fseek(file,mggf.frameoffset_offset,SEEK_SET);

	push	0
	push	DWORD PTR _mggf$[ebp+68]
	push	ebx
	call	_fseek

; 2908 : 
; 2909 : 	fread(offx,sizeof(int16),mgg->num_frames,file);

	movzx	eax, WORD PTR _mgg_sys+32
	push	ebx
	push	eax
	push	2
	push	DWORD PTR _offx$1$[ebp]
	call	_fread

; 2910 : 	fread(offy,sizeof(int16),mgg->num_frames,file);

	movzx	eax, WORD PTR _mgg_sys+32
	push	ebx
	push	eax
	push	2
	push	DWORD PTR _offy$1$[ebp]
	call	_fread

; 2911 : 
; 2912 : 	for(i=0;i<mgg->num_frames;i++)

	xor	ebx, ebx
	xor	eax, eax
	add	esp, 72					; 00000048H
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ax, WORD PTR _mgg_sys+32
	jae	SHORT $LN64@LoadMGG
	mov	ax, bx
$LL66@LoadMGG:

; 2913 : 	{
; 2914 : 		mgg->frames[i].x_offset=(offx[i]*GAME_WIDTH)/st.screenx;

	movzx	ecx, WORD PTR _st+228
	inc	ebx
	movzx	esi, ax
	mov	eax, DWORD PTR _offx$1$[ebp]
	mov	DWORD PTR _i$[ebp], ebx
	lea	edi, DWORD PTR [esi+esi*4]
	movzx	eax, WORD PTR [eax+esi*2]
	shl	eax, 14					; 0000000eH
	cdq
	idiv	ecx
	mov	ecx, DWORD PTR _mgg_sys+40
	mov	WORD PTR [ecx+edi*8+36], ax

; 2915 : 		mgg->frames[i].y_offset=(offy[i]*GAME_HEIGHT)/st.screeny;

	mov	eax, DWORD PTR _offy$1$[ebp]
	movzx	ecx, WORD PTR _st+230
	movzx	eax, WORD PTR [eax+esi*2]
	imul	eax, eax, 9216
	cdq
	idiv	ecx
	mov	ecx, DWORD PTR _mgg_sys+40
	mov	WORD PTR [ecx+edi*8+38], ax
	mov	ax, bx
	cmp	ax, WORD PTR _mgg_sys+32
	jb	SHORT $LL66@LoadMGG
	mov	esi, DWORD PTR _framealone$1$[ebp]
$LN64@LoadMGG:

; 2916 : 	}
; 2917 : 
; 2918 : 
; 2919 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 2920 : 
; 2921 : 	k=vbdt_num;

	mov	bx, WORD PTR _vbdt_num

; 2922 : 	
; 2923 : 	if(mggf.num_frames>1)

	mov	cx, WORD PTR _mggf$[ebp+32]
	movzx	eax, bx
	mov	DWORD PTR _k$1$[ebp], eax
	cmp	cx, 1
	jbe	$LN203@LoadMGG

; 2924 : 	{
; 2925 : 		for(i=(mggf.num_texinatlas), j=mggf.num_atlas;i<mggf.num_frames;i++, j++)

	movzx	edx, WORD PTR _mggf$[ebp+44]
	mov	DWORD PTR _i$[ebp], edx
	cmp	WORD PTR _mggf$[ebp+44], cx
	jae	$LN203@LoadMGG
	mov	cx, dx
$LL62@LoadMGG:

; 2926 : 		{	
; 2927 : 			if(framealone[i] && i==mggf.num_frames-1) 

	movzx	edi, cx
	mov	DWORD PTR tv3572[ebp], edi
	mov	edx, DWORD PTR [esi+edi*4]
	test	edx, edx
	je	SHORT $LN228@LoadMGG
	movzx	eax, WORD PTR _mggf$[ebp+32]
	dec	eax
	cmp	edi, eax
	je	$LN203@LoadMGG

; 2928 : 				break;
; 2929 : 
; 2930 : 			if(framealone[i]) 

	test	edx, edx
	jne	$LN61@LoadMGG
$LN228@LoadMGG:

; 2931 : 				continue;
; 2932 : 
; 2933 : 			if(i==(mggf.num_texinatlas) && (mgg->frames[i].w<1024 && mgg->frames[i].h<1024) && !mgg->frames[i].normal)

	cmp	cx, WORD PTR _mggf$[ebp+44]
	jne	$LN57@LoadMGG
	mov	ecx, DWORD PTR _mgg_sys+40
	lea	eax, DWORD PTR [edi+edi*4]
	shl	eax, 3
	mov	DWORD PTR tv3550[ebp], eax
	cmp	DWORD PTR [eax+ecx+24], 1024		; 00000400H
	jge	$LN57@LoadMGG
	cmp	DWORD PTR [eax+ecx+28], 1024		; 00000400H
	jge	$LN57@LoadMGG
	cmp	BYTE PTR [eax+ecx+8], 0
	jne	$LN57@LoadMGG

; 2934 : 			{
; 2935 : 				if(!vbdt_num)

	test	bx, bx
	jne	$LN56@LoadMGG

; 2936 : 				{
; 2937 : 					vbdt_num++;

	mov	ebx, 1

; 2938 : 					l=vbdt_num-1;

	mov	DWORD PTR _l$1$[ebp], 0

; 2939 : 					vbdt=(VB_DATAT*) malloc(sizeof(VB_DATAT));

	push	64					; 00000040H
	mov	WORD PTR _vbdt_num, bx
	call	_malloc

; 2940 : 
; 2941 : 					vbdt[l].normal=0;
; 2942 : 
; 2943 : 					vbdt[l].buffer_elements=8;

	mov	ecx, 8
	mov	DWORD PTR _vbdt, eax
	add	esp, 4
	mov	BYTE PTR [eax+44], 0
	mov	WORD PTR [eax+48], cx

; 2944 : 
; 2945 : 			#ifdef _VAO_RENDER
; 2946 : 			if(st.renderer.VAO_ON) CreateVAO(&vbdt[l],0,3);

	cmp	BYTE PTR _st+2336440, 0
	je	SHORT $LN55@LoadMGG
	push	ecx
	xor	dl, dl
	mov	ecx, eax
	call	_CreateVAO
	mov	bx, WORD PTR _vbdt_num
	add	esp, 4
$LN55@LoadMGG:

; 2947 : 			#endif
; 2948 : 			#ifdef _VBO_RENDER
; 2949 : 			if(st.renderer.VBO_ON) CreateVBO(&vbdt[l], 0);
; 2950 : 			#endif
; 2951 : 
; 2952 : 					w=(int16*) calloc(vbdt_num,sizeof(int16));

	movzx	esi, bx
	push	2
	push	esi
	call	_calloc

; 2953 : 					h=(int16*) calloc(vbdt_num,sizeof(int16));

	push	2
	push	esi
	mov	DWORD PTR _w$[ebp], eax
	call	_calloc

; 2954 : 					currh=(int16*) calloc(vbdt_num,sizeof(int16));

	push	2
	push	esi
	mov	DWORD PTR _h$[ebp], eax
	call	_calloc

; 2955 : 
; 2956 : 					if(!vbdt)

	mov	ecx, DWORD PTR _vbdt
	add	esp, 24					; 00000018H
	mov	DWORD PTR _currh$[ebp], eax
	test	ecx, ecx
	jne	SHORT $LN204@LoadMGG

; 2957 : 						LogApp("Error could not allocate memory for the Vertex Buffer");

	push	OFFSET ??_C@_0DG@BNCAOHGG@Error?5could?5not?5allocate?5memory?5@
	call	DWORD PTR __imp__SDL_Log

; 2958 : 				}
; 2959 : 				else

	mov	bx, WORD PTR _vbdt_num
	add	esp, 4
	mov	ecx, DWORD PTR _vbdt
$LN204@LoadMGG:
	mov	esi, DWORD PTR _w$[ebp]
$LN53@LoadMGG:

; 2987 : 				}
; 2988 : 
; 2989 : 				vbdt[l].num_elements=0;

	mov	eax, DWORD PTR _l$1$[ebp]
	movzx	edi, ax
	xor	eax, eax
	shl	edi, 6
	mov	DWORD PTR tv3462[ebp], edi
	mov	WORD PTR [edi+ecx+46], ax

; 2990 : 
; 2991 : 				glGenTextures(1,&vbdt[vbdt_num-1].texture);

	add	ecx, -28				; ffffffe4H
	movzx	eax, bx
	shl	eax, 6
	add	eax, ecx
	push	eax
	push	1
	call	DWORD PTR __imp__glGenTextures@8

; 2992 : 
; 2993 : 				glBindTexture(GL_TEXTURE_2D,vbdt[l].texture);

	mov	eax, DWORD PTR _vbdt
	push	DWORD PTR [edi+eax+36]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 2994 : 
; 2995 : 				glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,2048,2048,0,GL_BGRA,GL_UNSIGNED_BYTE,NULL);

	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36

; 2996 : 
; 2997 : 				//glBindTexture(GL_TEXTURE_2D,mgg->frames[i].data);
; 2998 : 
; 2999 : 				//data=malloc(framesize[j]);
; 3000 : 				/*
; 3001 : 				if(data==NULL)
; 3002 : 				{
; 3003 : 					LogApp("Error allocating memory for texture %d, size %d, file %s during atlas creating",i,framesize[i],name);
; 3004 : 					continue;
; 3005 : 				}
; 3006 : 				*/
; 3007 : 				
; 3008 : 			
; 3009 : 				//if(i==0) fseek(file,mggf.textures_offset+1,SEEK_SET);
; 3010 : 				//else fseek(file,frameoffset[j-1]+1,SEEK_SET);
; 3011 : 
; 3012 : 				//fread(data,framesize[j],1,file);
; 3013 : 
; 3014 : 				//imgdata=SOIL_load_image_from_memory((unsigned char*) data,framesize[j],&width,&height,&channel,0);
; 3015 : 
; 3016 : 				if (mgg->frames[i].channel == 4)

	mov	ecx, DWORD PTR tv3550[ebp]
	mov	ebx, DWORD PTR _mgg_sys+40
	mov	edx, DWORD PTR [ecx+ebx+32]
	cmp	edx, 4
	jne	$LN47@LoadMGG

; 3017 : 					channel2 = GL_RGBA;

	mov	edi, 6408				; 00001908H

; 3018 : 				else

	jmp	$LN229@LoadMGG
$LN56@LoadMGG:

; 2960 : 				{
; 2961 : 					vbdt_num++;
; 2962 : 					l=vbdt_num-1;
; 2963 : 					vbdt=(VB_DATAT*) realloc(vbdt,vbdt_num*sizeof(VB_DATAT));

	mov	ecx, DWORD PTR _vbdt
	inc	bx
	mov	WORD PTR _vbdt_num, bx
	mov	eax, DWORD PTR _vbdt_num
	dec	eax
	mov	DWORD PTR tv2752[ebp], ebx
	movzx	esi, ax
	movzx	eax, bx
	shl	eax, 6
	push	eax
	push	ecx
	mov	DWORD PTR _l$1$[ebp], esi
	call	_realloc
	mov	ecx, eax
	add	esp, 8

; 2964 : 
; 2965 : 					vbdt[l].normal=0;

	movzx	eax, si
	shl	eax, 6
	mov	DWORD PTR _vbdt, ecx
	add	ecx, eax

; 2966 : 
; 2967 : 					vbdt[l].buffer_elements=8;

	mov	eax, 8
	mov	BYTE PTR [ecx+44], 0
	mov	WORD PTR [ecx+48], ax

; 2968 : 
; 2969 : 					#ifdef _VAO_RENDER
; 2970 : 					if(st.renderer.VAO_ON) CreateVAO(&vbdt[l],0,3);

	cmp	BYTE PTR _st+2336440, 0
	je	SHORT $LN52@LoadMGG
	push	ecx
	xor	dl, dl
	call	_CreateVAO
	movzx	ebx, WORD PTR _vbdt_num
	add	esp, 4
	mov	DWORD PTR tv2752[ebp], ebx
$LN52@LoadMGG:

; 2971 : 					#endif
; 2972 : 					#ifdef _VBO_RENDER
; 2973 : 					if(st.renderer.VBO_ON) CreateVBO(&vbdt[l], 0);
; 2974 : 					#endif
; 2975 : 
; 2976 : 					w=(int16*) calloc(vbdt_num,sizeof(int16));

	movzx	edi, bx
	push	2
	push	edi
	mov	DWORD PTR tv3503[ebp], edi
	call	_calloc
	mov	esi, eax

; 2977 : 					h=(int16*) calloc(vbdt_num,sizeof(int16));

	push	2
	push	edi
	mov	DWORD PTR _w$[ebp], esi
	call	_calloc

; 2978 : 					currh=(int16*) calloc(vbdt_num,sizeof(int16));

	push	2
	push	edi
	mov	DWORD PTR _h$[ebp], eax
	call	_calloc
	add	esp, 24					; 00000018H
	mov	edi, eax
	mov	DWORD PTR _currh$[ebp], edi

; 2979 : 
; 2980 : 					if(vbdt_num>1)

	cmp	bx, 1
	jbe	SHORT $LN48@LoadMGG

; 2981 : 					{
; 2982 : 						for(n=0;n<vbdt_num-2;n++)

	mov	eax, DWORD PTR tv3503[ebp]
	xor	ecx, ecx
	add	eax, -2					; fffffffeH
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	jle	SHORT $LN48@LoadMGG
	mov	edx, DWORD PTR _h$[ebp]
	xor	eax, eax
	mov	ebx, 65535				; 0000ffffH
$LL169@LoadMGG:
	inc	ecx

; 2983 : 							currh[n]=w[n]=h[n]=-1;

	mov	WORD PTR [edx+eax*2], bx
	mov	WORD PTR [esi+eax*2], bx
	mov	WORD PTR [edi+eax*2], bx
	movzx	eax, cx
	cmp	eax, DWORD PTR $T1[ebp]
	jl	SHORT $LL169@LoadMGG
	mov	ebx, DWORD PTR tv2752[ebp]
$LN48@LoadMGG:

; 2984 : 					}
; 2985 : 
; 2986 : 					currh[l]=w[l]=h[l]=0;

	mov	eax, DWORD PTR _h$[ebp]
	xor	edi, edi
	mov	edx, DWORD PTR _l$1$[ebp]
	movzx	ecx, dx
	mov	WORD PTR [eax+ecx*2], di
	xor	eax, eax
	mov	edi, DWORD PTR _currh$[ebp]
	mov	WORD PTR [esi+ecx*2], ax
	mov	WORD PTR [edi+ecx*2], ax
	mov	ecx, DWORD PTR _vbdt
	jmp	$LN53@LoadMGG
$LN47@LoadMGG:

; 3019 : 				if (mgg->frames[i].channel == 3)

	mov	edi, DWORD PTR _channel2$[ebp]
	cmp	edx, 3
	mov	eax, 6407				; 00001907H
	cmove	edi, eax
$LN229@LoadMGG:

; 3020 : 					channel2 = GL_RGB;
; 3021 : 
; 3022 : 				imgdata = malloc(mgg->frames[i].w*mgg->frames[i].h*mgg->frames[i].channel);

	mov	eax, DWORD PTR [ecx+ebx+28]
	imul	eax, DWORD PTR [ecx+ebx+24]
	mov	DWORD PTR _channel2$[ebp], edi
	imul	eax, edx
	push	eax
	call	_malloc

; 3023 : 				glBindTexture(GL_TEXTURE_2D, mgg->frames[i].data);

	mov	ecx, DWORD PTR _mgg_sys+40
	mov	ebx, eax
	mov	eax, DWORD PTR tv3550[ebp]
	add	esp, 4
	mov	DWORD PTR _imgdata$2$[ebp], ebx
	push	DWORD PTR [eax+ecx]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 3024 : 				glGetTexImage(GL_TEXTURE_2D, 0, channel2, GL_UNSIGNED_BYTE, imgdata);

	push	ebx
	push	5121					; 00001401H
	movzx	edi, di
	push	edi
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glGetTexImage@20

; 3025 : 
; 3026 : 				glBindTexture(GL_TEXTURE_2D, vbdt[l].texture);

	mov	eax, DWORD PTR _vbdt
	mov	ecx, DWORD PTR tv3462[ebp]
	push	DWORD PTR [ecx+eax+36]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 3027 : 
; 3028 : 				glTexSubImage2D(GL_TEXTURE_2D,0,w[l],currh[l],mgg->frames[i].w,mgg->frames[i].h,channel2,GL_UNSIGNED_BYTE,imgdata);

	push	DWORD PTR _imgdata$2$[ebp]
	mov	ebx, DWORD PTR _l$1$[ebp]
	mov	ecx, DWORD PTR _currh$[ebp]
	mov	eax, DWORD PTR _mgg_sys+40
	movzx	edx, bx
	push	5121					; 00001401H
	push	edi
	movzx	ebx, WORD PTR [ecx+edx*2]
	mov	ecx, DWORD PTR tv3550[ebp]
	movzx	esi, WORD PTR [esi+edx*2]
	push	DWORD PTR [ecx+eax+28]
	push	DWORD PTR [ecx+eax+24]
	push	ebx
	push	esi
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexSubImage2D@36

; 3029 : 
; 3030 : 				mgg->frames[i].posx=(float)(w[l]*32768)/2048;

	movss	xmm1, DWORD PTR __real@3a000000
	mov	eax, DWORD PTR _mgg_sys+40
	shl	esi, 15					; 0000000fH

; 3031 : 				mgg->frames[i].posy=(float)(currh[l]*32768)/2048;

	shl	ebx, 15					; 0000000fH

; 3032 : 
; 3033 : 				w[l]=mgg->frames[i].w;

	mov	edx, DWORD PTR _w$[ebp]
	movd	xmm0, esi
	mov	esi, DWORD PTR tv3550[ebp]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	movd	xmm0, ebx
	mov	ebx, DWORD PTR _l$1$[ebp]
	cvtdq2ps xmm0, xmm0
	mov	WORD PTR [esi+eax+14], cx
	mov	eax, DWORD PTR _mgg_sys+40
	movzx	edi, bx
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	WORD PTR [esi+eax+16], cx
	mov	ecx, DWORD PTR _mgg_sys+40
	movzx	eax, WORD PTR [esi+ecx+24]
	mov	WORD PTR [edx+edi*2], ax

; 3034 : 				h[l]=mgg->frames[i].h;

	movzx	eax, WORD PTR [esi+ecx+28]
	mov	edx, DWORD PTR _h$[ebp]
	mov	WORD PTR [edx+edi*2], ax

; 3035 : 
; 3036 : 				mgg->frames[i].sizex=(float)(mgg->frames[i].w*32768)/2048;

	mov	eax, DWORD PTR [esi+ecx+24]
	shl	eax, 15					; 0000000fH
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [esi+ecx+18], ax

; 3037 : 				mgg->frames[i].sizey=(float)(mgg->frames[i].h*32768)/2048;

	mov	ecx, DWORD PTR _mgg_sys+40
	mov	eax, DWORD PTR [esi+ecx+28]
	shl	eax, 15					; 0000000fH
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [esi+ecx+20], ax

; 3038 : 
; 3039 : 				glDeleteTextures(1,&mgg->frames[i].data);

	mov	eax, DWORD PTR _mgg_sys+40
	add	eax, esi
	push	eax
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8

; 3040 : 
; 3041 : 				mgg->frames[i].data=vbdt[l].texture;

	mov	eax, DWORD PTR tv3462[ebp]
	mov	edi, DWORD PTR _vbdt

; 3042 : 
; 3043 : 				mgg->frames[i].vb_id=l;
; 3044 : 
; 3045 : 				mgg->frames[i].w = 2048;
; 3046 : 				mgg->frames[i].h = 2048;
; 3047 : 
; 3048 : 				//free(data);
; 3049 : 				free(imgdata);

	push	DWORD PTR _imgdata$2$[ebp]
	mov	ecx, DWORD PTR [eax+edi+36]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [esi+eax], ecx
	mov	eax, DWORD PTR _mgg_sys+40
	mov	WORD PTR [esi+eax+10], bx
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [esi+eax+24], 2048		; 00000800H
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [esi+eax+28], 2048		; 00000800H
	call	_free

; 3050 : 
; 3051 : 				//SOIL_free_image_data(imgdata);
; 3052 : 			}
; 3053 : 			else

	mov	bx, WORD PTR _vbdt_num
	add	esp, 4
	jmp	$LN19@LoadMGG
$LN57@LoadMGG:

; 3054 : 			{
; 3055 : 				if((mgg->frames[i].w+w[l]<2048 && mgg->frames[i].h+currh[l]<2048) && (mgg->frames[i].w<1024 && mgg->frames[i].h<1024) && !mgg->frames[i].normal)

	mov	eax, DWORD PTR _l$1$[ebp]
	lea	edi, DWORD PTR [edi+edi*4]
	mov	esi, DWORD PTR _w$[ebp]
	movzx	edx, ax
	shl	edi, 3
	mov	DWORD PTR tv3289[ebp], edx
	mov	DWORD PTR tv3549[ebp], edi
	movzx	eax, WORD PTR [esi+edx*2]
	mov	DWORD PTR tv3346[ebp], eax
	movzx	eax, ax
	mov	DWORD PTR tv3001[ebp], eax
	mov	eax, DWORD PTR _mgg_sys+40
	mov	ecx, DWORD PTR [edi+eax+24]
	mov	DWORD PTR tv3466[ebp], ecx
	add	ecx, DWORD PTR tv3001[ebp]
	mov	DWORD PTR tv3404[ebp], ecx
	cmp	ecx, 2048				; 00000800H
	mov	ecx, DWORD PTR _currh$[ebp]
	jge	$LN43@LoadMGG
	movzx	esi, WORD PTR [ecx+edx*2]
	mov	DWORD PTR tv3400[ebp], esi
	mov	esi, DWORD PTR [edi+eax+28]
	movzx	eax, WORD PTR [ecx+edx*2]
	add	eax, esi
	mov	DWORD PTR tv2984[ebp], esi
	mov	esi, DWORD PTR _w$[ebp]
	cmp	eax, 2048				; 00000800H
	mov	eax, DWORD PTR _mgg_sys+40
	jge	$LN43@LoadMGG
	cmp	DWORD PTR tv3466[ebp], 1024		; 00000400H
	jge	$LN43@LoadMGG
	cmp	DWORD PTR tv2984[ebp], 1024		; 00000400H
	jge	$LN43@LoadMGG
	cmp	BYTE PTR [edi+eax+8], 0
	jne	$LN43@LoadMGG

; 3056 : 				{
; 3057 : 					//glBindTexture(GL_TEXTURE_2D,mgg->frames[i].data);
; 3058 : 
; 3059 : 					//data=malloc(framesize[j]);
; 3060 : 					/*
; 3061 : 					if(data==NULL)
; 3062 : 					{
; 3063 : 						LogApp("Error allocating memory for texture %d, size %d, file %s during atlas creating",i,framesize[i],name);
; 3064 : 						continue;
; 3065 : 					}
; 3066 : 					*/
; 3067 : 					//fseek(file,frameoffset[j-1]+1,SEEK_SET);
; 3068 : 
; 3069 : 					//fread(data,framesize[j],1,file);
; 3070 : 
; 3071 : 					//imgdata=SOIL_load_image_from_memory((unsigned char*) data,framesize[j],&width,&height,&channel,0);
; 3072 : 
; 3073 : 					if (mgg->frames[i].channel == 4)

	mov	ecx, DWORD PTR [edi+eax+32]
	cmp	ecx, 4
	jne	SHORT $LN42@LoadMGG

; 3074 : 						channel2 = GL_RGBA;

	mov	ebx, 6408				; 00001908H

; 3075 : 					else

	jmp	SHORT $LN230@LoadMGG
$LN42@LoadMGG:

; 3076 : 						if (mgg->frames[i].channel == 3)

	mov	ebx, DWORD PTR _channel2$[ebp]
	cmp	ecx, 3
	mov	eax, 6407				; 00001907H
	cmove	ebx, eax
$LN230@LoadMGG:

; 3077 : 							channel2 = GL_RGB;
; 3078 : 
; 3079 : 					imgdata = malloc(mgg->frames[i].w*mgg->frames[i].h*mgg->frames[i].channel);

	mov	eax, DWORD PTR tv2984[ebp]
	imul	eax, ecx
	mov	DWORD PTR _channel2$[ebp], ebx
	imul	eax, DWORD PTR tv3466[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _imgdata$3$[ebp], eax

; 3080 : 					glBindTexture(GL_TEXTURE_2D, mgg->frames[i].data);

	mov	eax, DWORD PTR _mgg_sys+40
	push	DWORD PTR [edi+eax]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 3081 : 					glGetTexImage(GL_TEXTURE_2D, 0, channel2, GL_UNSIGNED_BYTE, imgdata);

	movzx	esi, bx
	mov	ebx, DWORD PTR _imgdata$3$[ebp]
	push	ebx
	push	5121					; 00001401H
	push	esi
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glGetTexImage@20

; 3082 : 
; 3083 : 					glBindTexture(GL_TEXTURE_2D,vbdt[l].texture);

	mov	ecx, DWORD PTR tv3289[ebp]
	mov	eax, DWORD PTR _vbdt
	shl	ecx, 6
	mov	DWORD PTR tv3461[ebp], ecx
	push	DWORD PTR [ecx+eax+36]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 3084 : 
; 3085 : 					glTexSubImage2D(GL_TEXTURE_2D,0,w[l],currh[l],mgg->frames[i].w,mgg->frames[i].h,channel2,GL_UNSIGNED_BYTE,imgdata);

	mov	ecx, DWORD PTR _mgg_sys+40
	push	ebx
	mov	ebx, DWORD PTR tv3400[ebp]
	push	5121					; 00001401H
	push	esi
	push	DWORD PTR [edi+ecx+28]
	mov	esi, DWORD PTR tv3001[ebp]
	push	DWORD PTR [edi+ecx+24]
	push	ebx
	push	esi
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexSubImage2D@36

; 3086 : 
; 3087 : 					mgg->frames[i].posx=(w[l]*32768)/2048;

	mov	ecx, DWORD PTR _mgg_sys+40
	shl	esi, 15					; 0000000fH
	mov	eax, esi

; 3088 : 					mgg->frames[i].posy=(currh[l]*32768)/2048;
; 3089 : 
; 3090 : 					w[l]+=mgg->frames[i].w;

	mov	esi, DWORD PTR _w$[ebp]
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [edi+ecx+14], ax
	mov	eax, ebx
	mov	ecx, DWORD PTR _mgg_sys+40

; 3091 : 
; 3092 : 					if(currh[l]+mgg->frames[i].h>h[l])

	mov	ebx, DWORD PTR _h$[ebp]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	mov	edx, DWORD PTR tv3289[ebp]
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [edi+ecx+16], ax
	mov	ecx, DWORD PTR _mgg_sys+40
	mov	ax, WORD PTR [edi+ecx+24]
	add	ax, WORD PTR tv3346[ebp]
	mov	ecx, DWORD PTR [edi+ecx+28]
	add	ecx, DWORD PTR tv3400[ebp]
	mov	WORD PTR [esi+edx*2], ax
	movzx	eax, WORD PTR [ebx+edx*2]
	mov	DWORD PTR tv3347[ebp], eax
	movzx	eax, ax
	cmp	ecx, eax

; 3093 : 						h[l]+=mgg->frames[i].h;

	mov	ecx, DWORD PTR _mgg_sys+40
	jle	SHORT $LN39@LoadMGG
	mov	ax, WORD PTR [edi+ecx+28]
	add	ax, WORD PTR tv3347[ebp]
	mov	WORD PTR [ebx+edx*2], ax
$LN39@LoadMGG:

; 3094 : 
; 3095 : 					mgg->frames[i].sizex=(mgg->frames[i].w*32768)/2048;

	mov	eax, DWORD PTR [edi+ecx+24]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [edi+ecx+18], ax

; 3096 : 					mgg->frames[i].sizey=(mgg->frames[i].h*32768)/2048;

	mov	ecx, DWORD PTR _mgg_sys+40
	mov	eax, DWORD PTR [edi+ecx+28]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [edi+ecx+20], ax

; 3097 : 
; 3098 : 					glDeleteTextures(1,&mgg->frames[i].data);

	mov	eax, DWORD PTR _mgg_sys+40
	add	eax, edi
	push	eax
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8

; 3099 : 
; 3100 : 					mgg->frames[i].data=vbdt[l].texture;

	mov	eax, DWORD PTR tv3461[ebp]
	mov	ecx, DWORD PTR _vbdt

; 3101 : 
; 3102 : 					mgg->frames[i].vb_id=l;
; 3103 : 
; 3104 : 					mgg->frames[i].w = 2048;
; 3105 : 					mgg->frames[i].h = 2048;
; 3106 : 
; 3107 : 					//free(data);
; 3108 : 
; 3109 : 					free(imgdata);

	push	DWORD PTR _imgdata$3$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+36]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [edi+eax], ecx
	mov	eax, DWORD PTR _mgg_sys+40
	mov	ecx, DWORD PTR _l$1$[ebp]
	mov	WORD PTR [edi+eax+10], cx
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [edi+eax+24], 2048		; 00000800H
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [edi+eax+28], 2048		; 00000800H
	call	_free

; 3110 : 
; 3111 : 					if(2048-w[l]<128 && 2048-currh[l]>128)

	mov	edx, DWORD PTR tv3289[ebp]
	mov	edi, 2048				; 00000800H
	mov	ecx, DWORD PTR tv3400[ebp]
	add	esp, 4
	movzx	eax, WORD PTR [esi+edx*2]
	sub	edi, eax
	cmp	edi, 128				; 00000080H
	jge	$LN198@LoadMGG
	mov	eax, 2048				; 00000800H
	sub	eax, ecx
	cmp	eax, 128				; 00000080H
	jle	SHORT $LN38@LoadMGG

; 3112 : 					{
; 3113 : 						w[l]=0;
; 3114 : 						currh[l]=h[l];

	mov	ecx, DWORD PTR _currh$[ebp]
	xor	eax, eax
	mov	WORD PTR [esi+edx*2], ax
	mov	ax, WORD PTR [ebx+edx*2]
	mov	WORD PTR [ecx+edx*2], ax

; 3115 : 					}
; 3116 : 					else

	jmp	$LN198@LoadMGG
$LN38@LoadMGG:

; 3117 : 					if(2048-w[l]<128 && 2048-currh[l]<128)

	cmp	edi, 128				; 00000080H
	jge	$LN198@LoadMGG
	mov	eax, 2048				; 00000800H
	sub	eax, ecx
	cmp	eax, 128				; 00000080H
	jge	$LN198@LoadMGG

; 3118 : 					{
; 3119 : 						if(l==vbdt_num-1)

	mov	bx, WORD PTR _vbdt_num
	movzx	eax, bx
	dec	eax
	cmp	edx, eax
	jne	$LN35@LoadMGG

; 3120 : 						{
; 3121 : 							vbdt_num++;

	inc	bx

; 3122 : 							vbdt=(VB_DATAT*) realloc(vbdt,vbdt_num*sizeof(VB_DATAT));

	movzx	esi, bx
	mov	edi, esi
	mov	WORD PTR _vbdt_num, bx
	shl	edi, 6
	push	edi
	push	DWORD PTR _vbdt
	call	_realloc

; 3123 : 
; 3124 : 							vbdt[vbdt_num-1].normal=0;
; 3125 : 
; 3126 : 							w=(int16*) realloc(w,vbdt_num*sizeof(int16));

	mov	edx, DWORD PTR _w$[ebp]
	add	esi, esi
	push	esi
	push	edx
	mov	DWORD PTR _vbdt, eax
	mov	BYTE PTR [edi+eax-20], 0
	call	_realloc

; 3127 : 							h=(int16*) realloc(h,vbdt_num*sizeof(int16));

	push	esi
	push	DWORD PTR _h$[ebp]
	mov	DWORD PTR _w$[ebp], eax
	call	_realloc
	mov	DWORD PTR _h$[ebp], eax

; 3128 : 
; 3129 : 							vbdt[vbdt_num-1].num_elements=0;

	xor	ecx, ecx
	mov	eax, DWORD PTR _vbdt

; 3130 : 
; 3131 : 							currh=(int16*) realloc(currh,vbdt_num*sizeof(int16));

	push	esi
	mov	WORD PTR [edi+eax-18], cx
	mov	ecx, DWORD PTR _currh$[ebp]
	push	ecx
	call	_realloc

; 3132 : 
; 3133 : 							currh[vbdt_num-1]=w[vbdt_num-1]=h[vbdt_num-1]=0;

	mov	edx, DWORD PTR _h$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _currh$[ebp], eax
	add	esp, 32					; 00000020H
	mov	WORD PTR [esi+eax-2], cx

; 3134 : 
; 3135 : 							l=vbdt_num-1;

	mov	eax, DWORD PTR _vbdt_num
	mov	WORD PTR [esi+edx-2], cx
	dec	eax
	mov	edx, DWORD PTR _w$[ebp]
	mov	WORD PTR [esi+edx-2], cx
	movzx	ecx, ax
	mov	DWORD PTR _l$1$[ebp], ecx

; 3136 : 						}
; 3137 : 						else

	jmp	$LN211@LoadMGG
$LN35@LoadMGG:

; 3138 : 						{
; 3139 : 							for(n=0;n<vbdt_num;n++)

	xor	eax, eax
	xor	edi, edi
	cmp	ax, bx
	jae	$LN211@LoadMGG
$LL33@LoadMGG:

; 3140 : 							{
; 3141 : 								if(2048-w[n]>128 || 2048-currh[n]>128)

	movzx	edx, di
	mov	ecx, 2048				; 00000800H
	movzx	eax, WORD PTR [esi+edx*2]
	sub	ecx, eax
	cmp	ecx, 128				; 00000080H
	jg	SHORT $LN155@LoadMGG
	mov	eax, DWORD PTR _currh$[ebp]
	mov	ecx, 2048				; 00000800H
	movzx	eax, WORD PTR [eax+edx*2]
	sub	ecx, eax
	cmp	ecx, 128				; 00000080H
	jg	SHORT $LN155@LoadMGG

; 3138 : 						{
; 3139 : 							for(n=0;n<vbdt_num;n++)

	inc	edi
	cmp	di, bx
	jb	SHORT $LL33@LoadMGG

; 2926 : 		{	
; 2927 : 			if(framealone[i] && i==mggf.num_frames-1) 

	jmp	$LN211@LoadMGG
$LN155@LoadMGG:

; 3142 : 								{
; 3143 : 									l=n;

	movzx	eax, di
	mov	DWORD PTR _l$1$[ebp], eax

; 3144 : 									break;
; 3145 : 								}
; 3146 : 							}
; 3147 : 						}
; 3148 : 					}
; 3149 : 				}
; 3150 : 				else

	jmp	$LN211@LoadMGG
$LN43@LoadMGG:

; 3151 : 				if((mgg->frames[i].w<1024 && mgg->frames[i].h<1024) && (mgg->frames[i].w+w[l]>2048 && mgg->frames[i].h+currh[l]>2048) && !mgg->frames[i].normal)

	cmp	DWORD PTR [edi+eax+24], 1024		; 00000400H
	jge	$LN211@LoadMGG
	mov	eax, DWORD PTR [edi+eax+28]
	mov	DWORD PTR tv3286[ebp], eax
	cmp	eax, 1024				; 00000400H
	jge	$LN211@LoadMGG
	cmp	DWORD PTR tv3404[ebp], 2048		; 00000800H
	jle	$LN211@LoadMGG
	movzx	eax, WORD PTR [ecx+edx*2]
	add	eax, DWORD PTR tv3286[ebp]
	cmp	eax, 2048				; 00000800H
	jle	$LN211@LoadMGG
	mov	eax, DWORD PTR _mgg_sys+40
	cmp	BYTE PTR [edi+eax+8], 0
	jne	$LN211@LoadMGG

; 3152 : 				{
; 3153 : 					if(l==vbdt_num-1)

	movzx	eax, bx
	dec	eax
	mov	DWORD PTR tv3393[ebp], eax
	cmp	edx, eax
	jne	$LN26@LoadMGG

; 3154 : 					{
; 3155 : 						vbdt_num++;

	inc	bx

; 3156 : 						vbdt=(VB_DATAT*) realloc(vbdt,vbdt_num*sizeof(VB_DATAT));

	movzx	esi, bx
	mov	WORD PTR _vbdt_num, bx
	mov	ebx, esi
	shl	ebx, 6
	push	ebx
	push	DWORD PTR _vbdt
	call	_realloc

; 3157 : 
; 3158 : 						vbdt[vbdt_num-1].normal=0;
; 3159 : 
; 3160 : 						w=(int16*) realloc(w,vbdt_num*sizeof(int16));

	mov	edx, DWORD PTR _w$[ebp]
	mov	edi, eax
	add	esi, esi
	mov	DWORD PTR _vbdt, edi
	push	esi
	push	edx
	mov	BYTE PTR [ebx+edi-20], 0
	call	_realloc

; 3161 : 						h=(int16*) realloc(h,vbdt_num*sizeof(int16));

	push	esi
	push	DWORD PTR _h$[ebp]
	mov	DWORD PTR _w$[ebp], eax
	call	_realloc

; 3162 : 
; 3163 : 						currh=(int16*) realloc(currh,vbdt_num*sizeof(int16));

	push	esi
	push	DWORD PTR _currh$[ebp]
	mov	DWORD PTR _h$[ebp], eax
	call	_realloc

; 3164 : 
; 3165 : 						currh[vbdt_num-1]=w[vbdt_num-1]=h[vbdt_num-1]=0;

	mov	ecx, DWORD PTR _h$[ebp]
	xor	edx, edx
	mov	DWORD PTR _currh$[ebp], eax
	add	esp, 32					; 00000020H
	mov	WORD PTR [esi+ecx-2], dx
	xor	ecx, ecx
	mov	edx, DWORD PTR _w$[ebp]
	mov	WORD PTR [esi+eax-2], cx

; 3166 : 
; 3167 : 						vbdt[vbdt_num-1].num_elements=0;

	xor	eax, eax
	mov	WORD PTR [ebx+edi-18], ax

; 3168 : 
; 3169 : 						glGenTextures(1,&vbdt[vbdt_num-1].texture);

	lea	eax, DWORD PTR [edi-28]
	add	eax, ebx
	push	eax
	push	1
	mov	WORD PTR [esi+edx-2], cx
	call	DWORD PTR __imp__glGenTextures@8

; 3170 : 
; 3171 : 						glBindTexture(GL_TEXTURE_2D,vbdt[vbdt_num-1].texture);

	movzx	ecx, WORD PTR _vbdt_num
	mov	eax, DWORD PTR _vbdt
	shl	ecx, 6
	push	DWORD PTR [ecx+eax-28]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 3172 : 
; 3173 : 						glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,2048,2048,0,GL_BGRA,GL_UNSIGNED_BYTE,NULL);

	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36

; 3174 : 
; 3175 : 						//glBindTexture(GL_TEXTURE_2D,mgg->frames[i].data);
; 3176 : 
; 3177 : 						//data=malloc(framesize[j]);
; 3178 : 						/*
; 3179 : 						if(data==NULL)
; 3180 : 						{
; 3181 : 							LogApp("Error allocating memory for texture %d, size %d, file %s during atlas creating",i,framesize[i],name);
; 3182 : 							continue;
; 3183 : 						}
; 3184 : 						*/
; 3185 : 						//fseek(file,frameoffset[j-1]+1,SEEK_SET);
; 3186 : 
; 3187 : 						//fread(data,framesize[j],1,file);
; 3188 : 
; 3189 : 						//imgdata=SOIL_load_image_from_memory((unsigned char*) data,framesize[j],&width,&height,&channel,0);
; 3190 : 
; 3191 : 						if (mgg->frames[i].channel == 4)

	mov	ebx, DWORD PTR tv3549[ebp]
	mov	edx, DWORD PTR _mgg_sys+40
	mov	ecx, DWORD PTR [ebx+edx+32]
	cmp	ecx, 4
	jne	SHORT $LN25@LoadMGG

; 3192 : 							channel2 = GL_RGBA;

	mov	esi, 6408				; 00001908H

; 3193 : 						else

	jmp	SHORT $LN231@LoadMGG
$LN25@LoadMGG:

; 3194 : 						if (mgg->frames[i].channel == 3)

	mov	esi, DWORD PTR _channel2$[ebp]
	cmp	ecx, 3
	mov	eax, 6407				; 00001907H
	cmove	esi, eax
$LN231@LoadMGG:

; 3195 : 							channel2 = GL_RGB;
; 3196 : 
; 3197 : 						imgdata = malloc(mgg->frames[i].w*mgg->frames[i].h*mgg->frames[i].channel);

	mov	eax, DWORD PTR [ebx+edx+28]
	imul	eax, DWORD PTR [ebx+edx+24]
	mov	DWORD PTR _channel2$[ebp], esi
	imul	eax, ecx
	push	eax
	call	_malloc
	add	esp, 4
	mov	edi, eax

; 3198 : 						glBindTexture(GL_TEXTURE_2D, mgg->frames[i].data);

	mov	eax, DWORD PTR _mgg_sys+40
	push	DWORD PTR [ebx+eax]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 3199 : 						glGetTexImage(GL_TEXTURE_2D, 0, channel2, GL_UNSIGNED_BYTE, imgdata);

	push	edi
	push	5121					; 00001401H
	movzx	esi, si
	push	esi
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glGetTexImage@20

; 3200 : 
; 3201 : 						glBindTexture(GL_TEXTURE_2D, vbdt[l].texture);

	mov	ecx, DWORD PTR tv3289[ebp]
	mov	eax, DWORD PTR _vbdt
	shl	ecx, 6
	push	DWORD PTR [ecx+eax+36]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 3202 : 				
; 3203 : 						glTexSubImage2D(GL_TEXTURE_2D,0,w[vbdt_num-1],currh[vbdt_num-1],mgg->frames[i].w,mgg->frames[i].h,channel2,GL_UNSIGNED_BYTE,imgdata);

	mov	eax, DWORD PTR _mgg_sys+40
	movzx	ecx, WORD PTR _vbdt_num
	push	edi
	push	5121					; 00001401H
	push	esi
	push	DWORD PTR [ebx+eax+28]
	push	DWORD PTR [ebx+eax+24]
	mov	eax, DWORD PTR _currh$[ebp]
	movzx	eax, WORD PTR [eax+ecx*2-2]
	push	eax
	mov	eax, DWORD PTR _w$[ebp]
	movzx	eax, WORD PTR [eax+ecx*2-2]
	push	eax
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexSubImage2D@36

; 3204 : 
; 3205 : 						mgg->frames[i].posx=(w[vbdt_num-1]*32768)/2048;

	movzx	esi, WORD PTR _vbdt_num
	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _mgg_sys+40
	movzx	eax, WORD PTR [eax+esi*2-2]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [ebx+ecx+14], ax

; 3206 : 						mgg->frames[i].posy=(currh[vbdt_num-1]*32768)/2048;

	mov	eax, DWORD PTR _currh$[ebp]
	mov	ecx, DWORD PTR _mgg_sys+40
	movzx	eax, WORD PTR [eax+esi*2-2]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx

; 3207 : 
; 3208 : 						w[vbdt_num-1]=mgg->frames[i].w;

	mov	edx, DWORD PTR _w$[ebp]
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [ebx+ecx+16], ax
	mov	ecx, DWORD PTR _mgg_sys+40
	movzx	eax, WORD PTR [ebx+ecx+24]
	mov	WORD PTR [edx+esi*2-2], ax

; 3209 : 						h[vbdt_num-1]=mgg->frames[i].h;

	mov	edx, DWORD PTR _h$[ebp]
	movzx	eax, WORD PTR [ebx+ecx+28]
	mov	WORD PTR [edx+esi*2-2], ax

; 3210 : 
; 3211 : 						mgg->frames[i].sizex=(mgg->frames[i].w*32768)/2048;

	mov	eax, DWORD PTR [ebx+ecx+24]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [ebx+ecx+18], ax

; 3212 : 						mgg->frames[i].sizey=(mgg->frames[i].h*32768)/2048;

	mov	ecx, DWORD PTR _mgg_sys+40
	mov	eax, DWORD PTR [ebx+ecx+28]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [ebx+ecx+20], ax

; 3213 : 
; 3214 : 						glDeleteTextures(1,&mgg->frames[i].data);

	mov	eax, DWORD PTR _mgg_sys+40
	add	eax, ebx
	push	eax
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8

; 3215 : 
; 3216 : 						mgg->frames[i].data=vbdt[vbdt_num-1].texture;

	mov	bx, WORD PTR _vbdt_num
	mov	eax, DWORD PTR _vbdt
	mov	edx, DWORD PTR tv3549[ebp]
	movzx	ecx, bx
	shl	ecx, 6

; 3217 : 
; 3218 : 						mgg->frames[i].vb_id=vbdt_num-1;
; 3219 : 
; 3220 : 						mgg->frames[i].w = 2048;
; 3221 : 						mgg->frames[i].h = 2048;
; 3222 : 
; 3223 : 						//free(data);
; 3224 : 
; 3225 : 						free(imgdata);

	push	edi
	mov	ecx, DWORD PTR [ecx+eax-28]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [edx+eax], ecx
	mov	eax, DWORD PTR _mgg_sys+40
	mov	ecx, DWORD PTR _vbdt_num
	dec	ecx
	mov	WORD PTR [edx+eax+10], cx
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [edx+eax+24], 2048		; 00000800H
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [edx+eax+28], 2048		; 00000800H
	call	_free
	add	esp, 4

; 3226 : 					}
; 3227 : 					else

	jmp	$LN211@LoadMGG
$LN26@LoadMGG:

; 3228 : 					{
; 3229 : 						for(n=l;n<vbdt_num;n++)

	mov	eax, DWORD PTR _l$1$[ebp]
	movzx	edx, ax
	mov	DWORD PTR _n$3$[ebp], edx
	cmp	ax, bx
	jae	$LN211@LoadMGG
	npad	6
$LL21@LoadMGG:

; 3230 : 						{
; 3231 : 							if(mgg->frames[i].w+w[n]<2048 || mgg->frames[i].h+currh[n]<2048)

	movzx	eax, dx
	mov	DWORD PTR tv3458[ebp], eax
	movzx	eax, WORD PTR [esi+eax*2]
	add	eax, DWORD PTR tv3466[ebp]
	cmp	eax, 2048				; 00000800H
	jl	$LN17@LoadMGG
	mov	eax, DWORD PTR tv3458[ebp]
	movzx	eax, WORD PTR [ecx+eax*2]
	add	eax, DWORD PTR tv3286[ebp]
	cmp	eax, 2048				; 00000800H
	jl	$LN17@LoadMGG

; 3298 : 
; 3299 : 								break;
; 3300 : 							}
; 3301 : 							else
; 3302 : 							if(n==vbdt_num-1)

	mov	eax, DWORD PTR tv3393[ebp]
	cmp	DWORD PTR tv3458[ebp], eax
	je	SHORT $LN157@LoadMGG

; 3228 : 					{
; 3229 : 						for(n=l;n<vbdt_num;n++)

	inc	edx
	mov	DWORD PTR _n$3$[ebp], edx
	cmp	dx, bx
	jb	SHORT $LL21@LoadMGG

; 2926 : 		{	
; 2927 : 			if(framealone[i] && i==mggf.num_frames-1) 

	jmp	$LN211@LoadMGG
$LN157@LoadMGG:

; 3303 : 							{
; 3304 : 								vbdt_num++;

	inc	bx

; 3305 : 								vbdt=(VB_DATAT*) realloc(vbdt,vbdt_num*sizeof(VB_DATAT));

	movzx	esi, bx
	mov	WORD PTR _vbdt_num, bx
	mov	ebx, esi
	shl	ebx, 6
	push	ebx
	push	DWORD PTR _vbdt
	call	_realloc

; 3306 : 
; 3307 : 								w=(int16*) realloc(w,vbdt_num*sizeof(int16));

	add	esi, esi
	mov	edi, eax
	push	esi
	push	DWORD PTR _w$[ebp]
	mov	DWORD PTR _vbdt, edi
	call	_realloc

; 3308 : 								h=(int16*) realloc(h,vbdt_num*sizeof(int16));

	push	esi
	push	DWORD PTR _h$[ebp]
	mov	DWORD PTR _w$[ebp], eax
	call	_realloc

; 3309 : 
; 3310 : 								vbdt[vbdt_num-1].normal=0;
; 3311 : 
; 3312 : 								currh=(int16*) realloc(currh,vbdt_num*sizeof(int16));

	push	esi
	push	DWORD PTR _currh$[ebp]
	mov	DWORD PTR _h$[ebp], eax
	mov	BYTE PTR [ebx+edi-20], 0
	call	_realloc
	mov	ecx, eax

; 3313 : 
; 3314 : 								currh[vbdt_num-1]=w[vbdt_num-1]=h[vbdt_num-1]=0;

	xor	edx, edx
	mov	eax, DWORD PTR _h$[ebp]
	add	esp, 32					; 00000020H
	mov	DWORD PTR _currh$[ebp], ecx
	mov	WORD PTR [esi+eax-2], dx
	mov	eax, DWORD PTR _w$[ebp]
	mov	WORD PTR [esi+eax-2], dx
	xor	eax, eax
	mov	WORD PTR [esi+ecx-2], ax

; 3315 : 
; 3316 : 								vbdt[vbdt_num-1].num_elements=0;

	mov	WORD PTR [ebx+edi-18], ax

; 3317 : 
; 3318 : 								glGenTextures(1,&vbdt[vbdt_num-1].texture);

	lea	eax, DWORD PTR [edi-28]
	add	eax, ebx
	push	eax
	push	1
	call	DWORD PTR __imp__glGenTextures@8

; 3319 : 
; 3320 : 								glBindTexture(GL_TEXTURE_2D,vbdt[vbdt_num-1].texture);

	movzx	ecx, WORD PTR _vbdt_num
	mov	eax, DWORD PTR _vbdt
	shl	ecx, 6
	push	DWORD PTR [ecx+eax-28]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 3321 : 
; 3322 : 								glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,2048,2048,0,GL_BGRA,GL_UNSIGNED_BYTE,NULL);

	push	0
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	push	2048					; 00000800H
	push	2048					; 00000800H
	push	32856					; 00008058H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36

; 3323 : 
; 3324 : 								//glBindTexture(GL_TEXTURE_2D,mgg->frames[i].data);
; 3325 : 
; 3326 : 								/*
; 3327 : 								data=malloc(framesize[j]);
; 3328 : 
; 3329 : 								if(data==NULL)
; 3330 : 								{
; 3331 : 									LogApp("Error allocating memory for texture %d, size %d, file %s during atlas creating",i,framesize[i],name);
; 3332 : 									continue;
; 3333 : 								}
; 3334 : 
; 3335 : 								fseek(file,frameoffset[j-1]+1,SEEK_SET);
; 3336 : 
; 3337 : 								fread(data,framesize[j],1,file);
; 3338 : 
; 3339 : 								imgdata=SOIL_load_image_from_memory((unsigned char*) data,framesize[j],&width,&height,&channel,0);
; 3340 : 								*/
; 3341 : 
; 3342 : 								if (mgg->frames[i].channel == 4)

	mov	ebx, DWORD PTR tv3549[ebp]
	mov	edx, DWORD PTR _mgg_sys+40
	mov	ecx, DWORD PTR [ebx+edx+32]
	cmp	ecx, 4
	jne	SHORT $LN9@LoadMGG

; 3343 : 									channel2 = GL_RGBA;

	mov	esi, 6408				; 00001908H

; 3344 : 								else

	jmp	SHORT $LN232@LoadMGG
$LN9@LoadMGG:

; 3345 : 									if (mgg->frames[i].channel == 3)

	mov	esi, DWORD PTR _channel2$[ebp]
	cmp	ecx, 3
	mov	eax, 6407				; 00001907H
	cmove	esi, eax
$LN232@LoadMGG:

; 3346 : 										channel2 = GL_RGB;
; 3347 : 
; 3348 : 								imgdata = malloc(mgg->frames[i].w*mgg->frames[i].h*mgg->frames[i].channel);

	mov	eax, DWORD PTR [ebx+edx+28]
	imul	eax, DWORD PTR [ebx+edx+24]
	mov	DWORD PTR _channel2$[ebp], esi
	imul	eax, ecx
	push	eax
	call	_malloc
	add	esp, 4
	mov	edi, eax

; 3349 : 								glBindTexture(GL_TEXTURE_2D, mgg->frames[i].data);

	mov	eax, DWORD PTR _mgg_sys+40
	push	DWORD PTR [ebx+eax]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 3350 : 								glGetTexImage(GL_TEXTURE_2D, 0, channel2, GL_UNSIGNED_BYTE, imgdata);

	push	edi
	push	5121					; 00001401H
	movzx	esi, si
	push	esi
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glGetTexImage@20

; 3351 : 
; 3352 : 								glBindTexture(GL_TEXTURE_2D, vbdt[l].texture);

	mov	ecx, DWORD PTR tv3289[ebp]
	mov	eax, DWORD PTR _vbdt
	shl	ecx, 6
	push	DWORD PTR [ecx+eax+36]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 3353 : 				
; 3354 : 								glTexSubImage2D(GL_TEXTURE_2D,0,w[vbdt_num-1],h[vbdt_num-1],mgg->frames[i].w,mgg->frames[i].h,channel2,GL_UNSIGNED_BYTE,imgdata);

	mov	eax, DWORD PTR _mgg_sys+40
	movzx	ecx, WORD PTR _vbdt_num
	push	edi
	push	5121					; 00001401H
	push	esi
	push	DWORD PTR [ebx+eax+28]
	push	DWORD PTR [ebx+eax+24]
	mov	eax, DWORD PTR _h$[ebp]
	movzx	eax, WORD PTR [eax+ecx*2-2]
	push	eax
	mov	eax, DWORD PTR _w$[ebp]
	movzx	eax, WORD PTR [eax+ecx*2-2]
	push	eax
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexSubImage2D@36

; 3355 : 
; 3356 : 								mgg->frames[i].posx=(w[vbdt_num-1]*32768)/2048;

	movzx	esi, WORD PTR _vbdt_num
	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _mgg_sys+40
	movzx	eax, WORD PTR [eax+esi*2-2]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [ebx+ecx+14], ax

; 3357 : 								mgg->frames[i].posy=(currh[vbdt_num-1]*32768)/2048;

	mov	eax, DWORD PTR _currh$[ebp]
	mov	ecx, DWORD PTR _mgg_sys+40
	movzx	eax, WORD PTR [eax+esi*2-2]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx

; 3358 : 
; 3359 : 								w[vbdt_num-1]=mgg->frames[i].w;

	mov	edx, DWORD PTR _w$[ebp]
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [ebx+ecx+16], ax
	mov	ecx, DWORD PTR _mgg_sys+40
	movzx	eax, WORD PTR [ebx+ecx+24]
	mov	WORD PTR [edx+esi*2-2], ax

; 3360 : 								h[vbdt_num-1]=mgg->frames[i].h;

	mov	edx, DWORD PTR _h$[ebp]
	movzx	eax, WORD PTR [ebx+ecx+28]
	mov	WORD PTR [edx+esi*2-2], ax

; 3361 : 
; 3362 : 								mgg->frames[i].sizex=(mgg->frames[i].w*32768)/2048;

	mov	eax, DWORD PTR [ebx+ecx+24]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [ebx+ecx+18], ax

; 3363 : 								mgg->frames[i].sizey=(mgg->frames[i].h*32768)/2048;

	mov	ecx, DWORD PTR _mgg_sys+40
	mov	eax, DWORD PTR [ebx+ecx+28]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [ebx+ecx+20], ax

; 3364 : 
; 3365 : 								glDeleteTextures(1,&mgg->frames[i].data);

	mov	eax, DWORD PTR _mgg_sys+40
	add	eax, ebx
	push	eax
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8

; 3366 : 
; 3367 : 								mgg->frames[i].data=vbdt[vbdt_num-1].texture;

	mov	bx, WORD PTR _vbdt_num
	mov	eax, DWORD PTR _vbdt
	mov	edx, DWORD PTR tv3549[ebp]
	movzx	ecx, bx
	shl	ecx, 6

; 3368 : 
; 3369 : 								mgg->frames[i].vb_id=vbdt_num-1;
; 3370 : 
; 3371 : 								mgg->frames[i].w = 2048;
; 3372 : 								mgg->frames[i].h = 2048;
; 3373 : 
; 3374 : 							//	free(data);
; 3375 : 
; 3376 : 								free(imgdata);

	push	edi
	mov	ecx, DWORD PTR [ecx+eax-28]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [edx+eax], ecx
	mov	eax, DWORD PTR _mgg_sys+40
	mov	ecx, DWORD PTR _vbdt_num
	dec	ecx
	mov	WORD PTR [edx+eax+10], cx
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [edx+eax+24], 2048		; 00000800H
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [edx+eax+28], 2048		; 00000800H
	call	_free

; 3377 : 
; 3378 : 								free(w);

	push	DWORD PTR _w$[ebp]
	call	_free

; 3379 : 								free(h);

	push	DWORD PTR _h$[ebp]
	call	_free

; 3380 : 								free(currh);

	push	DWORD PTR _currh$[ebp]
	call	_free
	add	esp, 16					; 00000010H

; 3381 : 
; 3382 : 								break;

	jmp	$LN211@LoadMGG
$LN17@LoadMGG:

; 3232 : 							{
; 3233 : 								//glBindTexture(GL_TEXTURE_2D,mgg->frames[i].data);
; 3234 : 
; 3235 : 								/*
; 3236 : 								data=malloc(framesize[j]);
; 3237 : 
; 3238 : 								if(data==NULL)
; 3239 : 								{
; 3240 : 									LogApp("Error allocating memory for texture %d, size %d, file %s during atlas creating",i,framesize[i],name);
; 3241 : 									continue;
; 3242 : 								}
; 3243 : 
; 3244 : 								fseek(file,frameoffset[j-1]+1,SEEK_SET);
; 3245 : 
; 3246 : 								fread(data,framesize[j],1,file);
; 3247 : 
; 3248 : 								imgdata=SOIL_load_image_from_memory((unsigned char*) data,framesize[j],&width,&height,&channel,0);
; 3249 : 								*/
; 3250 : 
; 3251 : 								if (mgg->frames[i].channel == 4)

	mov	eax, DWORD PTR _mgg_sys+40
	mov	ecx, DWORD PTR [edi+eax+32]
	cmp	ecx, 4
	jne	SHORT $LN16@LoadMGG

; 3252 : 									channel2 = GL_RGBA;

	mov	ebx, 6408				; 00001908H

; 3253 : 								else

	jmp	SHORT $LN233@LoadMGG
$LN16@LoadMGG:

; 3254 : 									if (mgg->frames[i].channel == 3)

	mov	ebx, DWORD PTR _channel2$[ebp]
	cmp	ecx, 3
	mov	eax, 6407				; 00001907H
	cmove	ebx, eax
$LN233@LoadMGG:

; 3255 : 										channel2 = GL_RGB;
; 3256 : 
; 3257 : 								imgdata = malloc(mgg->frames[i].w*mgg->frames[i].h*mgg->frames[i].channel);

	mov	eax, DWORD PTR tv3286[ebp]
	imul	eax, ecx
	mov	DWORD PTR _channel2$[ebp], ebx
	imul	eax, DWORD PTR tv3466[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _imgdata$6$[ebp], eax

; 3258 : 								glBindTexture(GL_TEXTURE_2D, mgg->frames[i].data);

	mov	eax, DWORD PTR _mgg_sys+40
	push	DWORD PTR [edi+eax]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 3259 : 								glGetTexImage(GL_TEXTURE_2D, 0, channel2, GL_UNSIGNED_BYTE, imgdata);

	push	DWORD PTR _imgdata$6$[ebp]
	movzx	edi, bx
	push	5121					; 00001401H
	push	edi
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glGetTexImage@20

; 3260 : 
; 3261 : 								glBindTexture(GL_TEXTURE_2D, vbdt[l].texture);

	mov	ecx, DWORD PTR tv3289[ebp]
	mov	eax, DWORD PTR _vbdt
	shl	ecx, 6
	push	DWORD PTR [ecx+eax+36]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 3262 : 				
; 3263 : 								glTexSubImage2D(GL_TEXTURE_2D,0,w[n],h[n],mgg->frames[i].w,mgg->frames[i].h,channel2,GL_UNSIGNED_BYTE,imgdata);

	push	DWORD PTR _imgdata$6$[ebp]
	mov	ecx, DWORD PTR _n$3$[ebp]
	mov	eax, DWORD PTR _mgg_sys+40
	push	5121					; 00001401H
	movzx	edx, cx
	mov	ecx, DWORD PTR _h$[ebp]
	movzx	ebx, WORD PTR [esi+edx*2]
	push	edi
	mov	edi, DWORD PTR tv3549[ebp]
	lea	ecx, DWORD PTR [ecx+edx*2]
	mov	DWORD PTR tv3323[ebp], edx
	mov	DWORD PTR tv3449[ebp], ecx
	lea	edx, DWORD PTR [esi+edx*2]
	movzx	ecx, WORD PTR [ecx]
	mov	esi, ebx
	push	DWORD PTR [edi+eax+28]
	mov	DWORD PTR tv3351[ebp], ecx
	push	DWORD PTR [edi+eax+24]
	movzx	ecx, cx
	push	ecx
	push	esi
	push	0
	push	3553					; 00000de1H
	mov	DWORD PTR tv3447[ebp], edx
	call	DWORD PTR __imp__glTexSubImage2D@36

; 3264 : 	
; 3265 : 								mgg->frames[i].posx=(w[n]*32768)/2048;

	mov	ecx, DWORD PTR _mgg_sys+40
	shl	esi, 15					; 0000000fH
	mov	eax, esi

; 3266 : 								mgg->frames[i].posy=(currh[n]*32768)/2048;

	mov	esi, DWORD PTR _currh$[ebp]
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [edi+ecx+14], ax
	mov	eax, DWORD PTR tv3323[ebp]
	mov	ecx, DWORD PTR _mgg_sys+40
	lea	eax, DWORD PTR [esi+eax*2]
	mov	DWORD PTR tv3445[ebp], eax
	movzx	eax, WORD PTR [eax]

; 3267 : 
; 3268 : 								w[n]+=mgg->frames[i].w;
; 3269 : 
; 3270 : 								if(currh[n]+mgg->frames[i].h>h[n])

	mov	esi, DWORD PTR tv3445[ebp]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [edi+ecx+16], ax
	mov	edx, DWORD PTR _mgg_sys+40
	movzx	ecx, WORD PTR [esi]
	mov	esi, DWORD PTR tv3351[ebp]
	mov	ax, WORD PTR [edi+edx+24]
	add	ax, bx
	mov	ebx, DWORD PTR tv3447[ebp]
	mov	WORD PTR [ebx], ax
	mov	eax, DWORD PTR [edi+edx+28]
	add	eax, ecx
	movzx	ecx, si
	mov	esi, DWORD PTR _currh$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN13@LoadMGG

; 3271 : 									h[n]+=mgg->frames[i].h;

	mov	ecx, DWORD PTR tv3449[ebp]
	mov	ax, WORD PTR [edi+edx+28]
	add	ax, WORD PTR tv3351[ebp]
	mov	WORD PTR [ecx], ax
$LN13@LoadMGG:

; 3272 : 
; 3273 : 								mgg->frames[i].sizex=(mgg->frames[i].w*32768)/2048;

	mov	eax, DWORD PTR [edi+edx+24]
	mov	ecx, DWORD PTR _mgg_sys+40
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [edi+ecx+18], ax

; 3274 : 								mgg->frames[i].sizey=(mgg->frames[i].h*32768)/2048;

	mov	ecx, DWORD PTR _mgg_sys+40
	mov	eax, DWORD PTR [edi+ecx+28]
	shl	eax, 15					; 0000000fH
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	mov	WORD PTR [edi+ecx+20], ax

; 3275 : 
; 3276 : 								glDeleteTextures(1,&mgg->frames[i].data);

	mov	eax, DWORD PTR _mgg_sys+40
	add	eax, edi
	push	eax
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8

; 3277 : 
; 3278 : 								mgg->frames[i].data=vbdt[n].texture;

	mov	ecx, DWORD PTR tv3323[ebp]
	mov	eax, DWORD PTR _vbdt

; 3279 : 
; 3280 : 								mgg->frames[i].vb_id=n;
; 3281 : 
; 3282 : 								mgg->frames[i].w = 2048;
; 3283 : 								mgg->frames[i].h = 2048;
; 3284 : 
; 3285 : 							//	free(data);
; 3286 : 
; 3287 : 								free(imgdata);

	push	DWORD PTR _imgdata$6$[ebp]
	shl	ecx, 6
	mov	ecx, DWORD PTR [ecx+eax+36]
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [edi+eax], ecx
	mov	eax, DWORD PTR _mgg_sys+40
	mov	ecx, DWORD PTR _n$3$[ebp]
	mov	WORD PTR [edi+eax+10], cx
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [edi+eax+24], 2048		; 00000800H
	mov	eax, DWORD PTR _mgg_sys+40
	mov	DWORD PTR [edi+eax+28], 2048		; 00000800H
	call	_free

; 3288 : 
; 3289 : 								if(2048-w[n]<128 && 2048-currh[n]>128)

	movzx	eax, WORD PTR [ebx]
	mov	ecx, 2048				; 00000800H
	sub	ecx, eax
	add	esp, 4
	cmp	ecx, 128				; 00000080H
	jge	SHORT $LN12@LoadMGG
	mov	edx, DWORD PTR tv3445[ebp]
	mov	eax, 2048				; 00000800H
	movzx	ecx, WORD PTR [edx]
	sub	eax, ecx
	cmp	eax, 128				; 00000080H
	jle	SHORT $LN12@LoadMGG

; 3290 : 								{
; 3291 : 									w[n]=0;

	xor	eax, eax
	mov	WORD PTR [ebx], ax

; 3292 : 									currh[n]=h[n];

	mov	eax, DWORD PTR tv3449[ebp]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [edx], ax
$LN12@LoadMGG:

; 3293 : 								}
; 3294 : 
; 3295 : 								free(w);

	push	DWORD PTR _w$[ebp]
	call	_free

; 3296 : 								free(h);

	push	DWORD PTR _h$[ebp]
	call	_free

; 3297 : 								free(currh);

	push	esi
	call	_free
	add	esp, 12					; 0000000cH
$LN198@LoadMGG:
	mov	bx, WORD PTR _vbdt_num
$LN211@LoadMGG:
	mov	edi, DWORD PTR _vbdt
$LN19@LoadMGG:

; 3383 : 							}
; 3384 : 						}
; 3385 : 					}
; 3386 : 				}
; 3387 : 			}
; 3388 : 
; 3389 : 			if(i==mggf.num_frames-1)

	movzx	eax, WORD PTR _mggf$[ebp+32]
	dec	eax
	cmp	DWORD PTR tv3572[ebp], eax
	jne	$LN218@LoadMGG

; 3390 : 			{
; 3391 : 				for(n=k;n<vbdt_num;n++)

	mov	eax, DWORD PTR _k$1$[ebp]
	movzx	esi, ax
	cmp	ax, bx
	jae	$LN218@LoadMGG
	npad	7
$LL5@LoadMGG:

; 3392 : 				{
; 3393 : 					glBindTexture(GL_TEXTURE_2D,vbdt[n].texture);

	movzx	eax, si
	shl	eax, 6
	push	DWORD PTR [eax+edi+36]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 3394 : 					//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
; 3395 : 					//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
; 3396 : 
; 3397 : 					if(mggf.mipmap)

	cmp	BYTE PTR _mggf$[ebp+72], 0
	je	SHORT $LN2@LoadMGG

; 3398 : 					{
; 3399 : 						glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);

	mov	ebx, DWORD PTR __imp__glTexParameteri@12
	push	9728					; 00002600H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	ebx

; 3400 : 						glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);

	push	9728					; 00002600H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	ebx

; 3401 : 					}
; 3402 : 					else

	jmp	SHORT $LN4@LoadMGG
$LN2@LoadMGG:

; 3403 : 						glGenerateMipmap(GL_TEXTURE_2D);

	push	3553					; 00000de1H
	call	DWORD PTR _GLeeFuncPtr_glGenerateMipmap
$LN4@LoadMGG:

; 3390 : 			{
; 3391 : 				for(n=k;n<vbdt_num;n++)

	mov	bx, WORD PTR _vbdt_num
	inc	esi
	cmp	si, bx
	jae	SHORT $LN218@LoadMGG
	mov	edi, DWORD PTR _vbdt
	jmp	SHORT $LL5@LoadMGG
$LN218@LoadMGG:
	mov	esi, DWORD PTR _framealone$1$[ebp]
$LN61@LoadMGG:

; 2924 : 	{
; 2925 : 		for(i=(mggf.num_texinatlas), j=mggf.num_atlas;i<mggf.num_frames;i++, j++)

	inc	DWORD PTR _i$[ebp]
	mov	cx, WORD PTR _i$[ebp]
	cmp	cx, WORD PTR _mggf$[ebp+32]
	jb	$LL62@LoadMGG
$LN203@LoadMGG:

; 3404 : 				}
; 3405 : 			}
; 3406 : 		}
; 3407 : 	}
; 3408 : 
; 3409 : #endif
; 3410 : 	
; 3411 : 	free(posx);

	push	DWORD PTR _posx$1$[ebp]
	call	_free

; 3412 : 	free(posy);

	push	DWORD PTR _posy$1$[ebp]
	call	_free

; 3413 : 	free(sizex);

	push	DWORD PTR _sizex$1$[ebp]
	call	_free

; 3414 : 	free(sizey);

	push	DWORD PTR _sizey$1$[ebp]
	call	_free

; 3415 : 	
; 3416 : 	//if(imgatlas!=0)
; 3417 : 		free(imgatlas);

	push	DWORD PTR _imgatlas$1$[ebp]
	call	_free

; 3418 : 
; 3419 : 	//if(framealone!=0)
; 3420 : 		free(framealone);

	push	esi
	call	_free

; 3421 : 
; 3422 : 	fclose(file);

	push	DWORD PTR _file$1$[ebp]
	call	_fclose
	add	esp, 28					; 0000001cH

; 3423 : 
; 3424 : 	return 1;

	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx

; 3425 : 		
; 3426 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN132@LoadMGG:

; 2511 : 	{
; 2512 : 		fclose(file);

	push	ebx
	call	_fclose

; 2513 : 		LogApp("Invalid MGG file info %s",name);

	push	OFFSET ??_C@_0BA@GLINHHCI@data?1mEngUI?4mgg?$AA@
	push	OFFSET ??_C@_0BJ@MDEIDPPP@Invalid?5MGG?5file?5info?5?$CFs?$AA@
	call	DWORD PTR __imp__SDL_Log

; 3425 : 		
; 3426 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	xor	ecx, ebp
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LoadMGG ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _InitMGG
_TEXT	SEGMENT
_InitMGG PROC						; COMDAT

; 3461 : {

	push	esi
	push	edi

; 3462 : 	uint16 i;
; 3463 : 
; 3464 : 	for(i=0; i<MAX_MAP_MGG; i++)

	mov	esi, OFFSET _mgg_map+36
	mov	edi, 64					; 00000040H
	npad	4
$LL9@InitMGG:

; 3465 : 	{
; 3466 : 		memset(&mgg_map[i],0,sizeof(_MGG));

	push	60					; 0000003cH
	lea	eax, DWORD PTR [esi-36]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3467 : 		mgg_map[i].type=NONE;

	mov	DWORD PTR [esi], 2
	lea	esi, DWORD PTR [esi+60]
	dec	edi
	jne	SHORT $LL9@InitMGG

; 3468 : 	}
; 3469 : 
; 3470 : 	for(i=0; i<MAX_GAME_MGG; i++)

	mov	esi, OFFSET _mgg_game+36
	mov	edi, 128				; 00000080H
$LL6@InitMGG:

; 3471 : 	{
; 3472 : 		memset(&mgg_game[i],0,sizeof(_MGG));

	push	60					; 0000003cH
	lea	eax, DWORD PTR [esi-36]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3473 : 		mgg_game[i].type=NONE;

	mov	DWORD PTR [esi], 2
	lea	esi, DWORD PTR [esi+60]
	dec	edi
	jne	SHORT $LL6@InitMGG

; 3474 : 	}
; 3475 : 
; 3476 : 	for(i=0; i<3; i++)

	mov	esi, OFFSET _mgg_sys+36
	mov	edi, 3
	npad	4
$LL3@InitMGG:

; 3477 : 	{
; 3478 : 		memset(&mgg_sys[i],0,sizeof(_MGG));

	push	60					; 0000003cH
	lea	eax, DWORD PTR [esi-36]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3479 : 		mgg_sys[i].type=NONE;

	mov	DWORD PTR [esi], 2
	lea	esi, DWORD PTR [esi+60]
	dec	edi
	jne	SHORT $LL3@InitMGG

; 3480 : 	}
; 3481 : }

	pop	edi
	pop	esi
	ret	0
_InitMGG ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _BASICBKD
_TEXT	SEGMENT
_b$dead$ = 8						; size = 1
_BASICBKD PROC						; COMDAT
; _r$dead$ = cl
; _g$dead$ = dl

; 4617 : {

	movaps	xmm0, XMMWORD PTR __xmm@46800000000000000000000000000000

; 4618 : 	float tmp, ax, ay, az;
; 4619 : 
; 4620 : 	uint32 i=0, j=0, k=0;
; 4621 : 
; 4622 : 	i=0;
; 4623 : 
; 4624 : 	lmp[i].data.data=st.game_lightmaps[0].tex;

	mov	eax, DWORD PTR _st+492

; 4625 : 	lmp[i].ang=0;
; 4626 : 
; 4627 : 			lmp[i].vertex[0]=0.0f;
; 4628 : 			lmp[i].vertex[1]=0.0f;
; 4629 : 			lmp[i].vertex[2]=0.0f;
; 4630 : 
; 4631 : 			lmp[i].vertex[3]=16384.0f;
; 4632 : 			lmp[i].vertex[4]=0.0f;
; 4633 : 			lmp[i].vertex[5]=0.0f;
; 4634 : 
; 4635 : 			lmp[i].vertex[6]=16384.0f;
; 4636 : 			lmp[i].vertex[7]=9216.0f;
; 4637 : 			lmp[i].vertex[8]=0.0f;
; 4638 : 
; 4639 : 			lmp[i].vertex[9]=0.0f;
; 4640 : 			lmp[i].vertex[10]=9216.0f;
; 4641 : 			lmp[i].vertex[11]=0.0f;
; 4642 : 
; 4643 : 			ax=(float) 1/(GAME_WIDTH/2);
; 4644 : 			ay=(float) 1/(GAME_HEIGHT/2);
; 4645 : 
; 4646 : 			ay*=-1.0f;
; 4647 : 
; 4648 : 			az=(float) 1/(4096/2);
; 4649 : 
; 4650 : 			lmp[i].texcor[0]=0;
; 4651 : 			lmp[i].texcor[1]=0;
; 4652 : 			lmp[i].texcor[2]=1;
; 4653 : 			lmp[i].texcor[3]=0;
; 4654 : 			lmp[i].texcor[4]=1;
; 4655 : 			lmp[i].texcor[5]=1;
; 4656 : 			lmp[i].texcor[6]=0;
; 4657 : 			lmp[i].texcor[7]=1;
; 4658 : 
; 4659 : 			for(j=0;j<12;j+=3)

	movss	xmm3, DWORD PTR __real@39000000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm4, DWORD PTR __real@39638e39
	movss	xmm5, DWORD PTR __real@3a000000
	movups	XMMWORD PTR _lmp+100, xmm0
	mov	DWORD PTR _lmp+44, eax
	xor	eax, eax
	movaps	xmm0, XMMWORD PTR __xmm@46100000468000000000000000000000
	movups	XMMWORD PTR _lmp+116, xmm0
	mov	WORD PTR _lmp+96, ax
	movaps	xmm0, XMMWORD PTR __xmm@00000000461000000000000000000000
	movups	XMMWORD PTR _lmp+132, xmm0
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movups	XMMWORD PTR _lmp+148, xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f800000000000003f8000003f800000
	movups	XMMWORD PTR _lmp+164, xmm0
	npad	8
$LL6@BASICBKD:

; 4660 : 			{
; 4661 : 				lmp[i].vertex[j]*=ax;

	movss	xmm0, DWORD PTR _lmp[eax+100]

; 4662 : 				lmp[i].vertex[j]-=1;
; 4663 : 
; 4664 : 				lmp[i].vertex[j+1]*=ay;

	movss	xmm1, DWORD PTR _lmp[eax+104]
	mulss	xmm0, xmm3
	mulss	xmm1, xmm4
	subss	xmm0, xmm2
	movss	DWORD PTR _lmp[eax+100], xmm0

; 4665 : 				lmp[i].vertex[j+1]+=1;

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR _lmp[eax+104], xmm0

; 4666 : 				
; 4667 : 				lmp[i].vertex[j+2]*=az;

	movss	xmm0, DWORD PTR _lmp[eax+108]
	mulss	xmm0, xmm5

; 4668 : 				lmp[i].vertex[j+2]-=1;

	subss	xmm0, xmm2
	movss	DWORD PTR _lmp[eax+108], xmm0
	add	eax, 12					; 0000000cH
	cmp	eax, 48					; 00000030H
	jb	SHORT $LL6@BASICBKD

; 4669 : 			}
; 4670 : 
; 4671 : 			for(j=0;j<16;j+=4)

	xor	eax, eax
	npad	11
$LL3@BASICBKD:

; 4672 : 			{
; 4673 : 				lmp[i].color[j]=r;

	mov	DWORD PTR _lmp[eax+228], -1
	add	eax, 4
	cmp	eax, 16					; 00000010H
	jb	SHORT $LL3@BASICBKD

; 4674 : 				lmp[i].color[j+1]=g;
; 4675 : 				lmp[i].color[j+2]=b;
; 4676 : 				lmp[i].color[j+3]=255;
; 4677 : 			}
; 4678 : 
; 4679 : 			st.num_lightmap++;

	inc	BYTE PTR _st+261

; 4680 : 
; 4681 : }

	ret	0
_BASICBKD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawUI
_TEXT	SEGMENT
_ty2$1$ = -28						; size = 4
tv2196 = -28						; size = 4
_y$1$ = -24						; size = 4
tv2105 = -20						; size = 4
tv2195 = -16						; size = 4
_x$1$ = -12						; size = 4
_ang$1$ = -8						; size = 4
_ang$1$ = -8						; size = 4
tv2197 = -8						; size = 4
_g$1$ = -2						; size = 1
_b$1$ = -1						; size = 1
_sizex$ = 8						; size = 4
_sizey$ = 12						; size = 4
_ang$ = 16						; size = 2
_r$ = 20						; size = 1
_g$ = 24						; size = 1
_b$ = 28						; size = 1
_x1$ = 32						; size = 4
_y1$ = 36						; size = 4
_x2$ = 40						; size = 4
_y2$ = 44						; size = 4
_data$ = 48						; size = 40
_a$ = 88						; size = 1
_layer$ = 92						; size = 1
_DrawUI	PROC						; COMDAT
; _x$ = ecx
; _y$ = edx

; 5341 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 5342 : 	float tmp, ax, ay, az, tx1, ty1, tx2, ty2, sy, py;
; 5343 : 	
; 5344 : 	uint32 i=0, j=0, k=0;
; 5345 : 			
; 5346 : 	if(st.num_entities==MAX_GRAPHICS-1)

	mov	esi, DWORD PTR _st+244
	mov	DWORD PTR _y$1$[ebp], edx
	mov	DWORD PTR _x$1$[ebp], ecx
	cmp	esi, 2047				; 000007ffH
	jne	SHORT $LN18@DrawUI

; 5347 : 		return 2;

	mov	al, 2
	pop	esi

; 5493 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@DrawUI:

; 5348 : 	else
; 5349 : 		i=st.num_entities;
; 5350 : 
; 5351 : 	ent[i].lightmapid=-1;
; 5352 : 
; 5353 : 			if(data.vb_id!=-1)

	movss	xmm3, DWORD PTR __real@3f800000
	or	eax, -1
	movss	xmm4, DWORD PTR __real@38000000
	imul	ecx, esi, 264
	mov	DWORD PTR tv2197[ebp], ecx
	mov	WORD PTR _ent[ecx+260], ax
	mov	eax, DWORD PTR _data$[ebp+8]
	shr	eax, 16					; 00000010H
	mov	DWORD PTR tv2196[ebp], eax
	cmp	ax, -1
	je	SHORT $LN16@DrawUI

; 5354 : 			{
; 5355 : 				ent[i].texrepeat[0]=(float) data.posx/32768;

	mov	eax, DWORD PTR _data$[ebp+12]

; 5356 : 				ent[i].texrepeat[1]=(float) data.posy/32768;

	mov	edx, DWORD PTR _data$[ebp+16]
	shr	eax, 16					; 00000010H
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movzx	eax, dx
	mulss	xmm0, xmm4
	movss	DWORD PTR _ent[ecx+212], xmm0
	movd	xmm0, eax

; 5357 : 				ent[i].texrepeat[2]=(float) data.sizex/32768;

	mov	eax, edx
	cvtdq2ps xmm0, xmm0
	shr	eax, 16					; 00000010H
	mulss	xmm0, xmm4
	movss	DWORD PTR _ent[ecx+216], xmm0
	movd	xmm0, eax

; 5358 : 				ent[i].texrepeat[3]=(float) data.sizey/32768;

	movzx	eax, WORD PTR _data$[ebp+20]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm4
	movss	DWORD PTR _ent[ecx+220], xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm4
	movss	DWORD PTR _ent[ecx+224], xmm0

; 5359 : 			}
; 5360 : 			else

	jmp	SHORT $LN15@DrawUI
$LN16@DrawUI:

; 5361 : 			{
; 5362 : 				ent[i].texrepeat[0]=0.0f;

	mov	DWORD PTR _ent[ecx+212], 0

; 5363 : 				ent[i].texrepeat[1]=0.0f;

	mov	DWORD PTR _ent[ecx+216], 0

; 5364 : 				ent[i].texrepeat[2]=1.0f;

	mov	DWORD PTR _ent[ecx+220], 1065353216	; 3f800000H

; 5365 : 				ent[i].texrepeat[3]=1.0f;

	mov	DWORD PTR _ent[ecx+224], 1065353216	; 3f800000H
$LN15@DrawUI:

; 5366 : 			}
; 5367 : 	
; 5368 : 			ent[i].data=data;
; 5369 : 
; 5370 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 5371 : 
; 5372 : 
; 5373 : 			if(r==0 && g==0 && b==0)

	cmp	BYTE PTR _r$[ebp], 0
	movdqu	xmm0, XMMWORD PTR _data$[ebp]
	movdqu	XMMWORD PTR _ent[ecx+44], xmm0
	movdqu	xmm0, XMMWORD PTR _data$[ebp+16]
	movdqu	XMMWORD PTR _ent[ecx+60], xmm0
	movq	xmm0, QWORD PTR _data$[ebp+32]
	movq	QWORD PTR _ent[ecx+76], xmm0
	jne	SHORT $LN109@DrawUI
	mov	al, BYTE PTR _g$[ebp]
	mov	BYTE PTR _g$1$[ebp], al
	test	al, al
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _b$1$[ebp], al
	jne	SHORT $LN14@DrawUI
	test	al, al
	jne	SHORT $LN14@DrawUI

; 5374 : 				r=g=b=1;

	mov	BYTE PTR _b$1$[ebp], 1
	mov	BYTE PTR _g$1$[ebp], 1
	mov	BYTE PTR _r$[ebp], 1
	jmp	SHORT $LN14@DrawUI
$LN109@DrawUI:
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _b$1$[ebp], al
	mov	al, BYTE PTR _g$[ebp]
	mov	BYTE PTR _g$1$[ebp], al
$LN14@DrawUI:

; 5375 : 
; 5376 : 			if(layer>7) layer=7;

	mov	ecx, 7
	cmp	BYTE PTR _layer$[ebp], cl
	push	ebx
	movzx	ebx, BYTE PTR _layer$[ebp]
	cmovg	ebx, ecx
	push	edi

; 5377 : 			//else if(layer<0) layer+=8;
; 5378 : 
; 5379 : 			z_buffer[layer][z_slot[layer]]=i;

	movsx	edi, bl
	mov	ecx, edi
	mov	DWORD PTR tv2195[ebp], edi
	shl	ecx, 11					; 0000000bH
	movzx	edx, WORD PTR _z_slot[edi*2]
	movsx	eax, dx
	add	ecx, eax

; 5380 : 			z_slot[layer]++;
; 5381 : 
; 5382 : 			if(layer>z_used) z_used=layer;

	cmp	bl, BYTE PTR _z_used
	lea	eax, DWORD PTR [edx+1]
	movzx	edx, BYTE PTR _z_used
	mov	WORD PTR _z_slot[edi*2], ax
	movzx	eax, bl
	cmovg	edx, eax
	mov	WORD PTR _z_buffer[ecx*2], si

; 5383 : 
; 5384 : 			//timej=GetTicks();
; 5385 : 
; 5386 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	mov	esi, DWORD PTR _ang$[ebp]
	mov	BYTE PTR _z_used, dl

; 217  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 5383 : 
; 5384 : 			//timej=GetTicks();
; 5385 : 
; 5386 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	eax, si

; 217  : 	if(ang>3600) ang-=3600;

	mov	DWORD PTR tv2105[ebp], edx
	cmp	si, dx
	jle	SHORT $LN23@DrawUI
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN111@DrawUI
$LN23@DrawUI:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN21@DrawUI
	lea	eax, DWORD PTR [esi+3600]
$LN111@DrawUI:
	movzx	eax, ax
$LN21@DrawUI:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, ax

; 5383 : 
; 5384 : 			//timej=GetTicks();
; 5385 : 
; 5386 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	edi, si

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN28@DrawUI
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN112@DrawUI
$LN28@DrawUI:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN26@DrawUI
	lea	eax, DWORD PTR [esi+3600]
$LN112@DrawUI:
	movzx	edi, ax
$LN26@DrawUI:

; 5383 : 
; 5384 : 			//timej=GetTicks();
; 5385 : 
; 5386 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx
	movd	xmm2, DWORD PTR _x$1$[ebp]
	sar	eax, 1
	neg	eax
	mov	ebx, DWORD PTR tv2197[ebp]
	cvtdq2ps xmm2, xmm2
	movd	xmm6, eax
	mov	eax, DWORD PTR _sizey$[ebp]
	cdq
	sub	eax, edx

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 5383 : 
; 5384 : 			//timej=GetTicks();
; 5385 : 
; 5386 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	sar	eax, 1
	neg	eax
	cvtdq2ps xmm6, xmm6
	movd	xmm5, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	movsx	eax, di

; 5383 : 
; 5384 : 			//timej=GetTicks();
; 5385 : 
; 5386 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR _st[ecx*4+2717808]
	cvtdq2ps xmm5, xmm5
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm5

; 5387 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	addss	xmm1, xmm2
	movss	DWORD PTR _ent[ebx+100], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN33@DrawUI
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN113@DrawUI
$LN33@DrawUI:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN31@DrawUI
	lea	eax, DWORD PTR [esi+3600]
$LN113@DrawUI:
	movzx	eax, ax
$LN31@DrawUI:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 5387 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN38@DrawUI
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN114@DrawUI
$LN38@DrawUI:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN36@DrawUI
	lea	ecx, DWORD PTR [esi+3600]
$LN114@DrawUI:
	movzx	ecx, cx
$LN36@DrawUI:
	movd	xmm7, DWORD PTR _y$1$[ebp]

; 5387 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR _st[eax*4+2732212]
	lea	edi, DWORD PTR _ent[ebx+104]

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx

; 5388 : 			ent[i].vertex[2]=layer;
; 5389 : 
; 5390 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	cvtdq2ps xmm7, xmm7
	movss	xmm1, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm1, xmm5
	addss	xmm1, xmm0
	movd	xmm0, DWORD PTR tv2195[ebp]
	cvtdq2ps xmm0, xmm0
	addss	xmm1, xmm7
	movss	DWORD PTR _ent[ebx+108], xmm0
	movss	DWORD PTR [edi], xmm1

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN43@DrawUI
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN115@DrawUI
$LN43@DrawUI:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN41@DrawUI
	lea	eax, DWORD PTR [esi+3600]
$LN115@DrawUI:
	movzx	eax, ax
$LN41@DrawUI:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, ax

; 5388 : 			ent[i].vertex[2]=layer;
; 5389 : 
; 5390 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	mov	DWORD PTR _ang$1$[ebp], eax

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN48@DrawUI
	lea	eax, DWORD PTR [esi-3600]
	movzx	eax, ax
	jmp	SHORT $LN116@DrawUI
$LN48@DrawUI:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN46@DrawUI
	lea	edx, DWORD PTR [esi+3600]
	movzx	eax, dx
$LN116@DrawUI:
	mov	DWORD PTR _ang$1$[ebp], eax
$LN46@DrawUI:

; 5388 : 			ent[i].vertex[2]=layer;
; 5389 : 
; 5390 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	mov	eax, DWORD PTR _sizex$[ebp]
	cdq
	sub	eax, edx

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 5388 : 			ent[i].vertex[2]=layer;
; 5389 : 
; 5390 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	sar	eax, 1
	movd	xmm2, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	mov	eax, DWORD PTR _ang$1$[ebp]
	cwde

; 5388 : 			ent[i].vertex[2]=layer;
; 5389 : 
; 5390 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtdq2ps xmm2, xmm2
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mov	eax, DWORD PTR _x$1$[ebp]
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm0, xmm5
	subss	xmm1, xmm0
	movd	xmm0, eax

; 5391 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	cvtdq2ps xmm0, xmm0
	addss	xmm1, xmm0
	movss	DWORD PTR _ent[ebx+112], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN53@DrawUI
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN117@DrawUI
$LN53@DrawUI:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN51@DrawUI
	lea	eax, DWORD PTR [esi+3600]
$LN117@DrawUI:
	movzx	eax, ax
$LN51@DrawUI:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 5391 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN58@DrawUI
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN118@DrawUI
$LN58@DrawUI:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN56@DrawUI
	lea	ecx, DWORD PTR [esi+3600]
$LN118@DrawUI:
	movzx	ecx, cx
$LN56@DrawUI:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx

; 5391 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _st[eax*4+2732212]

; 5392 : 			ent[i].vertex[5]=layer;

	mov	eax, DWORD PTR tv2195[ebp]
	movss	xmm1, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm1, xmm5
	addss	xmm1, xmm0
	movd	xmm0, eax

; 5393 : 
; 5394 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	cvtdq2ps xmm0, xmm0
	addss	xmm1, xmm7
	movss	DWORD PTR _ent[ebx+120], xmm0
	movss	DWORD PTR _ent[ebx+116], xmm1

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN63@DrawUI
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN119@DrawUI
$LN63@DrawUI:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN61@DrawUI
	lea	eax, DWORD PTR [esi+3600]
$LN119@DrawUI:
	movzx	eax, ax
$LN61@DrawUI:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, ax

; 5393 : 
; 5394 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	mov	DWORD PTR _ang$1$[ebp], eax

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN68@DrawUI
	lea	eax, DWORD PTR [esi-3600]
	movzx	eax, ax
	jmp	SHORT $LN120@DrawUI
$LN68@DrawUI:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN66@DrawUI
	lea	edx, DWORD PTR [esi+3600]
	movzx	eax, dx
$LN120@DrawUI:
	mov	DWORD PTR _ang$1$[ebp], eax
$LN66@DrawUI:

; 5393 : 
; 5394 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	mov	eax, DWORD PTR _sizey$[ebp]
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR _st[ecx*4+2717808]

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	ecx, 3600				; 00000e10H

; 5393 : 
; 5394 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _x$1$[ebp]
	sar	eax, 1
	movd	xmm5, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	mov	eax, DWORD PTR _ang$1$[ebp]
	cwde

; 5393 : 
; 5394 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtdq2ps xmm5, xmm5
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm5

; 5395 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0
	addss	xmm1, xmm0
	movss	DWORD PTR _ent[ebx+124], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, cx
	jle	SHORT $LN73@DrawUI
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN121@DrawUI
$LN73@DrawUI:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN71@DrawUI
	lea	eax, DWORD PTR [esi+3600]
$LN121@DrawUI:
	movzx	eax, ax
$LN71@DrawUI:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 5395 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, WORD PTR tv2105[ebp]
	jle	SHORT $LN78@DrawUI
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN122@DrawUI
$LN78@DrawUI:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN76@DrawUI
	lea	ecx, DWORD PTR [esi+3600]
$LN122@DrawUI:
	movzx	ecx, cx
$LN76@DrawUI:

; 5395 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	mulss	xmm2, DWORD PTR _st[eax*4+2732212]

; 5396 : 			ent[i].vertex[8]=layer;

	mov	eax, DWORD PTR tv2195[ebp]

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx

; 5395 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movss	xmm0, DWORD PTR _st[ecx*4+2717808]

; 217  : 	if(ang>3600) ang-=3600;

	mov	ecx, 3600				; 00000e10H

; 5395 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	mulss	xmm0, xmm5
	addss	xmm0, xmm2
	movd	xmm2, eax

; 5397 : 
; 5398 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	cvtdq2ps xmm2, xmm2
	addss	xmm0, xmm7
	movss	DWORD PTR _ent[ebx+132], xmm2
	movss	DWORD PTR _ent[ebx+128], xmm0

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, cx
	jle	SHORT $LN83@DrawUI
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN123@DrawUI
$LN83@DrawUI:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN81@DrawUI
	lea	eax, DWORD PTR [esi+3600]
$LN123@DrawUI:
	movzx	eax, ax
$LN81@DrawUI:

; 219  : 
; 220  : 	return st.CosTable[ang];

	cwde

; 5397 : 
; 5398 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	ecx, si

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, WORD PTR tv2105[ebp]
	jle	SHORT $LN88@DrawUI
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN124@DrawUI
$LN88@DrawUI:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN86@DrawUI
	lea	ecx, DWORD PTR [esi+3600]
$LN124@DrawUI:
	movzx	ecx, cx
$LN86@DrawUI:

; 5397 : 
; 5398 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR _st[eax*4+2717808]

; 227  : 
; 228  : 	return st.SinTable[ang];

	movsx	eax, cx

; 5397 : 
; 5398 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm5

; 5399 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 5397 : 
; 5398 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	addss	xmm1, xmm0
	movss	DWORD PTR _ent[ebx+136], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN93@DrawUI
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN125@DrawUI
$LN93@DrawUI:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN91@DrawUI
	lea	eax, DWORD PTR [esi+3600]
$LN125@DrawUI:
	movzx	eax, ax
$LN91@DrawUI:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 5399 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN98@DrawUI
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN126@DrawUI
$LN98@DrawUI:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN96@DrawUI
	lea	ecx, DWORD PTR [esi+3600]
$LN126@DrawUI:
	movzx	ecx, cx
$LN96@DrawUI:

; 5401 : 
; 5402 : 			//timel=GetTicks() - timej;
; 5403 : 
; 5404 : 			//ang=1000;
; 5405 : 			/*
; 5406 : 			ang/=10;
; 5407 : 
; 5408 : 			tmp=cos((ang*pi)/180);
; 5409 : 			tmp=mCos(ang*10);
; 5410 : 	*/
; 5411 : 			ax = (float) 1/(16384.0f  / 2.0f);
; 5412 : 			ay=(float) 1/(9216.0f / 2.0f);
; 5413 : 
; 5414 : 			ay*=-1.0f;
; 5415 : 
; 5416 : 			az=(float) 1/(4096/2);
; 5417 : 
; 5418 : 			if(data.vb_id==-1)

	cmp	WORD PTR tv2196[ebp], -1
	mulss	xmm6, DWORD PTR _st[eax*4+2732212]

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx

; 5400 : 			ent[i].vertex[11]=layer;

	movss	DWORD PTR _ent[ebx+144], xmm2
	movss	xmm0, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm0, xmm5
	addss	xmm0, xmm6
	addss	xmm0, xmm7
	movss	DWORD PTR _ent[ebx+140], xmm0

; 5401 : 
; 5402 : 			//timel=GetTicks() - timej;
; 5403 : 
; 5404 : 			//ang=1000;
; 5405 : 			/*
; 5406 : 			ang/=10;
; 5407 : 
; 5408 : 			tmp=cos((ang*pi)/180);
; 5409 : 			tmp=mCos(ang*10);
; 5410 : 	*/
; 5411 : 			ax = (float) 1/(16384.0f  / 2.0f);
; 5412 : 			ay=(float) 1/(9216.0f / 2.0f);
; 5413 : 
; 5414 : 			ay*=-1.0f;
; 5415 : 
; 5416 : 			az=(float) 1/(4096/2);
; 5417 : 
; 5418 : 			if(data.vb_id==-1)

	jne	SHORT $LN11@DrawUI

; 5419 : 			{
; 5420 : 				ent[i].texcor[0]=x1;
; 5421 : 				ent[i].texcor[1]=y1;
; 5422 : 				ent[i].texcor[2]=x2;

	movd	xmm0, DWORD PTR _x2$[ebp]
	movd	xmm2, DWORD PTR _x1$[ebp]
	movd	xmm1, DWORD PTR _y1$[ebp]
	cvtdq2ps xmm0, xmm0
	cvtdq2ps xmm2, xmm2
	movss	DWORD PTR _ent[ebx+156], xmm0

; 5423 : 				ent[i].texcor[3]=y1;
; 5424 : 				ent[i].texcor[4]=x2;

	movss	DWORD PTR _ent[ebx+164], xmm0
	movd	xmm0, DWORD PTR _y2$[ebp]
	cvtdq2ps xmm1, xmm1

; 5425 : 				ent[i].texcor[5]=y2;

	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _ent[ebx+148], xmm2
	movss	DWORD PTR _ent[ebx+152], xmm1
	movss	DWORD PTR _ent[ebx+160], xmm1
	movss	DWORD PTR _ent[ebx+168], xmm0

; 5426 : 				ent[i].texcor[6]=x1;

	movss	DWORD PTR _ent[ebx+172], xmm2

; 5427 : 				ent[i].texcor[7]=y2;

	movss	DWORD PTR _ent[ebx+176], xmm0

; 5428 : 			}
; 5429 : 			else

	jmp	$LN10@DrawUI
$LN11@DrawUI:

; 5430 : 			{
; 5431 : 				tx1=(float) x1/32768;
; 5432 : 				ty1=(float) y1/32768;
; 5433 : 				tx2=(float) x2/32768;
; 5434 : 				ty2=(float) y2/32768;
; 5435 : 
; 5436 : 				ent[i].texcor[0]=data.posx+(tx1*data.sizex);

	mov	ecx, DWORD PTR _data$[ebp+16]
	mov	eax, ecx
	movd	xmm0, DWORD PTR _x1$[ebp]
	movd	xmm3, DWORD PTR _y1$[ebp]
	movd	xmm5, DWORD PTR _x2$[ebp]
	movd	xmm1, DWORD PTR _y2$[ebp]
	shr	eax, 16					; 00000010H
	cvtdq2ps xmm0, xmm0
	movd	xmm6, eax
	mov	eax, DWORD PTR _data$[ebp+12]
	shr	eax, 16					; 00000010H
	cvtdq2ps xmm1, xmm1
	mulss	xmm0, xmm4
	cvtdq2ps xmm3, xmm3
	cvtdq2ps xmm5, xmm5
	mulss	xmm1, xmm4
	movd	xmm2, eax

; 5437 : 				ent[i].texcor[1]=data.posy+(ty1*data.sizey);

	movzx	eax, WORD PTR _data$[ebp+20]
	mulss	xmm3, xmm4
	mulss	xmm5, xmm4
	cvtdq2ps xmm6, xmm6
	movd	xmm4, eax
	cvtdq2ps xmm4, xmm4
	movzx	eax, cx
	movss	DWORD PTR _ty2$1$[ebp], xmm1
	movaps	xmm7, xmm6
	mulss	xmm7, xmm0
	movaps	xmm0, xmm4

; 5438 : 
; 5439 : 				ent[i].texcor[2]=data.posx+(tx2*data.sizex);
; 5440 : 				ent[i].texcor[3]=data.posy+(ty1*data.sizey);
; 5441 : 
; 5442 : 				ent[i].texcor[4]=data.posx+(tx2*data.sizex);
; 5443 : 				ent[i].texcor[5]=data.posy+(ty2*data.sizey);

	mulss	xmm4, DWORD PTR _ty2$1$[ebp]
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	cvtdq2ps xmm2, xmm2
	mulss	xmm0, xmm3
	addss	xmm4, xmm1
	movss	xmm3, DWORD PTR __real@3f800000
	addss	xmm7, xmm2
	mulss	xmm6, xmm5
	addss	xmm0, xmm1
	movss	DWORD PTR _ent[ebx+168], xmm4

; 5444 : 
; 5445 : 				ent[i].texcor[6]=data.posx+(tx1*data.sizex);
; 5446 : 				ent[i].texcor[7]=data.posy+(ty2*data.sizey);

	movss	DWORD PTR _ent[ebx+176], xmm4
	movss	xmm4, DWORD PTR __real@38000000
	addss	xmm6, xmm2
	movss	DWORD PTR _ent[ebx+148], xmm7
	movss	DWORD PTR _ent[ebx+172], xmm7
	movss	DWORD PTR _ent[ebx+152], xmm0
	movss	DWORD PTR _ent[ebx+160], xmm0
	movss	DWORD PTR _ent[ebx+156], xmm6
	movss	DWORD PTR _ent[ebx+164], xmm6
$LN10@DrawUI:

; 5447 : 			}
; 5448 : 
; 5449 : 			for(j=0;j<12;j+=3)

	movss	xmm2, DWORD PTR __real@39000000
	xor	eax, eax
	movss	xmm5, DWORD PTR __real@39638e39
	movss	xmm6, DWORD PTR __real@3a000000
$LL9@DrawUI:

; 5450 : 			{
; 5451 : 				ent[i].vertex[j]*=ax;

	movss	xmm0, DWORD PTR [edi-4]

; 5452 : 				ent[i].vertex[j]-=1;
; 5453 : 
; 5454 : 		 		ent[i].vertex[j+1]*=ay;

	movss	xmm1, DWORD PTR [edi]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm5
	subss	xmm0, xmm3
	movss	DWORD PTR [edi-4], xmm0

; 5455 : 				ent[i].vertex[j+1]+=1;

	movaps	xmm0, xmm3
	subss	xmm0, xmm1
	movss	DWORD PTR [edi], xmm0

; 5456 : 				
; 5457 : 				ent[i].vertex[j+2]*=az;

	movss	xmm0, DWORD PTR [edi+4]
	mulss	xmm0, xmm6

; 5458 : 				ent[i].vertex[j+2]-=1;

	subss	xmm0, xmm3
	movss	DWORD PTR [edi+4], xmm0

; 5459 : 				
; 5460 : 				if(j<8)

	cmp	eax, 8
	jae	SHORT $LN8@DrawUI

; 5461 : 				{
; 5462 : 					ent[i].texcor[j]/=(float)32768;

	movss	xmm0, DWORD PTR [edi+44]
	mulss	xmm0, xmm4
	movss	DWORD PTR [edi+44], xmm0

; 5463 : 					ent[i].texcor[j+1]/=(float)32768;

	movss	xmm0, DWORD PTR [edi+48]
	mulss	xmm0, xmm4
	movss	DWORD PTR [edi+48], xmm0

; 5464 : 					ent[i].texcor[j+2]/=(float)32768;

	movss	xmm0, DWORD PTR [edi+52]
	mulss	xmm0, xmm4
	movss	DWORD PTR [edi+52], xmm0
$LN8@DrawUI:

; 5447 : 			}
; 5448 : 
; 5449 : 			for(j=0;j<12;j+=3)

	add	eax, 3
	add	edi, 12					; 0000000cH
	cmp	eax, 12					; 0000000cH
	jb	SHORT $LL9@DrawUI

; 5465 : 				}
; 5466 : 				
; 5467 : 			}
; 5468 : 
; 5469 : 			for(j=0;j<16;j+=4)

	mov	cl, BYTE PTR _a$[ebp]
	xor	eax, eax
	mov	dl, BYTE PTR _b$1$[ebp]
	mov	ch, BYTE PTR _g$1$[ebp]
	mov	dh, BYTE PTR _r$[ebp]
	npad	1
$LL5@DrawUI:

; 5470 : 			{
; 5471 : 				ent[i].color[j]=r;

	mov	BYTE PTR _ent[ebx+eax+228], dh

; 5472 : 				ent[i].color[j+1]=g;

	mov	BYTE PTR _ent[ebx+eax+229], ch

; 5473 : 				ent[i].color[j+2]=b;

	mov	BYTE PTR _ent[ebx+eax+230], dl

; 5474 : 				ent[i].color[j+3]=a;

	mov	BYTE PTR _ent[ebx+eax+231], cl
	add	eax, 4
	cmp	eax, 16					; 00000010H
	jb	SHORT $LL5@DrawUI

; 5475 : 			}
; 5476 : 
; 5477 : 			if(data.vb_id!=-1)

	mov	ax, WORD PTR _data$[ebp+10]
	cmp	ax, -1
	je	SHORT $LN2@DrawUI

; 5478 : 			{
; 5479 : 				vbdt[data.vb_id].num_elements++;

	mov	ecx, DWORD PTR _vbdt
	cwde
	shl	eax, 6
	pop	edi
	inc	WORD PTR [eax+ecx+46]

; 5480 : 				ent[i].data.loc=vbdt[data.vb_id].num_elements-1;

	mov	eax, DWORD PTR _data$[ebp+10]
	cwde
	shl	eax, 6
	mov	ax, WORD PTR [eax+ecx+46]

; 5485 : 				texone_num++;
; 5486 : 			}
; 5487 : 
; 5488 : #endif
; 5489 : 
; 5490 : 			st.num_entities++;

	inc	DWORD PTR _st+244
	dec	ax
	mov	WORD PTR _ent[ebx+56], ax

; 5491 : 
; 5492 : 	return 0;

	xor	al, al
	pop	ebx
	pop	esi

; 5493 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@DrawUI:

; 5481 : 			}
; 5482 : 			else
; 5483 : 			{
; 5484 : 				texone_ids[texone_num]=i;

	mov	cx, WORD PTR _texone_num
	mov	edx, DWORD PTR _st+244

; 5485 : 				texone_num++;
; 5486 : 			}
; 5487 : 
; 5488 : #endif
; 5489 : 
; 5490 : 			st.num_entities++;

	inc	DWORD PTR _st+244
	movzx	eax, cx
	inc	cx
	pop	edi
	pop	ebx
	mov	WORD PTR _texone_num, cx
	mov	WORD PTR _texone_ids[eax*2], dx

; 5491 : 
; 5492 : 	return 0;

	xor	al, al
	pop	esi

; 5493 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DrawUI	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawLine
_TEXT	SEGMENT
tv2420 = -48						; size = 8
tv2417 = -48						; size = 8
_linewidth$2$ = -44					; size = 4
_ang2$ = -44						; size = 4
_ty2$ = -44						; size = 4
_tx2$ = -44						; size = 4
_ty1$ = -44						; size = 4
_tx1$ = -44						; size = 4
_i$1$ = -36						; size = 4
_ty2$1$ = -32						; size = 4
_tx2$1$ = -28						; size = 4
_ty1$1$ = -24						; size = 4
_tx1$1$ = -20						; size = 4
_y2$2$ = -16						; size = 4
_linewidth$1$ = -12					; size = 4
_x2$2$ = -8						; size = 4
_y$1$ = -4						; size = 4
_x2$ = 8						; size = 4
_y2$ = 12						; size = 4
_r$ = 16						; size = 1
_g$ = 20						; size = 1
_b$ = 24						; size = 1
_a$ = 28						; size = 1
_linewidth$ = 32					; size = 2
_z$ = 36						; size = 4
_DrawLine PROC						; COMDAT
; _x$ = ecx
; _y$ = edx

; 5869 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _y$1$[ebp], edx

; 5870 : 	uint8 valx=0, valy=0;
; 5871 : 
; 5872 : 	uint16 i=0, j=0, k=0;
; 5873 : 
; 5874 : 	int32 x3, y3;
; 5875 : 
; 5876 : 	uint32 a1;
; 5877 : 
; 5878 : 	int16 ang;
; 5879 : 
; 5880 : 	float ax=1/(GAME_WIDTH/2), ay=1/(9216.0f/2), az=1/(4096/2), ang2, tx1, ty1, tx2, ty2;
; 5881 : 
; 5882 : 	i=st.num_entities;

	mov	ecx, DWORD PTR _st+244

; 5883 : 
; 5884 : 	if(i==MAX_GRAPHICS-1 && ent[i].stat==USED)

	mov	edx, 2047				; 000007ffH
	movzx	eax, cx
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	ax, dx
	jne	SHORT $LN12@DrawLine
	cmp	DWORD PTR _ent+540448, 1
	jne	SHORT $LN12@DrawLine

; 5885 : 		return 2;

	mov	al, 2

; 6043 : 	//}
; 6044 : 
; 6045 : 	return 0;
; 6046 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@DrawLine:

; 5886 : 
; 5887 : 	//if(ent[i].stat==DEAD)
; 5888 : 	//{
; 5889 : 		ent[i].stat=USED;
; 5890 : 		st.num_entities++;
; 5891 : 		ent[i].data.data=DataNT;
; 5892 : 		ent[i].data.vb_id=-1;
; 5893 : 		ent[i].data.channel=0;
; 5894 : 		ent[i].data.normal=0;
; 5895 : 		ent[i].lightmapid=-1;
; 5896 : 
; 5897 : 		if(z>56) z=56;

	mov	ebx, DWORD PTR _z$[ebp]
	inc	ecx
	movzx	eax, ax
	imul	esi, eax, 264
	mov	eax, DWORD PTR _DataNT

; 5898 : 		//else if(z<16) z+=16;
; 5899 : 
; 5900 : 		z_buffer[z][z_slot[z]]=i;
; 5901 : 		z_slot[z]++;
; 5902 : 
; 5903 : 		if(z>z_used) z_used=z;
; 5904 : 		
; 5905 : 		if(z>15)

	movss	xmm2, DWORD PTR _st+2335400
	movss	xmm1, DWORD PTR _st+2335396
	mov	DWORD PTR _st+244, ecx
	mov	DWORD PTR _ent[esi+44], eax
	or	eax, -1
	mov	WORD PTR _ent[esi+54], ax
	mov	WORD PTR _ent[esi+260], ax
	mov	eax, 56					; 00000038H
	cmp	ebx, eax
	mov	DWORD PTR _ent[esi+40], 1
	mov	DWORD PTR _ent[esi+76], 0
	cmovg	ebx, eax
	mov	BYTE PTR _ent[esi+52], 0
	mov	ecx, ebx
	shl	ecx, 11					; 0000000bH
	movzx	edx, WORD PTR _z_slot[ebx*2]
	movsx	eax, dx
	add	ecx, eax
	mov	eax, DWORD PTR _i$1$[ebp]
	mov	WORD PTR _z_buffer[ecx*2], ax
	lea	eax, DWORD PTR [edx+1]
	movsx	ecx, BYTE PTR _z_used
	movzx	edx, BYTE PTR _z_used
	cmp	ebx, ecx

; 5908 : 			ty1=y;
; 5909 : 			tx2=x2;
; 5910 : 			ty2=y2;

	mov	ecx, DWORD PTR _y2$[ebp]
	mov	WORD PTR _z_slot[ebx*2], ax
	movzx	eax, bl
	cmovg	edx, eax
	mov	eax, DWORD PTR _x2$[ebp]
	mov	BYTE PTR _z_used, dl
	mov	edx, DWORD PTR _y$1$[ebp]
	cmp	ebx, 15					; 0000000fH
	jle	$LN111@DrawLine

; 5906 : 		{
; 5907 : 			tx1=x;

	movd	xmm0, edi
	cvtdq2ps xmm0, xmm0

; 5911 : 
; 5912 : 			x-=st.Camera.position.x;

	sub	edi, DWORD PTR _st+2335380
	movss	DWORD PTR _tx1$1$[ebp], xmm0
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0

; 5913 : 			y-=st.Camera.position.y;

	sub	edx, DWORD PTR _st+2335384
	movss	DWORD PTR _ty1$1$[ebp], xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0

; 5914 : 
; 5915 : 			x2-=st.Camera.position.x;

	sub	eax, DWORD PTR _st+2335380
	movss	DWORD PTR _tx2$1$[ebp], xmm0
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0

; 5916 : 			y2-=st.Camera.position.y;

	sub	ecx, DWORD PTR _st+2335384
	movss	DWORD PTR _ty2$1$[ebp], xmm0
	movd	xmm0, edi

; 5917 : 
; 5918 : 			x*=st.Camera.dimension.x;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	cvttss2si edi, xmm0
	movd	xmm0, edx

; 5919 : 			y*=st.Camera.dimension.y;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	cvttss2si edx, xmm0
	movd	xmm0, eax

; 5920 : 
; 5921 : 			x2*=st.Camera.dimension.x;

	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR _y$1$[ebp], edx
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	movd	xmm0, ecx

; 5922 : 			y2*=st.Camera.dimension.y;

	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR _x2$2$[ebp], eax

; 5923 : 
; 5924 : 			linewidth*=st.Camera.dimension.x;

	mov	eax, DWORD PTR _linewidth$[ebp]
	cwde
	mulss	xmm0, xmm2
	cvttss2si ecx, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	movzx	eax, ax
	jmp	SHORT $LN112@DrawLine
$LN111@DrawLine:
	movss	xmm0, DWORD PTR _tx1$[ebp]
	movss	DWORD PTR _tx1$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _ty1$[ebp]
	movss	DWORD PTR _ty1$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _tx2$[ebp]
	movss	DWORD PTR _tx2$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _ty2$[ebp]
	mov	DWORD PTR _x2$2$[ebp], eax
	mov	eax, DWORD PTR _linewidth$[ebp]
	movss	DWORD PTR _ty2$1$[ebp], xmm0
$LN112@DrawLine:
	mov	DWORD PTR _linewidth$1$[ebp], eax

; 5925 : 		}
; 5926 : 		
; 5927 : 		x3=x2-x;
; 5928 : 		y3=y2-y;

	mov	eax, ecx
	sub	eax, edx
	mov	DWORD PTR _y2$2$[ebp], ecx
	movd	xmm0, eax
	mov	eax, DWORD PTR _x2$2$[ebp]

; 5929 : 
; 5930 : 		ang2=atan2((float)y3,(float)x3);

	cvtdq2ps xmm0, xmm0
	sub	eax, edi
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv2420[ebp], xmm0
	fld	QWORD PTR tv2420[ebp]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv2417[ebp], xmm0
	fld	QWORD PTR tv2417[ebp]
	call	__CIatan2

; 5931 : 		if(ang2==pi)

	movsd	xmm2, QWORD PTR __real@400921fb53c8d4f1
	fstp	DWORD PTR _ang2$[ebp]
	movss	xmm1, DWORD PTR _ang2$[ebp]
	cvtps2pd xmm0, xmm1
	ucomisd	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@DrawLine
	xorps	xmm1, xmm1
$LN8@DrawLine:

; 5932 : 			ang2=0;
; 5933 : 		ang2+=pi;

	cvtps2pd xmm0, xmm1
	addsd	xmm0, xmm2
	cvtpd2ps xmm0, xmm0

; 5934 : 		ang2=(180/pi)*ang2;

	cvtps2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@404ca5dc1af05a77
	cvtpd2ps xmm0, xmm0

; 5935 : 		ang=ang2;

	cvttss2si ecx, xmm0

; 5936 : 		ang*=10;

	mov	ax, cx
	shl	cx, 2
	add	ax, cx
	add	ax, ax
	movzx	ecx, ax

; 5937 : 
; 5938 : 		linewidth/=2;

	mov	eax, DWORD PTR _linewidth$1$[ebp]
	cwde
	cdq
	sub	eax, edx
	sar	eax, 1
	movzx	edx, ax

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	eax, 3600				; 00000e10H

; 5937 : 
; 5938 : 		linewidth/=2;

	mov	DWORD PTR _linewidth$2$[ebp], edx

; 5939 : 		
; 5940 : 		ent[i].vertex[0]=(float) x-(linewidth*mSin(ang));

	mov	edx, ecx

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	cx, ax
	jle	SHORT $LN17@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN113@DrawLine
$LN17@DrawLine:

; 226  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN15@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN113@DrawLine:
	movzx	edx, ax
$LN15@DrawLine:

; 5939 : 		
; 5940 : 		ent[i].vertex[0]=(float) x-(linewidth*mSin(ang));

	mov	eax, DWORD PTR _linewidth$2$[ebp]
	cwde
	movd	xmm6, edi

; 207  : }
; 208  : 
; 209  : void _inline WTScf(float *x, float *y)
; 210  : {
; 211  : 	*x=(float) ((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;
; 212  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;
; 213  : }
; 214  : 
; 215  : float mCos(int16 ang)
; 216  : {
; 217  : 	if(ang>3600) ang-=3600;

	mov	edi, 3600				; 00000e10H

; 5939 : 		
; 5940 : 		ent[i].vertex[0]=(float) x-(linewidth*mSin(ang));

	cvtdq2ps xmm6, xmm6
	movd	xmm2, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	movsx	eax, dx

; 5939 : 		
; 5940 : 		ent[i].vertex[0]=(float) x-(linewidth*mSin(ang));

	movaps	xmm0, xmm6
	cvtdq2ps xmm2, xmm2
	movss	xmm1, DWORD PTR _st[eax*4+2732212]

; 5941 : 		ent[i].vertex[1]=(float) y+(linewidth*mCos(ang));

	mov	eax, ecx
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR _ent[esi+100], xmm0

; 207  : }
; 208  : 
; 209  : void _inline WTScf(float *x, float *y)
; 210  : {
; 211  : 	*x=(float) ((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;
; 212  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;
; 213  : }
; 214  : 
; 215  : float mCos(int16 ang)
; 216  : {
; 217  : 	if(ang>3600) ang-=3600;

	cmp	cx, di
	jle	SHORT $LN22@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN114@DrawLine
$LN22@DrawLine:

; 218  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN20@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN114@DrawLine:
	movzx	eax, ax
$LN20@DrawLine:
	movd	xmm3, DWORD PTR _y$1$[ebp]

; 5941 : 		ent[i].vertex[1]=(float) y+(linewidth*mCos(ang));

	lea	edx, DWORD PTR _ent[esi+104]

; 219  : 
; 220  : 	return st.CosTable[ang];

	cwde
	movd	xmm4, ebx

; 5941 : 		ent[i].vertex[1]=(float) y+(linewidth*mCos(ang));

	cvtdq2ps xmm3, xmm3
	movss	xmm0, DWORD PTR _st[eax*4+2717808]

; 5942 : 		ent[i].vertex[2]=z;
; 5943 : 
; 5944 : 		ent[i].vertex[3]=(float) x2-(linewidth*mSin(ang));

	mov	eax, ecx
	mulss	xmm0, xmm2
	cvtdq2ps xmm4, xmm4
	addss	xmm0, xmm3
	movss	DWORD PTR _ent[esi+108], xmm4
	movss	DWORD PTR [edx], xmm0

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	cx, di
	jle	SHORT $LN27@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN115@DrawLine
$LN27@DrawLine:

; 226  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN25@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN115@DrawLine:
	movzx	eax, ax
$LN25@DrawLine:
	movd	xmm5, DWORD PTR _x2$2$[ebp]

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 5942 : 		ent[i].vertex[2]=z;
; 5943 : 
; 5944 : 		ent[i].vertex[3]=(float) x2-(linewidth*mSin(ang));

	cvtdq2ps xmm5, xmm5
	movss	xmm1, DWORD PTR _st[eax*4+2732212]

; 5945 : 		ent[i].vertex[4]=(float) y2+(linewidth*mCos(ang));

	mov	eax, ecx
	mulss	xmm1, xmm2
	movaps	xmm0, xmm5
	subss	xmm0, xmm1
	movss	DWORD PTR _ent[esi+112], xmm0

; 207  : }
; 208  : 
; 209  : void _inline WTScf(float *x, float *y)
; 210  : {
; 211  : 	*x=(float) ((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;
; 212  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;
; 213  : }
; 214  : 
; 215  : float mCos(int16 ang)
; 216  : {
; 217  : 	if(ang>3600) ang-=3600;

	cmp	cx, di
	jle	SHORT $LN32@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN116@DrawLine
$LN32@DrawLine:

; 218  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN30@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN116@DrawLine:
	movzx	eax, ax
$LN30@DrawLine:
	movd	xmm1, DWORD PTR _y2$2$[ebp]

; 219  : 
; 220  : 	return st.CosTable[ang];

	cwde

; 5946 : 		ent[i].vertex[5]=z;

	movss	DWORD PTR _ent[esi+120], xmm4
	cvtdq2ps xmm1, xmm1
	movss	xmm0, DWORD PTR _st[eax*4+2717808]

; 5947 : 
; 5948 : 		ent[i].vertex[6]=(float) x2+(linewidth*mSin(ang));

	mov	eax, ecx
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	movss	DWORD PTR _ent[esi+116], xmm0

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	cx, di
	jle	SHORT $LN37@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN117@DrawLine
$LN37@DrawLine:

; 226  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN35@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN117@DrawLine:
	movzx	eax, ax
$LN35@DrawLine:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 5947 : 
; 5948 : 		ent[i].vertex[6]=(float) x2+(linewidth*mSin(ang));

	movss	xmm0, DWORD PTR _st[eax*4+2732212]

; 5949 : 		ent[i].vertex[7]=(float) y2-(linewidth*mCos(ang));

	mov	eax, ecx
	mulss	xmm0, xmm2
	addss	xmm0, xmm5
	movss	DWORD PTR _ent[esi+124], xmm0

; 207  : }
; 208  : 
; 209  : void _inline WTScf(float *x, float *y)
; 210  : {
; 211  : 	*x=(float) ((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;
; 212  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;
; 213  : }
; 214  : 
; 215  : float mCos(int16 ang)
; 216  : {
; 217  : 	if(ang>3600) ang-=3600;

	cmp	cx, di
	jle	SHORT $LN42@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN118@DrawLine
$LN42@DrawLine:

; 218  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN40@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN118@DrawLine:
	movzx	eax, ax
$LN40@DrawLine:

; 219  : 
; 220  : 	return st.CosTable[ang];

	cwde

; 5950 : 		ent[i].vertex[8]=z;

	movss	DWORD PTR _ent[esi+132], xmm4
	movss	xmm0, DWORD PTR _st[eax*4+2717808]

; 5951 : 
; 5952 : 		ent[i].vertex[9]=(float) x+(linewidth*mSin(ang));

	mov	eax, ecx
	mulss	xmm0, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR _ent[esi+128], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	cx, di
	jle	SHORT $LN47@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN119@DrawLine
$LN47@DrawLine:

; 226  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN45@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN119@DrawLine:
	movzx	eax, ax
$LN45@DrawLine:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 5951 : 
; 5952 : 		ent[i].vertex[9]=(float) x+(linewidth*mSin(ang));

	movss	xmm0, DWORD PTR _st[eax*4+2732212]

; 5953 : 		ent[i].vertex[10]=(float) y-(linewidth*mCos(ang));

	mov	eax, ecx
	mulss	xmm0, xmm2
	addss	xmm0, xmm6
	movss	DWORD PTR _ent[esi+136], xmm0

; 207  : }
; 208  : 
; 209  : void _inline WTScf(float *x, float *y)
; 210  : {
; 211  : 	*x=(float) ((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;
; 212  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;
; 213  : }
; 214  : 
; 215  : float mCos(int16 ang)
; 216  : {
; 217  : 	if(ang>3600) ang-=3600;

	cmp	cx, di
	jle	SHORT $LN52@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN120@DrawLine
$LN52@DrawLine:

; 218  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN50@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN120@DrawLine:
	movzx	eax, ax
$LN50@DrawLine:

; 219  : 
; 220  : 	return st.CosTable[ang];

	cwde

; 5954 : 		ent[i].vertex[11]=z;

	movss	DWORD PTR _ent[esi+144], xmm4
	movss	xmm0, DWORD PTR _st[eax*4+2717808]
	mulss	xmm0, xmm2
	subss	xmm3, xmm0
	movss	DWORD PTR _ent[esi+140], xmm3

; 5955 : 
; 5956 : 		ax=(float) 1/(GAME_WIDTH/2);
; 5957 : 		ay=(float) 1/(9216.0f/2);
; 5958 : 
; 5959 : 		ay*=-1.0f;
; 5960 : 
; 5961 : 		az=(float) 1/(4096/2);
; 5962 : 		
; 5963 : 		if(z>15)

	cmp	ebx, 15					; 0000000fH
	jle	$LN7@DrawLine

; 5964 : 		{
; 5965 : 			/*
; 5966 : 			ent[i].texcorlight[0]=(float)tx1+(((tx1-(tx2/2))-tx1)*mCos(ang) - ((ty1-(ty2/2))-ty1)*mSin(ang));
; 5967 : 			ent[i].texcorlight[1]=(float)ty1+(((tx1-(tx2/2))-tx1)*mSin(ang) + ((ty1-(ty2/2))-ty1)*mCos(ang));
; 5968 : 
; 5969 : 			ent[i].texcorlight[2]=(float)tx1+(((tx1+(tx2/2))-tx1)*mCos(ang) - ((ty1-(ty2/2))-ty1)*mSin(ang));
; 5970 : 			ent[i].texcorlight[3]=(float)ty1+(((tx1+(tx2/2))-tx1)*mSin(ang) + ((ty1-(ty2/2))-ty1)*mCos(ang));
; 5971 : 
; 5972 : 			ent[i].texcorlight[4]=(float)tx1+(((tx1+(tx2/2))-tx1)*mCos(ang) - ((ty1+(ty2/2))-ty1)*mSin(ang));
; 5973 : 			ent[i].texcorlight[5]=(float)ty1+(((tx1+(tx2/2))-tx1)*mSin(ang) + ((ty1+(ty2/2))-ty1)*mCos(ang));
; 5974 : 
; 5975 : 			ent[i].texcorlight[6]=(float)tx1+(((tx1-(tx2/2))-tx1)*mCos(ang) - ((ty1+(ty2/2))-ty1)*mSin(ang));
; 5976 : 			ent[i].texcorlight[7]=(float)ty1+(((tx1-(tx2/2))-tx1)*mSin(ang) + ((ty1+(ty2/2))-ty1)*mCos(ang));
; 5977 : 			*/
; 5978 : 		
; 5979 : 			ent[i].texcorlight[0]=(float) tx1-(linewidth*mSin(ang));

	mov	eax, ecx

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	cx, di
	jle	SHORT $LN57@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN121@DrawLine
$LN57@DrawLine:

; 226  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN55@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN121@DrawLine:
	movzx	eax, ax
$LN55@DrawLine:

; 5964 : 		{
; 5965 : 			/*
; 5966 : 			ent[i].texcorlight[0]=(float)tx1+(((tx1-(tx2/2))-tx1)*mCos(ang) - ((ty1-(ty2/2))-ty1)*mSin(ang));
; 5967 : 			ent[i].texcorlight[1]=(float)ty1+(((tx1-(tx2/2))-tx1)*mSin(ang) + ((ty1-(ty2/2))-ty1)*mCos(ang));
; 5968 : 
; 5969 : 			ent[i].texcorlight[2]=(float)tx1+(((tx1+(tx2/2))-tx1)*mCos(ang) - ((ty1-(ty2/2))-ty1)*mSin(ang));
; 5970 : 			ent[i].texcorlight[3]=(float)ty1+(((tx1+(tx2/2))-tx1)*mSin(ang) + ((ty1-(ty2/2))-ty1)*mCos(ang));
; 5971 : 
; 5972 : 			ent[i].texcorlight[4]=(float)tx1+(((tx1+(tx2/2))-tx1)*mCos(ang) - ((ty1+(ty2/2))-ty1)*mSin(ang));
; 5973 : 			ent[i].texcorlight[5]=(float)ty1+(((tx1+(tx2/2))-tx1)*mSin(ang) + ((ty1+(ty2/2))-ty1)*mCos(ang));
; 5974 : 
; 5975 : 			ent[i].texcorlight[6]=(float)tx1+(((tx1-(tx2/2))-tx1)*mCos(ang) - ((ty1+(ty2/2))-ty1)*mSin(ang));
; 5976 : 			ent[i].texcorlight[7]=(float)ty1+(((tx1-(tx2/2))-tx1)*mSin(ang) + ((ty1+(ty2/2))-ty1)*mCos(ang));
; 5977 : 			*/
; 5978 : 		
; 5979 : 			ent[i].texcorlight[0]=(float) tx1-(linewidth*mSin(ang));

	movss	xmm4, DWORD PTR _tx1$1$[ebp]

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 5964 : 		{
; 5965 : 			/*
; 5966 : 			ent[i].texcorlight[0]=(float)tx1+(((tx1-(tx2/2))-tx1)*mCos(ang) - ((ty1-(ty2/2))-ty1)*mSin(ang));
; 5967 : 			ent[i].texcorlight[1]=(float)ty1+(((tx1-(tx2/2))-tx1)*mSin(ang) + ((ty1-(ty2/2))-ty1)*mCos(ang));
; 5968 : 
; 5969 : 			ent[i].texcorlight[2]=(float)tx1+(((tx1+(tx2/2))-tx1)*mCos(ang) - ((ty1-(ty2/2))-ty1)*mSin(ang));
; 5970 : 			ent[i].texcorlight[3]=(float)ty1+(((tx1+(tx2/2))-tx1)*mSin(ang) + ((ty1-(ty2/2))-ty1)*mCos(ang));
; 5971 : 
; 5972 : 			ent[i].texcorlight[4]=(float)tx1+(((tx1+(tx2/2))-tx1)*mCos(ang) - ((ty1+(ty2/2))-ty1)*mSin(ang));
; 5973 : 			ent[i].texcorlight[5]=(float)ty1+(((tx1+(tx2/2))-tx1)*mSin(ang) + ((ty1+(ty2/2))-ty1)*mCos(ang));
; 5974 : 
; 5975 : 			ent[i].texcorlight[6]=(float)tx1+(((tx1-(tx2/2))-tx1)*mCos(ang) - ((ty1+(ty2/2))-ty1)*mSin(ang));
; 5976 : 			ent[i].texcorlight[7]=(float)ty1+(((tx1-(tx2/2))-tx1)*mSin(ang) + ((ty1+(ty2/2))-ty1)*mCos(ang));
; 5977 : 			*/
; 5978 : 		
; 5979 : 			ent[i].texcorlight[0]=(float) tx1-(linewidth*mSin(ang));

	movaps	xmm0, xmm4
	movss	xmm1, DWORD PTR _st[eax*4+2732212]

; 5980 : 			ent[i].texcorlight[1]=(float) ty1+(linewidth*mCos(ang));

	mov	eax, ecx
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR _ent[esi+180], xmm0

; 207  : }
; 208  : 
; 209  : void _inline WTScf(float *x, float *y)
; 210  : {
; 211  : 	*x=(float) ((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;
; 212  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;
; 213  : }
; 214  : 
; 215  : float mCos(int16 ang)
; 216  : {
; 217  : 	if(ang>3600) ang-=3600;

	cmp	cx, di
	jle	SHORT $LN62@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN122@DrawLine
$LN62@DrawLine:

; 218  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN60@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN122@DrawLine:
	movzx	eax, ax
$LN60@DrawLine:

; 5980 : 			ent[i].texcorlight[1]=(float) ty1+(linewidth*mCos(ang));

	movss	xmm5, DWORD PTR _ty1$1$[ebp]

; 219  : 
; 220  : 	return st.CosTable[ang];

	cwde

; 5980 : 			ent[i].texcorlight[1]=(float) ty1+(linewidth*mCos(ang));

	movss	xmm0, DWORD PTR _st[eax*4+2717808]

; 5981 : 
; 5982 : 			ent[i].texcorlight[2]=(float) tx2-(linewidth*mSin(ang));

	mov	eax, ecx
	mulss	xmm0, xmm2
	addss	xmm0, xmm5
	movss	DWORD PTR _ent[esi+184], xmm0

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	cx, di
	jle	SHORT $LN67@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN123@DrawLine
$LN67@DrawLine:

; 226  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN65@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN123@DrawLine:
	movzx	eax, ax
$LN65@DrawLine:

; 5981 : 
; 5982 : 			ent[i].texcorlight[2]=(float) tx2-(linewidth*mSin(ang));

	movss	xmm3, DWORD PTR _tx2$1$[ebp]

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 5981 : 
; 5982 : 			ent[i].texcorlight[2]=(float) tx2-(linewidth*mSin(ang));

	movaps	xmm0, xmm3
	movss	xmm1, DWORD PTR _st[eax*4+2732212]

; 5983 : 			ent[i].texcorlight[3]=(float) ty2+(linewidth*mCos(ang));

	mov	eax, ecx
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR _ent[esi+188], xmm0

; 207  : }
; 208  : 
; 209  : void _inline WTScf(float *x, float *y)
; 210  : {
; 211  : 	*x=(float) ((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;
; 212  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;
; 213  : }
; 214  : 
; 215  : float mCos(int16 ang)
; 216  : {
; 217  : 	if(ang>3600) ang-=3600;

	cmp	cx, di
	jle	SHORT $LN72@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN124@DrawLine
$LN72@DrawLine:

; 218  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN70@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN124@DrawLine:
	movzx	eax, ax
$LN70@DrawLine:

; 5983 : 			ent[i].texcorlight[3]=(float) ty2+(linewidth*mCos(ang));

	movss	xmm1, DWORD PTR _ty2$1$[ebp]

; 219  : 
; 220  : 	return st.CosTable[ang];

	cwde

; 5983 : 			ent[i].texcorlight[3]=(float) ty2+(linewidth*mCos(ang));

	movss	xmm0, DWORD PTR _st[eax*4+2717808]

; 5984 : 
; 5985 : 			ent[i].texcorlight[4]=(float) tx2+(linewidth*mSin(ang));

	mov	eax, ecx
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	movss	DWORD PTR _ent[esi+192], xmm0

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	cx, di
	jle	SHORT $LN77@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN125@DrawLine
$LN77@DrawLine:

; 226  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN75@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN125@DrawLine:
	movzx	eax, ax
$LN75@DrawLine:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 5984 : 
; 5985 : 			ent[i].texcorlight[4]=(float) tx2+(linewidth*mSin(ang));

	movss	xmm0, DWORD PTR _st[eax*4+2732212]

; 5986 : 			ent[i].texcorlight[5]=(float) ty2-(linewidth*mCos(ang));

	mov	eax, ecx
	mulss	xmm0, xmm2
	addss	xmm0, xmm3
	movss	DWORD PTR _ent[esi+196], xmm0

; 207  : }
; 208  : 
; 209  : void _inline WTScf(float *x, float *y)
; 210  : {
; 211  : 	*x=(float) ((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;
; 212  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;
; 213  : }
; 214  : 
; 215  : float mCos(int16 ang)
; 216  : {
; 217  : 	if(ang>3600) ang-=3600;

	cmp	cx, di
	jle	SHORT $LN82@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN126@DrawLine
$LN82@DrawLine:

; 218  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN80@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN126@DrawLine:
	movzx	eax, ax
$LN80@DrawLine:

; 219  : 
; 220  : 	return st.CosTable[ang];

	cwde

; 5986 : 			ent[i].texcorlight[5]=(float) ty2-(linewidth*mCos(ang));

	movss	xmm0, DWORD PTR _st[eax*4+2717808]

; 5987 : 
; 5988 : 			ent[i].texcorlight[6]=(float) tx1+(linewidth*mSin(ang));

	mov	eax, ecx
	mulss	xmm0, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR _ent[esi+200], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	cx, di
	jle	SHORT $LN87@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN127@DrawLine
$LN87@DrawLine:

; 226  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN85@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN127@DrawLine:
	movzx	eax, ax
$LN85@DrawLine:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 5987 : 
; 5988 : 			ent[i].texcorlight[6]=(float) tx1+(linewidth*mSin(ang));

	movss	xmm0, DWORD PTR _st[eax*4+2732212]

; 5989 : 			ent[i].texcorlight[7]=(float) ty1-(linewidth*mCos(ang));

	mov	eax, ecx
	mulss	xmm0, xmm2
	addss	xmm0, xmm4
	movss	DWORD PTR _ent[esi+204], xmm0

; 207  : }
; 208  : 
; 209  : void _inline WTScf(float *x, float *y)
; 210  : {
; 211  : 	*x=(float) ((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;
; 212  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;
; 213  : }
; 214  : 
; 215  : float mCos(int16 ang)
; 216  : {
; 217  : 	if(ang>3600) ang-=3600;

	cmp	cx, di
	jle	SHORT $LN92@DrawLine
	lea	eax, DWORD PTR [ecx-3600]
	jmp	SHORT $LN128@DrawLine
$LN92@DrawLine:

; 218  : 	else if(ang<0) ang+=3600;

	test	cx, cx
	jns	SHORT $LN90@DrawLine
	lea	eax, DWORD PTR [ecx+3600]
$LN128@DrawLine:
	movzx	eax, ax
$LN90@DrawLine:
	movd	xmm4, DWORD PTR _st+2335380
	movd	xmm3, DWORD PTR _st+2335384

; 219  : 
; 220  : 	return st.CosTable[ang];

	cwde

; 202  : 	*x-=st.Camera.position.x;

	cvtdq2ps xmm4, xmm4

; 5989 : 			ent[i].texcorlight[7]=(float) ty1-(linewidth*mCos(ang));

	movss	xmm0, DWORD PTR _st[eax*4+2717808]
	mulss	xmm0, xmm2

; 204  : 
; 205  : 	*x=(float) ((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;

	movzx	eax, WORD PTR _st+228
	movss	xmm2, DWORD PTR __real@38800000
	movss	xmm7, DWORD PTR _st+2335396

; 5989 : 			ent[i].texcorlight[7]=(float) ty1-(linewidth*mCos(ang));

	subss	xmm5, xmm0

; 206  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;

	movss	xmm1, DWORD PTR __real@46100000
	cvtdq2ps xmm3, xmm3

; 5989 : 			ent[i].texcorlight[7]=(float) ty1-(linewidth*mCos(ang));

	movss	DWORD PTR _ent[esi+208], xmm5

; 202  : 	*x-=st.Camera.position.x;

	movss	xmm0, DWORD PTR _ent[esi+180]
	subss	xmm0, xmm4
	movd	xmm5, eax

; 206  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;

	movzx	eax, WORD PTR _st+230
	cvtdq2ps xmm5, xmm5
	movss	DWORD PTR _ent[esi+180], xmm0
	movss	xmm0, DWORD PTR _ent[esi+184]
	subss	xmm0, xmm3
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	movss	DWORD PTR _ent[esi+184], xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR _ent[esi+180]
	mulss	xmm0, xmm2
	mulss	xmm0, xmm7
	movss	DWORD PTR _ent[esi+180], xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR _ent[esi+184]
	divss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _st+2335400
	movss	DWORD PTR _ent[esi+184], xmm0

; 202  : 	*x-=st.Camera.position.x;

	movss	xmm0, DWORD PTR _ent[esi+188]
	subss	xmm0, xmm4
	movss	DWORD PTR _ent[esi+188], xmm0

; 203  : 	*y-=st.Camera.position.y;

	movss	xmm0, DWORD PTR _ent[esi+192]
	subss	xmm0, xmm3
	movss	DWORD PTR _ent[esi+192], xmm0

; 204  : 
; 205  : 	*x=(float) ((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;

	movss	xmm0, DWORD PTR _ent[esi+188]
	mulss	xmm0, xmm5
	mulss	xmm0, xmm2
	mulss	xmm0, xmm7
	movss	DWORD PTR _ent[esi+188], xmm0

; 206  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR _ent[esi+192]
	divss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _st+2335400
	movss	DWORD PTR _ent[esi+192], xmm0

; 202  : 	*x-=st.Camera.position.x;

	movss	xmm0, DWORD PTR _ent[esi+196]
	subss	xmm0, xmm4
	movss	DWORD PTR _ent[esi+196], xmm0

; 203  : 	*y-=st.Camera.position.y;

	movss	xmm0, DWORD PTR _ent[esi+200]
	subss	xmm0, xmm3
	movss	DWORD PTR _ent[esi+200], xmm0

; 204  : 
; 205  : 	*x=(float) ((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR _ent[esi+196]
	mulss	xmm0, xmm2
	mulss	xmm0, xmm7
	movss	DWORD PTR _ent[esi+196], xmm0

; 206  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR _ent[esi+200]
	divss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _st+2335400
	movss	DWORD PTR _ent[esi+200], xmm0

; 202  : 	*x-=st.Camera.position.x;

	movss	xmm0, DWORD PTR _ent[esi+204]
	subss	xmm0, xmm4
	movss	DWORD PTR _ent[esi+204], xmm0

; 203  : 	*y-=st.Camera.position.y;

	movss	xmm0, DWORD PTR _ent[esi+208]
	subss	xmm0, xmm3
	movss	DWORD PTR _ent[esi+208], xmm0

; 204  : 
; 205  : 	*x=(float) ((*x*st.screenx)/GAME_WIDTH)*st.Camera.dimension.x;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR _ent[esi+204]
	mulss	xmm0, xmm2
	mulss	xmm0, xmm7
	movss	DWORD PTR _ent[esi+204], xmm0

; 206  : 	*y=(float) ((*y*st.screeny)/GAME_HEIGHT)*st.Camera.dimension.y;

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR _ent[esi+208]
	divss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _st+2335400
	movss	DWORD PTR _ent[esi+208], xmm0

; 5990 : 
; 5991 : 			WTSf(&ent[i].texcorlight[0],&ent[i].texcorlight[1]);
; 5992 : 			WTSf(&ent[i].texcorlight[2],&ent[i].texcorlight[3]);
; 5993 : 			WTSf(&ent[i].texcorlight[4],&ent[i].texcorlight[5]);
; 5994 : 			WTSf(&ent[i].texcorlight[6],&ent[i].texcorlight[7]);
; 5995 : 			
; 5996 : 			ent[i].texcorlight[0]/=(float) st.screenx;

	movss	xmm0, DWORD PTR _ent[esi+180]
	divss	xmm0, xmm5

; 5997 : 			ent[i].texcorlight[1]/=(float) st.screeny;
; 5998 : 			ent[i].texcorlight[2]/=(float) st.screenx;
; 5999 : 			ent[i].texcorlight[3]/=(float) st.screeny;
; 6000 : 			ent[i].texcorlight[4]/=(float) st.screenx;
; 6001 : 			ent[i].texcorlight[5]/=(float) st.screeny;
; 6002 : 			ent[i].texcorlight[6]/=(float) st.screenx;
; 6003 : 			ent[i].texcorlight[7]/=(float) st.screeny;
; 6004 : 
; 6005 : 			ent[i].texcorlight[1]*=-1;

	movss	xmm1, DWORD PTR __real@bf800000
	movss	DWORD PTR _ent[esi+180], xmm0
	movss	xmm0, DWORD PTR _ent[esi+188]
	divss	xmm0, xmm5
	movss	DWORD PTR _ent[esi+188], xmm0
	movss	xmm0, DWORD PTR _ent[esi+196]
	divss	xmm0, xmm5
	movss	DWORD PTR _ent[esi+196], xmm0
	movss	xmm0, DWORD PTR _ent[esi+204]
	divss	xmm0, xmm5
	movss	DWORD PTR _ent[esi+204], xmm0
	movss	xmm0, DWORD PTR _ent[esi+184]
	divss	xmm0, xmm6
	mulss	xmm0, xmm1
	movss	DWORD PTR _ent[esi+184], xmm0
	movss	xmm0, DWORD PTR _ent[esi+192]
	divss	xmm0, xmm6

; 6006 : 			ent[i].texcorlight[3]*=-1;

	mulss	xmm0, xmm1
	movss	DWORD PTR _ent[esi+192], xmm0
	movss	xmm0, DWORD PTR _ent[esi+200]
	divss	xmm0, xmm6

; 6007 : 			ent[i].texcorlight[5]*=-1;

	mulss	xmm0, xmm1
	movss	DWORD PTR _ent[esi+200], xmm0
	movss	xmm0, DWORD PTR _ent[esi+208]
	divss	xmm0, xmm6

; 6008 : 			ent[i].texcorlight[7]*=-1;

	mulss	xmm0, xmm1
	movss	DWORD PTR _ent[esi+208], xmm0
$LN7@DrawLine:

; 6009 : 		}
; 6010 : 
; 6011 : 		ent[i].texcor[0]=0.0f;
; 6012 : 		ent[i].texcor[1]=0.0f;
; 6013 : 		ent[i].texcor[2]=1.0f;

	movss	xmm2, DWORD PTR __real@3f800000
	mov	eax, 4
	movss	xmm3, DWORD PTR __real@39000000
	movss	xmm4, DWORD PTR __real@39638e39
	movss	xmm5, DWORD PTR __real@3a000000
	mov	DWORD PTR _ent[esi+148], 0
	mov	DWORD PTR _ent[esi+152], 0
	mov	DWORD PTR _ent[esi+156], 1065353216	; 3f800000H

; 6014 : 		ent[i].texcor[3]=0.0f;

	mov	DWORD PTR _ent[esi+160], 0

; 6015 : 		ent[i].texcor[4]=1.0f;

	mov	DWORD PTR _ent[esi+164], 1065353216	; 3f800000H

; 6016 : 		ent[i].texcor[5]=1.0f;

	mov	DWORD PTR _ent[esi+168], 1065353216	; 3f800000H

; 6017 : 		ent[i].texcor[6]=0.0f;

	mov	DWORD PTR _ent[esi+172], 0

; 6018 : 		ent[i].texcor[7]=1.0f;

	mov	DWORD PTR _ent[esi+176], 1065353216	; 3f800000H
	npad	3
$LL6@DrawLine:

; 6019 : 
; 6020 : 		for(j=0;j<12;j+=3)
; 6021 : 		{
; 6022 : 			ent[i].vertex[j]*=ax;

	movss	xmm0, DWORD PTR [edx-4]

; 6023 : 			ent[i].vertex[j]-=1;
; 6024 : 
; 6025 : 			ent[i].vertex[j+1]*=ay;

	movss	xmm1, DWORD PTR [edx]
	mulss	xmm0, xmm3
	mulss	xmm1, xmm4
	subss	xmm0, xmm2
	movss	DWORD PTR [edx-4], xmm0

; 6026 : 			ent[i].vertex[j+1]+=1;

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [edx], xmm0

; 6027 : 				
; 6028 : 			ent[i].vertex[j+2]*=az;

	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, xmm5

; 6029 : 			ent[i].vertex[j+2]-=1;

	subss	xmm0, xmm2
	movss	DWORD PTR [edx+4], xmm0
	add	edx, 12					; 0000000cH
	dec	eax
	jne	SHORT $LL6@DrawLine

; 6030 : 				
; 6031 : 		}
; 6032 : 
; 6033 : 		for(j=0;j<16;j+=4)

	mov	dl, BYTE PTR _a$[ebp]
	lea	eax, DWORD PTR _ent[esi+229]
	mov	bl, BYTE PTR _b$[ebp]
	mov	ecx, 4
	mov	dh, BYTE PTR _g$[ebp]
	mov	bh, BYTE PTR _r$[ebp]
$LL3@DrawLine:

; 6034 : 		{
; 6035 : 			ent[i].color[j]=r;

	mov	BYTE PTR [eax-1], bh
	lea	eax, DWORD PTR [eax+4]

; 6036 : 			ent[i].color[j+1]=g;

	mov	BYTE PTR [eax-4], dh

; 6037 : 			ent[i].color[j+2]=b;

	mov	BYTE PTR [eax-3], bl

; 6038 : 			ent[i].color[j+3]=a;

	mov	BYTE PTR [eax-2], dl
	dec	ecx
	jne	SHORT $LL3@DrawLine

; 6039 : 		}
; 6040 : 
; 6041 : 		texone_ids[texone_num]=i;

	mov	cx, WORD PTR _texone_num
	mov	edx, DWORD PTR _i$1$[ebp]
	movzx	eax, cx

; 6042 : 		texone_num++;

	inc	cx

; 6043 : 	//}
; 6044 : 
; 6045 : 	return 0;
; 6046 : }

	pop	edi
	pop	esi
	mov	WORD PTR _texone_num, cx
	mov	WORD PTR _texone_ids[eax*2], dx
	xor	al, al
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_DrawLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawString2
_TEXT	SEGMENT
tv2329 = -32						; size = 4
tv158 = -32						; size = 4
tv2289 = -28						; size = 4
_i$2$ = -24						; size = 4
_ang$1$ = -20						; size = 4
_ang$1$ = -20						; size = 4
_msg$1$ = -20						; size = 4
_y$1$ = -20						; size = 4
_co$ = -20						; size = 4
_id$1$ = -16						; size = 4
_sizey$1$ = -16						; size = 4
_text$1$ = -12						; size = 4
_sizex$1$ = -12						; size = 4
_x$1$ = -8						; size = 4
_g$1$ = -2						; size = 1
_b$1$ = -1						; size = 1
_y$ = 8							; size = 4
_sizex$ = 12						; size = 4
_sizey$ = 16						; size = 4
_ang$ = 20						; size = 2
_r$ = 24						; size = 1
_g$ = 28						; size = 1
_b$ = 32						; size = 1
_a$ = 36						; size = 1
_font$ = 40						; size = 1
_override_sizex$ = 44					; size = 4
_override_sizey$ = 48					; size = 4
_z$ = 52						; size = 1
_DrawString2 PROC					; COMDAT
; _text$ = ecx
; _x$ = edx

; 6464 : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _x$1$[ebp], edx

; 6465 : 	uint32 i=0, j=0, k=0, checked=0;
; 6466 : 	int32 t1, t2, t3, t4, timej, timel, id=-1;

	or	ebx, -1
	mov	edx, ecx
	mov	DWORD PTR _id$1$[ebp], ebx
	xor	edi, edi
	mov	DWORD PTR _text$1$[ebp], edx

; 6467 : 
; 6468 : 	SDL_Color co;
; 6469 : 	uint16 formatt;
; 6470 : 
; 6471 : 	float tmp, ax, ay, az;
; 6472 : 
; 6473 : 	uint8 val=0;
; 6474 : 	
; 6475 : 	SDL_Surface *msg;
; 6476 : 
; 6477 : 	if(st.num_entities==MAX_GRAPHICS-1)

	cmp	DWORD PTR _st+244, 2047			; 000007ffH
	je	$LN178@DrawString

; 6478 : 		return 2;
; 6479 : 
; 6480 : 	//Checkbounds(x,y,sizex,sizey,ang,GAME_WIDTH,9216)) return 1;
; 6481 : 
; 6482 : 	for(i=0;i<MAX_STRINGS;i++)

	xor	esi, esi
	npad	5
$LL38@DrawString:

; 6483 : 	{
; 6484 : 		if(st.strings[i].stat==2)

	imul	ecx, esi, 1068
	mov	al, BYTE PTR _st[ecx+2762084]
	cmp	al, 2
	jne	$LN35@DrawString

; 6485 : 		{
; 6486 : 			if(strcmp(text,st.strings[i].string)==NULL)

	lea	ecx, DWORD PTR _st[ecx+2761020]
	mov	eax, edx
	npad	4
$LL146@DrawString:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN147@DrawString
	test	dl, dl
	je	SHORT $LN148@DrawString
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN147@DrawString
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL146@DrawString
$LN148@DrawString:
	xor	eax, eax
	jmp	SHORT $LN149@DrawString
$LN147@DrawString:
	sbb	eax, eax
	or	eax, 1
$LN149@DrawString:
	test	eax, eax
	jne	$LN32@DrawString

; 6487 : 			{
; 6488 : 				st.strings[i].stat=1;

	imul	ecx, esi, 1068

; 6489 : 				j=st.num_entities;
; 6490 : 				st.strings[i].data.posx=i;
; 6491 : 				memcpy(&ent[j].data,&st.strings[i].data,sizeof(TEX_DATA));
; 6492 : 				id=i;

	mov	ebx, esi
	mov	DWORD PTR _id$1$[ebp], ebx

; 6493 : 				checked=1;

	mov	edi, 1
	mov	BYTE PTR _st[ecx+2762084], 1
	mov	eax, DWORD PTR _st+244
	imul	eax, eax, 264
	mov	WORD PTR _st[ecx+2762058], si
	movdqu	xmm0, XMMWORD PTR _st[ecx+2762044]
	add	eax, OFFSET _ent+44
	movdqu	XMMWORD PTR [eax], xmm0
	movdqu	xmm0, XMMWORD PTR _st[ecx+2762060]
	movdqu	XMMWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR _st[ecx+2762076]
	movq	QWORD PTR [eax+32], xmm0
$LN145@DrawString:

; 6517 : 			}
; 6518 : 		}
; 6519 : 	}
; 6520 : 
; 6521 : 	i=st.num_entities;

	mov	eax, DWORD PTR _st+244

; 6522 : 
; 6523 : 	if(checked==2)

	or	esi, -1
	mov	DWORD PTR _i$2$[ebp], eax
	cmp	edi, 2
	jne	$LN27@DrawString

; 6524 : 	{
; 6525 : 
; 6526 : 		co.r=255;
; 6527 : 		co.g=255;
; 6528 : 		co.b=255;
; 6529 : 		co.a=255;
; 6530 : 	
; 6531 : 		if(strlen(text)==0) 

	mov	edx, DWORD PTR _text$1$[ebp]
	mov	ecx, edx
	mov	DWORD PTR _co$[ebp], esi
	lea	esi, DWORD PTR [ecx+1]
$LL150@DrawString:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL150@DrawString

; 6532 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font," ",co);

	mov	eax, DWORD PTR _font$[ebp]
	push	DWORD PTR _co$[ebp]
	movzx	eax, al
	imul	eax, eax, 84
	sub	ecx, esi
	jne	$LN26@DrawString
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	DWORD PTR _st[eax+64344]
	call	DWORD PTR __imp__TTF_RenderUTF8_Blended
	mov	edx, eax
	mov	DWORD PTR _msg$1$[ebp], edx

; 6533 : 		else

	jmp	$LN156@DrawString
$LN35@DrawString:

; 6494 : 				break;
; 6495 : 			}
; 6496 : 		}
; 6497 : 		else
; 6498 : 		if(st.strings[i].stat==0 && checked==0)

	test	al, al
	jne	SHORT $LN32@DrawString
	test	edi, edi
	jne	SHORT $LN32@DrawString

; 6499 : 		{
; 6500 : 			checked=3;
; 6501 : 			id=i;

	mov	ebx, esi
	mov	edi, 3
	mov	DWORD PTR _id$1$[ebp], ebx
$LN32@DrawString:

; 6502 : 		}
; 6503 : 
; 6504 : 		if(i==MAX_STRINGS-1)

	cmp	esi, 511				; 000001ffH
	jne	SHORT $LN37@DrawString

; 6505 : 		{
; 6506 : 			if(id!=-1 && checked==3)

	cmp	ebx, -1
	je	SHORT $LN30@DrawString
	cmp	edi, 3
	jne	SHORT $LN30@DrawString

; 6507 : 			{
; 6508 : 				st.strings[id].stat=1;
; 6509 : 				strcpy(st.strings[id].string,text);

	mov	eax, DWORD PTR _text$1$[ebp]
	mov	ecx, eax
	imul	edx, ebx, 1068
	mov	BYTE PTR _st[edx+2762084], 1
	sub	edx, eax
	npad	2
$LL42@DrawString:
	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR _st[edx+ecx+2761019], al
	test	al, al
	jne	SHORT $LL42@DrawString

; 6510 : 				checked=2;

	mov	edi, 2

; 6511 : 			}
; 6512 : 			else

	jmp	SHORT $LN37@DrawString
$LN30@DrawString:

; 6513 : 			if(checked==0 && id==-1)

	test	edi, edi
	jne	SHORT $LN37@DrawString
	cmp	ebx, -1
	je	SHORT $LN133@DrawString
$LN37@DrawString:

; 6478 : 		return 2;
; 6479 : 
; 6480 : 	//Checkbounds(x,y,sizex,sizey,ang,GAME_WIDTH,9216)) return 1;
; 6481 : 
; 6482 : 	for(i=0;i<MAX_STRINGS;i++)

	inc	esi
	cmp	esi, 512				; 00000200H
	jae	$LN145@DrawString
	mov	edx, DWORD PTR _text$1$[ebp]
	jmp	$LL38@DrawString
$LN133@DrawString:

; 6514 : 			{
; 6515 : 				LogApp("Warning: max number os strings reached");

	push	OFFSET ??_C@_0CH@GLOGGAHF@Warning?3?5max?5number?5os?5strings?5r@
	call	DWORD PTR __imp__SDL_Log
	add	esp, 4
$LN178@DrawString:

; 6516 : 				return 2;

	mov	al, 2

; 6706 : 
; 6707 : 	return 0;
; 6708 : 
; 6709 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DrawString:

; 6534 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font,text,co);

	push	edx
	push	DWORD PTR _st[eax+64344]
	call	DWORD PTR __imp__TTF_RenderUTF8_Blended
	mov	edx, eax
	mov	DWORD PTR _msg$1$[ebp], eax
$LN156@DrawString:

; 6535 : 	
; 6536 : 		if(msg->format->BytesPerPixel==4)

	mov	eax, DWORD PTR [edx+4]
	add	esp, 12					; 0000000cH
	cmp	BYTE PTR [eax+9], 4
	jne	SHORT $LN24@DrawString

; 6537 : 		{
; 6538 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGBA;

	mov	esi, 32993				; 000080e1H
	mov	ecx, 6408				; 00001908H

; 6539 : 			else formatt=GL_BGRA_EXT;
; 6540 : 		} else

	jmp	SHORT $LN157@DrawString
$LN24@DrawString:

; 6541 : 		{
; 6542 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGB;

	mov	esi, 32992				; 000080e0H
	mov	ecx, 6407				; 00001907H
$LN157@DrawString:
	cmp	DWORD PTR [eax+12], 255			; 000000ffH
	cmove	esi, ecx

; 6543 : 			else formatt=GL_BGR_EXT;
; 6544 : 		}
; 6545 : 
; 6546 : 		glGenTextures(1,&ent[i].data.data);

	imul	edi, DWORD PTR _i$2$[ebp], 264
	lea	ebx, DWORD PTR _ent[edi+44]
	push	ebx
	push	1
	call	DWORD PTR __imp__glGenTextures@8

; 6547 : 		glBindTexture(GL_TEXTURE_2D,ent[i].data.data);

	push	DWORD PTR [ebx]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 6548 : 		glTexImage2D(GL_TEXTURE_2D,0,msg->format->BytesPerPixel,msg->w,msg->h,0,formatt,GL_UNSIGNED_BYTE,msg->pixels);

	mov	ecx, DWORD PTR _msg$1$[ebp]
	movzx	eax, si
	push	DWORD PTR [ecx+20]
	push	5121					; 00001401H
	push	eax
	mov	eax, DWORD PTR [ecx+4]
	push	0
	push	DWORD PTR [ecx+12]
	push	DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [eax+9]
	push	eax
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36

; 6549 : 
; 6550 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	mov	esi, DWORD PTR __imp__glTexParameteri@12
	push	9729					; 00002601H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	esi

; 6551 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	push	9729					; 00002601H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	esi

; 6552 : 
; 6553 : 		ent[i].data.channel=63; //magical number only used for rendering
; 6554 : 
; 6555 : 		ent[i].data.posx=id;
; 6556 : 
; 6557 : 		ent[i].data.normal=0;
; 6558 : 		ent[i].data.vb_id=-1;
; 6559 : 
; 6560 : 		ent[i].data.w=msg->w;

	mov	edx, DWORD PTR _msg$1$[ebp]
	or	esi, -1
	mov	ecx, DWORD PTR _id$1$[ebp]
	mov	DWORD PTR _ent[edi+76], 63		; 0000003fH
	mov	WORD PTR _ent[edi+58], cx
	mov	BYTE PTR _ent[edi+52], 0
	mov	WORD PTR _ent[edi+54], si
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _ent[edi+68], eax

; 6561 : 		ent[i].data.h=msg->h;

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _ent[edi+72], eax

; 6562 : 
; 6563 : 		ent[i].lightmapid=-1;
; 6564 : 
; 6565 : 		memcpy(&st.strings[id].data,&ent[i].data,sizeof(TEX_DATA));

	movdqu	xmm0, XMMWORD PTR [ebx]

; 6566 : 
; 6567 : 		SDL_FreeSurface(msg);

	push	edx
	imul	eax, ecx, 1068
	mov	WORD PTR _ent[edi+260], si
	add	eax, OFFSET _st+2762044
	movdqu	XMMWORD PTR [eax], xmm0
	movdqu	xmm0, XMMWORD PTR [ebx+16]
	movdqu	XMMWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [ebx+32]
	movq	QWORD PTR [eax+32], xmm0
	call	DWORD PTR __imp__SDL_FreeSurface
	mov	ebx, DWORD PTR _id$1$[ebp]
	add	esp, 4
	mov	eax, DWORD PTR _i$2$[ebp]
$LN27@DrawString:

; 6568 : 	}
; 6569 : 
; 6570 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 6571 : 
; 6572 : 	ent[i].lightmapid=-1;
; 6573 : 
; 6574 : 			if(override_sizex!=0)

	mov	ecx, DWORD PTR _override_sizex$[ebp]
	movss	xmm2, DWORD PTR __real@3a800000
	imul	edi, eax, 264
	mov	WORD PTR _ent[edi+260], si
	test	ecx, ecx
	je	SHORT $LN151@DrawString

; 6575 : 				sizex=st.strings[id].data.w*(float)(override_sizex/1024.0f);

	imul	eax, ebx, 1068
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	movd	xmm1, DWORD PTR _st[eax+2762068]
	cvtdq2ps xmm1, xmm1
	mulss	xmm0, xmm2
	mulss	xmm1, xmm0
	cvttss2si eax, xmm1
	jmp	SHORT $LN158@DrawString
$LN151@DrawString:
	mov	eax, DWORD PTR _sizex$[ebp]
$LN158@DrawString:

; 6576 : 
; 6577 : 			if(override_sizey!=0)

	mov	ecx, DWORD PTR _override_sizey$[ebp]
	mov	DWORD PTR _sizex$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN152@DrawString

; 6578 : 				sizey=st.strings[id].data.h*(float)(override_sizey/1024.0f);

	imul	eax, ebx, 1068
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	movd	xmm1, DWORD PTR _st[eax+2762072]
	cvtdq2ps xmm1, xmm1
	mulss	xmm0, xmm2
	mulss	xmm1, xmm0
	cvttss2si eax, xmm1
	jmp	SHORT $LN159@DrawString
$LN152@DrawString:
	mov	eax, DWORD PTR _sizey$[ebp]
$LN159@DrawString:

; 6579 : 
; 6580 : 			ent[i].texrepeat[0]=0.0f;
; 6581 : 			ent[i].texrepeat[1]=0.0f;
; 6582 : 			ent[i].texrepeat[2]=1.0f;
; 6583 : 			ent[i].texrepeat[3]=1.0f;
; 6584 : 
; 6585 : 			if(r==0 && g==0 && b==0)

	cmp	BYTE PTR _r$[ebp], 0
	movss	xmm3, DWORD PTR __real@3f800000
	mov	DWORD PTR _sizey$1$[ebp], eax
	mov	DWORD PTR _ent[edi+212], 0
	mov	DWORD PTR _ent[edi+216], 0
	mov	DWORD PTR _ent[edi+220], 1065353216	; 3f800000H
	mov	DWORD PTR _ent[edi+224], 1065353216	; 3f800000H
	jne	SHORT $LN153@DrawString
	mov	bl, BYTE PTR _g$[ebp]
	mov	dl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _g$1$[ebp], bl
	mov	BYTE PTR _b$1$[ebp], dl
	test	bl, bl
	jne	SHORT $LN16@DrawString
	test	dl, dl
	jne	SHORT $LN16@DrawString

; 6586 : 				r=g=b=1;

	mov	BYTE PTR _b$1$[ebp], 1
	mov	BYTE PTR _g$1$[ebp], 1
	mov	BYTE PTR _r$[ebp], 1
	jmp	SHORT $LN16@DrawString
$LN153@DrawString:
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _b$1$[ebp], al
	mov	al, BYTE PTR _g$[ebp]
	mov	BYTE PTR _g$1$[ebp], al
$LN16@DrawString:

; 6587 : 
; 6588 : 			if(z>39 && z<48)

	mov	cl, BYTE PTR _z$[ebp]
	movss	xmm4, DWORD PTR _st+2335400
	movss	xmm5, DWORD PTR _st+2335396
	mov	edx, DWORD PTR _st+2335384
	mov	esi, DWORD PTR _st+2335380
	lea	eax, DWORD PTR [ecx-40]
	cmp	al, 7
	ja	SHORT $LN15@DrawString

; 6589 : 			{
; 6590 : 				
; 6591 : 				x-=(float) st.Camera.position.x*st.Current_Map.bck2_v;

	movd	xmm1, DWORD PTR _x$1$[ebp]
	movd	xmm0, esi
	cvtdq2ps xmm0, xmm0
	cvtdq2ps xmm1, xmm1
	mulss	xmm0, DWORD PTR _st+66852
	subss	xmm1, xmm0
	movd	xmm0, edx

; 6592 : 				y-=(float) st.Camera.position.y*st.Current_Map.bck2_v;

	cvtdq2ps xmm0, xmm0
	cvttss2si eax, xmm1
	movd	xmm1, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR _st+66852
	mov	DWORD PTR _x$1$[ebp], eax
	cvtdq2ps xmm1, xmm1
	subss	xmm1, xmm0
	cvttss2si eax, xmm1

; 6593 : 			}
; 6594 : 			else

	jmp	$LN160@DrawString
$LN15@DrawString:

; 6595 : 			if(z>31 && z<40)

	lea	eax, DWORD PTR [ecx-32]
	cmp	al, 7
	ja	$LN13@DrawString

; 6596 : 			{
; 6597 : 				
; 6598 : 				x-=(float) st.Camera.position.x*st.Current_Map.bck1_v;
; 6599 : 				y-=(float) st.Camera.position.y*st.Current_Map.bck1_v;
; 6600 : 
; 6601 : 				sizex*=st.Camera.dimension.x;

	movd	xmm0, DWORD PTR _sizex$1$[ebp]
	cvtdq2ps xmm0, xmm0
	movd	xmm1, DWORD PTR _x$1$[ebp]
	mulss	xmm0, xmm5
	cvtdq2ps xmm1, xmm1
	cvttss2si ebx, xmm0
	movd	xmm0, DWORD PTR _sizey$1$[ebp]

; 6602 : 				sizey*=st.Camera.dimension.y;

	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR _sizex$1$[ebp], ebx
	mulss	xmm0, xmm4
	cvttss2si eax, xmm0
	movd	xmm0, esi
	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR _sizey$1$[ebp], eax
	mulss	xmm0, DWORD PTR _st+66856
	subss	xmm1, xmm0
	cvttss2si eax, xmm1
	movd	xmm1, DWORD PTR _y$[ebp]
	cvtdq2ps xmm1, xmm1
	movd	xmm0, eax

; 6603 : 
; 6604 : 				x*=st.Camera.dimension.x;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm5
	cvttss2si eax, xmm0
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR _x$1$[ebp], eax
	mulss	xmm0, DWORD PTR _st+66856
	subss	xmm1, xmm0
	cvttss2si eax, xmm1
	movd	xmm0, eax

; 6605 : 				y*=st.Camera.dimension.y;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm4
	cvttss2si eax, xmm0

; 6606 : 			}
; 6607 : 			else

	jmp	SHORT $LN161@DrawString
$LN13@DrawString:

; 6608 : 			if(z>23 && z<32)

	lea	eax, DWORD PTR [ecx-24]
	cmp	al, 7
	ja	SHORT $LN155@DrawString

; 6609 : 			{
; 6610 : 				x-=st.Camera.position.x;
; 6611 : 				y-=st.Camera.position.y;
; 6612 : 
; 6613 : 				sizex*=st.Camera.dimension.x;

	movd	xmm0, DWORD PTR _sizex$1$[ebp]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm5
	cvttss2si ebx, xmm0
	movd	xmm0, DWORD PTR _sizey$1$[ebp]

; 6614 : 				sizey*=st.Camera.dimension.y;

	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR _sizex$1$[ebp], ebx
	mulss	xmm0, xmm4
	cvttss2si eax, xmm0
	mov	DWORD PTR _sizey$1$[ebp], eax
	mov	eax, DWORD PTR _x$1$[ebp]
	sub	eax, esi
	movd	xmm0, eax

; 6615 : 
; 6616 : 				x*=st.Camera.dimension.x;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm5
	cvttss2si eax, xmm0
	mov	DWORD PTR _x$1$[ebp], eax
	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, edx
	movd	xmm0, eax

; 6617 : 				y*=st.Camera.dimension.y;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm4
	cvttss2si eax, xmm0
	jmp	SHORT $LN161@DrawString
$LN155@DrawString:
	mov	eax, DWORD PTR _y$[ebp]
$LN160@DrawString:
	mov	ebx, DWORD PTR _sizex$1$[ebp]
$LN161@DrawString:
	mov	DWORD PTR _y$1$[ebp], eax

; 6618 : 			}
; 6619 : 			if(z>15 && z<24)

	cmp	cl, 15					; 0000000fH
	jle	$LN9@DrawString
	cmp	cl, 24					; 00000018H
	jge	$LN10@DrawString

; 6620 : 			{
; 6621 : 				x-=(float) st.Camera.position.x*st.Current_Map.fr_v;
; 6622 : 				y-=(float) st.Camera.position.y*st.Current_Map.fr_v;
; 6623 : 
; 6624 : 				sizex*=st.Camera.dimension.x;

	movd	xmm0, ebx
	cvtdq2ps xmm0, xmm0
	movd	xmm1, DWORD PTR _x$1$[ebp]
	mulss	xmm0, xmm5
	cvtdq2ps xmm1, xmm1
	cvttss2si eax, xmm0
	movd	xmm0, DWORD PTR _sizey$1$[ebp]

; 6625 : 				sizey*=st.Camera.dimension.y;

	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR _sizex$1$[ebp], eax
	mulss	xmm0, xmm4
	cvttss2si eax, xmm0
	movd	xmm0, esi
	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR _sizey$1$[ebp], eax
	mulss	xmm0, DWORD PTR _st+66860
	subss	xmm1, xmm0
	cvttss2si eax, xmm1
	movd	xmm1, DWORD PTR _y$1$[ebp]
	cvtdq2ps xmm1, xmm1
	movd	xmm0, eax

; 6626 : 
; 6627 : 				x*=st.Camera.dimension.x;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm5
	cvttss2si eax, xmm0
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR _x$1$[ebp], eax
	mulss	xmm0, DWORD PTR _st+66860
	subss	xmm1, xmm0
	cvttss2si eax, xmm1
	movd	xmm0, eax

; 6628 : 				y*=st.Camera.dimension.y;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm4
	cvttss2si eax, xmm0
	mov	DWORD PTR _y$1$[ebp], eax
$LN10@DrawString:

; 6629 : 			}
; 6630 : 
; 6631 : 			if(z>15) z=15;

	mov	bl, 15					; 0000000fH

; 6632 : 			if(z<8) z=8;

	jmp	SHORT $LN8@DrawString
$LN9@DrawString:
	mov	eax, 8
	movzx	ebx, cl
	cmp	cl, al
	cmovl	ebx, eax
$LN8@DrawString:

; 6633 : 
; 6634 : 			z_buffer[z][z_slot[z]]=i;

	movsx	esi, bl
	mov	ecx, esi
	mov	DWORD PTR tv2329[ebp], esi
	shl	ecx, 11					; 0000000bH
	movzx	edx, WORD PTR _z_slot[esi*2]
	movsx	eax, dx
	add	ecx, eax
	mov	eax, DWORD PTR _i$2$[ebp]

; 6635 : 			z_slot[z]++;
; 6636 : 
; 6637 : 			if(z>z_used) z_used=z;

	cmp	bl, BYTE PTR _z_used
	mov	WORD PTR _z_buffer[ecx*2], ax
	lea	eax, DWORD PTR [edx+1]
	movzx	edx, BYTE PTR _z_used
	mov	WORD PTR _z_slot[esi*2], ax

; 6638 : 
; 6639 : 			//timej=GetTicks();
; 6640 : 
; 6641 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	mov	esi, DWORD PTR _ang$[ebp]
	movzx	eax, bl
	cmovg	edx, eax
	movzx	eax, si
	mov	BYTE PTR _z_used, dl

; 217  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H
	mov	DWORD PTR tv2289[ebp], edx
	cmp	si, dx
	jle	SHORT $LN45@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN162@DrawString
$LN45@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN43@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN162@DrawString:
	movzx	eax, ax
$LN43@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, ax

; 6638 : 
; 6639 : 			//timej=GetTicks();
; 6640 : 
; 6641 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	ebx, si

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN50@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN163@DrawString
$LN50@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN48@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN163@DrawString:
	movzx	ebx, ax
$LN48@DrawString:

; 6638 : 
; 6639 : 			//timej=GetTicks();
; 6640 : 
; 6641 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	mov	eax, DWORD PTR _sizex$1$[ebp]
	cdq
	sub	eax, edx
	movd	xmm2, DWORD PTR _x$1$[ebp]
	sar	eax, 1
	neg	eax
	cvtdq2ps xmm2, xmm2
	movd	xmm7, eax
	mov	eax, DWORD PTR _sizey$1$[ebp]
	cdq
	sub	eax, edx

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 6638 : 
; 6639 : 			//timej=GetTicks();
; 6640 : 
; 6641 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	sar	eax, 1
	neg	eax
	cvtdq2ps xmm7, xmm7
	movd	xmm4, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	movsx	eax, bx

; 6638 : 
; 6639 : 			//timej=GetTicks();
; 6640 : 
; 6641 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR _st[ecx*4+2717808]
	cvtdq2ps xmm4, xmm4
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm4

; 6642 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	addss	xmm1, xmm2
	movss	DWORD PTR _ent[edi+100], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN55@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN164@DrawString
$LN55@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN53@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN164@DrawString:
	movzx	eax, ax
$LN53@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 6642 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN60@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN165@DrawString
$LN60@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN58@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN165@DrawString:
	movzx	ecx, cx
$LN58@DrawString:
	movd	xmm5, DWORD PTR _y$1$[ebp]

; 6642 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR _st[eax*4+2732212]
	lea	ebx, DWORD PTR _ent[edi+104]

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx
	movd	xmm6, DWORD PTR tv2329[ebp]

; 6643 : 			ent[i].vertex[2]=z;
; 6644 : 
; 6645 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	cvtdq2ps xmm5, xmm5
	movss	xmm1, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm1, xmm4
	cvtdq2ps xmm6, xmm6
	addss	xmm1, xmm0
	movss	DWORD PTR _ent[edi+108], xmm6
	addss	xmm1, xmm5
	movss	DWORD PTR [ebx], xmm1

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN65@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN166@DrawString
$LN65@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN63@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN166@DrawString:
	movzx	eax, ax
$LN63@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, ax

; 6643 : 			ent[i].vertex[2]=z;
; 6644 : 
; 6645 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	mov	DWORD PTR _ang$1$[ebp], eax

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN70@DrawString
	lea	eax, DWORD PTR [esi-3600]
	movzx	eax, ax
	jmp	SHORT $LN167@DrawString
$LN70@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN68@DrawString
	lea	edx, DWORD PTR [esi+3600]
	movzx	eax, dx
$LN167@DrawString:
	mov	DWORD PTR _ang$1$[ebp], eax
$LN68@DrawString:

; 6643 : 			ent[i].vertex[2]=z;
; 6644 : 
; 6645 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	mov	eax, DWORD PTR _sizex$1$[ebp]
	cdq
	sub	eax, edx

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 6643 : 			ent[i].vertex[2]=z;
; 6644 : 
; 6645 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	sar	eax, 1
	movd	xmm2, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	mov	eax, DWORD PTR _ang$1$[ebp]
	cwde

; 6643 : 			ent[i].vertex[2]=z;
; 6644 : 
; 6645 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtdq2ps xmm2, xmm2
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mov	eax, DWORD PTR _x$1$[ebp]
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm0, xmm4
	subss	xmm1, xmm0
	movd	xmm0, eax

; 6646 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	cvtdq2ps xmm0, xmm0
	addss	xmm1, xmm0
	movss	DWORD PTR _ent[edi+112], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN75@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN168@DrawString
$LN75@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN73@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN168@DrawString:
	movzx	eax, ax
$LN73@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 6646 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN80@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN169@DrawString
$LN80@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN78@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN169@DrawString:
	movzx	ecx, cx
$LN78@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx

; 6646 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _st[eax*4+2732212]

; 6647 : 			ent[i].vertex[5]=z;
; 6648 : 
; 6649 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	movss	DWORD PTR _ent[edi+120], xmm6
	movss	xmm1, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm1, xmm4
	addss	xmm1, xmm0
	addss	xmm1, xmm5
	movss	DWORD PTR _ent[edi+116], xmm1

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN85@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN170@DrawString
$LN85@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN83@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN170@DrawString:
	movzx	eax, ax
$LN83@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, ax

; 6647 : 			ent[i].vertex[5]=z;
; 6648 : 
; 6649 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	mov	DWORD PTR _ang$1$[ebp], eax

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN90@DrawString
	lea	eax, DWORD PTR [esi-3600]
	movzx	eax, ax
	jmp	SHORT $LN171@DrawString
$LN90@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN88@DrawString
	lea	edx, DWORD PTR [esi+3600]
	movzx	eax, dx
$LN171@DrawString:
	mov	DWORD PTR _ang$1$[ebp], eax
$LN88@DrawString:

; 6647 : 			ent[i].vertex[5]=z;
; 6648 : 
; 6649 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	mov	eax, DWORD PTR _sizey$1$[ebp]
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR _st[ecx*4+2717808]

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	ecx, 3600				; 00000e10H

; 6647 : 			ent[i].vertex[5]=z;
; 6648 : 
; 6649 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _x$1$[ebp]
	sar	eax, 1
	movd	xmm4, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	mov	eax, DWORD PTR _ang$1$[ebp]
	cwde

; 6647 : 			ent[i].vertex[5]=z;
; 6648 : 
; 6649 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtdq2ps xmm4, xmm4
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm4

; 6650 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0
	addss	xmm1, xmm0
	movss	DWORD PTR _ent[edi+124], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, cx
	jle	SHORT $LN95@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN172@DrawString
$LN95@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN93@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN172@DrawString:
	movzx	eax, ax
$LN93@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 6650 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, WORD PTR tv2289[ebp]
	jle	SHORT $LN100@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN173@DrawString
$LN100@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN98@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN173@DrawString:
	movzx	ecx, cx
$LN98@DrawString:

; 6650 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	mulss	xmm2, DWORD PTR _st[eax*4+2732212]

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx

; 6651 : 			ent[i].vertex[8]=z;

	movss	DWORD PTR _ent[edi+132], xmm6

; 6652 : 
; 6653 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	movss	xmm0, DWORD PTR _st[ecx*4+2717808]

; 217  : 	if(ang>3600) ang-=3600;

	mov	ecx, 3600				; 00000e10H

; 6650 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	mulss	xmm0, xmm4
	addss	xmm0, xmm2
	addss	xmm0, xmm5
	movss	DWORD PTR _ent[edi+128], xmm0

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, cx
	jle	SHORT $LN105@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN174@DrawString
$LN105@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN103@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN174@DrawString:
	movzx	eax, ax
$LN103@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	cwde

; 6652 : 
; 6653 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	ecx, si

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, WORD PTR tv2289[ebp]
	jle	SHORT $LN110@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN175@DrawString
$LN110@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN108@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN175@DrawString:
	movzx	ecx, cx
$LN108@DrawString:

; 6652 : 
; 6653 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR _st[eax*4+2717808]

; 227  : 
; 228  : 	return st.SinTable[ang];

	movsx	eax, cx

; 6652 : 
; 6653 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm4

; 6654 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 6652 : 
; 6653 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	addss	xmm1, xmm0
	movss	DWORD PTR _ent[edi+136], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN115@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN176@DrawString
$LN115@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN113@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN176@DrawString:
	movzx	eax, ax
$LN113@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 6654 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN120@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN177@DrawString
$LN120@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN118@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN177@DrawString:
	movzx	ecx, cx
$LN118@DrawString:

; 6654 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	mulss	xmm7, DWORD PTR _st[eax*4+2732212]

; 219  : 
; 220  : 	return st.CosTable[ang];

	mov	eax, 4
	movsx	ecx, cx
	movss	xmm2, DWORD PTR __real@39000000

; 6655 : 			ent[i].vertex[11]=z;

	movss	DWORD PTR _ent[edi+144], xmm6

; 6656 : 
; 6657 : 			ang/=10;
; 6658 : 
; 6659 : 			tmp=cos((ang*pi)/180);
; 6660 : 			tmp=mCos(ang*10);
; 6661 : 	
; 6662 : 			ax=(float) 1/(16384.0f/2);
; 6663 : 			ay=(float) 1/(9216.0f/2);
; 6664 : 
; 6665 : 			ay*=-1.0f;
; 6666 : 
; 6667 : 			az=(float) 1/(4096/2);
; 6668 : 
; 6669 : 			
; 6670 : 				ent[i].texcor[0]=0;

	mov	DWORD PTR _ent[edi+148], 0
	movss	xmm0, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm0, xmm4

; 6671 : 				ent[i].texcor[1]=0;

	mov	DWORD PTR _ent[edi+152], 0

; 219  : 
; 220  : 	return st.CosTable[ang];

	movss	xmm4, DWORD PTR __real@39638e39

; 6672 : 				ent[i].texcor[2]=1;

	mov	DWORD PTR _ent[edi+156], 1065353216	; 3f800000H
	addss	xmm0, xmm7

; 6673 : 				ent[i].texcor[3]=0;

	mov	DWORD PTR _ent[edi+160], 0

; 6674 : 				ent[i].texcor[4]=1;

	mov	DWORD PTR _ent[edi+164], 1065353216	; 3f800000H

; 6675 : 				ent[i].texcor[5]=1;

	mov	DWORD PTR _ent[edi+168], 1065353216	; 3f800000H

; 6676 : 				ent[i].texcor[6]=0;

	mov	DWORD PTR _ent[edi+172], 0

; 6677 : 				ent[i].texcor[7]=1;

	mov	DWORD PTR _ent[edi+176], 1065353216	; 3f800000H
	addss	xmm0, xmm5

; 219  : 
; 220  : 	return st.CosTable[ang];

	movss	xmm5, DWORD PTR __real@3a000000

; 6654 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movss	DWORD PTR _ent[edi+140], xmm0
	npad	2
$LL6@DrawString:

; 6678 : 
; 6679 : 			for(j=0;j<12;j+=3)
; 6680 : 			{
; 6681 : 				ent[i].vertex[j]*=ax;

	movss	xmm0, DWORD PTR [ebx-4]

; 6682 : 				ent[i].vertex[j]-=1;
; 6683 : 
; 6684 : 				ent[i].vertex[j+1]*=ay;

	movss	xmm1, DWORD PTR [ebx]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm4
	subss	xmm0, xmm3
	movss	DWORD PTR [ebx-4], xmm0

; 6685 : 				ent[i].vertex[j+1]+=1;

	movaps	xmm0, xmm3
	subss	xmm0, xmm1
	movss	DWORD PTR [ebx], xmm0

; 6686 : 				
; 6687 : 				ent[i].vertex[j+2]*=az;

	movss	xmm0, DWORD PTR [ebx+4]
	mulss	xmm0, xmm5

; 6688 : 				ent[i].vertex[j+2]-=1;

	subss	xmm0, xmm3
	movss	DWORD PTR [ebx+4], xmm0
	add	ebx, 12					; 0000000cH
	dec	eax
	jne	SHORT $LL6@DrawString

; 6689 : 			}
; 6690 : 
; 6691 : 			for(j=0;j<16;j+=4)

	mov	cl, BYTE PTR _a$[ebp]
	mov	dl, BYTE PTR _b$1$[ebp]
	mov	bl, BYTE PTR _g$1$[ebp]
	mov	ch, BYTE PTR _r$[ebp]
	npad	7
$LL3@DrawString:

; 6692 : 			{
; 6693 : 				ent[i].color[j]=r;

	mov	BYTE PTR _ent[edi+eax+228], ch

; 6694 : 				ent[i].color[j+1]=g;

	mov	BYTE PTR _ent[edi+eax+229], bl

; 6695 : 				ent[i].color[j+2]=b;

	mov	BYTE PTR _ent[edi+eax+230], dl

; 6696 : 				ent[i].color[j+3]=a;

	mov	BYTE PTR _ent[edi+eax+231], cl
	add	eax, 4
	cmp	eax, 16					; 00000010H
	jb	SHORT $LL3@DrawString

; 6697 : 			}
; 6698 : 
; 6699 : 			
; 6700 : 				texone_ids[texone_num]=i;

	mov	cx, WORD PTR _texone_num
	mov	edx, DWORD PTR _i$2$[ebp]

; 6701 : 				texone_num++;
; 6702 : 
; 6703 : #endif
; 6704 : 
; 6705 : 			st.num_entities++;

	inc	DWORD PTR _st+244
	movzx	eax, cx
	inc	cx

; 6706 : 
; 6707 : 	return 0;
; 6708 : 
; 6709 : }

	pop	edi
	pop	esi
	mov	WORD PTR _texone_num, cx
	mov	WORD PTR _texone_ids[eax*2], dx
	xor	al, al
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_DrawString2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawStringUIv
_TEXT	SEGMENT
tv2008 = -28						; size = 4
tv158 = -28						; size = 4
_ang$1$ = -24						; size = 4
_x$1$ = -24						; size = 4
_msg$1$ = -20						; size = 4
_text$1$ = -20						; size = 4
_sizey$1$ = -20						; size = 4
_i$2$ = -16						; size = 4
_id$1$ = -12						; size = 4
_sizex$1$ = -12						; size = 4
tv2010 = -8						; size = 4
_co$ = -8						; size = 4
_g$1$ = -2						; size = 1
_b$1$ = -1						; size = 1
_y$ = 8							; size = 4
_sizex$ = 12						; size = 4
_sizey$ = 16						; size = 4
_ang$ = 20						; size = 2
_r$ = 24						; size = 1
_g$ = 28						; size = 1
_b$ = 32						; size = 1
_a$ = 36						; size = 1
_font$ = 40						; size = 1
_override_sizex$ = 44					; size = 4
_override_sizey$ = 48					; size = 4
_z$ = 52						; size = 1
_DrawStringUIv PROC					; COMDAT
; _text$ = ecx
; _x$ = edx

; 6712 : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	edi
	mov	DWORD PTR _x$1$[ebp], edx

; 6713 : 	uint8 valx=0, valy=0;
; 6714 : 	uint32 i=0, j=0, k=0, checked=0;
; 6715 : 	int32 t1, t2, t3, t4, timej, timel, id=-1;

	or	ebx, -1
	mov	edx, ecx
	mov	DWORD PTR _id$1$[ebp], ebx
	xor	edi, edi
	mov	DWORD PTR _text$1$[ebp], edx

; 6716 : 
; 6717 : 	SDL_Color co;
; 6718 : 	uint16 formatt;
; 6719 : 
; 6720 : 	float tmp, ax, ay, az;
; 6721 : 
; 6722 : 	uint8 val=0;
; 6723 : 	
; 6724 : 	SDL_Surface *msg;
; 6725 : if(st.num_entities==MAX_GRAPHICS-1)

	cmp	DWORD PTR _st+244, 2047			; 000007ffH
	jne	SHORT $LN32@DrawString

; 6726 : 		return 2;

	pop	edi
	mov	al, 2
	pop	ebx

; 6911 : 
; 6912 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@DrawString:
	push	esi

; 6727 : 
; 6728 : 	//Checkbounds(x,y,sizex,sizey,ang,GAME_WIDTH,GAME_HEIGHT)) return 1;
; 6729 : 
; 6730 : 	for(i=0;i<MAX_STRINGS;i++)

	xor	esi, esi
	npad	1
$LL31@DrawString:

; 6731 : 	{
; 6732 : 		if(st.strings[i].stat==2)

	imul	ecx, esi, 1068
	mov	al, BYTE PTR _st[ecx+2762084]
	cmp	al, 2
	jne	$LN28@DrawString

; 6733 : 		{
; 6734 : 			if(strcmp(text,st.strings[i].string)==NULL)

	lea	ecx, DWORD PTR _st[ecx+2761020]
	mov	eax, edx
	npad	4
$LL134@DrawString:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN135@DrawString
	test	dl, dl
	je	SHORT $LN136@DrawString
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN135@DrawString
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL134@DrawString
$LN136@DrawString:
	xor	eax, eax
	jmp	SHORT $LN137@DrawString
$LN135@DrawString:
	sbb	eax, eax
	or	eax, 1
$LN137@DrawString:
	test	eax, eax
	jne	$LN25@DrawString

; 6735 : 			{
; 6736 : 				st.strings[i].stat=1;

	imul	ecx, esi, 1068

; 6737 : 				j=st.num_entities;
; 6738 : 				st.strings[i].data.posx=i;
; 6739 : 				memcpy(&ent[j].data,&st.strings[i].data,sizeof(TEX_DATA));
; 6740 : 				id=i;

	mov	ebx, esi
	mov	DWORD PTR _id$1$[ebp], ebx

; 6741 : 				checked=1;

	mov	edi, 1
	mov	BYTE PTR _st[ecx+2762084], 1
	mov	eax, DWORD PTR _st+244
	imul	eax, eax, 264
	mov	WORD PTR _st[ecx+2762058], si
	movdqu	xmm0, XMMWORD PTR _st[ecx+2762044]
	add	eax, OFFSET _ent+44
	movdqu	XMMWORD PTR [eax], xmm0
	movdqu	xmm0, XMMWORD PTR _st[ecx+2762060]
	movdqu	XMMWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR _st[ecx+2762076]
	movq	QWORD PTR [eax+32], xmm0
$LN133@DrawString:

; 6765 : 			}
; 6766 : 		}
; 6767 : 	}
; 6768 : 
; 6769 : 	i=st.num_entities;

	mov	eax, DWORD PTR _st+244

; 6770 : 
; 6771 : 	if(checked==2)

	or	ecx, -1
	mov	DWORD PTR _i$2$[ebp], eax
	cmp	edi, 2
	jne	$LN20@DrawString

; 6772 : 	{
; 6773 : 
; 6774 : 		co.r=255;
; 6775 : 		co.g=255;
; 6776 : 		co.b=255;
; 6777 : 		co.a=255;
; 6778 : 
; 6779 : 		if(strlen(text)==0) 

	mov	edx, DWORD PTR _text$1$[ebp]
	mov	DWORD PTR _co$[ebp], ecx
	mov	ecx, edx
	lea	esi, DWORD PTR [ecx+1]
$LL138@DrawString:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL138@DrawString

; 6780 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font," ",co);

	mov	eax, DWORD PTR _font$[ebp]
	push	DWORD PTR _co$[ebp]
	movzx	eax, al
	imul	eax, eax, 84
	sub	ecx, esi
	jne	$LN19@DrawString
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	DWORD PTR _st[eax+64344]
	call	DWORD PTR __imp__TTF_RenderUTF8_Blended
	mov	edx, eax
	mov	DWORD PTR _msg$1$[ebp], edx

; 6781 : 		else

	jmp	$LN144@DrawString
$LN28@DrawString:

; 6742 : 				break;
; 6743 : 			}
; 6744 : 		}
; 6745 : 		else
; 6746 : 		if(st.strings[i].stat==0 && checked==0)

	test	al, al
	jne	SHORT $LN25@DrawString
	test	edi, edi
	jne	SHORT $LN25@DrawString

; 6747 : 		{
; 6748 : 			checked=3;
; 6749 : 			id=i;

	mov	ebx, esi
	mov	edi, 3
	mov	DWORD PTR _id$1$[ebp], ebx
$LN25@DrawString:

; 6750 : 		}
; 6751 : 
; 6752 : 		if(i==MAX_STRINGS-1)

	cmp	esi, 511				; 000001ffH
	jne	SHORT $LN30@DrawString

; 6753 : 		{
; 6754 : 			if(id!=-1 && checked==3)

	cmp	ebx, -1
	je	SHORT $LN23@DrawString
	cmp	edi, 3
	jne	SHORT $LN23@DrawString

; 6755 : 			{
; 6756 : 				st.strings[id].stat=1;
; 6757 : 				strcpy(st.strings[id].string,text);

	mov	eax, DWORD PTR _text$1$[ebp]
	mov	ecx, eax
	imul	edx, ebx, 1068
	mov	BYTE PTR _st[edx+2762084], 1
	sub	edx, eax
	npad	2
$LL35@DrawString:
	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR _st[ecx+edx+2761019], al
	test	al, al
	jne	SHORT $LL35@DrawString

; 6758 : 				checked=2;

	mov	edi, 2

; 6759 : 			}
; 6760 : 			else

	jmp	SHORT $LN30@DrawString
$LN23@DrawString:

; 6761 : 			if(checked==0 && id==-1)

	test	edi, edi
	jne	SHORT $LN30@DrawString
	cmp	ebx, -1
	je	SHORT $LN121@DrawString
$LN30@DrawString:

; 6727 : 
; 6728 : 	//Checkbounds(x,y,sizex,sizey,ang,GAME_WIDTH,GAME_HEIGHT)) return 1;
; 6729 : 
; 6730 : 	for(i=0;i<MAX_STRINGS;i++)

	inc	esi
	cmp	esi, 512				; 00000200H
	jae	$LN133@DrawString
	mov	edx, DWORD PTR _text$1$[ebp]
	jmp	$LL31@DrawString
$LN121@DrawString:

; 6762 : 			{
; 6763 : 				LogApp("Warning: max number os strings reached");

	push	OFFSET ??_C@_0CH@GLOGGAHF@Warning?3?5max?5number?5os?5strings?5r@
	call	DWORD PTR __imp__SDL_Log
	add	esp, 4

; 6764 : 				return 2;

	mov	al, 2
	pop	esi
	pop	edi
	pop	ebx

; 6911 : 
; 6912 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@DrawString:

; 6782 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font,text,co);

	push	edx
	push	DWORD PTR _st[eax+64344]
	call	DWORD PTR __imp__TTF_RenderUTF8_Blended
	mov	edx, eax
	mov	DWORD PTR _msg$1$[ebp], eax
$LN144@DrawString:

; 6783 : 	
; 6784 : 		if(msg->format->BytesPerPixel==4)

	mov	eax, DWORD PTR [edx+4]
	add	esp, 12					; 0000000cH
	cmp	BYTE PTR [eax+9], 4
	jne	SHORT $LN17@DrawString

; 6785 : 		{
; 6786 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGBA;

	mov	esi, 32993				; 000080e1H
	mov	ecx, 6408				; 00001908H

; 6787 : 			else formatt=GL_BGRA_EXT;
; 6788 : 		} else

	jmp	SHORT $LN145@DrawString
$LN17@DrawString:

; 6789 : 		{
; 6790 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGB;

	mov	esi, 32992				; 000080e0H
	mov	ecx, 6407				; 00001907H
$LN145@DrawString:
	cmp	DWORD PTR [eax+12], 255			; 000000ffH
	cmove	esi, ecx

; 6791 : 			else formatt=GL_BGR_EXT;
; 6792 : 		}
; 6793 : 
; 6794 : 		glGenTextures(1,&ent[i].data.data);

	imul	edi, DWORD PTR _i$2$[ebp], 264
	lea	ebx, DWORD PTR _ent[edi+44]
	push	ebx
	push	1
	call	DWORD PTR __imp__glGenTextures@8

; 6795 : 		glBindTexture(GL_TEXTURE_2D,ent[i].data.data);

	push	DWORD PTR [ebx]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 6796 : 		glTexImage2D(GL_TEXTURE_2D,0,msg->format->BytesPerPixel,msg->w,msg->h,0,formatt,GL_UNSIGNED_BYTE,msg->pixels);

	mov	ecx, DWORD PTR _msg$1$[ebp]
	movzx	eax, si
	push	DWORD PTR [ecx+20]
	push	5121					; 00001401H
	push	eax
	mov	eax, DWORD PTR [ecx+4]
	push	0
	push	DWORD PTR [ecx+12]
	push	DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [eax+9]
	push	eax
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36

; 6797 : 
; 6798 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	mov	esi, DWORD PTR __imp__glTexParameteri@12
	push	9729					; 00002601H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	esi

; 6799 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	push	9729					; 00002601H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	esi

; 6800 : 
; 6801 : 		ent[i].data.channel=63; //magical number only used for rendering
; 6802 : 
; 6803 : 		ent[i].data.posx=id;
; 6804 : 
; 6805 : 		ent[i].data.normal=0;
; 6806 : 		ent[i].data.vb_id=-1;
; 6807 : 
; 6808 : 		ent[i].data.w=msg->w;

	mov	edx, DWORD PTR _msg$1$[ebp]
	or	eax, -1
	mov	ecx, DWORD PTR _id$1$[ebp]
	mov	WORD PTR _ent[edi+54], ax
	mov	DWORD PTR _ent[edi+76], 63		; 0000003fH
	mov	WORD PTR _ent[edi+58], cx
	mov	BYTE PTR _ent[edi+52], 0
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _ent[edi+68], eax

; 6809 : 		ent[i].data.h=msg->h;

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _ent[edi+72], eax

; 6810 : 
; 6811 : 		memcpy(&st.strings[id].data,&ent[i].data,sizeof(TEX_DATA));

	movdqu	xmm0, XMMWORD PTR [ebx]

; 6812 : 
; 6813 : 		SDL_FreeSurface(msg);

	push	edx
	imul	eax, ecx, 1068
	add	eax, OFFSET _st+2762044
	movdqu	XMMWORD PTR [eax], xmm0
	movdqu	xmm0, XMMWORD PTR [ebx+16]
	movdqu	XMMWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [ebx+32]
	movq	QWORD PTR [eax+32], xmm0
	call	DWORD PTR __imp__SDL_FreeSurface
	mov	ebx, DWORD PTR _id$1$[ebp]
	add	esp, 4
	mov	eax, DWORD PTR _i$2$[ebp]
	or	ecx, -1
$LN20@DrawString:

; 6814 : 	}
; 6815 : 
; 6816 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 6817 : 
; 6818 : 	ent[i].lightmapid=-1;
; 6819 : 
; 6820 : 			
; 6821 : 			if(override_sizex!=0)

	movss	xmm2, DWORD PTR __real@3a800000
	imul	edi, eax, 264
	mov	WORD PTR _ent[edi+260], cx
	mov	ecx, DWORD PTR _override_sizex$[ebp]
	test	ecx, ecx
	je	SHORT $LN139@DrawString

; 6822 : 				sizex=st.strings[id].data.w*(float)(override_sizex/1024.0f);

	imul	eax, ebx, 1068
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	movd	xmm1, DWORD PTR _st[eax+2762068]
	cvtdq2ps xmm1, xmm1
	mulss	xmm0, xmm2
	mulss	xmm1, xmm0
	cvttss2si esi, xmm1
	jmp	SHORT $LN146@DrawString
$LN139@DrawString:
	mov	esi, DWORD PTR _sizex$[ebp]
$LN146@DrawString:

; 6823 : 
; 6824 : 			if(override_sizey!=0)

	mov	ecx, DWORD PTR _override_sizey$[ebp]
	mov	DWORD PTR _sizex$1$[ebp], esi
	test	ecx, ecx
	je	SHORT $LN140@DrawString

; 6825 : 				sizey=st.strings[id].data.h*(float)(override_sizey/1024.0f);

	imul	eax, ebx, 1068
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	movd	xmm1, DWORD PTR _st[eax+2762072]
	cvtdq2ps xmm1, xmm1
	mulss	xmm0, xmm2
	mulss	xmm1, xmm0
	cvttss2si eax, xmm1
	jmp	SHORT $LN147@DrawString
$LN140@DrawString:
	mov	eax, DWORD PTR _sizey$[ebp]
$LN147@DrawString:

; 6826 : 
; 6827 : 			if(r==0 && g==0 && b==0)

	cmp	BYTE PTR _r$[ebp], 0
	mov	DWORD PTR _sizey$1$[ebp], eax
	jne	SHORT $LN141@DrawString
	mov	al, BYTE PTR _g$[ebp]
	mov	BYTE PTR _g$1$[ebp], al
	test	al, al
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _b$1$[ebp], al
	jne	SHORT $LN9@DrawString
	test	al, al
	jne	SHORT $LN9@DrawString

; 6828 : 				r=g=b=1;

	mov	BYTE PTR _b$1$[ebp], 1
	mov	BYTE PTR _g$1$[ebp], 1
	mov	BYTE PTR _r$[ebp], 1
	jmp	SHORT $LN9@DrawString
$LN141@DrawString:
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _b$1$[ebp], al
	mov	al, BYTE PTR _g$[ebp]
	mov	BYTE PTR _g$1$[ebp], al
$LN9@DrawString:

; 6829 : 
; 6830 : 			if(z>7) z=7;

	movzx	ebx, BYTE PTR _z$[ebp]
	mov	ecx, 7
	cmp	BYTE PTR _z$[ebp], cl
	cmovg	ebx, ecx

; 6831 : 			//else if(z<0) z+=8;
; 6832 : 
; 6833 : 			z_buffer[z][z_slot[z]]=i;

	movsx	eax, bl
	mov	ecx, eax
	mov	DWORD PTR tv2010[ebp], eax
	shl	ecx, 11					; 0000000bH
	movzx	edx, WORD PTR _z_slot[eax*2]
	movsx	eax, dx
	add	ecx, eax
	mov	eax, DWORD PTR _i$2$[ebp]

; 6834 : 			z_slot[z]++;
; 6835 : 
; 6836 : 			if(z>z_used) z_used=z;

	cmp	bl, BYTE PTR _z_used
	mov	WORD PTR _z_buffer[ecx*2], ax
	lea	eax, DWORD PTR [edx+1]
	mov	ecx, DWORD PTR tv2010[ebp]
	movzx	edx, BYTE PTR _z_used
	mov	WORD PTR _z_slot[ecx*2], ax
	movzx	eax, bl
	cmovg	edx, eax

; 6837 : 
; 6838 : 			x+=sizex/2;

	mov	eax, esi

; 6839 : 			//y-=sizey/2;
; 6840 : 
; 6841 : 			//timej=GetTicks();
; 6842 : 
; 6843 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	mov	esi, DWORD PTR _ang$[ebp]
	mov	BYTE PTR _z_used, dl
	cdq
	sub	eax, edx
	movzx	ecx, si
	sar	eax, 1

; 217  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 6837 : 
; 6838 : 			x+=sizex/2;

	add	DWORD PTR _x$1$[ebp], eax
	mov	DWORD PTR tv2008[ebp], eax

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN38@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN148@DrawString
$LN38@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN36@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN148@DrawString:
	movzx	ecx, ax
$LN36@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx

; 6839 : 			//y-=sizey/2;
; 6840 : 
; 6841 : 			//timej=GetTicks();
; 6842 : 
; 6843 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	ebx, si

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN43@DrawString
	lea	eax, DWORD PTR [esi-3600]
	movzx	ebx, ax
	jmp	SHORT $LN41@DrawString
$LN43@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN41@DrawString
	lea	edx, DWORD PTR [esi+3600]
	movzx	ebx, dx
$LN41@DrawString:

; 6839 : 			//y-=sizey/2;
; 6840 : 
; 6841 : 			//timej=GetTicks();
; 6842 : 
; 6843 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	mov	eax, DWORD PTR _sizex$1$[ebp]
	cdq
	sub	eax, edx
	movd	xmm7, DWORD PTR _x$1$[ebp]
	sar	eax, 1
	neg	eax
	cvtdq2ps xmm7, xmm7
	movd	xmm6, eax
	mov	eax, DWORD PTR _sizey$1$[ebp]
	cdq
	sub	eax, edx

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 6839 : 			//y-=sizey/2;
; 6840 : 
; 6841 : 			//timej=GetTicks();
; 6842 : 
; 6843 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	sar	eax, 1
	neg	eax
	cvtdq2ps xmm6, xmm6
	movd	xmm3, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	movsx	eax, bx

; 6839 : 			//y-=sizey/2;
; 6840 : 
; 6841 : 			//timej=GetTicks();
; 6842 : 
; 6843 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR _st[ecx*4+2717808]
	cvtdq2ps xmm3, xmm3
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm3

; 6844 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	addss	xmm1, xmm7
	movss	DWORD PTR _ent[edi+100], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN48@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN149@DrawString
$LN48@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN46@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN149@DrawString:
	movzx	eax, ax
$LN46@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 6844 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN53@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN150@DrawString
$LN53@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN51@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN150@DrawString:
	movzx	ecx, cx
$LN51@DrawString:
	movd	xmm4, DWORD PTR _y$[ebp]

; 6844 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR _st[eax*4+2732212]
	lea	ebx, DWORD PTR _ent[edi+104]

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx
	movd	xmm5, DWORD PTR tv2010[ebp]

; 6845 : 			ent[i].vertex[2]=z;
; 6846 : 
; 6847 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	cvtdq2ps xmm4, xmm4
	movss	xmm1, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm1, xmm3
	cvtdq2ps xmm5, xmm5
	addss	xmm1, xmm0
	movss	DWORD PTR _ent[edi+108], xmm5
	addss	xmm1, xmm4
	movss	DWORD PTR [ebx], xmm1

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN58@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN151@DrawString
$LN58@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN56@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN151@DrawString:
	movzx	eax, ax
$LN56@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	cwde

; 6845 : 			ent[i].vertex[2]=z;
; 6846 : 
; 6847 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	ecx, si

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN63@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN152@DrawString
$LN63@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN61@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN152@DrawString:
	movzx	ecx, cx
$LN61@DrawString:
	movd	xmm2, DWORD PTR tv2008[ebp]

; 6845 : 			ent[i].vertex[2]=z;
; 6846 : 
; 6847 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtdq2ps xmm2, xmm2
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR _st[eax*4+2717808]

; 227  : 
; 228  : 	return st.SinTable[ang];

	movsx	eax, cx

; 6845 : 			ent[i].vertex[2]=z;
; 6846 : 
; 6847 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm3

; 6848 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	addss	xmm1, xmm7
	movss	DWORD PTR _ent[edi+112], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN68@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN153@DrawString
$LN68@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN66@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN153@DrawString:
	movzx	eax, ax
$LN66@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 6848 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN73@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN154@DrawString
$LN73@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN71@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN154@DrawString:
	movzx	ecx, cx
$LN71@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx

; 6848 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _st[eax*4+2732212]

; 6849 : 			ent[i].vertex[5]=z;
; 6850 : 
; 6851 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	movss	DWORD PTR _ent[edi+120], xmm5
	movss	xmm1, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	addss	xmm1, xmm4
	movss	DWORD PTR _ent[edi+116], xmm1

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN78@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN155@DrawString
$LN78@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN76@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN155@DrawString:
	movzx	eax, ax
$LN76@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, ax

; 6849 : 			ent[i].vertex[5]=z;
; 6850 : 
; 6851 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	mov	DWORD PTR _ang$1$[ebp], eax

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN83@DrawString
	lea	eax, DWORD PTR [esi-3600]
	movzx	eax, ax
	jmp	SHORT $LN156@DrawString
$LN83@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN81@DrawString
	lea	edx, DWORD PTR [esi+3600]
	movzx	eax, dx
$LN156@DrawString:
	mov	DWORD PTR _ang$1$[ebp], eax
$LN81@DrawString:

; 6849 : 			ent[i].vertex[5]=z;
; 6850 : 
; 6851 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	mov	eax, DWORD PTR _sizey$1$[ebp]
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR _st[ecx*4+2717808]
	cdq
	sub	eax, edx

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 6849 : 			ent[i].vertex[5]=z;
; 6850 : 
; 6851 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	sar	eax, 1
	movd	xmm3, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	mov	eax, DWORD PTR _ang$1$[ebp]
	cwde

; 6849 : 			ent[i].vertex[5]=z;
; 6850 : 
; 6851 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtdq2ps xmm3, xmm3
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm3

; 6852 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	addss	xmm1, xmm7
	movss	DWORD PTR _ent[edi+124], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN88@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN157@DrawString
$LN88@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN86@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN157@DrawString:
	movzx	eax, ax
$LN86@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 6852 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN93@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN158@DrawString
$LN93@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN91@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN158@DrawString:
	movzx	ecx, cx
$LN91@DrawString:

; 6852 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	mulss	xmm2, DWORD PTR _st[eax*4+2732212]

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx

; 6853 : 			ent[i].vertex[8]=z;

	movss	DWORD PTR _ent[edi+132], xmm5

; 6854 : 
; 6855 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	movss	xmm0, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm0, xmm3
	addss	xmm0, xmm2
	addss	xmm0, xmm4
	movss	DWORD PTR _ent[edi+128], xmm0

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN98@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN159@DrawString
$LN98@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN96@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN159@DrawString:
	movzx	eax, ax
$LN96@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	cwde

; 6854 : 
; 6855 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	ecx, si

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN103@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN160@DrawString
$LN103@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN101@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN160@DrawString:
	movzx	ecx, cx
$LN101@DrawString:

; 6854 : 
; 6855 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR _st[eax*4+2717808]

; 227  : 
; 228  : 	return st.SinTable[ang];

	movsx	eax, cx

; 6854 : 
; 6855 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm3

; 6856 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	addss	xmm1, xmm7
	movss	DWORD PTR _ent[edi+136], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN108@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN161@DrawString
$LN108@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN106@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN161@DrawString:
	movzx	eax, ax
$LN106@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 6856 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN113@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN162@DrawString
$LN113@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN111@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN162@DrawString:
	movzx	ecx, cx
$LN111@DrawString:

; 6856 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	mulss	xmm6, DWORD PTR _st[eax*4+2732212]

; 219  : 
; 220  : 	return st.CosTable[ang];

	mov	eax, 4
	movsx	ecx, cx

; 6875 : 				ent[i].texcor[2]=1;

	movss	xmm2, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent[edi+144], xmm5

; 219  : 
; 220  : 	return st.CosTable[ang];

	movss	xmm5, DWORD PTR __real@3a000000

; 6856 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movss	xmm0, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm0, xmm3

; 6857 : 			ent[i].vertex[11]=z;
; 6858 : 
; 6859 : 			/*
; 6860 : 			ang/=10;
; 6861 : 
; 6862 : 			tmp=cos((ang*pi)/180);
; 6863 : 			tmp=mCos(ang*10);
; 6864 : 	*/
; 6865 : 			ax=(float) 1/(GAME_WIDTH/2);
; 6866 : 			ay=(float) 1/(9216.0f/2);
; 6867 : 
; 6868 : 			ay*=-1.0f;
; 6869 : 
; 6870 : 			az=(float) 1/(4096/2);
; 6871 : 
; 6872 : 			
; 6873 : 				ent[i].texcor[0]=0;

	mov	DWORD PTR _ent[edi+148], 0

; 219  : 
; 220  : 	return st.CosTable[ang];

	movss	xmm3, DWORD PTR __real@39000000

; 6874 : 				ent[i].texcor[1]=0;

	mov	DWORD PTR _ent[edi+152], 0
	addss	xmm0, xmm6

; 6875 : 				ent[i].texcor[2]=1;

	mov	DWORD PTR _ent[edi+156], 1065353216	; 3f800000H

; 6876 : 				ent[i].texcor[3]=0;

	mov	DWORD PTR _ent[edi+160], 0

; 6877 : 				ent[i].texcor[4]=1;

	mov	DWORD PTR _ent[edi+164], 1065353216	; 3f800000H

; 6878 : 				ent[i].texcor[5]=1;

	mov	DWORD PTR _ent[edi+168], 1065353216	; 3f800000H

; 6879 : 				ent[i].texcor[6]=0;

	mov	DWORD PTR _ent[edi+172], 0
	addss	xmm0, xmm4

; 6880 : 				ent[i].texcor[7]=1;

	mov	DWORD PTR _ent[edi+176], 1065353216	; 3f800000H

; 219  : 
; 220  : 	return st.CosTable[ang];

	movss	xmm4, DWORD PTR __real@39638e39

; 6856 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movss	DWORD PTR _ent[edi+140], xmm0
	npad	9
$LL6@DrawString:

; 6881 : 
; 6882 : 			for(j=0;j<12;j+=3)
; 6883 : 			{
; 6884 : 				ent[i].vertex[j]*=ax;

	movss	xmm0, DWORD PTR [ebx-4]

; 6885 : 				ent[i].vertex[j]-=1;
; 6886 : 
; 6887 : 				ent[i].vertex[j+1]*=ay;

	movss	xmm1, DWORD PTR [ebx]
	mulss	xmm0, xmm3
	mulss	xmm1, xmm4
	subss	xmm0, xmm2
	movss	DWORD PTR [ebx-4], xmm0

; 6888 : 				ent[i].vertex[j+1]+=1;

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [ebx], xmm0

; 6889 : 				
; 6890 : 				ent[i].vertex[j+2]*=az;

	movss	xmm0, DWORD PTR [ebx+4]
	mulss	xmm0, xmm5

; 6891 : 				ent[i].vertex[j+2]-=1;

	subss	xmm0, xmm2
	movss	DWORD PTR [ebx+4], xmm0
	add	ebx, 12					; 0000000cH
	dec	eax
	jne	SHORT $LL6@DrawString

; 6892 : 			}
; 6893 : 
; 6894 : 			for(j=0;j<16;j+=4)

	mov	cl, BYTE PTR _a$[ebp]
	mov	dl, BYTE PTR _b$1$[ebp]
	mov	bl, BYTE PTR _g$1$[ebp]
	mov	ch, BYTE PTR _r$[ebp]
	npad	7
$LL3@DrawString:

; 6895 : 			{
; 6896 : 				ent[i].color[j]=r;

	mov	BYTE PTR _ent[edi+eax+228], ch

; 6897 : 				ent[i].color[j+1]=g;

	mov	BYTE PTR _ent[edi+eax+229], bl

; 6898 : 				ent[i].color[j+2]=b;

	mov	BYTE PTR _ent[edi+eax+230], dl

; 6899 : 				ent[i].color[j+3]=a;

	mov	BYTE PTR _ent[edi+eax+231], cl
	add	eax, 4
	cmp	eax, 16					; 00000010H
	jb	SHORT $LL3@DrawString

; 6900 : 			}
; 6901 : 
; 6902 : 			
; 6903 : 				texone_ids[texone_num]=i;

	mov	cx, WORD PTR _texone_num
	mov	edx, DWORD PTR _i$2$[ebp]

; 6904 : 				texone_num++;
; 6905 : 
; 6906 : #endif
; 6907 : 
; 6908 : 			st.num_entities++;

	inc	DWORD PTR _st+244
	movzx	eax, cx
	inc	cx
	pop	esi
	pop	edi
	mov	WORD PTR _texone_num, cx
	mov	WORD PTR _texone_ids[eax*2], dx

; 6909 : 
; 6910 : 	return 0;

	xor	al, al
	pop	ebx

; 6911 : 
; 6912 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DrawStringUIv ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawStringUI
_TEXT	SEGMENT
tv1976 = -28						; size = 4
tv158 = -28						; size = 4
_x$1$ = -24						; size = 4
_ang$1$ = -20						; size = 4
_msg$1$ = -20						; size = 4
_text$1$ = -20						; size = 4
_sizex$1$ = -20						; size = 4
_i$2$ = -16						; size = 4
_ang$1$ = -12						; size = 4
_id$1$ = -12						; size = 4
tv2016 = -12						; size = 4
_sizey$1$ = -8						; size = 4
_co$ = -8						; size = 4
_g$1$ = -2						; size = 1
_b$1$ = -1						; size = 1
_y$ = 8							; size = 4
_sizex$ = 12						; size = 4
_sizey$ = 16						; size = 4
_ang$ = 20						; size = 2
_r$ = 24						; size = 1
_g$ = 28						; size = 1
_b$ = 32						; size = 1
_a$ = 36						; size = 1
_font$ = 40						; size = 1
_override_sizex$ = 44					; size = 4
_override_sizey$ = 48					; size = 4
_z$ = 52						; size = 1
_DrawStringUI PROC					; COMDAT
; _text$ = ecx
; _x$ = edx

; 6915 : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	edi
	mov	DWORD PTR _x$1$[ebp], edx

; 6916 : 	uint32 i=0, j=0, k=0, checked=0;
; 6917 : 	int32 t1, t2, t3, t4, timej, timel, id=-1;

	or	ebx, -1
	mov	edx, ecx
	mov	DWORD PTR _id$1$[ebp], ebx
	xor	edi, edi
	mov	DWORD PTR _text$1$[ebp], edx

; 6918 : 
; 6919 : 	SDL_Color co;
; 6920 : 	uint16 formatt;
; 6921 : 
; 6922 : 	float tmp, ax, ay, az;
; 6923 : 
; 6924 : 	uint8 val=0;
; 6925 : 	
; 6926 : 	SDL_Surface *msg;
; 6927 : if(st.num_entities==MAX_GRAPHICS-1)

	cmp	DWORD PTR _st+244, 2047			; 000007ffH
	jne	SHORT $LN32@DrawString

; 6928 : 		return 2;

	pop	edi
	mov	al, 2
	pop	ebx

; 7115 : 
; 7116 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@DrawString:
	push	esi

; 6929 : 
; 6930 : 	//Checkbounds(x,y,sizex,sizey,ang,GAME_WIDTH,GAME_HEIGHT)) return 1;
; 6931 : 
; 6932 : 	for(i=0;i<MAX_STRINGS;i++)

	xor	esi, esi
	npad	1
$LL31@DrawString:

; 6933 : 	{
; 6934 : 		if(st.strings[i].stat==2)

	imul	ecx, esi, 1068
	mov	al, BYTE PTR _st[ecx+2762084]
	cmp	al, 2
	jne	$LN28@DrawString

; 6935 : 		{
; 6936 : 			if(strcmp(text,st.strings[i].string)==NULL)

	lea	ecx, DWORD PTR _st[ecx+2761020]
	mov	eax, edx
	npad	4
$LL134@DrawString:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN135@DrawString
	test	dl, dl
	je	SHORT $LN136@DrawString
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN135@DrawString
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL134@DrawString
$LN136@DrawString:
	xor	eax, eax
	jmp	SHORT $LN137@DrawString
$LN135@DrawString:
	sbb	eax, eax
	or	eax, 1
$LN137@DrawString:
	test	eax, eax
	jne	$LN25@DrawString

; 6937 : 			{
; 6938 : 				st.strings[i].stat=1;

	imul	ecx, esi, 1068

; 6939 : 				j=st.num_entities;
; 6940 : 				st.strings[i].data.posx=i;
; 6941 : 				memcpy(&ent[j].data,&st.strings[i].data,sizeof(TEX_DATA));
; 6942 : 				id=i;

	mov	ebx, esi
	mov	DWORD PTR _id$1$[ebp], ebx

; 6943 : 				checked=1;

	mov	edi, 1
	mov	BYTE PTR _st[ecx+2762084], 1
	mov	eax, DWORD PTR _st+244
	imul	eax, eax, 264
	mov	WORD PTR _st[ecx+2762058], si
	movdqu	xmm0, XMMWORD PTR _st[ecx+2762044]
	add	eax, OFFSET _ent+44
	movdqu	XMMWORD PTR [eax], xmm0
	movdqu	xmm0, XMMWORD PTR _st[ecx+2762060]
	movdqu	XMMWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR _st[ecx+2762076]
	movq	QWORD PTR [eax+32], xmm0
$LN133@DrawString:

; 6967 : 			}
; 6968 : 		}
; 6969 : 	}
; 6970 : 
; 6971 : 	i=st.num_entities;

	mov	eax, DWORD PTR _st+244

; 6972 : 
; 6973 : 	if(checked==2)

	or	ecx, -1
	mov	DWORD PTR _i$2$[ebp], eax
	cmp	edi, 2
	jne	$LN20@DrawString

; 6974 : 	{
; 6975 : 
; 6976 : 		co.r=255;
; 6977 : 		co.g=255;
; 6978 : 		co.b=255;
; 6979 : 		co.a=255;
; 6980 : 
; 6981 : 		if(strlen(text)==0) 

	mov	edx, DWORD PTR _text$1$[ebp]
	mov	DWORD PTR _co$[ebp], ecx
	mov	ecx, edx
	lea	esi, DWORD PTR [ecx+1]
$LL138@DrawString:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL138@DrawString

; 6982 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font," ",co);

	mov	eax, DWORD PTR _font$[ebp]
	push	DWORD PTR _co$[ebp]
	movzx	eax, al
	imul	eax, eax, 84
	sub	ecx, esi
	jne	$LN19@DrawString
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	DWORD PTR _st[eax+64344]
	call	DWORD PTR __imp__TTF_RenderUTF8_Blended
	mov	edx, eax
	mov	DWORD PTR _msg$1$[ebp], edx

; 6983 : 		else

	jmp	$LN144@DrawString
$LN28@DrawString:

; 6944 : 				break;
; 6945 : 			}
; 6946 : 		}
; 6947 : 		else
; 6948 : 		if(st.strings[i].stat==0 && checked==0)

	test	al, al
	jne	SHORT $LN25@DrawString
	test	edi, edi
	jne	SHORT $LN25@DrawString

; 6949 : 		{
; 6950 : 			checked=3;
; 6951 : 			id=i;

	mov	ebx, esi
	mov	edi, 3
	mov	DWORD PTR _id$1$[ebp], ebx
$LN25@DrawString:

; 6952 : 		}
; 6953 : 
; 6954 : 		if(i==MAX_STRINGS-1)

	cmp	esi, 511				; 000001ffH
	jne	SHORT $LN30@DrawString

; 6955 : 		{
; 6956 : 			if(id!=-1 && checked==3)

	cmp	ebx, -1
	je	SHORT $LN23@DrawString
	cmp	edi, 3
	jne	SHORT $LN23@DrawString

; 6957 : 			{
; 6958 : 				st.strings[id].stat=1;
; 6959 : 				strcpy(st.strings[id].string,text);

	mov	eax, DWORD PTR _text$1$[ebp]
	mov	ecx, eax
	imul	edx, ebx, 1068
	mov	BYTE PTR _st[edx+2762084], 1
	sub	edx, eax
	npad	2
$LL35@DrawString:
	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR _st[ecx+edx+2761019], al
	test	al, al
	jne	SHORT $LL35@DrawString

; 6960 : 				checked=2;

	mov	edi, 2

; 6961 : 			}
; 6962 : 			else

	jmp	SHORT $LN30@DrawString
$LN23@DrawString:

; 6963 : 			if(checked==0 && id==-1)

	test	edi, edi
	jne	SHORT $LN30@DrawString
	cmp	ebx, -1
	je	SHORT $LN121@DrawString
$LN30@DrawString:

; 6929 : 
; 6930 : 	//Checkbounds(x,y,sizex,sizey,ang,GAME_WIDTH,GAME_HEIGHT)) return 1;
; 6931 : 
; 6932 : 	for(i=0;i<MAX_STRINGS;i++)

	inc	esi
	cmp	esi, 512				; 00000200H
	jae	$LN133@DrawString
	mov	edx, DWORD PTR _text$1$[ebp]
	jmp	$LL31@DrawString
$LN121@DrawString:

; 6964 : 			{
; 6965 : 				LogApp("Warning: max number os strings reached");

	push	OFFSET ??_C@_0CH@GLOGGAHF@Warning?3?5max?5number?5os?5strings?5r@
	call	DWORD PTR __imp__SDL_Log
	add	esp, 4

; 6966 : 				return 2;

	mov	al, 2
	pop	esi
	pop	edi
	pop	ebx

; 7115 : 
; 7116 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@DrawString:

; 6984 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font,text,co);

	push	edx
	push	DWORD PTR _st[eax+64344]
	call	DWORD PTR __imp__TTF_RenderUTF8_Blended
	mov	edx, eax
	mov	DWORD PTR _msg$1$[ebp], eax
$LN144@DrawString:

; 6985 : 	
; 6986 : 		if(msg->format->BytesPerPixel==4)

	mov	eax, DWORD PTR [edx+4]
	add	esp, 12					; 0000000cH
	cmp	BYTE PTR [eax+9], 4
	jne	SHORT $LN17@DrawString

; 6987 : 		{
; 6988 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGBA;

	mov	esi, 32993				; 000080e1H
	mov	ecx, 6408				; 00001908H

; 6989 : 			else formatt=GL_BGRA_EXT;
; 6990 : 		} else

	jmp	SHORT $LN145@DrawString
$LN17@DrawString:

; 6991 : 		{
; 6992 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGB;

	mov	esi, 32992				; 000080e0H
	mov	ecx, 6407				; 00001907H
$LN145@DrawString:
	cmp	DWORD PTR [eax+12], 255			; 000000ffH
	cmove	esi, ecx

; 6993 : 			else formatt=GL_BGR_EXT;
; 6994 : 		}
; 6995 : 
; 6996 : 		glGenTextures(1,&ent[i].data.data);

	imul	edi, DWORD PTR _i$2$[ebp], 264
	lea	ebx, DWORD PTR _ent[edi+44]
	push	ebx
	push	1
	call	DWORD PTR __imp__glGenTextures@8

; 6997 : 		glBindTexture(GL_TEXTURE_2D,ent[i].data.data);

	push	DWORD PTR [ebx]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 6998 : 		glTexImage2D(GL_TEXTURE_2D,0,msg->format->BytesPerPixel,msg->w,msg->h,0,formatt,GL_UNSIGNED_BYTE,msg->pixels);

	mov	ecx, DWORD PTR _msg$1$[ebp]
	movzx	eax, si
	push	DWORD PTR [ecx+20]
	push	5121					; 00001401H
	push	eax
	mov	eax, DWORD PTR [ecx+4]
	push	0
	push	DWORD PTR [ecx+12]
	push	DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [eax+9]
	push	eax
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36

; 6999 : 
; 7000 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	mov	esi, DWORD PTR __imp__glTexParameteri@12
	push	9729					; 00002601H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	esi

; 7001 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	push	9729					; 00002601H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	esi

; 7002 : 
; 7003 : 		ent[i].data.channel=63; //magical number only used for rendering
; 7004 : 
; 7005 : 		ent[i].data.posx=id;
; 7006 : 
; 7007 : 		ent[i].data.normal=0;
; 7008 : 		ent[i].data.vb_id=-1;
; 7009 : 
; 7010 : 		ent[i].data.w=msg->w;

	mov	edx, DWORD PTR _msg$1$[ebp]
	or	eax, -1
	mov	ecx, DWORD PTR _id$1$[ebp]
	mov	WORD PTR _ent[edi+54], ax
	mov	DWORD PTR _ent[edi+76], 63		; 0000003fH
	mov	WORD PTR _ent[edi+58], cx
	mov	BYTE PTR _ent[edi+52], 0
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _ent[edi+68], eax

; 7011 : 		ent[i].data.h=msg->h;

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _ent[edi+72], eax

; 7012 : 
; 7013 : 		memcpy(&st.strings[id].data,&ent[i].data,sizeof(TEX_DATA));

	movdqu	xmm0, XMMWORD PTR [ebx]

; 7014 : 
; 7015 : 		SDL_FreeSurface(msg);

	push	edx
	imul	eax, ecx, 1068
	add	eax, OFFSET _st+2762044
	movdqu	XMMWORD PTR [eax], xmm0
	movdqu	xmm0, XMMWORD PTR [ebx+16]
	movdqu	XMMWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [ebx+32]
	movq	QWORD PTR [eax+32], xmm0
	call	DWORD PTR __imp__SDL_FreeSurface
	mov	ebx, DWORD PTR _id$1$[ebp]
	add	esp, 4
	mov	eax, DWORD PTR _i$2$[ebp]
	or	ecx, -1
$LN20@DrawString:

; 7016 : 	}
; 7017 : 
; 7018 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 7019 : 
; 7020 : 	ent[i].lightmapid=-1;
; 7021 : 
; 7022 : 			
; 7023 : 			if(override_sizex!=0)

	movss	xmm2, DWORD PTR __real@3a800000
	imul	edi, eax, 264
	mov	WORD PTR _ent[edi+260], cx
	mov	ecx, DWORD PTR _override_sizex$[ebp]
	test	ecx, ecx
	je	SHORT $LN139@DrawString

; 7024 : 				sizex=st.strings[id].data.w*(float)(override_sizex/1024.0f);

	imul	eax, ebx, 1068
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	movd	xmm1, DWORD PTR _st[eax+2762068]
	cvtdq2ps xmm1, xmm1
	mulss	xmm0, xmm2
	mulss	xmm1, xmm0
	cvttss2si eax, xmm1
	jmp	SHORT $LN146@DrawString
$LN139@DrawString:
	mov	eax, DWORD PTR _sizex$[ebp]
$LN146@DrawString:

; 7025 : 
; 7026 : 			if(override_sizey!=0)

	mov	ecx, DWORD PTR _override_sizey$[ebp]
	mov	DWORD PTR _sizex$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN140@DrawString

; 7027 : 				sizey=st.strings[id].data.h*(float)(override_sizey/1024.0f);

	imul	eax, ebx, 1068
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	movd	xmm1, DWORD PTR _st[eax+2762072]
	cvtdq2ps xmm1, xmm1
	mulss	xmm0, xmm2
	mulss	xmm1, xmm0
	cvttss2si eax, xmm1
	jmp	SHORT $LN147@DrawString
$LN140@DrawString:
	mov	eax, DWORD PTR _sizey$[ebp]
$LN147@DrawString:

; 7028 : 
; 7029 : 			ent[i].texrepeat[0]=0.0f;
; 7030 : 			ent[i].texrepeat[1]=0.0f;
; 7031 : 			ent[i].texrepeat[2]=1.0f;
; 7032 : 			ent[i].texrepeat[3]=1.0f;
; 7033 : 
; 7034 : 			if(r==0 && g==0 && b==0)

	cmp	BYTE PTR _r$[ebp], 0
	movss	xmm2, DWORD PTR __real@3f800000
	mov	DWORD PTR _sizey$1$[ebp], eax
	mov	DWORD PTR _ent[edi+212], 0
	mov	DWORD PTR _ent[edi+216], 0
	mov	DWORD PTR _ent[edi+220], 1065353216	; 3f800000H
	mov	DWORD PTR _ent[edi+224], 1065353216	; 3f800000H
	jne	SHORT $LN141@DrawString
	mov	al, BYTE PTR _g$[ebp]
	mov	BYTE PTR _g$1$[ebp], al
	test	al, al
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _b$1$[ebp], al
	jne	SHORT $LN9@DrawString
	test	al, al
	jne	SHORT $LN9@DrawString

; 7035 : 				r=g=b=1;

	mov	BYTE PTR _b$1$[ebp], 1
	mov	BYTE PTR _g$1$[ebp], 1
	mov	BYTE PTR _r$[ebp], 1
	jmp	SHORT $LN9@DrawString
$LN141@DrawString:
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _b$1$[ebp], al
	mov	al, BYTE PTR _g$[ebp]
	mov	BYTE PTR _g$1$[ebp], al
$LN9@DrawString:

; 7036 : 
; 7037 : 			if(z>7) z=7;

	movzx	ebx, BYTE PTR _z$[ebp]
	mov	ecx, 7
	cmp	BYTE PTR _z$[ebp], cl
	cmovg	ebx, ecx

; 7038 : 			//else if(z<0) z+=8;
; 7039 : 
; 7040 : 			z_buffer[z][z_slot[z]]=i;

	movsx	esi, bl
	mov	ecx, esi
	mov	DWORD PTR tv2016[ebp], esi
	shl	ecx, 11					; 0000000bH
	movzx	edx, WORD PTR _z_slot[esi*2]
	movsx	eax, dx
	add	ecx, eax
	mov	eax, DWORD PTR _i$2$[ebp]

; 7041 : 			z_slot[z]++;
; 7042 : 
; 7043 : 			if(z>z_used) z_used=z;

	cmp	bl, BYTE PTR _z_used
	mov	WORD PTR _z_buffer[ecx*2], ax
	lea	eax, DWORD PTR [edx+1]
	movzx	edx, BYTE PTR _z_used
	mov	WORD PTR _z_slot[esi*2], ax

; 7044 : 
; 7045 : 			//timej=GetTicks();
; 7046 : 
; 7047 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	mov	esi, DWORD PTR _ang$[ebp]
	movzx	eax, bl
	cmovg	edx, eax
	movzx	eax, si
	mov	BYTE PTR _z_used, dl

; 217  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H
	mov	DWORD PTR tv1976[ebp], edx
	cmp	si, dx
	jle	SHORT $LN38@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN148@DrawString
$LN38@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN36@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN148@DrawString:
	movzx	eax, ax
$LN36@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, ax

; 7044 : 
; 7045 : 			//timej=GetTicks();
; 7046 : 
; 7047 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	ebx, si

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN43@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN149@DrawString
$LN43@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN41@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN149@DrawString:
	movzx	ebx, ax
$LN41@DrawString:

; 7044 : 
; 7045 : 			//timej=GetTicks();
; 7046 : 
; 7047 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	mov	eax, DWORD PTR _sizex$1$[ebp]
	cdq
	sub	eax, edx
	movd	xmm3, DWORD PTR _x$1$[ebp]
	sar	eax, 1
	neg	eax
	cvtdq2ps xmm3, xmm3
	movd	xmm7, eax
	mov	eax, DWORD PTR _sizey$1$[ebp]
	cdq
	sub	eax, edx

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 7044 : 
; 7045 : 			//timej=GetTicks();
; 7046 : 
; 7047 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	sar	eax, 1
	neg	eax
	cvtdq2ps xmm7, xmm7
	movd	xmm4, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	movsx	eax, bx

; 7044 : 
; 7045 : 			//timej=GetTicks();
; 7046 : 
; 7047 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR _st[ecx*4+2717808]
	cvtdq2ps xmm4, xmm4
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm4

; 7048 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	addss	xmm1, xmm3
	movss	DWORD PTR _ent[edi+100], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN48@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN150@DrawString
$LN48@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN46@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN150@DrawString:
	movzx	eax, ax
$LN46@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 7048 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN53@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN151@DrawString
$LN53@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN51@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN151@DrawString:
	movzx	ecx, cx
$LN51@DrawString:
	movd	xmm5, DWORD PTR _y$[ebp]

; 7048 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR _st[eax*4+2732212]
	lea	ebx, DWORD PTR _ent[edi+104]

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx
	movd	xmm6, DWORD PTR tv2016[ebp]

; 7049 : 			ent[i].vertex[2]=z;
; 7050 : 
; 7051 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	cvtdq2ps xmm5, xmm5
	movss	xmm1, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm1, xmm4
	cvtdq2ps xmm6, xmm6
	addss	xmm1, xmm0
	movss	DWORD PTR _ent[edi+108], xmm6
	addss	xmm1, xmm5
	movss	DWORD PTR [ebx], xmm1

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN58@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN152@DrawString
$LN58@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN56@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN152@DrawString:
	movzx	eax, ax
$LN56@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, ax

; 7049 : 			ent[i].vertex[2]=z;
; 7050 : 
; 7051 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	mov	DWORD PTR _ang$1$[ebp], eax

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN63@DrawString
	lea	eax, DWORD PTR [esi-3600]
	movzx	eax, ax
	jmp	SHORT $LN153@DrawString
$LN63@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN61@DrawString
	lea	edx, DWORD PTR [esi+3600]
	movzx	eax, dx
$LN153@DrawString:
	mov	DWORD PTR _ang$1$[ebp], eax
$LN61@DrawString:

; 7049 : 			ent[i].vertex[2]=z;
; 7050 : 
; 7051 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	mov	eax, DWORD PTR _sizex$1$[ebp]
	cdq
	sub	eax, edx

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 7049 : 			ent[i].vertex[2]=z;
; 7050 : 
; 7051 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	sar	eax, 1
	movd	xmm3, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	mov	eax, DWORD PTR _ang$1$[ebp]
	cwde

; 7049 : 			ent[i].vertex[2]=z;
; 7050 : 
; 7051 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtdq2ps xmm3, xmm3
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mov	eax, DWORD PTR _x$1$[ebp]
	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm0, xmm4
	subss	xmm1, xmm0
	movd	xmm0, eax

; 7052 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	cvtdq2ps xmm0, xmm0
	addss	xmm1, xmm0
	movss	DWORD PTR _ent[edi+112], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN68@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN154@DrawString
$LN68@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN66@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN154@DrawString:
	movzx	eax, ax
$LN66@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 7052 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN73@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN155@DrawString
$LN73@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN71@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN155@DrawString:
	movzx	ecx, cx
$LN71@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx

; 7052 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR _st[eax*4+2732212]

; 7053 : 			ent[i].vertex[5]=z;
; 7054 : 
; 7055 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	movss	DWORD PTR _ent[edi+120], xmm6
	movss	xmm1, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm1, xmm4
	addss	xmm1, xmm0
	addss	xmm1, xmm5
	movss	DWORD PTR _ent[edi+116], xmm1

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN78@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN156@DrawString
$LN78@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN76@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN156@DrawString:
	movzx	eax, ax
$LN76@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, ax

; 7053 : 			ent[i].vertex[5]=z;
; 7054 : 
; 7055 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	mov	DWORD PTR _ang$1$[ebp], eax

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN83@DrawString
	lea	eax, DWORD PTR [esi-3600]
	movzx	eax, ax
	jmp	SHORT $LN157@DrawString
$LN83@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN81@DrawString
	lea	edx, DWORD PTR [esi+3600]
	movzx	eax, dx
$LN157@DrawString:
	mov	DWORD PTR _ang$1$[ebp], eax
$LN81@DrawString:

; 7053 : 			ent[i].vertex[5]=z;
; 7054 : 
; 7055 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	mov	eax, DWORD PTR _sizey$1$[ebp]
	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR _st[ecx*4+2717808]

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	ecx, 3600				; 00000e10H

; 7053 : 			ent[i].vertex[5]=z;
; 7054 : 
; 7055 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _x$1$[ebp]
	sar	eax, 1
	movd	xmm4, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	mov	eax, DWORD PTR _ang$1$[ebp]
	cwde

; 7053 : 			ent[i].vertex[5]=z;
; 7054 : 
; 7055 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtdq2ps xmm4, xmm4
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm4

; 7056 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0
	addss	xmm1, xmm0
	movss	DWORD PTR _ent[edi+124], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, cx
	jle	SHORT $LN88@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN158@DrawString
$LN88@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN86@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN158@DrawString:
	movzx	eax, ax
$LN86@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 7056 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, WORD PTR tv1976[ebp]
	jle	SHORT $LN93@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN159@DrawString
$LN93@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN91@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN159@DrawString:
	movzx	ecx, cx
$LN91@DrawString:

; 7056 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	mulss	xmm3, DWORD PTR _st[eax*4+2732212]

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx

; 7057 : 			ent[i].vertex[8]=z;

	movss	DWORD PTR _ent[edi+132], xmm6

; 7058 : 
; 7059 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	movss	xmm0, DWORD PTR _st[ecx*4+2717808]

; 217  : 	if(ang>3600) ang-=3600;

	mov	ecx, 3600				; 00000e10H

; 7056 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	mulss	xmm0, xmm4
	addss	xmm0, xmm3
	addss	xmm0, xmm5
	movss	DWORD PTR _ent[edi+128], xmm0

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, cx
	jle	SHORT $LN98@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN160@DrawString
$LN98@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN96@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN160@DrawString:
	movzx	eax, ax
$LN96@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	cwde

; 7058 : 
; 7059 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	ecx, si

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, WORD PTR tv1976[ebp]
	jle	SHORT $LN103@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN161@DrawString
$LN103@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN101@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN161@DrawString:
	movzx	ecx, cx
$LN101@DrawString:

; 7058 : 
; 7059 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR _st[eax*4+2717808]

; 227  : 
; 228  : 	return st.SinTable[ang];

	movsx	eax, cx

; 7058 : 
; 7059 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm4

; 7060 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 7058 : 
; 7059 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	addss	xmm1, xmm0
	movss	DWORD PTR _ent[edi+136], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN108@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN162@DrawString
$LN108@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN106@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN162@DrawString:
	movzx	eax, ax
$LN106@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 7060 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN113@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN163@DrawString
$LN113@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN111@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN163@DrawString:
	movzx	ecx, cx
$LN111@DrawString:

; 7060 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	mulss	xmm7, DWORD PTR _st[eax*4+2732212]

; 219  : 
; 220  : 	return st.CosTable[ang];

	mov	eax, 4
	movsx	ecx, cx
	movss	xmm3, DWORD PTR __real@39000000

; 7061 : 			ent[i].vertex[11]=z;

	movss	DWORD PTR _ent[edi+144], xmm6

; 7062 : 
; 7063 : 			/*
; 7064 : 			ang/=10;
; 7065 : 
; 7066 : 			tmp=cos((ang*pi)/180);
; 7067 : 			tmp=mCos(ang*10);
; 7068 : 	*/
; 7069 : 			ax=(float) 1/(GAME_WIDTH/2);
; 7070 : 			ay=(float) 1/(9216.0f/2);
; 7071 : 
; 7072 : 			ay*=-1.0f;
; 7073 : 
; 7074 : 			az=(float) 1/(4096/2);
; 7075 : 
; 7076 : 			
; 7077 : 				ent[i].texcor[0]=0;

	mov	DWORD PTR _ent[edi+148], 0
	movss	xmm0, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm0, xmm4

; 7078 : 				ent[i].texcor[1]=0;

	mov	DWORD PTR _ent[edi+152], 0

; 219  : 
; 220  : 	return st.CosTable[ang];

	movss	xmm4, DWORD PTR __real@39638e39

; 7079 : 				ent[i].texcor[2]=1;

	mov	DWORD PTR _ent[edi+156], 1065353216	; 3f800000H
	addss	xmm0, xmm7

; 7080 : 				ent[i].texcor[3]=0;

	mov	DWORD PTR _ent[edi+160], 0

; 7081 : 				ent[i].texcor[4]=1;

	mov	DWORD PTR _ent[edi+164], 1065353216	; 3f800000H

; 7082 : 				ent[i].texcor[5]=1;

	mov	DWORD PTR _ent[edi+168], 1065353216	; 3f800000H

; 7083 : 				ent[i].texcor[6]=0;

	mov	DWORD PTR _ent[edi+172], 0

; 7084 : 				ent[i].texcor[7]=1;

	mov	DWORD PTR _ent[edi+176], 1065353216	; 3f800000H
	addss	xmm0, xmm5

; 219  : 
; 220  : 	return st.CosTable[ang];

	movss	xmm5, DWORD PTR __real@3a000000

; 7060 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movss	DWORD PTR _ent[edi+140], xmm0
	npad	2
$LL6@DrawString:

; 7085 : 
; 7086 : 			for(j=0;j<12;j+=3)
; 7087 : 			{
; 7088 : 				ent[i].vertex[j]*=ax;

	movss	xmm0, DWORD PTR [ebx-4]

; 7089 : 				ent[i].vertex[j]-=1;
; 7090 : 
; 7091 : 				ent[i].vertex[j+1]*=ay;

	movss	xmm1, DWORD PTR [ebx]
	mulss	xmm0, xmm3
	mulss	xmm1, xmm4
	subss	xmm0, xmm2
	movss	DWORD PTR [ebx-4], xmm0

; 7092 : 				ent[i].vertex[j+1]+=1;

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [ebx], xmm0

; 7093 : 				
; 7094 : 				ent[i].vertex[j+2]*=az;

	movss	xmm0, DWORD PTR [ebx+4]
	mulss	xmm0, xmm5

; 7095 : 				ent[i].vertex[j+2]-=1;

	subss	xmm0, xmm2
	movss	DWORD PTR [ebx+4], xmm0
	add	ebx, 12					; 0000000cH
	dec	eax
	jne	SHORT $LL6@DrawString

; 7096 : 			}
; 7097 : 
; 7098 : 			for(j=0;j<16;j+=4)

	mov	cl, BYTE PTR _a$[ebp]
	mov	dl, BYTE PTR _b$1$[ebp]
	mov	bl, BYTE PTR _g$1$[ebp]
	mov	ch, BYTE PTR _r$[ebp]
	npad	7
$LL3@DrawString:

; 7099 : 			{
; 7100 : 				ent[i].color[j]=r;

	mov	BYTE PTR _ent[edi+eax+228], ch

; 7101 : 				ent[i].color[j+1]=g;

	mov	BYTE PTR _ent[edi+eax+229], bl

; 7102 : 				ent[i].color[j+2]=b;

	mov	BYTE PTR _ent[edi+eax+230], dl

; 7103 : 				ent[i].color[j+3]=a;

	mov	BYTE PTR _ent[edi+eax+231], cl
	add	eax, 4
	cmp	eax, 16					; 00000010H
	jb	SHORT $LL3@DrawString

; 7104 : 			}
; 7105 : 
; 7106 : 			
; 7107 : 				texone_ids[texone_num]=i;

	mov	cx, WORD PTR _texone_num
	mov	edx, DWORD PTR _i$2$[ebp]

; 7108 : 				texone_num++;
; 7109 : 
; 7110 : #endif
; 7111 : 
; 7112 : 			st.num_entities++;

	inc	DWORD PTR _st+244
	movzx	eax, cx
	inc	cx
	pop	esi
	pop	edi
	mov	WORD PTR _texone_num, cx
	mov	WORD PTR _texone_ids[eax*2], dx

; 7113 : 
; 7114 : 	return 0;

	xor	al, al
	pop	ebx

; 7115 : 
; 7116 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DrawStringUI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawString2UI
_TEXT	SEGMENT
tv1985 = -28						; size = 4
tv158 = -28						; size = 4
_x$1$ = -24						; size = 4
_ang$1$ = -20						; size = 4
_msg$1$ = -20						; size = 4
_text$1$ = -20						; size = 4
_sizex$1$ = -20						; size = 4
_i$2$ = -16						; size = 4
_ang$1$ = -12						; size = 4
_id$1$ = -12						; size = 4
tv2025 = -12						; size = 4
_sizey$1$ = -8						; size = 4
_co$ = -8						; size = 4
_g$1$ = -2						; size = 1
_b$1$ = -1						; size = 1
_y$ = 8							; size = 4
_sizex$ = 12						; size = 4
_sizey$ = 16						; size = 4
_ang$ = 20						; size = 2
_r$ = 24						; size = 1
_g$ = 28						; size = 1
_b$ = 32						; size = 1
_a$ = 36						; size = 1
_font$ = 40						; size = 1
_override_sizex$ = 44					; size = 4
_override_sizey$ = 48					; size = 4
_z$ = 52						; size = 1
_DrawString2UI PROC					; COMDAT
; _text$ = ecx
; _x$ = edx

; 7119 : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	edi
	mov	DWORD PTR _x$1$[ebp], edx

; 7120 : 	uint32 i=0, j=0, k=0, checked=0;
; 7121 : 	int32 t1, t2, t3, t4, timej, timel, id=-1;

	or	ebx, -1
	mov	edx, ecx
	mov	DWORD PTR _id$1$[ebp], ebx
	xor	edi, edi
	mov	DWORD PTR _text$1$[ebp], edx

; 7122 : 
; 7123 : 	SDL_Color co;
; 7124 : 	uint16 formatt;
; 7125 : 
; 7126 : 	float tmp, ax, ay, az;
; 7127 : 
; 7128 : 	uint8 val=0;
; 7129 : 	
; 7130 : 	SDL_Surface *msg;
; 7131 : 
; 7132 : 	if(st.num_entities==MAX_GRAPHICS-1)

	cmp	DWORD PTR _st+244, 2047			; 000007ffH
	jne	SHORT $LN34@DrawString

; 7133 : 		return 2;

	pop	edi
	mov	al, 2
	pop	ebx

; 7319 : 
; 7320 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@DrawString:
	push	esi

; 7134 : 
; 7135 : 	//Checkbounds(x,y,sizex,sizey,ang,GAME_WIDTH,GAME_HEIGHT)) return 1;
; 7136 : 
; 7137 : 	for(i=0;i<MAX_STRINGS;i++)

	xor	esi, esi
	npad	1
$LL33@DrawString:

; 7138 : 	{
; 7139 : 		if(st.strings[i].stat==2)

	imul	ecx, esi, 1068
	mov	al, BYTE PTR _st[ecx+2762084]
	cmp	al, 2
	jne	$LN30@DrawString

; 7140 : 		{
; 7141 : 			if(strcmp(text,st.strings[i].string)==NULL)

	lea	ecx, DWORD PTR _st[ecx+2761020]
	mov	eax, edx
	npad	4
$LL136@DrawString:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN137@DrawString
	test	dl, dl
	je	SHORT $LN138@DrawString
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN137@DrawString
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL136@DrawString
$LN138@DrawString:
	xor	eax, eax
	jmp	SHORT $LN139@DrawString
$LN137@DrawString:
	sbb	eax, eax
	or	eax, 1
$LN139@DrawString:
	test	eax, eax
	jne	$LN27@DrawString

; 7142 : 			{
; 7143 : 				st.strings[i].stat=1;

	imul	ecx, esi, 1068

; 7144 : 				j=st.num_entities;
; 7145 : 				st.strings[i].data.posx=i;
; 7146 : 				memcpy(&ent[j].data,&st.strings[i].data,sizeof(TEX_DATA));
; 7147 : 				id=i;

	mov	ebx, esi
	mov	DWORD PTR _id$1$[ebp], ebx

; 7148 : 				checked=1;

	mov	edi, 1
	mov	BYTE PTR _st[ecx+2762084], 1
	mov	eax, DWORD PTR _st+244
	imul	eax, eax, 264
	mov	WORD PTR _st[ecx+2762058], si
	movdqu	xmm0, XMMWORD PTR _st[ecx+2762044]
	add	eax, OFFSET _ent+44
	movdqu	XMMWORD PTR [eax], xmm0
	movdqu	xmm0, XMMWORD PTR _st[ecx+2762060]
	movdqu	XMMWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR _st[ecx+2762076]
	movq	QWORD PTR [eax+32], xmm0
$LN135@DrawString:

; 7172 : 			}
; 7173 : 		}
; 7174 : 	}
; 7175 : 
; 7176 : 	i=st.num_entities;

	mov	eax, DWORD PTR _st+244

; 7177 : 
; 7178 : 	if(checked==2)

	or	ecx, -1
	mov	DWORD PTR _i$2$[ebp], eax
	cmp	edi, 2
	jne	$LN22@DrawString

; 7179 : 	{
; 7180 : 
; 7181 : 		co.r=255;
; 7182 : 		co.g=255;
; 7183 : 		co.b=255;
; 7184 : 		co.a=255;
; 7185 : 	
; 7186 : 		if(strlen(text)==0) 

	mov	edx, DWORD PTR _text$1$[ebp]
	mov	DWORD PTR _co$[ebp], ecx
	mov	ecx, edx
	lea	esi, DWORD PTR [ecx+1]
$LL140@DrawString:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL140@DrawString

; 7187 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font," ",co);

	mov	eax, DWORD PTR _font$[ebp]
	push	DWORD PTR _co$[ebp]
	movzx	eax, al
	imul	eax, eax, 84
	sub	ecx, esi
	jne	$LN21@DrawString
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	DWORD PTR _st[eax+64344]
	call	DWORD PTR __imp__TTF_RenderUTF8_Blended
	mov	edx, eax
	mov	DWORD PTR _msg$1$[ebp], edx

; 7188 : 		else

	jmp	$LN146@DrawString
$LN30@DrawString:

; 7149 : 				break;
; 7150 : 			}
; 7151 : 		}
; 7152 : 		else
; 7153 : 		if(st.strings[i].stat==0 && checked==0)

	test	al, al
	jne	SHORT $LN27@DrawString
	test	edi, edi
	jne	SHORT $LN27@DrawString

; 7154 : 		{
; 7155 : 			checked=3;
; 7156 : 			id=i;

	mov	ebx, esi
	mov	edi, 3
	mov	DWORD PTR _id$1$[ebp], ebx
$LN27@DrawString:

; 7157 : 		}
; 7158 : 
; 7159 : 		if(i==MAX_STRINGS-1)

	cmp	esi, 511				; 000001ffH
	jne	SHORT $LN32@DrawString

; 7160 : 		{
; 7161 : 			if(id!=-1 && checked==3)

	cmp	ebx, -1
	je	SHORT $LN25@DrawString
	cmp	edi, 3
	jne	SHORT $LN25@DrawString

; 7162 : 			{
; 7163 : 				st.strings[id].stat=1;
; 7164 : 				strcpy(st.strings[id].string,text);

	mov	eax, DWORD PTR _text$1$[ebp]
	mov	ecx, eax
	imul	edx, ebx, 1068
	mov	BYTE PTR _st[edx+2762084], 1
	sub	edx, eax
	npad	2
$LL37@DrawString:
	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR _st[ecx+edx+2761019], al
	test	al, al
	jne	SHORT $LL37@DrawString

; 7165 : 				checked=2;

	mov	edi, 2

; 7166 : 			}
; 7167 : 			else

	jmp	SHORT $LN32@DrawString
$LN25@DrawString:

; 7168 : 			if(checked==0 && id==-1)

	test	edi, edi
	jne	SHORT $LN32@DrawString
	cmp	ebx, -1
	je	SHORT $LN123@DrawString
$LN32@DrawString:

; 7134 : 
; 7135 : 	//Checkbounds(x,y,sizex,sizey,ang,GAME_WIDTH,GAME_HEIGHT)) return 1;
; 7136 : 
; 7137 : 	for(i=0;i<MAX_STRINGS;i++)

	inc	esi
	cmp	esi, 512				; 00000200H
	jae	$LN135@DrawString
	mov	edx, DWORD PTR _text$1$[ebp]
	jmp	$LL33@DrawString
$LN123@DrawString:

; 7169 : 			{
; 7170 : 				LogApp("Warning: max number os strings reached");

	push	OFFSET ??_C@_0CH@GLOGGAHF@Warning?3?5max?5number?5os?5strings?5r@
	call	DWORD PTR __imp__SDL_Log
	add	esp, 4

; 7171 : 				return 2;

	mov	al, 2
	pop	esi
	pop	edi
	pop	ebx

; 7319 : 
; 7320 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@DrawString:

; 7189 : 			msg=TTF_RenderUTF8_Blended(st.fonts[font].font,text,co);

	push	edx
	push	DWORD PTR _st[eax+64344]
	call	DWORD PTR __imp__TTF_RenderUTF8_Blended
	mov	edx, eax
	mov	DWORD PTR _msg$1$[ebp], eax
$LN146@DrawString:

; 7190 : 	
; 7191 : 		if(msg->format->BytesPerPixel==4)

	mov	eax, DWORD PTR [edx+4]
	add	esp, 12					; 0000000cH
	cmp	BYTE PTR [eax+9], 4
	jne	SHORT $LN19@DrawString

; 7192 : 		{
; 7193 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGBA;

	mov	esi, 32993				; 000080e1H
	mov	ecx, 6408				; 00001908H

; 7194 : 			else formatt=GL_BGRA_EXT;
; 7195 : 		} else

	jmp	SHORT $LN147@DrawString
$LN19@DrawString:

; 7196 : 		{
; 7197 : 			if(msg->format->Rmask==0x000000ff) formatt=GL_RGB;

	mov	esi, 32992				; 000080e0H
	mov	ecx, 6407				; 00001907H
$LN147@DrawString:
	cmp	DWORD PTR [eax+12], 255			; 000000ffH
	cmove	esi, ecx

; 7198 : 			else formatt=GL_BGR_EXT;
; 7199 : 		}
; 7200 : 
; 7201 : 		glGenTextures(1,&ent[i].data.data);

	imul	edi, DWORD PTR _i$2$[ebp], 264
	lea	ebx, DWORD PTR _ent[edi+44]
	push	ebx
	push	1
	call	DWORD PTR __imp__glGenTextures@8

; 7202 : 		glBindTexture(GL_TEXTURE_2D,ent[i].data.data);

	push	DWORD PTR [ebx]
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 7203 : 		glTexImage2D(GL_TEXTURE_2D,0,msg->format->BytesPerPixel,msg->w,msg->h,0,formatt,GL_UNSIGNED_BYTE,msg->pixels);

	mov	ecx, DWORD PTR _msg$1$[ebp]
	movzx	eax, si
	push	DWORD PTR [ecx+20]
	push	5121					; 00001401H
	push	eax
	mov	eax, DWORD PTR [ecx+4]
	push	0
	push	DWORD PTR [ecx+12]
	push	DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [eax+9]
	push	eax
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36

; 7204 : 
; 7205 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	mov	esi, DWORD PTR __imp__glTexParameteri@12
	push	9729					; 00002601H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	esi

; 7206 : 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	push	9729					; 00002601H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	esi

; 7207 : 
; 7208 : 		ent[i].data.channel=63; //magical number only used for rendering
; 7209 : 
; 7210 : 		ent[i].data.posx=id;
; 7211 : 
; 7212 : 		ent[i].data.normal=0;
; 7213 : 		ent[i].data.vb_id=-1;
; 7214 : 
; 7215 : 		ent[i].data.w=msg->w;

	mov	edx, DWORD PTR _msg$1$[ebp]
	or	eax, -1
	mov	ecx, DWORD PTR _id$1$[ebp]
	mov	WORD PTR _ent[edi+54], ax
	mov	DWORD PTR _ent[edi+76], 63		; 0000003fH
	mov	WORD PTR _ent[edi+58], cx
	mov	BYTE PTR _ent[edi+52], 0
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _ent[edi+68], eax

; 7216 : 		ent[i].data.h=msg->h;

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _ent[edi+72], eax

; 7217 : 
; 7218 : 		memcpy(&st.strings[id].data,&ent[i].data,sizeof(TEX_DATA));

	movdqu	xmm0, XMMWORD PTR [ebx]

; 7219 : 
; 7220 : 		SDL_FreeSurface(msg);

	push	edx
	imul	eax, ecx, 1068
	add	eax, OFFSET _st+2762044
	movdqu	XMMWORD PTR [eax], xmm0
	movdqu	xmm0, XMMWORD PTR [ebx+16]
	movdqu	XMMWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [ebx+32]
	movq	QWORD PTR [eax+32], xmm0
	call	DWORD PTR __imp__SDL_FreeSurface
	mov	ebx, DWORD PTR _id$1$[ebp]
	add	esp, 4
	mov	eax, DWORD PTR _i$2$[ebp]
	or	ecx, -1
$LN22@DrawString:

; 7221 : 	}
; 7222 : 
; 7223 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 7224 : 
; 7225 : 	ent[i].lightmapid=-1;
; 7226 : 
; 7227 : 			
; 7228 : 			if(override_sizex!=0)

	movss	xmm2, DWORD PTR __real@3a800000
	imul	edi, eax, 264
	mov	WORD PTR _ent[edi+260], cx
	mov	ecx, DWORD PTR _override_sizex$[ebp]
	test	ecx, ecx
	je	SHORT $LN141@DrawString

; 7229 : 				sizex=st.strings[id].data.w*(float)(override_sizex/1024.0f);

	imul	eax, ebx, 1068
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	movd	xmm1, DWORD PTR _st[eax+2762068]
	cvtdq2ps xmm1, xmm1
	mulss	xmm0, xmm2
	mulss	xmm1, xmm0
	cvttss2si eax, xmm1
	jmp	SHORT $LN148@DrawString
$LN141@DrawString:
	mov	eax, DWORD PTR _sizex$[ebp]
$LN148@DrawString:

; 7230 : 
; 7231 : 			if(override_sizey!=0)

	mov	ecx, DWORD PTR _override_sizey$[ebp]
	mov	DWORD PTR _sizex$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN142@DrawString

; 7232 : 				sizey=st.strings[id].data.h*(float)(override_sizey/1024.0f);

	imul	eax, ebx, 1068
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	movd	xmm1, DWORD PTR _st[eax+2762072]
	cvtdq2ps xmm1, xmm1
	mulss	xmm0, xmm2
	mulss	xmm1, xmm0
	cvttss2si eax, xmm1
	jmp	SHORT $LN149@DrawString
$LN142@DrawString:
	mov	eax, DWORD PTR _sizey$[ebp]
$LN149@DrawString:

; 7233 : 
; 7234 : 			ent[i].texrepeat[0]=0.0f;
; 7235 : 			ent[i].texrepeat[1]=0.0f;
; 7236 : 			ent[i].texrepeat[2]=1.0f;
; 7237 : 			ent[i].texrepeat[3]=1.0f;
; 7238 : 
; 7239 : 			if(r==0 && g==0 && b==0)

	cmp	BYTE PTR _r$[ebp], 0
	movss	xmm2, DWORD PTR __real@3f800000
	mov	DWORD PTR _sizey$1$[ebp], eax
	mov	al, BYTE PTR _b$[ebp]
	mov	DWORD PTR _ent[edi+212], 0
	mov	DWORD PTR _ent[edi+216], 0
	mov	DWORD PTR _ent[edi+220], 1065353216	; 3f800000H
	mov	DWORD PTR _ent[edi+224], 1065353216	; 3f800000H
	mov	BYTE PTR _b$1$[ebp], al
	jne	SHORT $LN143@DrawString
	mov	cl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _g$1$[ebp], cl
	test	cl, cl
	jne	SHORT $LN11@DrawString
	test	al, al
	jne	SHORT $LN11@DrawString

; 7240 : 				r=g=b=1;

	mov	BYTE PTR _b$1$[ebp], 1
	mov	BYTE PTR _g$1$[ebp], 1
	mov	BYTE PTR _r$[ebp], 1
	jmp	SHORT $LN11@DrawString
$LN143@DrawString:
	mov	al, BYTE PTR _g$[ebp]
	mov	BYTE PTR _g$1$[ebp], al
$LN11@DrawString:

; 7241 : 
; 7242 : 			if(z>15) z=15;

	mov	bl, BYTE PTR _z$[ebp]
	cmp	bl, 15					; 0000000fH
	jle	SHORT $LN10@DrawString
	mov	bl, 15					; 0000000fH
	jmp	SHORT $LN8@DrawString
$LN10@DrawString:

; 7243 : 			else if(z<8) z+=8;

	cmp	bl, 8
	jge	SHORT $LN8@DrawString
	add	bl, 8
$LN8@DrawString:

; 7244 : 
; 7245 : 			z_buffer[z][z_slot[z]]=i;

	movsx	esi, bl
	mov	ecx, esi
	mov	DWORD PTR tv2025[ebp], esi
	shl	ecx, 11					; 0000000bH
	movzx	edx, WORD PTR _z_slot[esi*2]
	movsx	eax, dx
	add	ecx, eax
	mov	eax, DWORD PTR _i$2$[ebp]

; 7246 : 			z_slot[z]++;
; 7247 : 
; 7248 : 			if(z>z_used) z_used=z;

	cmp	bl, BYTE PTR _z_used
	mov	WORD PTR _z_buffer[ecx*2], ax
	lea	eax, DWORD PTR [edx+1]
	movzx	edx, BYTE PTR _z_used
	mov	WORD PTR _z_slot[esi*2], ax

; 7249 : 
; 7250 : 			//timej=GetTicks();
; 7251 : 
; 7252 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	mov	esi, DWORD PTR _ang$[ebp]
	movzx	eax, bl
	cmovg	edx, eax
	movzx	eax, si
	mov	BYTE PTR _z_used, dl

; 217  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H
	mov	DWORD PTR tv1985[ebp], edx
	cmp	si, dx
	jle	SHORT $LN40@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN150@DrawString
$LN40@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN38@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN150@DrawString:
	movzx	eax, ax
$LN38@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, ax

; 7249 : 
; 7250 : 			//timej=GetTicks();
; 7251 : 
; 7252 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	ebx, si

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN45@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN151@DrawString
$LN45@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN43@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN151@DrawString:
	movzx	ebx, ax
$LN43@DrawString:

; 7249 : 
; 7250 : 			//timej=GetTicks();
; 7251 : 
; 7252 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	mov	eax, DWORD PTR _sizex$1$[ebp]
	cdq
	sub	eax, edx
	movd	xmm3, DWORD PTR _x$1$[ebp]
	sar	eax, 1
	neg	eax
	cvtdq2ps xmm3, xmm3
	movd	xmm7, eax
	mov	eax, DWORD PTR _sizey$1$[ebp]
	cdq
	sub	eax, edx

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 7249 : 
; 7250 : 			//timej=GetTicks();
; 7251 : 
; 7252 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	sar	eax, 1
	neg	eax
	cvtdq2ps xmm7, xmm7
	movd	xmm4, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	movsx	eax, bx

; 7249 : 
; 7250 : 			//timej=GetTicks();
; 7251 : 
; 7252 : 			ent[i].vertex[0]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR _st[ecx*4+2717808]
	cvtdq2ps xmm4, xmm4
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm4

; 7253 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	addss	xmm1, xmm3
	movss	DWORD PTR _ent[edi+100], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN50@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN152@DrawString
$LN50@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN48@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN152@DrawString:
	movzx	eax, ax
$LN48@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 7253 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN55@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN153@DrawString
$LN55@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN53@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN153@DrawString:
	movzx	ecx, cx
$LN53@DrawString:
	movd	xmm5, DWORD PTR _y$[ebp]

; 7253 : 			ent[i].vertex[1]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR _st[eax*4+2732212]
	lea	ebx, DWORD PTR _ent[edi+104]

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx
	movd	xmm6, DWORD PTR tv2025[ebp]

; 7254 : 			ent[i].vertex[2]=z;
; 7255 : 
; 7256 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	cvtdq2ps xmm5, xmm5
	movss	xmm1, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm1, xmm4
	cvtdq2ps xmm6, xmm6
	addss	xmm1, xmm0
	movss	DWORD PTR _ent[edi+108], xmm6
	addss	xmm1, xmm5
	movss	DWORD PTR [ebx], xmm1

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN60@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN154@DrawString
$LN60@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN58@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN154@DrawString:
	movzx	eax, ax
$LN58@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, ax

; 7254 : 			ent[i].vertex[2]=z;
; 7255 : 
; 7256 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	mov	DWORD PTR _ang$1$[ebp], eax

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN65@DrawString
	lea	eax, DWORD PTR [esi-3600]
	movzx	eax, ax
	jmp	SHORT $LN155@DrawString
$LN65@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN63@DrawString
	lea	edx, DWORD PTR [esi+3600]
	movzx	eax, dx
$LN155@DrawString:
	mov	DWORD PTR _ang$1$[ebp], eax
$LN63@DrawString:

; 7254 : 			ent[i].vertex[2]=z;
; 7255 : 
; 7256 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	mov	eax, DWORD PTR _sizex$1$[ebp]
	cdq
	sub	eax, edx

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 7254 : 			ent[i].vertex[2]=z;
; 7255 : 
; 7256 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	sar	eax, 1
	movd	xmm3, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	mov	eax, DWORD PTR _ang$1$[ebp]
	cwde

; 7254 : 			ent[i].vertex[2]=z;
; 7255 : 
; 7256 : 			ent[i].vertex[3]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y-(sizey/2))-y)*mSin(ang));

	cvtdq2ps xmm3, xmm3
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mov	eax, DWORD PTR _x$1$[ebp]
	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm0, xmm4
	subss	xmm1, xmm0
	movd	xmm0, eax

; 7257 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	cvtdq2ps xmm0, xmm0
	addss	xmm1, xmm0
	movss	DWORD PTR _ent[edi+112], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN70@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN156@DrawString
$LN70@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN68@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN156@DrawString:
	movzx	eax, ax
$LN68@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 7257 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN75@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN157@DrawString
$LN75@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN73@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN157@DrawString:
	movzx	ecx, cx
$LN73@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx

; 7257 : 			ent[i].vertex[4]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y-(sizey/2))-y)*mCos(ang));

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR _st[eax*4+2732212]

; 7258 : 			ent[i].vertex[5]=z;
; 7259 : 
; 7260 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	movss	DWORD PTR _ent[edi+120], xmm6
	movss	xmm1, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm1, xmm4
	addss	xmm1, xmm0
	addss	xmm1, xmm5
	movss	DWORD PTR _ent[edi+116], xmm1

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN80@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN158@DrawString
$LN80@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN78@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN158@DrawString:
	movzx	eax, ax
$LN78@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, ax

; 7258 : 			ent[i].vertex[5]=z;
; 7259 : 
; 7260 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	mov	DWORD PTR _ang$1$[ebp], eax

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN85@DrawString
	lea	eax, DWORD PTR [esi-3600]
	movzx	eax, ax
	jmp	SHORT $LN159@DrawString
$LN85@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN83@DrawString
	lea	edx, DWORD PTR [esi+3600]
	movzx	eax, dx
$LN159@DrawString:
	mov	DWORD PTR _ang$1$[ebp], eax
$LN83@DrawString:

; 7258 : 			ent[i].vertex[5]=z;
; 7259 : 
; 7260 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	mov	eax, DWORD PTR _sizey$1$[ebp]
	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR _st[ecx*4+2717808]

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	ecx, 3600				; 00000e10H

; 7258 : 			ent[i].vertex[5]=z;
; 7259 : 
; 7260 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _x$1$[ebp]
	sar	eax, 1
	movd	xmm4, eax

; 227  : 
; 228  : 	return st.SinTable[ang];

	mov	eax, DWORD PTR _ang$1$[ebp]
	cwde

; 7258 : 			ent[i].vertex[5]=z;
; 7259 : 
; 7260 : 			ent[i].vertex[6]=(float)x+(((x+(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	cvtdq2ps xmm4, xmm4
	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm4

; 7261 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0
	addss	xmm1, xmm0
	movss	DWORD PTR _ent[edi+124], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, cx
	jle	SHORT $LN90@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN160@DrawString
$LN90@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN88@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN160@DrawString:
	movzx	eax, ax
$LN88@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 7261 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, WORD PTR tv1985[ebp]
	jle	SHORT $LN95@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN161@DrawString
$LN95@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN93@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN161@DrawString:
	movzx	ecx, cx
$LN93@DrawString:

; 7261 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	mulss	xmm3, DWORD PTR _st[eax*4+2732212]

; 219  : 
; 220  : 	return st.CosTable[ang];

	movsx	ecx, cx

; 7262 : 			ent[i].vertex[8]=z;

	movss	DWORD PTR _ent[edi+132], xmm6

; 7263 : 
; 7264 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	eax, si
	movss	xmm0, DWORD PTR _st[ecx*4+2717808]

; 217  : 	if(ang>3600) ang-=3600;

	mov	ecx, 3600				; 00000e10H

; 7261 : 			ent[i].vertex[7]=(float)y+(((x+(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	mulss	xmm0, xmm4
	addss	xmm0, xmm3
	addss	xmm0, xmm5
	movss	DWORD PTR _ent[edi+128], xmm0

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, cx
	jle	SHORT $LN100@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN162@DrawString
$LN100@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN98@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN162@DrawString:
	movzx	eax, ax
$LN98@DrawString:

; 219  : 
; 220  : 	return st.CosTable[ang];

	cwde

; 7263 : 
; 7264 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movzx	ecx, si

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, WORD PTR tv1985[ebp]
	jle	SHORT $LN105@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN163@DrawString
$LN105@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN103@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN163@DrawString:
	movzx	ecx, cx
$LN103@DrawString:

; 7263 : 
; 7264 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR _st[eax*4+2717808]

; 227  : 
; 228  : 	return st.SinTable[ang];

	movsx	eax, cx

; 7263 : 
; 7264 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	movss	xmm0, DWORD PTR _st[eax*4+2732212]
	mulss	xmm0, xmm4

; 7265 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	eax, si
	subss	xmm1, xmm0
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	mov	edx, 3600				; 00000e10H

; 7263 : 
; 7264 : 			ent[i].vertex[9]=(float)x+(((x-(sizex/2))-x)*mCos(ang) - ((y+(sizey/2))-y)*mSin(ang));

	addss	xmm1, xmm0
	movss	DWORD PTR _ent[edi+136], xmm1

; 221  : }
; 222  : 
; 223  : float mSin(int16 ang)
; 224  : {
; 225  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN110@DrawString
	lea	eax, DWORD PTR [esi-3600]
	jmp	SHORT $LN164@DrawString
$LN110@DrawString:

; 226  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN108@DrawString
	lea	eax, DWORD PTR [esi+3600]
$LN164@DrawString:
	movzx	eax, ax
$LN108@DrawString:

; 227  : 
; 228  : 	return st.SinTable[ang];

	cwde

; 7265 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movzx	ecx, si

; 217  : 	if(ang>3600) ang-=3600;

	cmp	si, dx
	jle	SHORT $LN115@DrawString
	lea	ecx, DWORD PTR [esi-3600]
	jmp	SHORT $LN165@DrawString
$LN115@DrawString:

; 218  : 	else if(ang<0) ang+=3600;

	test	si, si
	jns	SHORT $LN113@DrawString
	lea	ecx, DWORD PTR [esi+3600]
$LN165@DrawString:
	movzx	ecx, cx
$LN113@DrawString:

; 7265 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	mulss	xmm7, DWORD PTR _st[eax*4+2732212]

; 219  : 
; 220  : 	return st.CosTable[ang];

	mov	eax, 4
	movsx	ecx, cx
	movss	xmm3, DWORD PTR __real@39000000

; 7266 : 			ent[i].vertex[11]=z;

	movss	DWORD PTR _ent[edi+144], xmm6

; 7267 : 			/*
; 7268 : 			ang/=10;
; 7269 : 
; 7270 : 			tmp=cos((ang*pi)/180);
; 7271 : 			tmp=mCos(ang*10);
; 7272 : 	*/
; 7273 : 			ax=(float) 1/(GAME_WIDTH/2);
; 7274 : 			ay=(float) 1/(9216.0f/2);
; 7275 : 
; 7276 : 			ay*=-1.0f;
; 7277 : 
; 7278 : 			az=(float) 1/(4096/2);
; 7279 : 
; 7280 : 			
; 7281 : 				ent[i].texcor[0]=0;

	mov	DWORD PTR _ent[edi+148], 0
	movss	xmm0, DWORD PTR _st[ecx*4+2717808]
	mulss	xmm0, xmm4

; 7282 : 				ent[i].texcor[1]=0;

	mov	DWORD PTR _ent[edi+152], 0

; 219  : 
; 220  : 	return st.CosTable[ang];

	movss	xmm4, DWORD PTR __real@39638e39

; 7283 : 				ent[i].texcor[2]=1;

	mov	DWORD PTR _ent[edi+156], 1065353216	; 3f800000H
	addss	xmm0, xmm7

; 7284 : 				ent[i].texcor[3]=0;

	mov	DWORD PTR _ent[edi+160], 0

; 7285 : 				ent[i].texcor[4]=1;

	mov	DWORD PTR _ent[edi+164], 1065353216	; 3f800000H

; 7286 : 				ent[i].texcor[5]=1;

	mov	DWORD PTR _ent[edi+168], 1065353216	; 3f800000H

; 7287 : 				ent[i].texcor[6]=0;

	mov	DWORD PTR _ent[edi+172], 0

; 7288 : 				ent[i].texcor[7]=1;

	mov	DWORD PTR _ent[edi+176], 1065353216	; 3f800000H
	addss	xmm0, xmm5

; 219  : 
; 220  : 	return st.CosTable[ang];

	movss	xmm5, DWORD PTR __real@3a000000

; 7265 : 			ent[i].vertex[10]=(float)y+(((x-(sizex/2))-x)*mSin(ang) + ((y+(sizey/2))-y)*mCos(ang));

	movss	DWORD PTR _ent[edi+140], xmm0
	npad	3
$LL6@DrawString:

; 7289 : 
; 7290 : 			for(j=0;j<12;j+=3)
; 7291 : 			{
; 7292 : 				ent[i].vertex[j]*=ax;

	movss	xmm0, DWORD PTR [ebx-4]

; 7293 : 				ent[i].vertex[j]-=1;
; 7294 : 
; 7295 : 				ent[i].vertex[j+1]*=ay;

	movss	xmm1, DWORD PTR [ebx]
	mulss	xmm0, xmm3
	mulss	xmm1, xmm4
	subss	xmm0, xmm2
	movss	DWORD PTR [ebx-4], xmm0

; 7296 : 				ent[i].vertex[j+1]+=1;

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [ebx], xmm0

; 7297 : 				
; 7298 : 				ent[i].vertex[j+2]*=az;

	movss	xmm0, DWORD PTR [ebx+4]
	mulss	xmm0, xmm5

; 7299 : 				ent[i].vertex[j+2]-=1;

	subss	xmm0, xmm2
	movss	DWORD PTR [ebx+4], xmm0
	add	ebx, 12					; 0000000cH
	dec	eax
	jne	SHORT $LL6@DrawString

; 7300 : 			}
; 7301 : 
; 7302 : 			for(j=0;j<16;j+=4)

	mov	cl, BYTE PTR _a$[ebp]
	mov	dl, BYTE PTR _b$1$[ebp]
	mov	bl, BYTE PTR _g$1$[ebp]
	mov	ch, BYTE PTR _r$[ebp]
	npad	7
$LL3@DrawString:

; 7303 : 			{
; 7304 : 				ent[i].color[j]=r;

	mov	BYTE PTR _ent[edi+eax+228], ch

; 7305 : 				ent[i].color[j+1]=g;

	mov	BYTE PTR _ent[edi+eax+229], bl

; 7306 : 				ent[i].color[j+2]=b;

	mov	BYTE PTR _ent[edi+eax+230], dl

; 7307 : 				ent[i].color[j+3]=a;

	mov	BYTE PTR _ent[edi+eax+231], cl
	add	eax, 4
	cmp	eax, 16					; 00000010H
	jb	SHORT $LL3@DrawString

; 7308 : 			}
; 7309 : 
; 7310 : 			
; 7311 : 				texone_ids[texone_num]=i;

	mov	cx, WORD PTR _texone_num
	mov	edx, DWORD PTR _i$2$[ebp]

; 7312 : 				texone_num++;
; 7313 : 
; 7314 : #endif
; 7315 : 
; 7316 : 			st.num_entities++;

	inc	DWORD PTR _st+244
	movzx	eax, cx
	inc	cx
	pop	esi
	pop	edi
	mov	WORD PTR _texone_num, cx
	mov	WORD PTR _texone_ids[eax*2], dx

; 7317 : 
; 7318 : 	return 0;

	xor	al, al
	pop	ebx

; 7319 : 
; 7320 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DrawString2UI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _DrawSys
_TEXT	SEGMENT
_DrawSys PROC						; COMDAT

; 8615 : {

	push	esi

; 8616 : 	register uint16 i=0;
; 8617 : 
; 8618 : 	for(i=0;i<st.num_calls;i++)

	xor	eax, eax
	xor	esi, esi
	cmp	ax, WORD PTR _st+262
	jae	$LN9@DrawSys
	npad	14
$LL11@DrawSys:

; 8619 : 	{
; 8620 : 		switch(st.renderer.ppline[i].type)

	movzx	eax, si
	imul	eax, eax, 372
	movzx	ecx, BYTE PTR _st[eax+2336876]
	cmp	ecx, 8
	ja	$LN10@DrawSys
	jmp	DWORD PTR $LN20@DrawSys[ecx*4]
$LN6@DrawSys:

; 8621 : 		{	
; 8622 : #ifndef MGEAR_CLEAN_VERSION
; 8623 : 			case GRAPHICS_CALL: DrawGraphic(st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,st.renderer.ppline[i].color.r,
; 8624 : 									st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].data,st.renderer.ppline[i].color.a,st.renderer.ppline[i].tex_panx,st.renderer.ppline[i].tex_pany,
; 8625 : 									st.renderer.ppline[i].tex_sizex,st.renderer.ppline[i].tex_sizey,st.renderer.ppline[i].pos.z,0); break;
; 8626 : 
; 8627 : 			case HUD_CALL: DrawHud(st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,st.renderer.ppline[i].color.r,
; 8628 : 							  st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].tex_panx,st.renderer.ppline[i].tex_pany,st.renderer.ppline[i].tex_sizex,
; 8629 : 							  st.renderer.ppline[i].tex_sizey,st.renderer.ppline[i].data,st.renderer.ppline[i].color.a,st.renderer.ppline[i].pos.z); break;
; 8630 : #endif
; 8631 : 			case UI_CALL: DrawUI(st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,st.renderer.ppline[i].color.r,
; 8632 : 							  st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].tex_panx,st.renderer.ppline[i].tex_pany,st.renderer.ppline[i].tex_sizex,
; 8633 : 							  st.renderer.ppline[i].tex_sizey,st.renderer.ppline[i].data,st.renderer.ppline[i].color.a,st.renderer.ppline[i].pos.z); break;

	movzx	ecx, BYTE PTR _st[eax+2336888]
	movdqu	xmm0, XMMWORD PTR _st[eax+2337208]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336931]
	push	ecx
	sub	esp, 40					; 00000028H
	mov	edx, DWORD PTR _st[eax+2336884]
	mov	ecx, esp
	push	DWORD PTR _st[eax+2337200]
	movdqu	XMMWORD PTR [ecx], xmm0
	push	DWORD PTR _st[eax+2337196]
	movdqu	xmm0, XMMWORD PTR _st[eax+2337224]
	push	DWORD PTR _st[eax+2337192]
	movdqu	XMMWORD PTR [ecx+16], xmm0
	push	DWORD PTR _st[eax+2337188]
	movq	xmm0, QWORD PTR _st[eax+2337240]
	movq	QWORD PTR [ecx+32], xmm0
	movzx	ecx, BYTE PTR _st[eax+2336930]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336929]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336928]
	push	ecx
	movzx	ecx, WORD PTR _st[eax+2337204]
	push	ecx
	push	DWORD PTR _st[eax+2336908]
	mov	ecx, DWORD PTR _st[eax+2336880]
	push	DWORD PTR _st[eax+2336904]
	call	_DrawUI
	add	esp, 88					; 00000058H
	jmp	$LN10@DrawSys
$LN5@DrawSys:

; 8634 : #ifndef MGEAR_CLEAN_VERSION
; 8635 : 			case STRING_CALL: DrawString(st.renderer.ppline[i].text,st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,
; 8636 : 								  st.renderer.ppline[i].color.r,st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].color.a,st.renderer.ppline[i].font,st.renderer.ppline[i].size2.x,
; 8637 : 								  st.renderer.ppline[i].size2.y,st.renderer.ppline[i].pos.z); break;
; 8638 : #endif
; 8639 : 			case STRING2_CALL: DrawString2(st.renderer.ppline[i].text,st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,
; 8640 : 								  st.renderer.ppline[i].color.r,st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].color.a,st.renderer.ppline[i].font,st.renderer.ppline[i].size2.x,
; 8641 : 								  st.renderer.ppline[i].size2.y,st.renderer.ppline[i].pos.z); break;

	movzx	ecx, BYTE PTR _st[eax+2336888]
	push	ecx
	push	DWORD PTR _st[eax+2336920]
	movzx	ecx, BYTE PTR _st[eax+2337206]
	push	DWORD PTR _st[eax+2336916]
	mov	edx, DWORD PTR _st[eax+2336880]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336931]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336930]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336929]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336928]
	push	ecx
	movzx	ecx, WORD PTR _st[eax+2337204]
	push	ecx
	push	DWORD PTR _st[eax+2336908]
	lea	ecx, DWORD PTR _st[eax+2336932]
	push	DWORD PTR _st[eax+2336904]
	push	DWORD PTR _st[eax+2336884]
	call	_DrawString2
	jmp	$LN18@DrawSys
$LN4@DrawSys:

; 8642 : 
; 8643 : 			case STRINGUI_CALL: DrawStringUI(st.renderer.ppline[i].text,st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,
; 8644 : 								  st.renderer.ppline[i].color.r,st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].color.a,st.renderer.ppline[i].font,st.renderer.ppline[i].size2.x,
; 8645 : 								  st.renderer.ppline[i].size2.y,st.renderer.ppline[i].pos.z); break;

	movzx	ecx, BYTE PTR _st[eax+2336888]
	push	ecx
	push	DWORD PTR _st[eax+2336920]
	movzx	ecx, BYTE PTR _st[eax+2337206]
	push	DWORD PTR _st[eax+2336916]
	mov	edx, DWORD PTR _st[eax+2336880]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336931]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336930]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336929]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336928]
	push	ecx
	movzx	ecx, WORD PTR _st[eax+2337204]
	push	ecx
	push	DWORD PTR _st[eax+2336908]
	lea	ecx, DWORD PTR _st[eax+2336932]
	push	DWORD PTR _st[eax+2336904]
	push	DWORD PTR _st[eax+2336884]
	call	_DrawStringUI
	jmp	$LN18@DrawSys
$LN3@DrawSys:

; 8646 : 
; 8647 : 			case STRINGUI2_CALL: DrawString2UI(st.renderer.ppline[i].text,st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,
; 8648 : 								  st.renderer.ppline[i].color.r,st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].color.a,st.renderer.ppline[i].font,st.renderer.ppline[i].size2.x,
; 8649 : 								  st.renderer.ppline[i].size2.y,st.renderer.ppline[i].pos.z); break;

	movzx	ecx, BYTE PTR _st[eax+2336888]
	push	ecx
	push	DWORD PTR _st[eax+2336920]
	movzx	ecx, BYTE PTR _st[eax+2337206]
	push	DWORD PTR _st[eax+2336916]
	mov	edx, DWORD PTR _st[eax+2336880]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336931]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336930]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336929]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336928]
	push	ecx
	movzx	ecx, WORD PTR _st[eax+2337204]
	push	ecx
	push	DWORD PTR _st[eax+2336908]
	lea	ecx, DWORD PTR _st[eax+2336932]
	push	DWORD PTR _st[eax+2336904]
	push	DWORD PTR _st[eax+2336884]
	call	_DrawString2UI
	jmp	$LN18@DrawSys
$LN2@DrawSys:

; 8650 : 
; 8651 : 			case LINE_CALL: DrawLine(st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].pos2.x,st.renderer.ppline[i].pos2.y,st.renderer.ppline[i].color.r,st.renderer.ppline[i].color.g,
; 8652 : 								st.renderer.ppline[i].color.b,st.renderer.ppline[i].color.a,st.renderer.ppline[i].size.x,st.renderer.ppline[i].pos.z); break;

	push	DWORD PTR _st[eax+2336888]
	movzx	ecx, WORD PTR _st[eax+2336904]
	mov	edx, DWORD PTR _st[eax+2336884]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336931]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336930]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336929]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336928]
	push	ecx
	push	DWORD PTR _st[eax+2336896]
	mov	ecx, DWORD PTR _st[eax+2336880]
	push	DWORD PTR _st[eax+2336892]
	call	_DrawLine
	add	esp, 32					; 00000020H
	jmp	SHORT $LN10@DrawSys
$LN1@DrawSys:

; 8653 : 
; 8654 : 			case STRINGUIV_CALL: DrawStringUIv(st.renderer.ppline[i].text,st.renderer.ppline[i].pos.x,st.renderer.ppline[i].pos.y,st.renderer.ppline[i].size.x,st.renderer.ppline[i].size.y,st.renderer.ppline[i].ang,
; 8655 : 								  st.renderer.ppline[i].color.r,st.renderer.ppline[i].color.g,st.renderer.ppline[i].color.b,st.renderer.ppline[i].color.a,st.renderer.ppline[i].font,st.renderer.ppline[i].size2.x,
; 8656 : 								  st.renderer.ppline[i].size2.y,st.renderer.ppline[i].pos.z); break;

	movzx	ecx, BYTE PTR _st[eax+2336888]
	push	ecx
	push	DWORD PTR _st[eax+2336920]
	movzx	ecx, BYTE PTR _st[eax+2337206]
	push	DWORD PTR _st[eax+2336916]
	mov	edx, DWORD PTR _st[eax+2336880]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336931]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336930]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336929]
	push	ecx
	movzx	ecx, BYTE PTR _st[eax+2336928]
	push	ecx
	movzx	ecx, WORD PTR _st[eax+2337204]
	push	ecx
	push	DWORD PTR _st[eax+2336908]
	lea	ecx, DWORD PTR _st[eax+2336932]
	push	DWORD PTR _st[eax+2336904]
	push	DWORD PTR _st[eax+2336884]
	call	_DrawStringUIv
$LN18@DrawSys:
	add	esp, 48					; 00000030H
$LN10@DrawSys:

; 8616 : 	register uint16 i=0;
; 8617 : 
; 8618 : 	for(i=0;i<st.num_calls;i++)

	inc	esi
	cmp	si, WORD PTR _st+262
	jb	$LL11@DrawSys
$LN9@DrawSys:

; 8657 : 		}
; 8658 : 	}
; 8659 : 
; 8660 : 	//Finish();
; 8661 : }

	pop	esi
	ret	0
	npad	2
$LN20@DrawSys:
	DD	$LN6@DrawSys
	DD	$LN10@DrawSys
	DD	$LN2@DrawSys
	DD	$LN10@DrawSys
	DD	$LN10@DrawSys
	DD	$LN5@DrawSys
	DD	$LN4@DrawSys
	DD	$LN3@DrawSys
	DD	$LN1@DrawSys
_DrawSys ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _Renderer
_TEXT	SEGMENT
tv2038 = -36						; size = 4
tv1984 = -36						; size = 4
tv2013 = -32						; size = 4
tv1953 = -32						; size = 4
tv2012 = -28						; size = 4
_j$2$ = -24						; size = 4
_i$1$ = -24						; size = 4
tv2040 = -24						; size = 4
tv1759 = -24						; size = 4
_n$1$ = -20						; size = 4
tv1970 = -20						; size = 4
tv2014 = -16						; size = 4
tv1988 = -16						; size = 4
_tex_bound$1$ = -12					; size = 4
_tex_bound$2$ = -8					; size = 4
_k$1$ = -4						; size = 4
_i$4$ = -4						; size = 4
_Renderer PROC						; COMDAT
; _type$dead$ = cl

; 8664 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi

; 8667 : 	GLenum error;
; 8668 : 
; 8669 : 	uint32 num_targets=0;
; 8670 : 	 int32 i=0, j=0, m=0, timej, timel, n=0;
; 8671 : 	uint16 *k, l=0;
; 8672 : 
; 8673 : 	static uint32 tesg=0;
; 8674 : 
; 8675 : 	int8 mrt=0;
; 8676 : 
; 8677 : 	float m1, m2;
; 8678 : 
; 8679 : 	float vertex[12]={
; 8680 : 		-1,-1,0, 1,-1,0,
; 8681 : 		1,1,0, -1,1,0 };
; 8682 : 
; 8683 : 	float texcoord[8]={
; 8684 : 		0,0, 1,0,
; 8685 : 		1,1, 0,1 };
; 8686 : 
; 8687 : 	float tile[2];
; 8688 : 
; 8689 : 	GLuint fbo, fbr, txo=0, txr, cat[1]={ GL_COLOR_ATTACHMENT0 };
; 8690 : 
; 8691 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 8692 : 
; 8693 : //if(tesg==0)
; 8694 : //{
; 8695 : 	for(i=0;i<vbdt_num;i++)

	movzx	edi, WORD PTR _vbdt_num
	mov	DWORD PTR _tex_bound$1$[ebp], -1
	mov	DWORD PTR _tex_bound$2$[ebp], -1
	test	edi, edi
	jle	SHORT $LN82@Renderer

; 8665 : 
; 8666 : 	GLint unif, texcat, vertat, pos, col, texc, tex_bound[2]= { -1, -1 };

	mov	ebx, DWORD PTR _vbdt
	mov	ecx, edi
	add	ebx, 46					; 0000002eH
	mov	DWORD PTR tv2040[ebp], edi
$LL84@Renderer:

; 8696 : 	{
; 8697 : 		if(vbdt[i].num_elements>0)

	movzx	eax, WORD PTR [ebx]
	test	ax, ax
	je	SHORT $LN83@Renderer

; 8698 : 		{
; 8699 : 			vbdt[i].vertex=(float*) calloc(vbdt[i].num_elements*12,sizeof(float));

	mov	edi, eax
	push	4
	lea	eax, DWORD PTR [edi+edi*2]
	shl	eax, 2
	push	eax
	call	_calloc

; 8700 : 			vbdt[i].texcoord=(float*) calloc(vbdt[i].num_elements*8,sizeof(float));

	lea	esi, DWORD PTR [edi*8]
	mov	DWORD PTR [ebx-34], eax
	push	4
	push	esi
	call	_calloc
	mov	DWORD PTR [ebx-30], eax

; 8701 : 			vbdt[i].index=(GLushort*) calloc(vbdt[i].num_elements*6,sizeof(GLushort));

	lea	eax, DWORD PTR [edi+edi*2]
	add	eax, eax
	push	2
	push	eax
	call	_calloc

; 8702 : 			vbdt[i].color=(GLubyte*) calloc(vbdt[i].num_elements*16,sizeof(GLubyte));

	push	1
	shl	edi, 4
	push	edi
	mov	DWORD PTR [ebx-14], eax
	call	_calloc

; 8703 : 			vbdt[i].texcoordlight=(float*) calloc(vbdt[i].num_elements*8,sizeof(float));

	push	4
	push	esi
	mov	DWORD PTR [ebx-18], eax
	call	_calloc
	mov	ecx, DWORD PTR tv2040[ebp]
	add	esp, 40					; 00000028H
	mov	DWORD PTR [ebx-26], eax
$LN83@Renderer:

; 8667 : 	GLenum error;
; 8668 : 
; 8669 : 	uint32 num_targets=0;
; 8670 : 	 int32 i=0, j=0, m=0, timej, timel, n=0;
; 8671 : 	uint16 *k, l=0;
; 8672 : 
; 8673 : 	static uint32 tesg=0;
; 8674 : 
; 8675 : 	int8 mrt=0;
; 8676 : 
; 8677 : 	float m1, m2;
; 8678 : 
; 8679 : 	float vertex[12]={
; 8680 : 		-1,-1,0, 1,-1,0,
; 8681 : 		1,1,0, -1,1,0 };
; 8682 : 
; 8683 : 	float texcoord[8]={
; 8684 : 		0,0, 1,0,
; 8685 : 		1,1, 0,1 };
; 8686 : 
; 8687 : 	float tile[2];
; 8688 : 
; 8689 : 	GLuint fbo, fbr, txo=0, txr, cat[1]={ GL_COLOR_ATTACHMENT0 };
; 8690 : 
; 8691 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 8692 : 
; 8693 : //if(tesg==0)
; 8694 : //{
; 8695 : 	for(i=0;i<vbdt_num;i++)

	add	ebx, 64					; 00000040H
	dec	ecx
	mov	DWORD PTR tv2040[ebp], ecx
	jne	SHORT $LL84@Renderer
	movzx	edi, WORD PTR _vbdt_num
$LN82@Renderer:

; 8704 : 			//vbdt[i].texrepeat=(float*) calloc(vbdt[i].num_elements*4,sizeof(float));
; 8705 : 		}
; 8706 : 	}
; 8707 : 
; 8708 : 	k=(uint16*) calloc(vbdt_num,sizeof(uint16));

	push	2
	push	edi
	call	_calloc
	mov	esi, eax
	add	esp, 8

; 8709 : 
; 8710 : 	for(m=z_used;m>-1;m--)

	movsx	eax, BYTE PTR _z_used
	mov	DWORD PTR _k$1$[ebp], esi
	cmp	eax, -1
	jle	$LN78@Renderer

; 8704 : 			//vbdt[i].texrepeat=(float*) calloc(vbdt[i].num_elements*4,sizeof(float));
; 8705 : 		}
; 8706 : 	}
; 8707 : 
; 8708 : 	k=(uint16*) calloc(vbdt_num,sizeof(uint16));

	mov	edx, DWORD PTR _vbdt
	lea	edi, DWORD PTR _z_slot[eax*2]
	mov	ebx, eax
	mov	DWORD PTR tv2012[ebp], edi
	shl	ebx, 12					; 0000000cH
	add	ebx, OFFSET _z_buffer
	inc	eax
	mov	DWORD PTR tv2013[ebp], ebx
	mov	DWORD PTR tv2038[ebp], eax
	npad	2
$LL80@Renderer:

; 8711 : 	{
; 8712 : 		if(!z_slot[m]) continue;

	movzx	eax, WORD PTR [edi]
	test	ax, ax
	je	$LN79@Renderer

; 8713 : 		else
; 8714 : 		for(n=0;n<z_slot[m];n++)

	xor	ecx, ecx
	mov	DWORD PTR _n$1$[ebp], ecx
	mov	DWORD PTR tv1759[ebp], ecx
	cmp	cx, ax
	jge	$LN79@Renderer
	mov	DWORD PTR tv2014[ebp], ebx
$LL75@Renderer:

; 8715 : 		{
; 8716 : 			i=z_buffer[m][n];

	movsx	eax, WORD PTR [ebx]

; 8717 : 			if(ent[i].data.vb_id!=-1)

	imul	ebx, eax, 264
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	WORD PTR _ent[ebx+54], -1
	je	$LN72@Renderer

; 8718 : 			{
; 8719 : 				for(j=0;j<16;j++)

	xor	edi, edi
	npad	4
$LL71@Renderer:

; 8720 : 				{
; 8721 : 					//if(j<4)
; 8722 : 						//vbdt[ent[i].data.vb_id].texrepeat[(k[ent[i].data.vb_id])+j]=ent[i].texrepeat[j];
; 8723 : 
; 8724 : 					vbdt[ent[i].data.vb_id].color[(k[ent[i].data.vb_id]*16)+j]=ent[i].color[j];

	movsx	eax, WORD PTR _ent[ebx+54]
	movzx	ecx, WORD PTR [esi+eax*2]
	shl	eax, 6
	shl	ecx, 4
	add	ecx, DWORD PTR [eax+edx+28]
	mov	al, BYTE PTR _ent[ebx+edi+228]
	mov	BYTE PTR [ecx+edi], al

; 8725 : 
; 8726 : 					if(j<12)

	cmp	edi, 12					; 0000000cH
	jge	SHORT $LN68@Renderer

; 8727 : 						vbdt[ent[i].data.vb_id].vertex[(k[ent[i].data.vb_id]*12)+j]=ent[i].vertex[j];

	mov	eax, DWORD PTR _i$1$[ebp]
	movsx	ecx, WORD PTR _ent[ebx+54]
	shl	eax, 5
	add	eax, DWORD PTR _i$1$[ebp]
	lea	esi, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR _k$1$[ebp]
	movzx	eax, WORD PTR [eax+ecx*2]
	shl	ecx, 6
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _vbdt
	mov	ecx, DWORD PTR [ecx+eax+12]
	mov	eax, DWORD PTR _ent[esi*4+100]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	edx, DWORD PTR _vbdt
$LN68@Renderer:

; 8728 : 
; 8729 : 					if(j<8)

	cmp	edi, 8
	jge	SHORT $LN67@Renderer

; 8730 : 					{
; 8731 : 						vbdt[ent[i].data.vb_id].texcoord[(k[ent[i].data.vb_id]*8)+j]=ent[i].texcor[j];

	mov	eax, DWORD PTR _i$1$[ebp]
	movsx	ecx, WORD PTR _ent[ebx+54]
	shl	eax, 5
	add	eax, DWORD PTR _i$1$[ebp]
	lea	esi, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR _k$1$[ebp]
	movzx	eax, WORD PTR [eax+ecx*2]
	shl	ecx, 6
	lea	edx, DWORD PTR [edi+eax*8]
	mov	eax, DWORD PTR _vbdt
	mov	ecx, DWORD PTR [ecx+eax+16]
	mov	eax, DWORD PTR _ent[esi*4+148]
	mov	DWORD PTR [ecx+edx*4], eax

; 8732 : 
; 8733 : 						vbdt[ent[i].data.vb_id].texcoordlight[(k[ent[i].data.vb_id]*8)+j]=ent[i].texcorlight[j];

	movsx	ecx, WORD PTR _ent[ebx+54]
	mov	eax, DWORD PTR _k$1$[ebp]
	movzx	eax, WORD PTR [eax+ecx*2]
	shl	ecx, 6
	lea	edx, DWORD PTR [edi+eax*8]
	mov	eax, DWORD PTR _vbdt
	mov	ecx, DWORD PTR [ecx+eax+20]
	mov	eax, DWORD PTR _ent[esi*4+180]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	edx, DWORD PTR _vbdt
$LN67@Renderer:

; 8734 : 					}
; 8735 : 					
; 8736 : 					if(j<=2)

	cmp	edi, 2
	jg	SHORT $LN66@Renderer

; 8737 : 						vbdt[ent[i].data.vb_id].index[(k[ent[i].data.vb_id]*6)+j]=((k[ent[i].data.vb_id]*6)-(k[ent[i].data.vb_id]*2))+j;

	movsx	esi, WORD PTR _ent[ebx+54]
	mov	eax, DWORD PTR _k$1$[ebp]
	movzx	eax, WORD PTR [eax+esi*2]
	shl	esi, 6
	lea	edx, DWORD PTR [edi+eax*4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR _vbdt
	mov	eax, DWORD PTR [esi+eax+32]
	mov	WORD PTR [eax+ecx*2], dx
	mov	edx, DWORD PTR _vbdt
$LN66@Renderer:

; 8738 : 
; 8739 : 					if(j==3 || j==4)

	cmp	edi, 3
	je	SHORT $LN64@Renderer
	cmp	edi, 4
	jne	SHORT $LN65@Renderer
$LN64@Renderer:

; 8740 : 						vbdt[ent[i].data.vb_id].index[(k[ent[i].data.vb_id]*6)+j]=((k[ent[i].data.vb_id]*6)-(k[ent[i].data.vb_id]*2))+(j-1);

	movsx	esi, WORD PTR _ent[ebx+54]
	mov	eax, DWORD PTR _k$1$[ebp]
	movzx	eax, WORD PTR [eax+esi*2]
	lea	edx, DWORD PTR [eax*4-1]
	lea	eax, DWORD PTR [eax+eax*2]
	add	edx, edi
	lea	ecx, DWORD PTR [edi+eax*2]
	shl	esi, 6
	mov	eax, DWORD PTR _vbdt
	mov	eax, DWORD PTR [esi+eax+32]
	mov	WORD PTR [eax+ecx*2], dx
	mov	edx, DWORD PTR _vbdt
$LN65@Renderer:

; 8741 : 
; 8742 : 					if(j==5)

	cmp	edi, 5
	jne	SHORT $LN70@Renderer

; 8743 : 						vbdt[ent[i].data.vb_id].index[(k[ent[i].data.vb_id]*6)+j]=((k[ent[i].data.vb_id]*6)-(k[ent[i].data.vb_id]*2));

	movsx	esi, WORD PTR _ent[ebx+54]
	mov	eax, DWORD PTR _k$1$[ebp]
	movzx	eax, WORD PTR [eax+esi*2]
	shl	esi, 6
	lea	edx, DWORD PTR [eax*4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR _vbdt
	mov	eax, DWORD PTR [esi+eax+32]
	mov	WORD PTR [eax+ecx*4+10], dx
	mov	edx, DWORD PTR _vbdt
$LN70@Renderer:

; 8718 : 			{
; 8719 : 				for(j=0;j<16;j++)

	mov	esi, DWORD PTR _k$1$[ebp]
	inc	edi
	cmp	edi, 16					; 00000010H
	jl	$LL71@Renderer

; 8744 : 				}
; 8745 : 
; 8746 : 				ent[i].data.loc=k[ent[i].data.vb_id];

	movsx	ecx, WORD PTR _ent[ebx+54]

; 8747 : 
; 8748 : 				k[ent[i].data.vb_id]++;
; 8749 : 			}
; 8750 : 			else

	mov	edi, DWORD PTR tv2012[ebp]
	movzx	eax, WORD PTR [esi+ecx*2]
	mov	WORD PTR _ent[ebx+56], ax
	inc	eax
	mov	WORD PTR [esi+ecx*2], ax
	mov	ecx, DWORD PTR _n$1$[ebp]
	jmp	SHORT $LN74@Renderer
$LN72@Renderer:

; 8751 : 				ent[i].data.loc=-1;

	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR _ent[ebx+56], ax
$LN74@Renderer:

; 8713 : 		else
; 8714 : 		for(n=0;n<z_slot[m];n++)

	mov	ebx, DWORD PTR tv2014[ebp]
	inc	ecx
	movsx	eax, WORD PTR [edi]
	add	ebx, 2
	mov	DWORD PTR _n$1$[ebp], ecx
	mov	DWORD PTR tv2014[ebp], ebx
	cmp	ecx, eax
	jl	$LL75@Renderer
	mov	ebx, DWORD PTR tv2013[ebp]
$LN79@Renderer:

; 8709 : 
; 8710 : 	for(m=z_used;m>-1;m--)

	sub	edi, 2
	sub	ebx, 4096				; 00001000H
	dec	DWORD PTR tv2038[ebp]
	mov	DWORD PTR tv2012[ebp], edi
	mov	DWORD PTR tv2013[ebp], ebx
	jne	$LL80@Renderer
	movzx	edi, WORD PTR _vbdt_num
$LN78@Renderer:

; 8752 : 		}
; 8753 : 	}
; 8754 : 
; 8755 : 	free(k);

	push	esi
	call	_free

; 8756 : 
; 8757 : #ifdef _VAO_RENDER
; 8758 : 
; 8759 : 	if(st.renderer.VAO_ON)

	mov	al, BYTE PTR _st+2336440
	add	esp, 4
	test	al, al
	je	$LN2@Renderer

; 8760 : 	{
; 8761 : 		for(i=0;i<vbdt_num;i++)

	xor	ebx, ebx
	test	edi, edi
	jle	$LN49@Renderer
	mov	ecx, DWORD PTR _vbdt
	xor	edi, edi
$LL60@Renderer:

; 8762 : 		{
; 8763 : 			if(vbdt[i].num_elements>0)

	movzx	edx, WORD PTR [edi+ecx+46]
	lea	esi, DWORD PTR [edi+ecx]
	test	dx, dx
	je	SHORT $LN59@Renderer

; 8764 : 			{
; 8765 : 				if(vbdt[i].num_elements<vbdt[i].buffer_elements)

	movzx	eax, WORD PTR [esi+48]
	cmp	dx, ax
	jae	SHORT $LN56@Renderer

; 8766 : 				{
; 8767 : 					if(vbdt[i].num_elements!=vbdt[i].num_elements2)
; 8768 : 					{
; 8769 : 						UpdateVAO(&vbdt[i],0,1,3);

	push	ecx
	mov	ecx, esi
	cmp	dx, WORD PTR [esi+50]
	je	SHORT $LN55@Renderer
	push	1
	xor	dl, dl
	call	_UpdateVAO

; 8770 : 						vbdt[i].num_elements2=vbdt[i].num_elements;

	mov	ecx, DWORD PTR _vbdt
	mov	ax, WORD PTR [edi+ecx+46]
	mov	WORD PTR [edi+ecx+50], ax

; 8771 : 					}
; 8772 : 					else

	jmp	SHORT $LN136@Renderer
$LN55@Renderer:

; 8773 : 						UpdateVAO(&vbdt[i],0,0,3);

	push	0
	xor	dl, dl

; 8774 : 				}
; 8775 : 				else

	jmp	SHORT $LN137@Renderer
$LN56@Renderer:

; 8776 : 				if(vbdt[i].num_elements<vbdt[i].buffer_elements-8)

	lea	ecx, DWORD PTR [eax-8]

; 8777 : 				{
; 8778 : 					vbdt[i].buffer_elements=vbdt[i].num_elements+8;

	lea	eax, DWORD PTR [edx+8]
	cmp	edx, ecx

; 8779 : 					UpdateVAO(&vbdt[i],1,1,3);

	push	ecx
	mov	WORD PTR [esi+48], ax
	mov	dl, 1
	push	1
	mov	ecx, esi
$LN137@Renderer:

; 8780 : 				}
; 8781 : 				else
; 8782 : 				if(vbdt[i].num_elements>=vbdt[i].buffer_elements)
; 8783 : 				{
; 8784 : 					vbdt[i].buffer_elements=vbdt[i].num_elements+8;
; 8785 : 					UpdateVAO(&vbdt[i],1,1,3);

	call	_UpdateVAO
	mov	ecx, DWORD PTR _vbdt
$LN136@Renderer:
	add	esp, 8
$LN59@Renderer:

; 8760 : 	{
; 8761 : 		for(i=0;i<vbdt_num;i++)

	movzx	eax, WORD PTR _vbdt_num
	inc	ebx
	add	edi, 64					; 00000040H
	cmp	ebx, eax
	jl	SHORT $LL60@Renderer
	mov	al, BYTE PTR _st+2336440
$LN49@Renderer:

; 8786 : 				}
; 8787 : 			}
; 8788 : 		}
; 8789 : 	}
; 8790 : 
; 8791 : #endif
; 8792 : 		/*
; 8793 : 		else
; 8794 : 		if(vbdt[i].num_elements==0 && vbdt[i].buffer_elements>8)
; 8795 : 		{
; 8796 : 			vbdt[i].buffer_elements=8;
; 8797 : 			UpdateVAO(&vbdt[i],2,0,2);
; 8798 : 		}
; 8799 : 		*/
; 8800 : 
; 8801 : #endif
; 8802 : 
; 8803 : 	if(type)
; 8804 : 		st.num_lightmap=1; //Make sure BASICBKD() is being used
; 8805 : 
; 8806 : 	num_targets=st.num_entities;
; 8807 : 
; 8808 : #ifdef _VAO_RENDER
; 8809 : 	if(st.renderer.VAO_ON)

	test	al, al
	je	$LN2@Renderer

; 8810 : 	{
; 8811 : 		glUseProgram(st.renderer.Program[3]);

	push	DWORD PTR _st+2336660
	call	DWORD PTR _GLeeFuncPtr_glUseProgram

; 8812 : 
; 8813 : 		glUniform1i(st.renderer.unifs[1],0);

	push	0
	push	DWORD PTR _st+2336716
	call	DWORD PTR _GLeeFuncPtr_glUniform1i

; 8814 : 
; 8815 : 		glUniform1i(st.renderer.unifs[2],2);

	push	2
	push	DWORD PTR _st+2336720
	call	DWORD PTR _GLeeFuncPtr_glUniform1i

; 8816 : 
; 8817 : 		glUniform1i(st.renderer.unifs[3],1);

	push	1
	push	DWORD PTR _st+2336724
	call	DWORD PTR _GLeeFuncPtr_glUniform1i

; 8818 : 
; 8819 : 		glUniform1f(st.renderer.unifs[4],0);

	push	ecx
	mov	DWORD PTR [esp], 0
	push	DWORD PTR _st+2336728
	call	DWORD PTR _GLeeFuncPtr_glUniform1f

; 8820 : 
; 8821 : 		glBindFramebuffer(GL_FRAMEBUFFER,st.renderer.FBO[0]);

	push	DWORD PTR _st+2336776
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glBindFramebuffer

; 8822 : 
; 8823 : 		glDrawBuffers(1,&st.renderer.Buffers[0]);

	push	OFFSET _st+2336856
	push	1
	call	DWORD PTR _GLeeFuncPtr_glDrawBuffers

; 8824 : 
; 8825 : 		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	push	16640					; 00004100H
	call	DWORD PTR __imp__glClear@4

; 8826 : 
; 8827 : 		glActiveTexture(GL_TEXTURE0);

	push	33984					; 000084c0H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture

; 8828 : 
; 8829 : 		glBindVertexArray(vbd.vao_id);

	push	DWORD PTR _vbd
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray

; 8830 : 
; 8831 : 		glBindBuffer(GL_ARRAY_BUFFER,vbd.vbo_id);

	push	DWORD PTR _vbd+8
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer

; 8832 : 
; 8833 : 		if(z_used>15)

	cmp	BYTE PTR _z_used, 15			; 0000000fH
	mov	ebx, DWORD PTR __imp__glBindTexture@8
	jle	$LN44@Renderer

; 8834 : 		{
; 8835 : 			for(i=0;i<st.num_lightmap;i++)

	xor	edi, edi
	cmp	BYTE PTR _st+261, 0
	jbe	$LN44@Renderer
	mov	esi, OFFSET _lmp+100
$LL46@Renderer:

; 8836 : 			{
; 8837 : 				glBindTexture(GL_TEXTURE_2D,lmp[i].data.data);

	push	DWORD PTR [esi-56]
	push	3553					; 00000de1H
	call	ebx

; 8838 : 
; 8839 : 				glBufferSubData(GL_ARRAY_BUFFER,0,12*sizeof(float),lmp[i].vertex);

	push	esi
	push	48					; 00000030H
	push	0
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 8840 : 				glBufferSubData(GL_ARRAY_BUFFER,12*sizeof(float),8*sizeof(float),vbd.texcoord);

	push	DWORD PTR _vbd+16
	push	32					; 00000020H
	push	48					; 00000030H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 8841 : 				glBufferSubData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float)),16*sizeof(GLubyte),lmp[i].color);

	lea	eax, DWORD PTR [esi+128]
	push	eax
	push	16					; 00000010H
	push	80					; 00000050H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 8842 : 
; 8843 : 				glDrawRangeElements(GL_TRIANGLES,0,6,6,GL_UNSIGNED_SHORT,0);

	push	0
	push	5123					; 00001403H
	push	6
	push	6
	push	0
	push	4
	call	DWORD PTR _GLeeFuncPtr_glDrawRangeElements
	movzx	eax, BYTE PTR _st+261
	inc	edi
	add	esi, 264				; 00000108H
	cmp	edi, eax
	jl	SHORT $LL46@Renderer
$LN44@Renderer:

; 8844 : 			}
; 8845 : 		}
; 8846 : 
; 8847 : 		glActiveTexture(GL_TEXTURE2);

	push	33986					; 000084c2H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture

; 8848 : 
; 8849 : 		glBindTexture(GL_TEXTURE_2D,st.renderer.FBTex[0]);

	push	DWORD PTR _st+2336792
	push	3553					; 00000de1H
	call	ebx

; 8850 : 
; 8851 : 		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

	mov	esi, DWORD PTR __imp__glTexParameterf@12
	push	ecx
	mov	DWORD PTR [esp], 1175977984		; 46180000H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	esi

; 8852 : 		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

	push	ecx
	mov	DWORD PTR [esp], 1175977984		; 46180000H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	esi

; 8853 : 
; 8854 : 		glBindFramebuffer(GL_FRAMEBUFFER,0);

	push	0
	push	36160					; 00008d40H
	call	DWORD PTR _GLeeFuncPtr_glBindFramebuffer

; 8855 : 
; 8856 : 		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	push	16640					; 00004100H
	call	DWORD PTR __imp__glClear@4

; 8857 : 
; 8858 : 		for(i=z_used;i>-1;i--)

	movsx	eax, BYTE PTR _z_used
	mov	DWORD PTR _i$4$[ebp], eax
	cmp	eax, -1
	jle	$LN133@Renderer

; 8844 : 			}
; 8845 : 		}
; 8846 : 
; 8847 : 		glActiveTexture(GL_TEXTURE2);

	mov	edx, eax
	lea	ecx, DWORD PTR _z_slot[eax*2]
	shl	edx, 11					; 0000000bH
	mov	DWORD PTR tv1988[ebp], edx
	mov	DWORD PTR tv1970[ebp], ecx
$LL43@Renderer:

; 8859 : 		{
; 8860 : 			for(j=0;j<z_slot[i];j++)

	xor	edi, edi
	xor	esi, esi
	mov	DWORD PTR _j$2$[ebp], edi
	cmp	si, WORD PTR [ecx]
	jge	$LN38@Renderer
$LL40@Renderer:

; 8861 : 			{
; 8862 : 				if(ent[z_buffer[i][j]].data.vb_id!=-1)

	lea	ebx, DWORD PTR [edx+edi]
	movsx	ecx, WORD PTR _z_buffer[ebx*2]
	mov	eax, ecx
	mov	DWORD PTR tv1953[ebp], ebx
	shl	eax, 5
	add	eax, ecx

; 8863 : 				{
; 8864 : 					m=ent[z_buffer[i][j]].data.vb_id;
; 8865 : 
; 8866 : 					glActiveTexture(GL_TEXTURE0);

	push	33984					; 000084c0H
	movzx	eax, WORD PTR _ent[eax*8+54]
	cmp	ax, -1
	je	$LN37@Renderer
	movsx	esi, ax
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture

; 8867 : 
; 8868 : 					if(tex_bound[0]!=vbdt[m].texture)

	mov	eax, DWORD PTR _vbdt
	shl	esi, 6
	mov	eax, DWORD PTR [esi+eax+36]
	cmp	DWORD PTR _tex_bound$1$[ebp], eax
	je	SHORT $LN36@Renderer

; 8869 : 					{
; 8870 : 						glBindTexture(GL_TEXTURE_2D,vbdt[m].texture);

	push	eax
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 8871 : 						tex_bound[0]=vbdt[m].texture;

	mov	eax, DWORD PTR _vbdt
	mov	eax, DWORD PTR [esi+eax+36]
	mov	DWORD PTR _tex_bound$1$[ebp], eax
$LN36@Renderer:

; 8872 : 					}
; 8873 : 
; 8874 : 					//glUniform2f(st.renderer.unifs[6],(float) ent[z_buffer[i][j]].data.sizex/32768,(float) ent[z_buffer[i][j]].data.sizey/32768);
; 8875 : 					//glUniform2f(st.renderer.unifs[7],(float) ent[z_buffer[i][j]].data.posx/32768,(float) ent[z_buffer[i][j]].data.posy/32768);
; 8876 : 
; 8877 : 					if(i<16  || ent[z_buffer[i][j]].lightmapid==-2)

	cmp	DWORD PTR _i$4$[ebp], 16		; 00000010H
	jl	SHORT $LN34@Renderer
	movsx	ecx, WORD PTR _z_buffer[ebx*2]
	mov	eax, ecx
	shl	eax, 5
	add	eax, ecx
	cmp	WORD PTR _ent[eax*8+260], -2		; fffffffeH
	je	SHORT $LN34@Renderer

; 8879 : 					else
; 8880 : 					{
; 8881 : 						glActiveTexture(GL_TEXTURE1);

	push	33985					; 000084c1H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture

; 8882 : 
; 8883 : 						if(vbdt[m].normal)

	mov	eax, DWORD PTR _vbdt
	cmp	BYTE PTR [esi+eax+44], 0
	je	SHORT $LN32@Renderer

; 8884 : 						{
; 8885 : 							if(tex_bound[1]!=vbdt[m].Ntexture)

	mov	eax, DWORD PTR [esi+eax+40]
	cmp	DWORD PTR _tex_bound$2$[ebp], eax
	je	SHORT $LN31@Renderer

; 8886 : 							{
; 8887 : 								glBindTexture(GL_TEXTURE_2D,vbdt[m].Ntexture);

	push	eax
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8

; 8888 : 								tex_bound[1]=vbdt[m].Ntexture;

	mov	eax, DWORD PTR _vbdt
	mov	eax, DWORD PTR [esi+eax+40]
	mov	DWORD PTR _tex_bound$2$[ebp], eax
$LN31@Renderer:

; 8889 : 							}
; 8890 : 							glUniform1f(st.renderer.unifs[4],1);

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H

; 8891 : 						}
; 8892 : 						else

	jmp	SHORT $LN138@Renderer
$LN32@Renderer:

; 8893 : 						{
; 8894 : 							//if(tex_bound[1]!=vbdt[m].texture)
; 8895 : 							//{
; 8896 : 							//	glBindTexture(GL_TEXTURE_2D,vbdt[m].texture);
; 8897 : 								//tex_bound[1]=vbdt[m].texture;
; 8898 : 							//}
; 8899 : 
; 8900 : 							glUniform1f(st.renderer.unifs[4],2);

	push	ecx
	mov	DWORD PTR [esp], 1073741824		; 40000000H
	jmp	SHORT $LN138@Renderer
$LN34@Renderer:

; 8878 : 						glUniform1f(st.renderer.unifs[4],3);

	push	ecx
	mov	DWORD PTR [esp], 1077936128		; 40400000H
$LN138@Renderer:
	push	DWORD PTR _st+2336728
	call	DWORD PTR _GLeeFuncPtr_glUniform1f

; 8901 : 						}
; 8902 : 
; 8903 : 					}
; 8904 : 
; 8905 : 					glBindVertexArray(vbdt[m].vao_id);

	mov	eax, DWORD PTR _vbdt
	push	DWORD PTR [esi+eax]
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray

; 8906 : 
; 8907 : 					l=0;
; 8908 : 					if(j<z_slot[i]-2)

	mov	eax, DWORD PTR tv1970[ebp]
	xor	esi, esi
	movsx	ecx, WORD PTR [eax]
	lea	eax, DWORD PTR [ecx-2]
	cmp	edi, eax
	jge	$LN132@Renderer

; 8909 : 					{
; 8910 : 						for(m=j+1;m<z_slot[i];m++)

	lea	edx, DWORD PTR [edi+1]
	cmp	edx, ecx
	jge	$LN132@Renderer
	movsx	eax, WORD PTR _z_buffer[ebx*2]
	mov	ecx, eax
	shl	ecx, 5
	add	ecx, eax
	mov	eax, DWORD PTR tv1988[ebp]
	shl	ecx, 3
	add	eax, edx
	mov	DWORD PTR tv1984[ebp], ecx
	mov	ebx, ecx
	lea	edi, DWORD PTR _z_buffer[eax*2]
	npad	3
$LL28@Renderer:

; 8911 : 						{
; 8912 : 							if(ent[z_buffer[i][m]].data.vb_id==ent[z_buffer[i][j]].data.vb_id && ent[z_buffer[i][m]].lightmapid==ent[z_buffer[i][j]].lightmapid)

	movsx	eax, WORD PTR [edi]
	mov	ecx, eax
	shl	ecx, 5
	add	ecx, eax
	movzx	eax, WORD PTR _ent[ebx+54]
	cmp	WORD PTR _ent[ecx*8+54], ax
	jne	SHORT $LN25@Renderer
	mov	ax, WORD PTR _ent[ecx*8+260]
	cmp	ax, WORD PTR _ent[ebx+260]
	jne	SHORT $LN25@Renderer

; 8909 : 					{
; 8910 : 						for(m=j+1;m<z_slot[i];m++)

	mov	ecx, DWORD PTR tv1970[ebp]
	inc	edx

; 8913 : 								l++;

	inc	esi
	add	edi, 2
	movsx	eax, WORD PTR [ecx]
	cmp	edx, eax
	jl	SHORT $LL28@Renderer
$LN25@Renderer:

; 8914 : 							else
; 8915 : 								break;
; 8916 : 						}
; 8917 : 					}
; 8918 : 
; 8919 : 					if(!l)

	mov	ebx, DWORD PTR tv1953[ebp]
	test	si, si
	je	SHORT $LN132@Renderer

; 8921 : 					else
; 8922 : 						glDrawRangeElements(GL_TRIANGLES,0,((ent[z_buffer[i][j]].data.loc+l)*6)+6,(l*6)+6,GL_UNSIGNED_SHORT,(void*) ((ent[z_buffer[i][j]].data.loc*6)*2));

	mov	eax, DWORD PTR tv1984[ebp]
	movzx	ecx, si
	movzx	edx, WORD PTR _ent[eax+56]
	lea	eax, DWORD PTR [edx+edx*2]
	shl	eax, 2
	push	eax
	lea	eax, DWORD PTR [ecx+1]
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	push	5123					; 00001403H
	push	eax
	lea	eax, DWORD PTR [edx+1]
	add	eax, ecx
	jmp	SHORT $LN139@Renderer
$LN132@Renderer:

; 8920 : 						glDrawRangeElements(GL_TRIANGLES,0,(ent[z_buffer[i][j]].data.loc*6)+6,6,GL_UNSIGNED_SHORT,(void*) ((ent[z_buffer[i][j]].data.loc*6)*2));

	movsx	ecx, WORD PTR _z_buffer[ebx*2]
	mov	eax, ecx
	shl	eax, 5
	add	eax, ecx
	movzx	ecx, WORD PTR _ent[eax*8+56]
	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 2
	push	eax
	push	5123					; 00001403H
	push	6
	lea	eax, DWORD PTR [ecx+1]
$LN139@Renderer:
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	push	eax
	push	0
	push	4
	call	DWORD PTR _GLeeFuncPtr_glDrawRangeElements

; 8923 : 
; 8924 : 					glBindVertexArray(0);

	push	0
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray

; 8925 : 
; 8926 : 					if(l)
; 8927 : 						j+=l;

	mov	edi, DWORD PTR _j$2$[ebp]
	test	si, si
	je	$LN39@Renderer
	movzx	eax, si
	add	edi, eax

; 8928 : 				}
; 8929 : 				else

	jmp	$LN39@Renderer
$LN37@Renderer:

; 8930 : 				{
; 8931 : 					glActiveTexture(GL_TEXTURE0);

	call	DWORD PTR _GLeeFuncPtr_glActiveTexture

; 8932 : 
; 8933 : 					if(tex_bound[0]!=ent[z_buffer[i][j]].data.data)

	movsx	eax, WORD PTR _z_buffer[ebx*2]

; 8934 : 					{
; 8935 : 						glBindTexture(GL_TEXTURE_2D,ent[z_buffer[i][j]].data.data);

	mov	esi, DWORD PTR __imp__glBindTexture@8
	mov	ecx, eax
	shl	ecx, 5
	add	ecx, eax
	shl	ecx, 3
	mov	eax, DWORD PTR _ent[ecx+44]
	cmp	DWORD PTR _tex_bound$1$[ebp], eax
	je	SHORT $LN19@Renderer
	push	eax
	push	3553					; 00000de1H
	call	esi

; 8936 : 						tex_bound[0]=ent[z_buffer[i][j]].data.data;

	movsx	eax, WORD PTR _z_buffer[ebx*2]
	mov	ecx, eax
	shl	ecx, 5
	add	ecx, eax
	shl	ecx, 3
	mov	eax, DWORD PTR _ent[ecx+44]
	mov	DWORD PTR _tex_bound$1$[ebp], eax
$LN19@Renderer:

; 8937 : 					}
; 8938 : 
; 8939 : 					//glUniform2f(st.renderer.unifs[6],(float) ent[z_buffer[i][j]].data.sizex/32768,(float) ent[z_buffer[i][j]].data.sizey/32768);
; 8940 : 					//glUniform2f(st.renderer.unifs[7],(float) ent[z_buffer[i][j]].data.posx/32768,(float) ent[z_buffer[i][j]].data.posy/32768);
; 8941 : 
; 8942 : 					if(i<16 || ent[z_buffer[i][j]].lightmapid==-2)

	cmp	DWORD PTR _i$4$[ebp], 16		; 00000010H
	jl	$LN17@Renderer
	cmp	WORD PTR _ent[ecx+260], -2		; fffffffeH
	je	$LN17@Renderer

; 8944 : 					else
; 8945 : 					{
; 8946 : 						glActiveTexture(GL_TEXTURE1);

	push	33985					; 000084c1H
	call	DWORD PTR _GLeeFuncPtr_glActiveTexture

; 8947 : 
; 8948 : 						if(ent[z_buffer[i][j]].data.normal)

	movsx	eax, WORD PTR _z_buffer[ebx*2]
	mov	ecx, eax
	shl	ecx, 5
	add	ecx, eax
	shl	ecx, 3
	cmp	BYTE PTR _ent[ecx+52], 0
	je	SHORT $LN15@Renderer

; 8949 : 						{
; 8950 : 							glUniform1f(st.renderer.unifs[4],1);

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	DWORD PTR _st+2336728
	call	DWORD PTR _GLeeFuncPtr_glUniform1f

; 8951 : 
; 8952 : 							if(tex_bound[1]!=ent[z_buffer[i][j]].data.Ndata)

	movsx	ecx, WORD PTR _z_buffer[ebx*2]
	mov	eax, ecx
	shl	eax, 5
	add	eax, ecx
	mov	eax, DWORD PTR _ent[eax*8+48]
	cmp	DWORD PTR _tex_bound$2$[ebp], eax
	je	$LN13@Renderer

; 8953 : 							{
; 8954 : 								glBindTexture(GL_TEXTURE_2D,ent[z_buffer[i][j]].data.Ndata);

	push	eax
	push	3553					; 00000de1H
	call	esi

; 8955 : 								tex_bound[1]=ent[z_buffer[i][j]].data.Ndata;

	movsx	ecx, WORD PTR _z_buffer[ebx*2]
	mov	eax, ecx
	shl	eax, 5
	add	eax, ecx
	mov	esi, DWORD PTR _ent[eax*8+48]
	mov	DWORD PTR _tex_bound$2$[ebp], esi

; 8956 : 							}
; 8957 : 						}
; 8958 : 						else

	jmp	SHORT $LN13@Renderer
$LN15@Renderer:

; 8959 : 						{
; 8960 : 							if(tex_bound[1]!=ent[z_buffer[i][j]].data.data)

	mov	eax, DWORD PTR _ent[ecx+44]
	cmp	DWORD PTR _tex_bound$2$[ebp], eax
	je	SHORT $LN12@Renderer

; 8961 : 							{
; 8962 : 								glBindTexture(GL_TEXTURE_2D,ent[z_buffer[i][j]].data.data);

	push	eax
	push	3553					; 00000de1H
	call	esi

; 8963 : 								tex_bound[1]=ent[z_buffer[i][j]].data.data;

	movsx	ecx, WORD PTR _z_buffer[ebx*2]
	mov	eax, ecx
	shl	eax, 5
	add	eax, ecx
	mov	eax, DWORD PTR _ent[eax*8+44]
	mov	DWORD PTR _tex_bound$2$[ebp], eax
$LN12@Renderer:

; 8964 : 							}
; 8965 : 
; 8966 : 							glUniform1f(st.renderer.unifs[4],2);

	push	ecx
	mov	DWORD PTR [esp], 1073741824		; 40000000H
	jmp	SHORT $LN140@Renderer
$LN17@Renderer:

; 8943 : 						glUniform1f(st.renderer.unifs[4],3);

	push	ecx
	mov	DWORD PTR [esp], 1077936128		; 40400000H
$LN140@Renderer:
	push	DWORD PTR _st+2336728
	call	DWORD PTR _GLeeFuncPtr_glUniform1f
$LN13@Renderer:

; 8967 : 						}
; 8968 : 					}
; 8969 : 
; 8970 : 					glBindVertexArray(vbd.vao_id);

	push	DWORD PTR _vbd
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray

; 8971 : 
; 8972 : 					glBindBuffer(GL_ARRAY_BUFFER,vbd.vbo_id);

	push	DWORD PTR _vbd+8
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBindBuffer

; 8973 : 
; 8974 : 					glBufferSubData(GL_ARRAY_BUFFER,0,12*sizeof(float),ent[z_buffer[i][j]].vertex);

	movsx	ecx, WORD PTR _z_buffer[ebx*2]
	mov	eax, ecx
	shl	eax, 5
	add	eax, ecx
	lea	eax, DWORD PTR _ent[eax*8+100]
	push	eax
	push	48					; 00000030H
	push	0
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 8975 : 					glBufferSubData(GL_ARRAY_BUFFER,12*sizeof(float),8*sizeof(float),ent[z_buffer[i][j]].texcor);

	movsx	ecx, WORD PTR _z_buffer[ebx*2]
	mov	eax, ecx
	shl	eax, 5
	add	eax, ecx
	lea	eax, DWORD PTR _ent[eax*8+148]
	push	eax
	push	32					; 00000020H
	push	48					; 00000030H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 8976 : 					glBufferSubData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float)),16*sizeof(GLubyte),ent[z_buffer[i][j]].color);

	movsx	ecx, WORD PTR _z_buffer[ebx*2]
	mov	eax, ecx
	shl	eax, 5
	add	eax, ecx
	lea	eax, DWORD PTR _ent[eax*8+228]
	push	eax
	push	16					; 00000010H
	push	80					; 00000050H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 8977 : 					glBufferSubData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float))+(16*sizeof(GLubyte)),8*sizeof(float),ent[z_buffer[i][j]].texcorlight);

	movsx	ecx, WORD PTR _z_buffer[ebx*2]
	mov	eax, ecx
	shl	eax, 5
	add	eax, ecx
	lea	eax, DWORD PTR _ent[eax*8+180]
	push	eax
	push	32					; 00000020H
	push	96					; 00000060H
	push	34962					; 00008892H
	call	DWORD PTR _GLeeFuncPtr_glBufferSubData

; 8978 : 					//glBufferSubData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float))+(16*sizeof(GLubyte))+(8*sizeof(GLfloat)),4*sizeof(float),ent[z_buffer[i][j]].texrepeat);
; 8979 : 
; 8980 : 					glDrawRangeElements(GL_TRIANGLES,0,6,6,GL_UNSIGNED_SHORT,0);

	push	0
	push	5123					; 00001403H
	push	6
	push	6
	push	0
	push	4
	call	DWORD PTR _GLeeFuncPtr_glDrawRangeElements

; 8981 : 
; 8982 : 					glBindVertexArray(0);

	push	0
	call	DWORD PTR _GLeeFuncPtr_glBindVertexArray
$LN39@Renderer:

; 8859 : 		{
; 8860 : 			for(j=0;j<z_slot[i];j++)

	mov	ecx, DWORD PTR tv1970[ebp]
	inc	edi
	mov	edx, DWORD PTR tv1988[ebp]
	mov	DWORD PTR _j$2$[ebp], edi
	movsx	eax, WORD PTR [ecx]
	cmp	edi, eax
	jl	$LL40@Renderer
	mov	eax, DWORD PTR _i$4$[ebp]
$LN38@Renderer:

; 8983 : 				}
; 8984 : 			}
; 8985 : 
; 8986 : 			if(i==0) break;

	test	eax, eax
	je	SHORT $LN133@Renderer

; 8857 : 
; 8858 : 		for(i=z_used;i>-1;i--)

	dec	eax
	sub	edx, 2048				; 00000800H
	sub	ecx, 2
	mov	DWORD PTR _i$4$[ebp], eax
	mov	DWORD PTR tv1988[ebp], edx
	mov	DWORD PTR tv1970[ebp], ecx
	cmp	eax, -1
	jg	$LL43@Renderer
$LN133@Renderer:

; 8987 : 		}
; 8988 : 
; 8989 : 		memset(z_buffer,0,57*(2048)*sizeof(int16));

	push	233472					; 00039000H
	push	0
	push	OFFSET _z_buffer
	call	_memset

; 8990 : 		memset(z_slot,0,57*sizeof(int16));

	push	114					; 00000072H
	push	0
	push	OFFSET _z_slot
	call	_memset
	mov	edi, DWORD PTR __imp__glDeleteTextures@8
	add	esp, 24					; 00000018H

; 8991 : 		z_used=0;

	mov	BYTE PTR _z_used, 0
	mov	esi, OFFSET _st+2762084
	npad	6
$LL10@Renderer:

; 8994 : 		{
; 8995 : 			if(st.strings[i].stat==1)

	mov	al, BYTE PTR [esi]
	cmp	al, 1
	jne	SHORT $LN7@Renderer

; 8996 : 			{
; 8997 : 				st.strings[i].stat=2;

	mov	BYTE PTR [esi], 2

; 8998 : 				continue;

	jmp	SHORT $LN9@Renderer
$LN7@Renderer:

; 8999 : 			}
; 9000 : 			else
; 9001 : 			if(st.strings[i].stat==2)

	cmp	al, 2
	jne	SHORT $LN9@Renderer

; 9002 : 			{
; 9003 : 				glDeleteTextures(1,&st.strings[i].data.data);

	lea	eax, DWORD PTR [esi-40]
	push	eax
	push	1
	call	edi

; 9004 : 				st.strings[i].data.channel=0;

	mov	DWORD PTR [esi-8], 0

; 9005 : 				st.strings[i].stat=0;

	mov	BYTE PTR [esi], 0
$LN9@Renderer:

; 8992 : 
; 8993 : 		for(i=0;i<MAX_STRINGS;i++)

	add	esi, 1068				; 0000042cH
	cmp	esi, OFFSET _st+3308900
	jl	SHORT $LL10@Renderer

; 9006 : 			}
; 9007 : 		}
; 9008 : 		
; 9009 : 		for(i=0;i<vbdt_num;i++)

	movzx	ecx, WORD PTR _vbdt_num
	test	ecx, ecx
	jle	SHORT $LN2@Renderer
	mov	eax, DWORD PTR _vbdt
	add	eax, 46					; 0000002eH
$LL4@Renderer:

; 9010 : 		{
; 9011 : 			if(vbdt[i].num_elements>0)

	cmp	WORD PTR [eax], 0
	jbe	SHORT $LN3@Renderer

; 9012 : 			{
; 9013 : 				vbdt[i].num_elements=0;

	xor	edx, edx
	mov	WORD PTR [eax], dx
$LN3@Renderer:

; 9006 : 			}
; 9007 : 		}
; 9008 : 		
; 9009 : 		for(i=0;i<vbdt_num;i++)

	add	eax, 64					; 00000040H
	dec	ecx
	jne	SHORT $LL4@Renderer
$LN2@Renderer:

; 9014 : 			}
; 9015 : 		}
; 9016 : 		
; 9017 : 	}
; 9018 : 	
; 9019 : #endif
; 9020 : 	
; 9021 : #ifdef _VBO_RENDER
; 9022 : 	if(st.renderer.VBO_ON)
; 9023 : 	{
; 9024 : 		glBindFramebuffer(GL_FRAMEBUFFER,st.renderer.FBO[0]);
; 9025 : 
; 9026 : 		if(st.num_lightmap>0)
; 9027 : 		{
; 9028 : 			glDrawBuffers(1,&st.renderer.Buffers[2]);
; 9029 : 
; 9030 : 			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
; 9031 : 
; 9032 : 			for(i=0;i<st.num_lightmap;i++)
; 9033 : 			{
; 9034 : 				glUseProgram(st.renderer.Program[2]);
; 9035 : 				unif=glGetUniformLocation(st.renderer.Program[2],"texu");
; 9036 : 				glUniform1i(unif,0);
; 9037 : 
; 9038 : 				unif=glGetUniformLocation(st.renderer.Program[2],"normal");
; 9039 : 				glUniform1f(unif,0);
; 9040 : 
; 9041 : 				glActiveTexture(GL_TEXTURE0);
; 9042 : 				glBindTexture(GL_TEXTURE_2D,lmp[i].data.data);
; 9043 : 
; 9044 : 				glBindBuffer(GL_ARRAY_BUFFER,vbd.vbo_id);
; 9045 : 				glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,vbd.ibo_id);
; 9046 : 
; 9047 : 				glBufferData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float))+(16*sizeof(GLubyte)),NULL,GL_STREAM_DRAW);
; 9048 : 				glBufferSubData(GL_ARRAY_BUFFER,0,12*sizeof(float),lmp[i].vertex);
; 9049 : 				glBufferSubData(GL_ARRAY_BUFFER,12*sizeof(float),8*sizeof(float),texcoord);
; 9050 : 				glBufferSubData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float)),16*sizeof(GLubyte),vbd.color);
; 9051 : 
; 9052 : 				glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*sizeof(GLushort)),vbd.index,GL_STREAM_DRAW);
; 9053 : 				
; 9054 : 				pos=glGetAttribLocation(st.renderer.Program[2],"Position");
; 9055 : 				texc=glGetAttribLocation(st.renderer.Program[2],"TexCoord");
; 9056 : 				col=glGetAttribLocation(st.renderer.Program[2],"Color");
; 9057 : 
; 9058 : 				glEnableVertexAttribArray(pos);
; 9059 : 				glEnableVertexAttribArray(texc);
; 9060 : 				glEnableVertexAttribArray(col);
; 9061 : 
; 9062 : 				glVertexAttribPointer(pos,3,GL_FLOAT,GL_FALSE,0,0);
; 9063 : 				glVertexAttribPointer(texc,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) (12*sizeof(GLfloat)));
; 9064 : 				glVertexAttribPointer(col,4,GL_UNSIGNED_BYTE,GL_TRUE,0,(GLvoid*) ((12*sizeof(GLfloat))+(8*sizeof(GLfloat))));
; 9065 : 				
; 9066 : 				glDrawRangeElements(GL_TRIANGLES,0,6,6,GL_UNSIGNED_SHORT,0);
; 9067 : 				
; 9068 : 				glDisableVertexAttribArray(pos);
; 9069 : 				glDisableVertexAttribArray(texc);
; 9070 : 				glDisableVertexAttribArray(col);
; 9071 : 				
; 9072 : 				glBindBuffer(GL_ARRAY_BUFFER,0);
; 9073 : 				glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);
; 9074 : 
; 9075 : 				glUseProgram(0);
; 9076 : 			}
; 9077 : 		}
; 9078 : 
; 9079 : 		//glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
; 9080 : 
; 9081 : 		glBindFramebuffer(GL_FRAMEBUFFER,0);
; 9082 : 		//glDrawBuffers(1,&st.renderer.Buffers[1]);
; 9083 : 
; 9084 : 		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
; 9085 : 
; 9086 : 		glActiveTexture(GL_TEXTURE2);
; 9087 : 		glBindTexture(GL_TEXTURE_2D,st.renderer.FBTex[2]);
; 9088 : 
; 9089 : 		glGenerateMipmap(GL_TEXTURE_2D);
; 9090 : 
; 9091 : 		glUseProgram(st.renderer.Program[3]);
; 9092 : 
; 9093 : 		unif=glGetUniformLocation(st.renderer.Program[3],"texu");
; 9094 : 		glUniform1i(unif,0);
; 9095 : 
; 9096 : 		unif=glGetUniformLocation(st.renderer.Program[3],"texu2");
; 9097 : 		glUniform1i(unif,2);
; 9098 : 
; 9099 : 		unif=glGetUniformLocation(st.renderer.Program[3],"texu3");
; 9100 : 		glUniform1i(unif,1);
; 9101 : 
; 9102 : 
; 9103 : 		for(i=z_used;i>-1;i--)
; 9104 : 		{
; 9105 : 			for(j=0;j<z_slot[i];j++)
; 9106 : 			{
; 9107 : 				if(ent[z_buffer[i][j]].data.vb_id!=-1)
; 9108 : 				{
; 9109 : 					m=ent[z_buffer[i][j]].data.vb_id;
; 9110 : 
; 9111 : 					glActiveTexture(GL_TEXTURE0);
; 9112 : 
; 9113 : 					if(tex_bound[0]!=vbdt[m].texture)
; 9114 : 					{
; 9115 : 						glBindTexture(GL_TEXTURE_2D,vbdt[m].texture);
; 9116 : 						tex_bound[0]=vbdt[m].texture;
; 9117 : 					}
; 9118 : 
; 9119 : 					if(i<16)
; 9120 : 						glUniform1i(st.renderer.unifs[4],3);
; 9121 : 					else
; 9122 : 					{
; 9123 : 						glActiveTexture(GL_TEXTURE1);
; 9124 : 
; 9125 : 						if(vbdt[i].normal)
; 9126 : 						{
; 9127 : 							if(tex_bound[1]!=vbdt[m].texture)
; 9128 : 							{
; 9129 : 								glBindTexture(GL_TEXTURE_2D,vbdt[m].Ntexture);
; 9130 : 								tex_bound[1]=vbdt[m].texture;
; 9131 : 							}
; 9132 : 							unif=glGetUniformLocation(st.renderer.Program[3],"normal");
; 9133 : 							glUniform1f(unif,1);
; 9134 : 						}
; 9135 : 						else
; 9136 : 						{
; 9137 : 							if(tex_bound[1]!=vbdt[m].texture)
; 9138 : 							{
; 9139 : 								glBindTexture(GL_TEXTURE_2D,vbdt[m].texture);
; 9140 : 								tex_bound[1]=vbdt[m].texture;
; 9141 : 							}
; 9142 : 
; 9143 : 							unif=glGetUniformLocation(st.renderer.Program[3],"normal");
; 9144 : 							glUniform1f(unif,2);
; 9145 : 						}
; 9146 : 					}
; 9147 : 
; 9148 : 					//glBindVertexArray(vbdt[m].vao_id);
; 9149 : 					glBindBuffer(GL_ARRAY_BUFFER,vbdt[m].vbo_id);
; 9150 : 					glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,vbdt[m].ibo_id);
; 9151 : 
; 9152 : 					glBufferData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float))+(16*sizeof(GLubyte)),NULL,GL_STREAM_DRAW);
; 9153 : 					glBufferSubData(GL_ARRAY_BUFFER,0,12*sizeof(float),vbdt[m].vertex);
; 9154 : 					glBufferSubData(GL_ARRAY_BUFFER,12*sizeof(float),8*sizeof(float),vbdt[m].texcoord);
; 9155 : 					glBufferSubData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float)),16*sizeof(GLubyte),vbdt[m].color);
; 9156 : 
; 9157 : 					glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*sizeof(GLushort)),vbdt[m].index,GL_STREAM_DRAW);
; 9158 : 
; 9159 : 					pos=glGetAttribLocation(st.renderer.Program[3],"Position");
; 9160 : 					texc=glGetAttribLocation(st.renderer.Program[3],"TexCoord");
; 9161 : 					col=glGetAttribLocation(st.renderer.Program[3],"Color");
; 9162 : 
; 9163 : 					glEnableVertexAttribArray(pos);
; 9164 : 					glEnableVertexAttribArray(texc);
; 9165 : 					glEnableVertexAttribArray(col);
; 9166 : 
; 9167 : 					glVertexAttribPointer(pos,3,GL_FLOAT,GL_FALSE,0,0);
; 9168 : 					glVertexAttribPointer(texc,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) (12*sizeof(GLfloat)));
; 9169 : 					glVertexAttribPointer(col,4,GL_UNSIGNED_BYTE,GL_TRUE,0,(GLvoid*) ((12*sizeof(GLfloat))+(8*sizeof(GLfloat))));
; 9170 : 
; 9171 : 					l=0;
; 9172 : 					if(j<z_slot[i]-2)
; 9173 : 					{
; 9174 : 						for(m=j+1;m<z_slot[i];m++)
; 9175 : 						{
; 9176 : 							if(ent[z_buffer[i][m]].data.vb_id==ent[z_buffer[i][j]].data.vb_id)
; 9177 : 								l++;
; 9178 : 							else
; 9179 : 								break;
; 9180 : 						}
; 9181 : 					}
; 9182 : 
; 9183 : 					if(!l)
; 9184 : 						glDrawRangeElements(GL_TRIANGLES,(ent[z_buffer[i][j]].data.loc*6),(ent[z_buffer[i][j]].data.loc*6)+6,(ent[z_buffer[i][j]].data.loc*6)+6,GL_UNSIGNED_SHORT,0);
; 9185 : 					else
; 9186 : 						glDrawRangeElements(GL_TRIANGLES,(ent[z_buffer[i][j]].data.loc*6),((ent[z_buffer[i][j]].data.loc+l)*6)+6,((ent[z_buffer[i][j]].data.loc+l)*6)+6,GL_UNSIGNED_SHORT,0);
; 9187 : 
; 9188 : 					glDisableVertexAttribArray(pos);
; 9189 : 					glDisableVertexAttribArray(texc);
; 9190 : 					glDisableVertexAttribArray(col);
; 9191 : 
; 9192 : 					glBindBuffer(GL_ARRAY_BUFFER,0);
; 9193 : 					glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);
; 9194 : 
; 9195 : 					if(l)
; 9196 : 						j+=l;
; 9197 : 				}
; 9198 : 				else
; 9199 : 				{
; 9200 : 					glActiveTexture(GL_TEXTURE0);
; 9201 : 
; 9202 : 					if(tex_bound[0]!=ent[z_buffer[i][j]].data.data)
; 9203 : 					{
; 9204 : 						glBindTexture(GL_TEXTURE_2D,ent[z_buffer[i][j]].data.data);
; 9205 : 						tex_bound[0]=ent[z_buffer[i][j]].data.data;
; 9206 : 					}
; 9207 : 
; 9208 : 					if(i<16)
; 9209 : 						glUniform1i(st.renderer.unifs[4],3);
; 9210 : 					else
; 9211 : 					{
; 9212 : 						glActiveTexture(GL_TEXTURE1);
; 9213 : 
; 9214 : 						if(ent[z_buffer[i][j]].data.normal)
; 9215 : 						{
; 9216 : 							unif=glGetUniformLocation(st.renderer.Program[3],"normal");
; 9217 : 							glUniform1f(unif,1);
; 9218 : 
; 9219 : 							if(tex_bound[1]!=ent[z_buffer[i][j]].data.data)
; 9220 : 							{
; 9221 : 								glBindTexture(GL_TEXTURE_2D,ent[z_buffer[i][j]].data.Ndata);
; 9222 : 								tex_bound[1]=ent[z_buffer[i][j]].data.data;
; 9223 : 							}
; 9224 : 						}
; 9225 : 						else
; 9226 : 						{
; 9227 : 							if(tex_bound[1]!=ent[z_buffer[i][j]].data.data)
; 9228 : 							{
; 9229 : 								glBindTexture(GL_TEXTURE_2D,ent[z_buffer[i][j]].data.data);
; 9230 : 								tex_bound[1]=ent[z_buffer[i][j]].data.data;
; 9231 : 							}
; 9232 : 
; 9233 : 							unif=glGetUniformLocation(st.renderer.Program[3],"normal");
; 9234 : 							glUniform1f(unif,2);
; 9235 : 						}
; 9236 : 					}
; 9237 : 
; 9238 : 					//glBindVertexArray(vbd.vao_id);
; 9239 : 
; 9240 : 					glBindBuffer(GL_ARRAY_BUFFER,vbd.vbo_id);
; 9241 : 					glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,vbd.ibo_id);
; 9242 : 
; 9243 : 					glBufferData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float))+(16*sizeof(GLubyte)),NULL,GL_STREAM_DRAW);
; 9244 : 					glBufferSubData(GL_ARRAY_BUFFER,0,12*sizeof(float),ent[z_buffer[i][j]].vertex);
; 9245 : 					glBufferSubData(GL_ARRAY_BUFFER,12*sizeof(float),8*sizeof(float),ent[z_buffer[i][j]].texcor);
; 9246 : 					glBufferSubData(GL_ARRAY_BUFFER,(12*sizeof(float))+(8*sizeof(float)),16*sizeof(GLubyte),ent[z_buffer[i][j]].color);
; 9247 : 
; 9248 : 					glBufferData(GL_ELEMENT_ARRAY_BUFFER,(6*sizeof(GLushort)),vbd.index,GL_STREAM_DRAW);
; 9249 : 
; 9250 : 					pos=glGetAttribLocation(st.renderer.Program[3],"Position");
; 9251 : 					texc=glGetAttribLocation(st.renderer.Program[3],"TexCoord");
; 9252 : 					col=glGetAttribLocation(st.renderer.Program[3],"Color");
; 9253 : 
; 9254 : 					glEnableVertexAttribArray(pos);
; 9255 : 					glEnableVertexAttribArray(texc);
; 9256 : 					glEnableVertexAttribArray(col);
; 9257 : 
; 9258 : 					glVertexAttribPointer(pos,3,GL_FLOAT,GL_FALSE,0,0);
; 9259 : 					glVertexAttribPointer(texc,2,GL_FLOAT,GL_FALSE,0,(GLvoid*) (12*sizeof(GLfloat)));
; 9260 : 					glVertexAttribPointer(col,4,GL_UNSIGNED_BYTE,GL_TRUE,0,(GLvoid*) ((12*sizeof(GLfloat))+(8*sizeof(GLfloat))));
; 9261 : 
; 9262 : 					glDrawRangeElements(GL_TRIANGLES,0,6,6,GL_UNSIGNED_SHORT,0);
; 9263 : 					
; 9264 : 					glDisableVertexAttribArray(pos);
; 9265 : 					glDisableVertexAttribArray(texc);
; 9266 : 					glDisableVertexAttribArray(col);
; 9267 : 
; 9268 : 					glBindBuffer(GL_ARRAY_BUFFER,0);
; 9269 : 					glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);
; 9270 : 				}
; 9271 : 			}
; 9272 : 
; 9273 : 			if(i==0) break;
; 9274 : 		}
; 9275 : 
; 9276 : 		//glBindTexture(GL_TEXTURE_2D,st.renderer.FBTex[2]);
; 9277 : 
; 9278 : 		//glGenerateMipmap(GL_TEXTURE_2D);
; 9279 : 
; 9280 : 		memset(z_buffer,0,(5*8)*(2048));
; 9281 : 		memset(z_slot,0,5*8);
; 9282 : 		z_used=0;
; 9283 : 
; 9284 : 		for(i=0;i<MAX_STRINGS;i++)
; 9285 : 		{
; 9286 : 			if(st.strings[i].stat==1)
; 9287 : 			{
; 9288 : 				st.strings[i].stat=2;
; 9289 : 				continue;
; 9290 : 			}
; 9291 : 			else
; 9292 : 			if(st.strings[i].stat==2)
; 9293 : 			{
; 9294 : 				glDeleteTextures(1,&st.strings[i].data.data);
; 9295 : 				st.strings[i].data.channel=0;
; 9296 : 				st.strings[i].stat=0;
; 9297 : 			}
; 9298 : 		}
; 9299 : 		
; 9300 : 		for(i=0;i<vbdt_num;i++)
; 9301 : 		{
; 9302 : 			if(vbdt[i].num_elements>0)
; 9303 : 			{
; 9304 : 				vbdt[i].num_elements=0;
; 9305 : 			}
; 9306 : 		}
; 9307 : 		
; 9308 : 	}
; 9309 : #endif
; 9310 : 
; 9311 : #ifdef _VA_RENDER
; 9312 : 
; 9313 : 	if(st.renderer.VA_ON)
; 9314 : 	{
; 9315 : 		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
; 9316 : 		glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
; 9317 : 
; 9318 : 		//glEnable(GL_ALPHA_TEST);
; 9319 : 		//glAlphaFunc(GL_EQUAL,1.0);
; 9320 : 
; 9321 : 		for(i=z_used;i>-1;i--)
; 9322 : 		{
; 9323 : 			for(j=0;j<z_slot[i];j++)
; 9324 : 			{
; 9325 : 				if(ent[z_buffer[i][j]].data.vb_id!=-1)
; 9326 : 				{
; 9327 : 					m=ent[z_buffer[i][j]].data.vb_id;
; 9328 : 
; 9329 : 					//glActiveTexture(GL_TEXTURE0);
; 9330 : 
; 9331 : 					if(tex_bound[0]!=vbdt[m].texture)
; 9332 : 					{
; 9333 : 						glBindTexture(GL_TEXTURE_2D,vbdt[m].texture);
; 9334 : 						tex_bound[0]=vbdt[m].texture;
; 9335 : 					}
; 9336 : 
; 9337 : 					//glBindTexture(GL_TEXTURE_2D,vbdt[i].texture);
; 9338 : 
; 9339 : 					glEnableClientState(GL_VERTEX_ARRAY);
; 9340 : 					glEnableClientState(GL_TEXTURE_COORD_ARRAY);
; 9341 : 					glEnableClientState(GL_COLOR_ARRAY);
; 9342 : 
; 9343 : 					glVertexPointer(3,GL_FLOAT,0,vbdt[m].vertex);
; 9344 : 					glTexCoordPointer(2,GL_FLOAT,0,vbdt[m].texcoord);
; 9345 : 					glColorPointer(4,GL_UNSIGNED_BYTE,0,vbdt[m].color);
; 9346 : 
; 9347 : 					//glDrawRangeElements(GL_TRIANGLES,0,vbdt[i].num_elements*6,vbdt[i].num_elements*6,GL_UNSIGNED_SHORT,vbdt[i].index);
; 9348 : 
; 9349 : 					l=0;
; 9350 : 					if(j<z_slot[i]-2)
; 9351 : 					{
; 9352 : 						for(m=j+1;m<z_slot[i];m++)
; 9353 : 						{
; 9354 : 							if(ent[z_buffer[i][m]].data.vb_id==ent[z_buffer[i][j]].data.vb_id)
; 9355 : 								l++;
; 9356 : 							else
; 9357 : 								break;
; 9358 : 						}
; 9359 : 					}
; 9360 : 
; 9361 : 					if(!l)
; 9362 : 						glDrawRangeElements(GL_TRIANGLES,(ent[z_buffer[i][j]].data.loc*6),(ent[z_buffer[i][j]].data.loc*6)+6,(ent[z_buffer[i][j]].data.loc*6)+6,GL_UNSIGNED_SHORT,vbdt[m].index);
; 9363 : 					else
; 9364 : 						glDrawRangeElements(GL_TRIANGLES,(ent[z_buffer[i][j]].data.loc*6),((ent[z_buffer[i][j]].data.loc+l)*6)+6,((ent[z_buffer[i][j]].data.loc+l)*6)+6,GL_UNSIGNED_SHORT,vbdt[m].index);
; 9365 : 
; 9366 : 					//glBindVertexArray(0);
; 9367 : 
; 9368 : 					if(l)
; 9369 : 						j+=l;
; 9370 : 
; 9371 : 					glDisableClientState(GL_VERTEX_ARRAY);
; 9372 : 					glDisableClientState(GL_TEXTURE_COORD_ARRAY);
; 9373 : 					glDisableClientState(GL_COLOR_ARRAY);
; 9374 : 				}
; 9375 : 				else
; 9376 : 				{
; 9377 : 					//glActiveTexture(GL_TEXTURE0);
; 9378 : 
; 9379 : 					if(tex_bound[0]!=ent[z_buffer[i][j]].data.data)
; 9380 : 					{
; 9381 : 						glBindTexture(GL_TEXTURE_2D,ent[z_buffer[i][j]].data.data);
; 9382 : 						tex_bound[0]=ent[z_buffer[i][j]].data.data;
; 9383 : 					}
; 9384 : 
; 9385 : 					glEnableClientState(GL_VERTEX_ARRAY);
; 9386 : 					glEnableClientState(GL_TEXTURE_COORD_ARRAY);
; 9387 : 					glEnableClientState(GL_COLOR_ARRAY);
; 9388 : 
; 9389 : 					glVertexPointer(3,GL_FLOAT,0,ent[z_buffer[i][j]].vertex);
; 9390 : 					glTexCoordPointer(2,GL_FLOAT,0,ent[z_buffer[i][j]].texcor);
; 9391 : 					glColorPointer(4,GL_UNSIGNED_BYTE,0,ent[z_buffer[i][j]].color);
; 9392 : 
; 9393 : 					glDrawRangeElements(GL_TRIANGLES,0,6,6,GL_UNSIGNED_SHORT,vbd.index);
; 9394 : 
; 9395 : 					glDisableClientState(GL_VERTEX_ARRAY);
; 9396 : 					glDisableClientState(GL_TEXTURE_COORD_ARRAY);
; 9397 : 					glDisableClientState(GL_COLOR_ARRAY);
; 9398 : 				}
; 9399 : 			}
; 9400 : 		}
; 9401 : 
; 9402 : 		glDisable(GL_DEPTH_TEST);
; 9403 : 		
; 9404 : 		glBlendFunc(GL_DST_COLOR, GL_ZERO);
; 9405 : 
; 9406 : 		if(st.num_lightmap>0)
; 9407 : 		{
; 9408 : 			for(i=0;i<st.num_lightmap;i++)
; 9409 : 			{
; 9410 : 				glBindTexture(GL_TEXTURE_2D,lmp[i].data.data);
; 9411 : 
; 9412 : 				glEnableClientState(GL_VERTEX_ARRAY);
; 9413 : 				glEnableClientState(GL_TEXTURE_COORD_ARRAY);
; 9414 : 				glEnableClientState(GL_COLOR_ARRAY);
; 9415 : 
; 9416 : 				glVertexPointer(3,GL_FLOAT,0,lmp[i].vertex);
; 9417 : 				glTexCoordPointer(2,GL_FLOAT,0,texcoord);
; 9418 : 				glColorPointer(4,GL_UNSIGNED_BYTE,0,vbd.color);
; 9419 : 
; 9420 : 				glDrawRangeElements(GL_TRIANGLES,0,6,6,GL_UNSIGNED_SHORT,vbd.index);
; 9421 : 
; 9422 : 				glDisableClientState(GL_VERTEX_ARRAY);
; 9423 : 				glDisableClientState(GL_TEXTURE_COORD_ARRAY);
; 9424 : 				glDisableClientState(GL_COLOR_ARRAY);
; 9425 : 			}
; 9426 : 		}
; 9427 : 
; 9428 : 		glEnable(GL_DEPTH_TEST);
; 9429 : 
; 9430 : 		memset(z_buffer,0,(5*8)*(2048));
; 9431 : 		memset(z_slot,0,5*8);
; 9432 : 		z_used=0;
; 9433 : 
; 9434 : 		for(i=0;i<MAX_STRINGS;i++)
; 9435 : 		{
; 9436 : 			if(st.strings[i].stat==1)
; 9437 : 			{
; 9438 : 				st.strings[i].stat=2;
; 9439 : 				continue;
; 9440 : 			}
; 9441 : 			else
; 9442 : 			if(st.strings[i].stat==2)
; 9443 : 			{
; 9444 : 				glDeleteTextures(1,&st.strings[i].data.data);
; 9445 : 				st.strings[i].data.channel=0;
; 9446 : 				st.strings[i].stat=0;
; 9447 : 			}
; 9448 : 		}
; 9449 : 		
; 9450 : 		for(i=0;i<vbdt_num;i++)
; 9451 : 		{
; 9452 : 			if(vbdt[i].num_elements>0)
; 9453 : 			{
; 9454 : 				vbdt[i].num_elements=0;
; 9455 : 			}
; 9456 : 		}
; 9457 : 	}
; 9458 : 
; 9459 : #endif
; 9460 : 
; 9461 : 	st.num_entities=0;
; 9462 : 
; 9463 : #if defined (_VAO_RENDER) || defined (_VBO_RENDER) || defined (_VA_RENDER)
; 9464 : 	texone_num=0;

	xor	eax, eax
	mov	DWORD PTR _st+244, 0

; 9465 : #endif
; 9466 : 
; 9467 : 	st.num_lightmap=0;
; 9468 : 	memset(&ent,0,MAX_GRAPHICS);

	push	2048					; 00000800H
	push	eax
	push	OFFSET _ent
	mov	WORD PTR _texone_num, ax
	mov	BYTE PTR _st+261, al
	call	_memset

; 9469 : 	memset(&lmp,0,MAX_LIGHTMAPS);

	push	128					; 00000080H
	push	0
	push	OFFSET _lmp
	call	_memset
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx

; 9470 : 
; 9471 : 	//SDL_GL_SwapWindow(wn);
; 9472 : 
; 9473 : 	
; 9474 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Renderer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\engine.c
;	COMDAT _Finish
_TEXT	SEGMENT
_Finish	PROC						; COMDAT

; 9478 : 	register uint16 i=0;
; 9479 : 
; 9480 : 	//for(i=0;i<st.num_calls;i++)
; 9481 : 		//if(st.renderer.ppline[i].type>3)
; 9482 : 			//free(st.renderer.ppline[i].text);
; 9483 : 
; 9484 : 	st.num_calls=0;
; 9485 : 
; 9486 : 	memset(st.renderer.ppline,MAX_DRAWCALLS,sizeof(PIPELINE));

	push	372					; 00000174H
	xor	eax, eax
	push	1024					; 00000400H
	push	OFFSET _st+2336876
	mov	WORD PTR _st+262, ax
	call	_memset
	add	esp, 12					; 0000000cH

; 9487 : }

	ret	0
_Finish	ENDP
_TEXT	ENDS
END
