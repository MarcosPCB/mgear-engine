; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	C:\Users\Marcos\Desktop\prj\mGear-1\mGear-1\input.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DA@PMCGCBBG@Game?5Controller?5?$CFd?5could?5not?5be?5@ ; `string'
PUBLIC	??_C@_0BM@LJNKGHEH@Found?5?$CFd?5controller?5devices?$AA@ ; `string'
PUBLIC	??_C@_0DC@MGGNMPIL@Controller?5?$CFd?5does?5not?5support?5f@ ; `string'
PUBLIC	??_C@_0CA@HBDNELMP@Could?5not?5initialize?5rumble?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BL@HONEDAOF@Text?5Input?5already?5started?$AA@ ; `string'
EXTRN	__imp__SDL_HapticOpenFromJoystick:PROC
EXTRN	__imp__SDL_GameControllerGetAxis:PROC
EXTRN	__imp__SDL_GameControllerClose:PROC
EXTRN	__imp__SDL_GameControllerUpdate:PROC
EXTRN	__imp__SDL_StartTextInput:PROC
EXTRN	__imp__SDL_GameControllerOpen:PROC
EXTRN	__imp__SDL_IsGameController:PROC
EXTRN	__imp__SDL_JoystickOpen:PROC
EXTRN	__imp__SDL_NumJoysticks:PROC
EXTRN	__imp__SDL_JoystickClose:PROC
EXTRN	__imp__SDL_GameControllerGetButton:PROC
EXTRN	__imp__SDL_WarpMouseInWindow:PROC
EXTRN	__imp__SDL_HapticRumbleInit:PROC
EXTRN	__imp__SDL_HapticClose:PROC
EXTRN	__imp__SDL_StopTextInput:PROC
;	COMDAT ??_C@_0BL@HONEDAOF@Text?5Input?5already?5started?$AA@
CONST	SEGMENT
??_C@_0BL@HONEDAOF@Text?5Input?5already?5started?$AA@ DB 'Text Input alre'
	DB	'ady started', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HBDNELMP@Could?5not?5initialize?5rumble?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0CA@HBDNELMP@Could?5not?5initialize?5rumble?3?5?$CFs?$AA@ DB 'Could'
	DB	' not initialize rumble: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MGGNMPIL@Controller?5?$CFd?5does?5not?5support?5f@
CONST	SEGMENT
??_C@_0DC@MGGNMPIL@Controller?5?$CFd?5does?5not?5support?5f@ DB 'Controll'
	DB	'er %d does not support force feedback: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LJNKGHEH@Found?5?$CFd?5controller?5devices?$AA@
CONST	SEGMENT
??_C@_0BM@LJNKGHEH@Found?5?$CFd?5controller?5devices?$AA@ DB 'Found %d co'
	DB	'ntroller devices', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PMCGCBBG@Game?5Controller?5?$CFd?5could?5not?5be?5@
CONST	SEGMENT
??_C@_0DA@PMCGCBBG@Game?5Controller?5?$CFd?5could?5not?5be?5@ DB 'Game Co'
	DB	'ntroller %d could not be initialized: %s', 00H ; `string'
PUBLIC	_InputClose
PUBLIC	_InputInit
PUBLIC	_InputProcess
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\input.c
;	COMDAT _InputProcess
_TEXT	SEGMENT
_j$1$ = -4						; size = 4
_InputProcess PROC					; COMDAT

; 152  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 153  : 	size_t len;
; 154  : 	uint16 i, j;
; 155  : 		//while(SDL_PollEvent(&events))
; 156  : 
; 157  : 				for(i=0;i<MAX_KEYS;i++)

	mov	edx, DWORD PTR _events
	mov	eax, OFFSET _st+65648
	push	ebx
	mov	ebx, DWORD PTR _events+16
	mov	ecx, 128				; 00000080H
	push	esi
	push	edi
	npad	3
$LL32@InputProce:

; 158  : 				{
; 159  : 				
; 160  : 					if(events.type==SDL_KEYUP)

	cmp	edx, 769				; 00000301H
	jne	SHORT $LN29@InputProce

; 161  : 					{
; 162  : 						if(st.keys[i].key==events.key.keysym.scancode)

	cmp	DWORD PTR [eax-4], ebx
	jne	SHORT $LN31@InputProce

; 163  : 							st.keys[i].state=0;

	mov	BYTE PTR [eax], 0

; 164  : 					}
; 165  : 					else

	jmp	SHORT $LN31@InputProce
$LN29@InputProce:

; 166  : 					if(events.type==SDL_KEYDOWN)

	cmp	edx, 768				; 00000300H
	jne	SHORT $LN31@InputProce

; 167  : 					{
; 168  : 						if(st.keys[i].key==events.key.keysym.scancode)

	cmp	DWORD PTR [eax-4], ebx
	jne	SHORT $LN31@InputProce

; 169  : 							st.keys[i].state=1;

	mov	BYTE PTR [eax], 1
$LN31@InputProce:

; 153  : 	size_t len;
; 154  : 	uint16 i, j;
; 155  : 		//while(SDL_PollEvent(&events))
; 156  : 
; 157  : 				for(i=0;i<MAX_KEYS;i++)

	add	eax, 8
	dec	ecx
	jne	SHORT $LL32@InputProce

; 170  : 					}
; 171  : 				
; 172  : 				}
; 173  : 
; 174  : 				if(st.control_num>0)

	cmp	BYTE PTR _st+2335447, cl
	jbe	$LN21@InputProce

; 175  : 				{
; 176  : 					SDL_GameControllerUpdate();

	call	DWORD PTR __imp__SDL_GameControllerUpdate

; 177  : 
; 178  : 					for(j=0;j<st.control_num;j++)

	xor	ecx, ecx
	mov	DWORD PTR _j$1$[ebp], ecx
	cmp	BYTE PTR _st+2335447, cl
	jbe	SHORT $LN50@InputProce
	npad	9
$LL23@InputProce:
	movzx	eax, cx

; 179  : 					{		
; 180  : 						for(i=0;i<15;i++)

	xor	edi, edi
	imul	ebx, eax, 248
	lea	esi, DWORD PTR _st[ebx+2335456]
$LL20@InputProce:

; 181  : 						{
; 182  : 							st.controller[j].button[i].state=SDL_GameControllerGetButton(st.controller[j].device,st.controller[j].button[i].name);

	push	DWORD PTR [esi-4]
	push	DWORD PTR _st[ebx+2335448]
	call	DWORD PTR __imp__SDL_GameControllerGetButton
	add	esp, 8
	mov	BYTE PTR [esi], al

; 183  : 
; 184  : 							if(i<6)

	cmp	di, 6
	jae	SHORT $LN19@InputProce

; 185  : 								st.controller[j].axis[i].state=SDL_GameControllerGetAxis(st.controller[j].device,st.controller[j].axis[i].name);

	push	DWORD PTR [esi+116]
	push	DWORD PTR _st[ebx+2335448]
	call	DWORD PTR __imp__SDL_GameControllerGetAxis
	add	esp, 8
	mov	WORD PTR [esi+120], ax
$LN19@InputProce:

; 179  : 					{		
; 180  : 						for(i=0;i<15;i++)

	inc	edi
	add	esi, 8
	cmp	di, 15					; 0000000fH
	jb	SHORT $LL20@InputProce

; 177  : 
; 178  : 					for(j=0;j<st.control_num;j++)

	mov	ecx, DWORD PTR _j$1$[ebp]
	movzx	eax, BYTE PTR _st+2335447
	inc	ecx
	mov	DWORD PTR _j$1$[ebp], ecx
	cmp	cx, ax
	jb	SHORT $LL23@InputProce
$LN50@InputProce:
	mov	edx, DWORD PTR _events
	mov	ebx, DWORD PTR _events+16
$LN21@InputProce:

; 186  : 						}
; 187  : 					}
; 188  : 				}
; 189  : 				
; 190  : 				if(st.keys[BACKSPACE_KEY].state && st.Text_Input)

	cmp	BYTE PTR _st+65856, 0
	je	SHORT $LN51@InputProce
	cmp	BYTE PTR _st+66798, 0
	je	SHORT $LN51@InputProce

; 191  : 				{
; 192  : 					len=strlen(st.TextInput);

	mov	ecx, OFFSET _st+66670
	lea	esi, DWORD PTR [ecx+1]
$LL47@InputProce:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL47@InputProce
	sub	ecx, esi

; 193  : 
; 194  : 					if(len>1)

	cmp	ecx, 1
	jbe	SHORT $LN15@InputProce

; 195  : 					{
; 196  : 						st.TextInput[len]='\b';
; 197  : 						st.TextInput[len-1]='\0';

	mov	WORD PTR _st[ecx+66669], 2048		; 00000800H

; 198  : 					}
; 199  : 					else

	jmp	SHORT $LN13@InputProce
$LN15@InputProce:

; 200  : 					if(len==1)

	movzx	eax, BYTE PTR _st+66670
	xor	esi, esi
	cmp	ecx, 1
	cmove	eax, esi
	mov	BYTE PTR _st+66670, al
$LN13@InputProce:

; 201  : 					{
; 202  : 						st.TextInput[0]='\0';
; 203  : 					}
; 204  : 
; 205  : 					st.keys[BACKSPACE_KEY].state=0;

	mov	BYTE PTR _st+65856, 0
$LN51@InputProce:

; 206  : 				}
; 207  : 				
; 208  : 				if(events.type==SDL_TEXTINPUT && st.Text_Input)

	cmp	edx, 771				; 00000303H
	jne	SHORT $LN12@InputProce
	cmp	BYTE PTR _st+66798, 0
	je	$LN2@InputProce

; 209  : 					strcat(st.TextInput,events.text.text);

	mov	edx, OFFSET _events+12
	mov	esi, edx
$LL48@InputProce:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL48@InputProce
	mov	edi, OFFSET _st+66670
	sub	edx, esi
	dec	edi
$LL49@InputProce:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL49@InputProce
	mov	ecx, edx
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb

; 210  : 				
; 211  : 				if(events.type==SDL_MOUSEMOTION)

	jmp	$LN2@InputProce
$LN12@InputProce:
	cmp	edx, 1024				; 00000400H
	jne	SHORT $LN11@InputProce

; 212  : 				{
; 213  : 					st.mouse.x=events.motion.x;

	mov	eax, DWORD PTR _events+20
	mov	DWORD PTR _st+65624, eax

; 214  : 					st.mouse.y=events.motion.y;

	mov	eax, DWORD PTR _events+24
	mov	DWORD PTR _st+65628, eax

; 215  : 				}
; 216  : 
; 217  : 				if(events.type==SDL_MOUSEBUTTONDOWN)

	jmp	$LN2@InputProce
$LN11@InputProce:
	cmp	edx, 1025				; 00000401H
	jne	SHORT $LN10@InputProce

; 218  : 				{
; 219  : 					st.mouse.x=events.motion.x;

	mov	eax, DWORD PTR _events+20
	mov	DWORD PTR _st+65624, eax

; 220  : 					st.mouse.y=events.motion.y;

	mov	eax, DWORD PTR _events+24
	mov	DWORD PTR _st+65628, eax

; 221  : 
; 222  : 					if(events.button.button==SDL_BUTTON_LEFT)

	cmp	bl, 1
	jne	SHORT $LN9@InputProce

; 223  : 						st.mouse1=1;

	mov	BYTE PTR _st+65636, bl

; 224  : 
; 225  : 					if(events.button.button==SDL_BUTTON_RIGHT)

	jmp	SHORT $LN2@InputProce
$LN9@InputProce:
	cmp	bl, 3
	jne	SHORT $LN2@InputProce

; 226  : 						st.mouse2=1;

	mov	BYTE PTR _st+65637, 1

; 227  : 
; 228  : 				}
; 229  : 				else

	jmp	SHORT $LN2@InputProce
$LN10@InputProce:

; 230  : 				if(events.type==SDL_MOUSEBUTTONUP)

	cmp	edx, 1026				; 00000402H
	jne	SHORT $LN6@InputProce

; 231  : 				{
; 232  : 					st.mouse.x=events.motion.x;

	mov	eax, DWORD PTR _events+20
	mov	DWORD PTR _st+65624, eax

; 233  : 					st.mouse.y=events.motion.y;

	mov	eax, DWORD PTR _events+24
	mov	DWORD PTR _st+65628, eax

; 234  : 
; 235  : 					if(events.button.button==SDL_BUTTON_LEFT)

	cmp	bl, 1
	jne	SHORT $LN5@InputProce

; 236  : 						st.mouse1=0;

	mov	BYTE PTR _st+65636, 0

; 237  : 
; 238  : 					if(events.button.button==SDL_BUTTON_RIGHT)

	jmp	SHORT $LN2@InputProce
$LN5@InputProce:
	cmp	bl, 3
	jne	SHORT $LN2@InputProce

; 239  : 						st.mouse2=0;

	mov	BYTE PTR _st+65637, 0

; 240  : 
; 241  : 				}
; 242  : 				else

	jmp	SHORT $LN2@InputProce
$LN6@InputProce:

; 243  : 				if(events.type==SDL_MOUSEWHEEL)

	mov	eax, DWORD PTR _st+65640
	cmp	edx, 1027				; 00000403H
	cmove	eax, DWORD PTR _events+20
	mov	DWORD PTR _st+65640, eax
$LN2@InputProce:

; 244  : 					st.mouse_wheel=events.wheel.y;
; 245  : 
; 246  : 		
; 247  : 
; 248  : 		if(st.keys[RETURN_KEY].state && st.PlayingVideo)

	cmp	BYTE PTR _st+65656, 0
	pop	edi
	pop	esi
	pop	ebx
	je	SHORT $LN1@InputProce
	cmp	BYTE PTR _st+66669, 0
	je	SHORT $LN1@InputProce

; 249  : 		{
; 250  : 			st.PlayingVideo=0;

	mov	BYTE PTR _st+66669, 0

; 251  : 			st.keys[RETURN_KEY].state=0;

	mov	BYTE PTR _st+65656, 0
$LN1@InputProce:

; 252  : 		}
; 253  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_InputProcess ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\input.c
;	COMDAT _InputInit
_TEXT	SEGMENT
tv1078 = -4						; size = 4
_num$2$ = -4						; size = 4
_InputInit PROC						; COMDAT

; 4    : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5    : 	uint32 num, j, i;
; 6    : 
; 7    : 	st.keys[ESC_KEY].key=SDL_SCANCODE_ESCAPE;

	mov	DWORD PTR _st+65644, 41			; 00000029H

; 8    : 	st.keys[RETURN_KEY].key=SDL_SCANCODE_RETURN;
; 9    : 	st.keys[2].key=SDL_SCANCODE_RIGHT;
; 10   : 	st.keys[3].key=SDL_SCANCODE_LEFT;
; 11   : 	st.keys[4].key=SDL_SCANCODE_UP;
; 12   : 	st.keys[5].key=SDL_SCANCODE_DOWN;
; 13   : 	st.keys[6].key=SDL_SCANCODE_SPACE;
; 14   : 	st.keys[7].key=SDL_SCANCODE_LCTRL;
; 15   : 	st.keys[8].key=SDL_SCANCODE_RCTRL;
; 16   : 	st.keys[9].key=SDL_SCANCODE_LSHIFT;
; 17   : 	st.keys[10].key=SDL_SCANCODE_RSHIFT;
; 18   : 	st.keys[11].key=SDL_SCANCODE_TAB;
; 19   : 	st.keys[12].key=SDL_SCANCODE_LALT;
; 20   : 	st.keys[13].key=SDL_SCANCODE_RALT;
; 21   : 	st.keys[14].key=SDL_SCANCODE_F1;

	xor	ecx, ecx
	mov	DWORD PTR _st+65652, 40			; 00000028H
	mov	DWORD PTR _st+65660, 79			; 0000004fH
	mov	DWORD PTR _st+65668, 80			; 00000050H
	mov	DWORD PTR _st+65676, 82			; 00000052H
	mov	DWORD PTR _st+65684, 81			; 00000051H
	mov	DWORD PTR _st+65692, 44			; 0000002cH
	mov	DWORD PTR _st+65700, 224		; 000000e0H
	mov	DWORD PTR _st+65708, 228		; 000000e4H
	mov	DWORD PTR _st+65716, 225		; 000000e1H
	mov	DWORD PTR _st+65724, 229		; 000000e5H
	mov	DWORD PTR _st+65732, 43			; 0000002bH
	mov	DWORD PTR _st+65740, 226		; 000000e2H
	mov	DWORD PTR _st+65748, 230		; 000000e6H
$LL23@InputInit:
	lea	eax, DWORD PTR [ecx+58]
	mov	DWORD PTR _st[ecx*8+65756], eax
	inc	ecx
	cmp	ecx, 12					; 0000000cH
	jl	SHORT $LL23@InputInit

; 22   : 	st.keys[15].key=SDL_SCANCODE_F2;
; 23   : 	st.keys[16].key=SDL_SCANCODE_F3;
; 24   : 	st.keys[17].key=SDL_SCANCODE_F4;
; 25   : 	st.keys[18].key=SDL_SCANCODE_F5;
; 26   : 	st.keys[19].key=SDL_SCANCODE_F6;
; 27   : 	st.keys[20].key=SDL_SCANCODE_F7;
; 28   : 	st.keys[21].key=SDL_SCANCODE_F8;
; 29   : 	st.keys[22].key=SDL_SCANCODE_F9;
; 30   : 	st.keys[23].key=SDL_SCANCODE_F10;
; 31   : 	st.keys[24].key=SDL_SCANCODE_F11;
; 32   : 	st.keys[25].key=SDL_SCANCODE_F12;
; 33   : 	st.keys[26].key=SDL_SCANCODE_BACKSPACE;

	mov	DWORD PTR _st+65852, 42			; 0000002aH

; 34   : 	st.keys[27].key=SDL_SCANCODE_0;
; 35   : 	st.keys[28].key=SDL_SCANCODE_1;
; 36   : 	st.keys[29].key=SDL_SCANCODE_2;
; 37   : 	st.keys[30].key=SDL_SCANCODE_3;
; 38   : 	st.keys[31].key=SDL_SCANCODE_4;
; 39   : 	st.keys[32].key=SDL_SCANCODE_5;
; 40   : 	st.keys[33].key=SDL_SCANCODE_6;
; 41   : 	st.keys[34].key=SDL_SCANCODE_7;
; 42   : 	st.keys[35].key=SDL_SCANCODE_8;
; 43   : 	st.keys[36].key=SDL_SCANCODE_9;
; 44   : 	st.keys[37].key=SDL_SCANCODE_A;

	xor	ecx, ecx
	mov	DWORD PTR _st+65860, 39			; 00000027H
	mov	DWORD PTR _st+65868, 30			; 0000001eH
	mov	DWORD PTR _st+65876, 31			; 0000001fH
	mov	DWORD PTR _st+65884, 32			; 00000020H
	mov	DWORD PTR _st+65892, 33			; 00000021H
	mov	DWORD PTR _st+65900, 34			; 00000022H
	mov	DWORD PTR _st+65908, 35			; 00000023H
	mov	DWORD PTR _st+65916, 36			; 00000024H
	mov	DWORD PTR _st+65924, 37			; 00000025H
	mov	DWORD PTR _st+65932, 38			; 00000026H
$LL25@InputInit:
	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _st[ecx*8+65940], eax
	inc	ecx
	cmp	ecx, 26					; 0000001aH
	jl	SHORT $LL25@InputInit

; 45   : 	st.keys[38].key=SDL_SCANCODE_B;
; 46   : 	st.keys[39].key=SDL_SCANCODE_C;
; 47   : 	st.keys[40].key=SDL_SCANCODE_D;
; 48   : 	st.keys[41].key=SDL_SCANCODE_E;
; 49   : 	st.keys[42].key=SDL_SCANCODE_F;
; 50   : 	st.keys[43].key=SDL_SCANCODE_G;
; 51   : 	st.keys[44].key=SDL_SCANCODE_H;
; 52   : 	st.keys[45].key=SDL_SCANCODE_I;
; 53   : 	st.keys[46].key=SDL_SCANCODE_J;
; 54   : 	st.keys[47].key=SDL_SCANCODE_K;
; 55   : 	st.keys[48].key=SDL_SCANCODE_L;
; 56   : 	st.keys[49].key=SDL_SCANCODE_M;
; 57   : 	st.keys[50].key=SDL_SCANCODE_N;
; 58   : 	st.keys[51].key=SDL_SCANCODE_O;
; 59   : 	st.keys[52].key=SDL_SCANCODE_P;
; 60   : 	st.keys[53].key=SDL_SCANCODE_Q;
; 61   : 	st.keys[54].key=SDL_SCANCODE_R;
; 62   : 	st.keys[55].key=SDL_SCANCODE_S;
; 63   : 	st.keys[56].key=SDL_SCANCODE_T;
; 64   : 	st.keys[57].key=SDL_SCANCODE_U;
; 65   : 	st.keys[58].key=SDL_SCANCODE_V;
; 66   : 	st.keys[59].key=SDL_SCANCODE_W;
; 67   : 	st.keys[60].key=SDL_SCANCODE_X;
; 68   : 	st.keys[61].key=SDL_SCANCODE_Y;
; 69   : 	st.keys[62].key=SDL_SCANCODE_Z;
; 70   : 	st.keys[63].key=SDL_SCANCODE_COMMA;

	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _st+66148, 54			; 00000036H

; 71   : 	st.keys[64].key=SDL_SCANCODE_BACKSLASH;

	mov	DWORD PTR _st+66156, 49			; 00000031H

; 72   : 	st.keys[65].key=SDL_SCANCODE_GRAVE;

	mov	DWORD PTR _st+66164, 53			; 00000035H

; 73   : 	st.keys[66].key=SDL_SCANCODE_SLASH;

	mov	DWORD PTR _st+66172, 56			; 00000038H

; 74   : 	st.keys[67].key=SDL_SCANCODE_APOSTROPHE;

	mov	DWORD PTR _st+66180, 52			; 00000034H

; 75   : 	st.keys[68].key=SDL_SCANCODE_EQUALS;

	mov	DWORD PTR _st+66188, 46			; 0000002eH

; 76   : 	st.keys[69].key=SDL_SCANCODE_MINUS;

	mov	DWORD PTR _st+66196, 45			; 0000002dH

; 77   : 	st.keys[70].key=SDL_SCANCODE_LEFTBRACKET;

	mov	DWORD PTR _st+66204, 47			; 0000002fH

; 78   : 	st.keys[71].key=SDL_SCANCODE_RIGHTBRACKET;

	mov	DWORD PTR _st+66212, 48			; 00000030H

; 79   : 	st.keys[72].key=SDL_SCANCODE_PERIOD;

	mov	DWORD PTR _st+66220, 55			; 00000037H

; 80   : 	st.keys[73].key=SDL_SCANCODE_SEMICOLON;

	mov	DWORD PTR _st+66228, 51			; 00000033H

; 81   : 	st.keys[74].key=SDL_SCANCODE_CAPSLOCK;

	mov	DWORD PTR _st+66236, 57			; 00000039H

; 82   : 	st.keys[75].key=SDL_SCANCODE_DELETE;

	mov	DWORD PTR _st+66244, 76			; 0000004cH

; 83   : 
; 84   : 	num=SDL_NumJoysticks();

	call	DWORD PTR __imp__SDL_NumJoysticks

; 90   : 
; 91   : 	for(i=0;i<num;i++)

	mov	edi, DWORD PTR __imp__SDL_Log
	mov	ecx, 4
	cmp	eax, ecx
	cmova	eax, ecx
	xor	ebx, ebx
	xor	esi, esi
	mov	DWORD PTR _num$2$[ebp], eax
	test	eax, eax
	je	SHORT $LN13@InputInit

; 85   : 
; 86   : 	//Check if it's a game controller
; 87   : 
; 88   : 	if(num>4) num=4; //Max number of joysticks is 4
; 89   : 	j=0;

	mov	edi, OFFSET _st+2335692
	npad	3
$LL15@InputInit:

; 92   : 	{
; 93   : 		if(SDL_IsGameController(i))

	push	esi
	call	DWORD PTR __imp__SDL_IsGameController
	add	esp, 4
	test	eax, eax
	je	SHORT $LN14@InputInit

; 94   : 		{
; 95   : 			if((st.controller[j].device=SDL_GameControllerOpen(i))==NULL)

	push	esi
	call	DWORD PTR __imp__SDL_GameControllerOpen
	add	esp, 4
	mov	DWORD PTR [edi-244], eax
	test	eax, eax
	je	SHORT $LN44@InputInit

; 96   : 				LogApp("Game Controller %d could not be initialized: %s",i,SDL_GetError());
; 97   : 			else
; 98   : 			if((st.controller[j].joystick=SDL_JoystickOpen(i))==NULL)

	push	esi
	call	DWORD PTR __imp__SDL_JoystickOpen
	add	esp, 4
	mov	DWORD PTR [edi], eax
	test	eax, eax
	jne	SHORT $LN9@InputInit
$LN44@InputInit:

; 99   : 				LogApp("Game Controller %d could not be initialized: %s",i,SDL_GetError());

	call	DWORD PTR __imp__SDL_GetError
	push	eax
	push	esi
	push	OFFSET ??_C@_0DA@PMCGCBBG@Game?5Controller?5?$CFd?5could?5not?5be?5@
	call	DWORD PTR __imp__SDL_Log
	add	esp, 12					; 0000000cH

; 100  : 			else

	jmp	SHORT $LN14@InputInit
$LN9@InputInit:

; 101  : 				j++;

	inc	ebx
	add	edi, 248				; 000000f8H
$LN14@InputInit:

; 90   : 
; 91   : 	for(i=0;i<num;i++)

	inc	esi
	cmp	esi, DWORD PTR _num$2$[ebp]
	jb	SHORT $LL15@InputInit
	mov	edi, DWORD PTR __imp__SDL_Log
$LN13@InputInit:

; 102  : 		}
; 103  : 		/*
; 104  : 		else
; 105  : 		if((st.Joy[i]=SDL_JoystickOpen(i))==NULL)
; 106  : 			LogApp("Joystick %d could not be initialized: %s",i,SDL_GetError());
; 107  : 			*/
; 108  : 	}
; 109  : 
; 110  : 	LogApp("Found %d controller devices",j);

	push	ebx
	push	OFFSET ??_C@_0BM@LJNKGHEH@Found?5?$CFd?5controller?5devices?$AA@
	call	edi
	add	esp, 8

; 111  : 
; 112  : 	if(j>0)

	test	ebx, ebx
	je	$LN4@InputInit

; 113  : 	{
; 114  : 
; 115  : 		st.control_num=j;

	mov	BYTE PTR _st+2335447, bl
	mov	esi, OFFSET _st+2335620
	mov	DWORD PTR tv1078[ebp], ebx
	npad	2
$LL6@InputInit:

; 118  : 		{
; 119  : 			if((st.controller[i].force=SDL_HapticOpenFromJoystick(st.controller[i].joystick))==NULL)

	push	DWORD PTR [esi+72]
	call	DWORD PTR __imp__SDL_HapticOpenFromJoystick
	add	esp, 4
	mov	DWORD PTR [esi], eax
	test	eax, eax
	jne	SHORT $LN3@InputInit

; 120  : 				LogApp("Controller %d does not support force feedback: %s",j,SDL_GetError());

	call	DWORD PTR __imp__SDL_GetError
	push	eax
	push	ebx
	push	OFFSET ??_C@_0DC@MGGNMPIL@Controller?5?$CFd?5does?5not?5support?5f@
	call	edi
	add	esp, 12					; 0000000cH

; 121  : 			else

	jmp	SHORT $LN1@InputInit
$LN3@InputInit:

; 122  : 				if(SDL_HapticRumbleInit(st.controller[i].force)!=0)

	push	eax
	call	DWORD PTR __imp__SDL_HapticRumbleInit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@InputInit

; 123  : 					LogApp("Could not initialize rumble: %s",SDL_GetError());

	call	DWORD PTR __imp__SDL_GetError
	push	eax
	push	OFFSET ??_C@_0CA@HBDNELMP@Could?5not?5initialize?5rumble?3?5?$CFs?$AA@
	call	edi
	add	esp, 8
$LN1@InputInit:

; 124  : 
; 125  : 			st.controller[i].axis[0].name=SDL_CONTROLLER_AXIS_LEFTX;

	mov	DWORD PTR [esi-48], 0
	lea	ecx, DWORD PTR [esi-168]

; 126  : 			st.controller[i].axis[1].name=SDL_CONTROLLER_AXIS_LEFTY;

	mov	DWORD PTR [esi-40], 1

; 127  : 			st.controller[i].axis[2].name=SDL_CONTROLLER_AXIS_RIGHTX;
; 128  : 			st.controller[i].axis[3].name=SDL_CONTROLLER_AXIS_RIGHTY;
; 129  : 			st.controller[i].axis[4].name=SDL_CONTROLLER_AXIS_TRIGGERLEFT;
; 130  : 			st.controller[i].axis[5].name=SDL_CONTROLLER_AXIS_TRIGGERRIGHT;
; 131  : 
; 132  : 			st.controller[i].button[0].name=SDL_CONTROLLER_BUTTON_A;

	xor	eax, eax
	mov	DWORD PTR [esi-32], 2
	mov	DWORD PTR [esi-24], 3
	mov	DWORD PTR [esi-16], 4
	mov	DWORD PTR [esi-8], 5
$LL27@InputInit:
	mov	DWORD PTR [ecx], eax
	lea	ecx, DWORD PTR [ecx+8]
	inc	eax
	cmp	eax, 15					; 0000000fH
	jl	SHORT $LL27@InputInit

; 116  : 
; 117  : 		for(i=0;i<j;i++)

	add	esi, 248				; 000000f8H
	dec	DWORD PTR tv1078[ebp]
	jne	$LL6@InputInit
$LN4@InputInit:
	pop	edi
	pop	esi
	pop	ebx

; 133  : 			st.controller[i].button[1].name=SDL_CONTROLLER_BUTTON_B;
; 134  : 			st.controller[i].button[2].name=SDL_CONTROLLER_BUTTON_X;
; 135  : 			st.controller[i].button[3].name=SDL_CONTROLLER_BUTTON_Y;
; 136  : 			st.controller[i].button[4].name=SDL_CONTROLLER_BUTTON_BACK;
; 137  : 			st.controller[i].button[5].name=SDL_CONTROLLER_BUTTON_GUIDE;
; 138  : 			st.controller[i].button[6].name=SDL_CONTROLLER_BUTTON_START;
; 139  : 			st.controller[i].button[7].name=SDL_CONTROLLER_BUTTON_LEFTSTICK;
; 140  : 			st.controller[i].button[8].name=SDL_CONTROLLER_BUTTON_RIGHTSTICK;
; 141  : 			st.controller[i].button[9].name=SDL_CONTROLLER_BUTTON_LEFTSHOULDER;
; 142  : 			st.controller[i].button[10].name=SDL_CONTROLLER_BUTTON_RIGHTSHOULDER;
; 143  : 			st.controller[i].button[11].name=SDL_CONTROLLER_BUTTON_DPAD_UP;
; 144  : 			st.controller[i].button[12].name=SDL_CONTROLLER_BUTTON_DPAD_DOWN;
; 145  : 			st.controller[i].button[13].name=SDL_CONTROLLER_BUTTON_DPAD_LEFT;
; 146  : 			st.controller[i].button[14].name=SDL_CONTROLLER_BUTTON_DPAD_RIGHT;
; 147  : 		}
; 148  : 	}
; 149  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_InputInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\marcos\desktop\prj\mgear-1\mgear-1\input.c
;	COMDAT _InputClose
_TEXT	SEGMENT
_InputClose PROC					; COMDAT

; 257  : 	uint16 i;
; 258  : 
; 259  : 	if(st.control_num>0)

	mov	al, BYTE PTR _st+2335447
	test	al, al
	je	SHORT $LN1@InputClose

; 260  : 	{
; 261  : 		for(i=0;i<st.control_num;i++)

	push	edi
	xor	edi, edi
	test	al, al
	je	SHORT $LN11@InputClose
	push	ebx
	mov	ebx, DWORD PTR __imp__SDL_HapticClose
	push	esi
	npad	8
$LL3@InputClose:

; 262  : 		{
; 263  : 			SDL_HapticClose(st.controller[i].force);

	movzx	eax, di
	imul	esi, eax, 248
	push	DWORD PTR _st[esi+2335620]
	call	ebx

; 264  : 			SDL_JoystickClose(st.controller[i].joystick);

	push	DWORD PTR _st[esi+2335692]
	call	DWORD PTR __imp__SDL_JoystickClose

; 265  : 			SDL_GameControllerClose(st.controller[i].device);

	push	DWORD PTR _st[esi+2335448]
	call	DWORD PTR __imp__SDL_GameControllerClose
	movzx	eax, BYTE PTR _st+2335447
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	di, ax
	jb	SHORT $LL3@InputClose
	pop	esi
	pop	ebx
$LN11@InputClose:
	pop	edi
$LN1@InputClose:

; 266  : 		}
; 267  : 	}
; 268  : }

	ret	0
_InputClose ENDP
_TEXT	ENDS
END
